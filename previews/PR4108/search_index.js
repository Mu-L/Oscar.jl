var documenterSearchIndex = {"docs":
[{"location":"Groups/subgroups/","page":"Subgroups","title":"Subgroups","text":"CurrentModule = Oscar\nDocTestSetup = Oscar.doctestsetup()","category":"page"},{"location":"Groups/subgroups/#subgroups","page":"Subgroups","title":"Subgroups","text":"","category":"section"},{"location":"Groups/subgroups/","page":"Subgroups","title":"Subgroups","text":"The following functions are available in OSCAR for subgroup properties:","category":"page"},{"location":"Groups/subgroups/","page":"Subgroups","title":"Subgroups","text":"sub(G::GAPGroup, gens::AbstractVector{<:GAPGroupElem}; check::Bool = true)\nis_subset(H::GAPGroup, G::GAPGroup)\nis_subgroup(H::GAPGroup, G::GAPGroup)\nembedding(H::GAPGroup, G::GAPGroup)\nindex(G::GAPGroup, H::GAPGroup)\nis_maximal_subgroup(H::GAPGroup, G::GAPGroup; check::Bool = true)\nis_normalized_by(H::GAPGroup , G::GAPGroup)\nis_normal_subgroup(H::GAPGroup, G::GAPGroup)\nis_characteristic_subgroup(H::GAPGroup, G::GAPGroup; check::Bool = true)","category":"page"},{"location":"Groups/subgroups/#sub-Tuple{Oscar.GAPGroup, AbstractVector{<:GAPGroupElem}}","page":"Subgroups","title":"sub","text":"sub(G::GAPGroup, gens::AbstractVector{<:GAPGroupElem}; check::Bool = true)\nsub(gens::GAPGroupElem...)\n\nReturn two objects: a group H, that is the subgroup of G generated by the elements x,y,..., and the embedding homomorphism of H into G. The object H has the same type of G, and it has no memory of the \"parent\" group G: it is an independent group.\n\nIf check is set to false then it is not checked whether each element of gens is an element of G.\n\nExamples\n\njulia> G = symmetric_group(4); H, _ = sub(G,[cperm([1,2,3]),cperm([2,3,4])]);\n\njulia> H == alternating_group(4)\ntrue\n\n\n\n\n\n","category":"method"},{"location":"Groups/subgroups/#is_subset-Tuple{Oscar.GAPGroup, Oscar.GAPGroup}","page":"Subgroups","title":"is_subset","text":"is_subset(H::GAPGroup, G::GAPGroup)\n\nReturn true if H is a subset of G, otherwise return false.\n\nExamples\n\njulia> g = symmetric_group(300); h = derived_subgroup(g)[1];\n\njulia> is_subset(h, g)\ntrue\n\njulia> is_subset(g, h)\nfalse\n\n\n\n\n\n","category":"method"},{"location":"Groups/subgroups/#is_subgroup-Tuple{Oscar.GAPGroup, Oscar.GAPGroup}","page":"Subgroups","title":"is_subgroup","text":"is_subgroup(H::GAPGroup, G::GAPGroup)\n\nReturn (true,f) if H is a subgroup of G, where f is the embedding homomorphism of H into G, otherwise return (false,nothing).\n\nIf you do not need the embedding then better call is_subset(H::GAPGroup, G::GAPGroup).\n\n\n\n\n\n","category":"method"},{"location":"Groups/subgroups/#embedding-Tuple{Oscar.GAPGroup, Oscar.GAPGroup}","page":"Subgroups","title":"embedding","text":"embedding(H::GAPGroup, G::GAPGroup)\n\nReturn the embedding morphism of H into G. An exception is thrown if H is not a subgroup of G.\n\n\n\n\n\n","category":"method"},{"location":"Groups/subgroups/#index-Tuple{Oscar.GAPGroup, Oscar.GAPGroup}","page":"Subgroups","title":"index","text":"index(::Type{I} = ZZRingElem, G::GAPGroup, H::GAPGroup) where I <: IntegerUnion\nindex(::Type{I} = ZZRingElem, G::FinGenAbGroup, H::FinGenAbGroup) where I <: IntegerUnion\n\nReturn the index of H in G, as an instance of type I.\n\nExamples\n\njulia> G = symmetric_group(5); H, _ = derived_subgroup(G);\n\njulia> index(G,H)\n2\n\n\n\n\n\n","category":"method"},{"location":"Groups/subgroups/#is_maximal_subgroup-Tuple{Oscar.GAPGroup, Oscar.GAPGroup}","page":"Subgroups","title":"is_maximal_subgroup","text":"is_maximal_subgroup(H::GAPGroup, G::GAPGroup; check::Bool = true)\n\nReturn whether H is a maximal subgroup of G, i. e., whether H is a proper subgroup of G and there is no proper subgroup of G that properly contains H.\n\nIf check is set to false then it is not checked whether H is a subgroup of G. If check is not set to false then an exception is thrown if H is not a subgroup of G.\n\nExamples\n\njulia> G = symmetric_group(4);\n\njulia> is_maximal_subgroup(sylow_subgroup(G, 2)[1], G)\ntrue\n\njulia> is_maximal_subgroup(sylow_subgroup(G, 3)[1], G)\nfalse\n\njulia> is_maximal_subgroup(sylow_subgroup(G, 3)[1], sylow_subgroup(G, 2)[1])\nERROR: ArgumentError: H is not a subgroup of G\n\n\n\n\n\n","category":"method"},{"location":"Groups/subgroups/#is_normalized_by-Tuple{Oscar.GAPGroup, Oscar.GAPGroup}","page":"Subgroups","title":"is_normalized_by","text":"is_normalized_by(H::GAPGroup, G::GAPGroup)\n\nReturn whether the group H is normalized by G, i.e., whether H is invariant under conjugation with elements of G.\n\nNote that H need not be a subgroup of G. To test whether H is a normal subgroup of G, use is_normal_subgroup.\n\nExamples\n\njulia> G = symmetric_group(4);\n\njulia> is_normalized_by(sylow_subgroup(G, 2)[1], G)\nfalse\n\njulia> is_normalized_by(derived_subgroup(G)[1], G)\ntrue\n\njulia> is_normalized_by(derived_subgroup(G)[1], sylow_subgroup(G, 2)[1])\ntrue\n\n\n\n\n\n","category":"method"},{"location":"Groups/subgroups/#is_normal_subgroup-Tuple{Oscar.GAPGroup, Oscar.GAPGroup}","page":"Subgroups","title":"is_normal_subgroup","text":"is_normal_subgroup(H::GAPGroup, G::GAPGroup)\n\nReturn whether the group H is a normal subgroup of G, i.e., whether H is a subgroup of G that is invariant under conjugation with elements of G.\n\n(See is_normalized_by for an invariance check only.)\n\nExamples\n\njulia> G = symmetric_group(4);\n\njulia> is_normal_subgroup(sylow_subgroup(G, 2)[1], G)\nfalse\n\njulia> is_normal_subgroup(derived_subgroup(G)[1], G)\ntrue\n\njulia> is_normal_subgroup(derived_subgroup(G)[1], sylow_subgroup(G, 2)[1])\nfalse\n\n\n\n\n\n","category":"method"},{"location":"Groups/subgroups/#is_characteristic_subgroup-Tuple{Oscar.GAPGroup, Oscar.GAPGroup}","page":"Subgroups","title":"is_characteristic_subgroup","text":"is_characteristic_subgroup(H::GAPGroup, G::GAPGroup; check::Bool = true)\n\nReturn whether the subgroup H of G is characteristic in G, i.e., H is invariant under all automorphisms of G.\n\nIf check is set to false then it is not checked whether H is a subgroup of G. If check is not set to false then an exception is thrown if H is not a subgroup of G.\n\nExamples\n\njulia> G = symmetric_group(4);\n\njulia> is_characteristic_subgroup(derived_subgroup(G)[1], G)\ntrue\n\njulia> is_characteristic_subgroup(sylow_subgroup(G, 3)[1], G)\nfalse\n\njulia> is_characteristic_subgroup(sylow_subgroup(G, 3)[1], sylow_subgroup(G, 2)[1])\nERROR: ArgumentError: H is not a subgroup of G\n\n\n\n\n\n","category":"method"},{"location":"Groups/subgroups/#Standard-subgroups","page":"Subgroups","title":"Standard subgroups","text":"","category":"section"},{"location":"Groups/subgroups/","page":"Subgroups","title":"Subgroups","text":"The following functions are available in OSCAR to obtain standard subgroups of a group G. Every such function returns a tuple (H,f), where H is a group of the same type of G and f is the embedding homomorphism of H into G.","category":"page"},{"location":"Groups/subgroups/","page":"Subgroups","title":"Subgroups","text":"trivial_subgroup\ncenter(G::GAPGroup)\nsylow_subgroup(G::GAPGroup, p::IntegerUnion)\nderived_subgroup\nfitting_subgroup\nfrattini_subgroup\nsocle\nsolvable_radical\npcore(G::GAPGroup, p::IntegerUnion)\nintersect(::T, V::T...) where T<:GAPGroup","category":"page"},{"location":"Groups/subgroups/#trivial_subgroup","page":"Subgroups","title":"trivial_subgroup","text":"trivial_subgroup(G::GAPGroup)\n\nReturn the trivial subgroup of G, together with its embedding morphism into G.\n\nExamples\n\njulia> trivial_subgroup(symmetric_group(5))\n(Permutation group of degree 5 and order 1, Hom: permutation group -> Sym(5))\n\n\n\n\n\n","category":"function"},{"location":"Groups/subgroups/#center-Tuple{Oscar.GAPGroup}","page":"Subgroups","title":"center","text":"center(G::Group)\n\nReturn the center of G, i.e., the subgroup of all x in G such that x y equals y x for every y in G, together with its embedding morphism into G.\n\nExamples\n\njulia> center(symmetric_group(3))\n(Permutation group of degree 3 and order 1, Hom: permutation group -> Sym(3))\n\njulia> center(quaternion_group(8))\n(Sub-pc group of order 2, Hom: sub-pc group -> pc group)\n\n\n\n\n\n","category":"method"},{"location":"Groups/subgroups/#sylow_subgroup-Tuple{Oscar.GAPGroup, Union{Integer, ZZRingElem}}","page":"Subgroups","title":"sylow_subgroup","text":"sylow_subgroup(G::Group, p::IntegerUnion)\n\nReturn a Sylow p-subgroup of the finite group G, for a prime p. This is a subgroup of p-power order in G whose index in G is coprime to p.\n\nExamples\n\njulia> g = symmetric_group(4); order(g)\n24\n\njulia> s = sylow_subgroup(g, 2); order(s[1])\n8\n\njulia> s = sylow_subgroup(g, 3); order(s[1])\n3\n\n\n\n\n\n\n","category":"method"},{"location":"Groups/subgroups/#derived_subgroup","page":"Subgroups","title":"derived_subgroup","text":"derived_subgroup(G::GAPGroup)\n\nReturn the derived subgroup G' of G, i.e., the subgroup generated by all commutators of G, together with an embedding G' into G.\n\nExamples\n\njulia> derived_subgroup(symmetric_group(5))\n(Alt(5), Hom: Alt(5) -> Sym(5))\n\n\n\n\n\n","category":"function"},{"location":"Groups/subgroups/#fitting_subgroup","page":"Subgroups","title":"fitting_subgroup","text":"fitting_subgroup(G::GAPGroup)\n\nReturn the Fitting subgroup of G, i.e., the largest nilpotent normal subgroup of G.\n\n\n\n\n\n","category":"function"},{"location":"Groups/subgroups/#frattini_subgroup","page":"Subgroups","title":"frattini_subgroup","text":"frattini_subgroup(G::GAPGroup)\n\nReturn the Frattini subgroup of G, i.e., the intersection of all maximal subgroups of G.\n\n\n\n\n\n","category":"function"},{"location":"Groups/subgroups/#socle","page":"Subgroups","title":"socle","text":"socle(G::GAPGroup)\n\nReturn the socle of G, i.e., the subgroup generated by all minimal normal subgroups of G, see minimal_normal_subgroups.\n\n\n\n\n\n","category":"function"},{"location":"Groups/subgroups/#solvable_radical","page":"Subgroups","title":"solvable_radical","text":"solvable_radical(G::GAPGroup)\n\nReturn the solvable radical of G, i.e., the largest solvable normal subgroup of G.\n\n\n\n\n\n","category":"function"},{"location":"Groups/subgroups/#pcore-Tuple{Oscar.GAPGroup, Union{Integer, ZZRingElem}}","page":"Subgroups","title":"pcore","text":"pcore(G::Group, p::IntegerUnion)\n\nReturn C, f, where C is the p-core (i.e. the largest normal p-subgroup) of G and f is the embedding morphism of C into G.\n\n\n\n\n\n","category":"method"},{"location":"Groups/subgroups/#intersect-Union{Tuple{T}, Tuple{T, Vararg{T}}} where T<:Oscar.GAPGroup","page":"Subgroups","title":"intersect","text":"intersect(V::T...) where T <: Group\nintersect(V::AbstractVector{<:GAPGroup})\n\nIf V is  G_1 G_2 ldots G_n , return the intersection K of the groups G_1 G_2 ldots G_n, together with the embeddings of K into G_i.\n\n\n\n\n\n","category":"method"},{"location":"Groups/subgroups/","page":"Subgroups","title":"Subgroups","text":"The following functions return a vector of subgroups.","category":"page"},{"location":"Groups/subgroups/","page":"Subgroups","title":"Subgroups","text":"normal_subgroups\nmaximal_normal_subgroups\nminimal_normal_subgroups\ncharacteristic_subgroups\nderived_series\nsylow_system\nhall_system\ncomplement_system\nchief_series\ncomposition_series\njennings_series\np_central_series\nlower_central_series\nupper_central_series","category":"page"},{"location":"Groups/subgroups/#normal_subgroups","page":"Subgroups","title":"normal_subgroups","text":"normal_subgroups(G::Group)\n\nReturn all normal subgroups of G (see is_normal).\n\nExamples\n\njulia> normal_subgroups(symmetric_group(5))\n3-element Vector{PermGroup}:\n Sym(5)\n Alt(5)\n Permutation group of degree 5 and order 1\n\njulia> normal_subgroups(quaternion_group(8))\n6-element Vector{SubPcGroup}:\n Sub-pc group of order 8\n Sub-pc group of order 4\n Sub-pc group of order 4\n Sub-pc group of order 4\n Sub-pc group of order 2\n Sub-pc group of order 1\n\n\n\n\n\n","category":"function"},{"location":"Groups/subgroups/#maximal_normal_subgroups","page":"Subgroups","title":"maximal_normal_subgroups","text":"maximal_normal_subgroups(G::Group)\n\nReturn all maximal normal subgroups of G, i.e., those proper normal subgroups of G that are maximal among the proper normal subgroups.\n\nExamples\n\njulia> maximal_normal_subgroups(symmetric_group(4))\n1-element Vector{PermGroup}:\n Alt(4)\n\njulia> maximal_normal_subgroups(quaternion_group(8))\n3-element Vector{SubPcGroup}:\n Sub-pc group of order 4\n Sub-pc group of order 4\n Sub-pc group of order 4\n\n\n\n\n\n","category":"function"},{"location":"Groups/subgroups/#minimal_normal_subgroups","page":"Subgroups","title":"minimal_normal_subgroups","text":"minimal_normal_subgroups(G::Group)\n\nReturn all minimal normal subgroups of G, i.e., of those nontrivial normal subgroups of G that are minimal among the nontrivial normal subgroups.\n\nExamples\n\njulia> minimal_normal_subgroups(symmetric_group(4))\n1-element Vector{PermGroup}:\n Permutation group of degree 4 and order 4\n\njulia> minimal_normal_subgroups(quaternion_group(8))\n1-element Vector{SubPcGroup}:\n Sub-pc group of order 2\n\n\n\n\n\n","category":"function"},{"location":"Groups/subgroups/#characteristic_subgroups","page":"Subgroups","title":"characteristic_subgroups","text":"characteristic_subgroups(G::Group)\n\nReturn the list of characteristic subgroups of G, i.e., those subgroups that are invariant under all automorphisms of G.\n\nExamples\n\njulia> characteristic_subgroups(symmetric_group(3))\n3-element Vector{PermGroup}:\n Sym(3)\n Permutation group of degree 3 and order 3\n Permutation group of degree 3 and order 1\n\njulia> characteristic_subgroups(quaternion_group(8))\n3-element Vector{SubPcGroup}:\n Sub-pc group of order 8\n Sub-pc group of order 2\n Sub-pc group of order 1\n\n\n\n\n\n","category":"function"},{"location":"Groups/subgroups/#derived_series","page":"Subgroups","title":"derived_series","text":"derived_series(G::GAPGroup)\n\nReturn the vector  G_1 G_2 ldots , where G_1 = G and G_i+1 = derived_subgroup(G_i). See also derived_length.\n\nExamples\n\njulia> G = derived_series(symmetric_group(4))\n4-element Vector{PermGroup}:\n Sym(4)\n Alt(4)\n Permutation group of degree 4 and order 4\n Permutation group of degree 4 and order 1\n\njulia> derived_series(symmetric_group(5))\n2-element Vector{PermGroup}:\n Sym(5)\n Alt(5)\n\njulia> derived_series(dihedral_group(8))\n3-element Vector{SubPcGroup}:\n Sub-pc group of order 8\n Sub-pc group of order 2\n Sub-pc group of order 1\n\n\n\n\n\nderived_series(L::LieAlgebra) -> Vector{LieAlgebraIdeal}\n\nReturn the derived series of L, i.e. the sequence of ideals  L^(0) = L, L^(i + 1) = L^(i) L^(i).\n\nwarning: Experimental\nThis function is part of the experimental code in Oscar. Please read here for more details.\n\n\n\n\n\n","category":"function"},{"location":"Groups/subgroups/#sylow_system","page":"Subgroups","title":"sylow_system","text":"sylow_system(G::Group)\n\nReturn a vector of Sylow p-subgroups of the finite group G, where p runs over the prime factors of the order of G, such that every two such subgroups commute with each other (as subgroups).\n\nSylow systems exist only for solvable groups, an exception is thrown if G is not solvable.\n\n\n\n\n\n","category":"function"},{"location":"Groups/subgroups/#hall_system","page":"Subgroups","title":"hall_system","text":"hall_system(G::Group)\n\nReturn a vector of Hall P-subgroups of the finite group G, where P runs over the subsets of prime factors of the order of G.\n\nHall systems exist only for solvable groups, an exception is thrown if G is not solvable.\n\n\n\n\n\n","category":"function"},{"location":"Groups/subgroups/#complement_system","page":"Subgroups","title":"complement_system","text":"complement_system(G::Group)\n\nReturn a vector of Hall p-subgroups of the finite group G, where p runs over the prime factors of the order of G.\n\nComplement systems exist only for solvable groups, an exception is thrown if G is not solvable.\n\n\n\n\n\n","category":"function"},{"location":"Groups/subgroups/#chief_series","page":"Subgroups","title":"chief_series","text":"chief_series(G::GAPGroup)\n\nReturn a vector  G_1 G_2 ldots  of normal subgroups of G such that G_i  G_i+1 and there is no normal subgroup N of G such that G_i > N > G_{i+1}.\n\nNote that in general there is more than one chief series, this function returns an arbitrary one.\n\nExamples\n\njulia> chief_series(alternating_group(4))\n3-element Vector{PermGroup}:\n Alt(4)\n Permutation group of degree 4 and order 4\n Permutation group of degree 4 and order 1\n\njulia> chief_series(quaternion_group(8))\n4-element Vector{SubPcGroup}:\n Sub-pc group of order 8\n Sub-pc group of order 4\n Sub-pc group of order 2\n Sub-pc group of order 1\n\n\n\n\n\n","category":"function"},{"location":"Groups/subgroups/#composition_series","page":"Subgroups","title":"composition_series","text":"composition_series(M::ModAlgAss) -> Vector{MatElem}\n\nGiven a Fq[G]-module M, it returns a composition series for M, i.e. a sequence of submodules such that the quotient of two consecutive elements is irreducible.\n\n\n\n\n\ncomposition_series(G::GAPGroup)\n\nReturn a vector  G_1 G_2 ldots  of subgroups forming a subnormal series which cannot be refined, i.e., G_i+1 is normal in G_i and the quotient G_iG_i+1 is simple.\n\nNote that in general there is more than one composition series, this function returns an arbitrary one.\n\nExamples\n\njulia> composition_series(alternating_group(4))\n4-element Vector{PermGroup}:\n Permutation group of degree 4 and order 12\n Permutation group of degree 4 and order 4\n Permutation group of degree 4 and order 2\n Permutation group of degree 4 and order 1\n\njulia> composition_series(quaternion_group(8))\n4-element Vector{SubPcGroup}:\n Sub-pc group of order 8\n Sub-pc group of order 4\n Sub-pc group of order 2\n Sub-pc group of order 1\n\n\n\n\n\n","category":"function"},{"location":"Groups/subgroups/#jennings_series","page":"Subgroups","title":"jennings_series","text":"jennings_series(G::GAPGroup)\n\nReturn for a p-group G the vector  G_1 G_2 ldots  where G_1 = G and beyond that G_i+1 = G_iG G_j^p where j is the smallest integer  ip.\n\nAn exception is thrown if G is not a p-group.\n\nExamples\n\njulia> jennings_series(dihedral_group(16))\n5-element Vector{SubPcGroup}:\n Sub-pc group of order 16\n Sub-pc group of order 4\n Sub-pc group of order 2\n Sub-pc group of order 2\n Sub-pc group of order 1\n\njulia> jennings_series(dihedral_group(10))\nERROR: ArgumentError: group must be a p-group\n\n\n\n\n\n","category":"function"},{"location":"Groups/subgroups/#p_central_series","page":"Subgroups","title":"p_central_series","text":"p_central_series(G::GAPGroup, p::IntegerUnion)\n\nReturn the vector  G_1 G_2 ldots  where G_1 = G and beyond that G_i+1 = G G_i G_i^p.\n\nAn exception is thrown if p is not a prime.\n\nExamples\n\njulia> p_central_series(alternating_group(4), 2)\n1-element Vector{PermGroup}:\n Alt(4)\n\njulia> p_central_series(alternating_group(4), 3)\n2-element Vector{PermGroup}:\n Alt(4)\n Permutation group of degree 4 and order 4\n\njulia> p_central_series(alternating_group(4), 4)\nERROR: ArgumentError: p must be a prime\n\n\n\n\n\n","category":"function"},{"location":"Groups/subgroups/#lower_central_series","page":"Subgroups","title":"lower_central_series","text":"lower_central_series(G::GAPGroup)\n\nReturn the vector  G_1 G_2 ldots  where G_1 = G and beyond that G_i+1 = G G_i. The series ends as soon as it is repeating (e.g. when the trivial subgroup is reached, which happens if and only if G is nilpotent).\n\nIt is a central series of normal (and even characteristic) subgroups of G. The name derives from the fact that G_i is contained in the i-th step subgroup of any central series.\n\nSee also upper_central_series and nilpotency_class.\n\nExamples\n\njulia> lower_central_series(dihedral_group(8))\n3-element Vector{SubPcGroup}:\n Sub-pc group of order 8\n Sub-pc group of order 2\n Sub-pc group of order 1\n\njulia> lower_central_series(dihedral_group(12))\n2-element Vector{SubPcGroup}:\n Sub-pc group of order 12\n Sub-pc group of order 3\n\njulia> lower_central_series(symmetric_group(4))\n2-element Vector{PermGroup}:\n Sym(4)\n Alt(4)\n\n\n\n\n\nlower_central_series(L::LieAlgebra) -> Vector{LieAlgebraIdeal}\n\nReturn the lower central series of L, i.e. the sequence of ideals L^(0) = L, L^(i + 1) = L L^(i).\n\nwarning: Experimental\nThis function is part of the experimental code in Oscar. Please read here for more details.\n\n\n\n\n\n","category":"function"},{"location":"Groups/subgroups/#upper_central_series","page":"Subgroups","title":"upper_central_series","text":"upper_central_series(G::GAPGroup)\n\nReturn the vector  G_1 G_2 ldots  where the last entry is the trivial group, and G_i is defined as the overgroup of G_i+1 satisfying G_i  G_i+1 = Z(GG_i+1). The series ends as soon as it is repeating (e.g. when the whole group G is reached, which happens if and only if G is nilpotent).\n\nIt is a central series of normal subgroups. The name derives from the fact that G_i contains every i-th step subgroup of a central series.\n\nSee also lower_central_series and nilpotency_class.\n\nExamples\n\njulia> upper_central_series(dihedral_group(8))\n3-element Vector{SubPcGroup}:\n Sub-pc group of order 8\n Sub-pc group of order 2\n Sub-pc group of order 1\n\njulia> upper_central_series(dihedral_group(12))\n2-element Vector{SubPcGroup}:\n Sub-pc group of order 2\n Sub-pc group of order 1\n\njulia> upper_central_series(symmetric_group(4))\n1-element Vector{PermGroup}:\n Permutation group of degree 4 and order 1\n\n\n\n\n\n","category":"function"},{"location":"Groups/subgroups/","page":"Subgroups","title":"Subgroups","text":"note: Note\nWhen a function returns a vector of subgroups, the output consists in the subgroups only; the embeddings are not returned as well. To get the embedding homomorphism of the subgroup H in G, one can type embedding(H, G).","category":"page"},{"location":"Groups/subgroups/","page":"Subgroups","title":"Subgroups","text":"The following functions return an iterator of subgroups. Usually it is more efficient to work with (representatives of) the underlying conjugacy classes of subgroups instead.","category":"page"},{"location":"Groups/subgroups/","page":"Subgroups","title":"Subgroups","text":"complements(G::GAPGroup, N::GAPGroup)\nhall_subgroups\nlow_index_subgroups\nmaximal_subgroups\nsubgroups(G::GAPGroup)","category":"page"},{"location":"Groups/subgroups/#complements-Tuple{Oscar.GAPGroup, Oscar.GAPGroup}","page":"Subgroups","title":"complements","text":"complements(G::GAPGroup, N::GAPGroup)\n\nReturn an iterator over the complements of the normal subgroup N in G. Very likely it is better to use complement_classes instead.\n\nExamples\n\njulia> G = symmetric_group(3);\n\njulia> describe(first(complements(G, derived_subgroup(G)[1])))\n\"C2\"\n\n\n\n\n\n","category":"method"},{"location":"Groups/subgroups/#hall_subgroups","page":"Subgroups","title":"hall_subgroups","text":"hall_subgroups(G::Group, P::AbstractVector{<:IntegerUnion})\n\nReturn an iterator over the Hall P-subgroups in G. Very likely it is better to use hall_subgroup_classes instead.\n\nExamples\n\njulia> g = GL(3, 2);\n\njulia> describe(first(hall_subgroups(g, [2, 3])))\n\"S4\"\n\n\n\n\n\n","category":"function"},{"location":"Groups/subgroups/#low_index_subgroups","page":"Subgroups","title":"low_index_subgroups","text":"low_index_subgroups(G::Group, n::Int)\n\nReturn an iterator over the subgroups of index at most n in G. Very likely it is better to use low_index_subgroup_classes instead.\n\nExamples\n\njulia> G = alternating_group(6);\n\njulia> length(collect(low_index_subgroups(G, 6)))\n13\n\n\n\n\n\n","category":"function"},{"location":"Groups/subgroups/#maximal_subgroups","page":"Subgroups","title":"maximal_subgroups","text":"maximal_subgroups(G::Group)\n\nReturn an iterator over the maximal subgroups in G. Very likely it is better to use maximal_subgroup_classes instead.\n\nExamples\n\njulia> println([order(H) for H in maximal_subgroups(symmetric_group(3))])\nZZRingElem[3, 2, 2, 2]\n\njulia> println([order(H) for H in maximal_subgroups(quaternion_group(8))])\nZZRingElem[4, 4, 4]\n\n\n\n\n\n","category":"function"},{"location":"Groups/subgroups/#subgroups-Tuple{Oscar.GAPGroup}","page":"Subgroups","title":"subgroups","text":"subgroups(G::GAPGroup)\n\nReturn an iterator over all subgroups in G. Very likely it is better to use subgroup_classes instead.\n\nExamples\n\njulia> println([order(H) for H in subgroups(symmetric_group(3))])\nZZRingElem[1, 2, 2, 2, 3, 6]\n\njulia> println([order(H) for H in subgroups(quaternion_group(8))])\nZZRingElem[1, 2, 4, 4, 4, 8]\n\n\n\n\n\n","category":"method"},{"location":"Groups/subgroups/#Conjugation-action-of-elements-and-subgroups","page":"Subgroups","title":"Conjugation action of elements and subgroups","text":"","category":"section"},{"location":"Groups/subgroups/","page":"Subgroups","title":"Subgroups","text":"is_conjugate(G::GAPGroup, x::GAPGroupElem, y::GAPGroupElem)\nis_conjugate(G::GAPGroup, H::GAPGroup, K::GAPGroup)\nis_conjugate_with_data(G::GAPGroup, x::GAPGroupElem, y::GAPGroupElem)\nis_conjugate_with_data(G::GAPGroup, H::GAPGroup, K::GAPGroup)\ncentralizer(G::GAPGroup, x::GAPGroupElem)\ncentralizer(G::GAPGroup, H::GAPGroup)\nnormalizer(G::GAPGroup, x::GAPGroupElem)\nnormalizer(G::GAPGroup, H::GAPGroup)\ncore(G::GAPGroup, H::GAPGroup)\nnormal_closure(G::GAPGroup, H::GAPGroup)","category":"page"},{"location":"Groups/subgroups/#is_conjugate-Tuple{Oscar.GAPGroup, GAPGroupElem, GAPGroupElem}","page":"Subgroups","title":"is_conjugate","text":"is_conjugate(G::GAPGroup, x::GAPGroupElem, y::GAPGroupElem)\n\nReturn whether x and y are conjugate elements in G, i.e., there is an element z in G such that inv(z)*x*z equals y. To also return the element z, use is_conjugate_with_data(G::GAPGroup, x::GAPGroupElem, y::GAPGroupElem).\n\n\n\n\n\n","category":"method"},{"location":"Groups/subgroups/#is_conjugate-Tuple{Oscar.GAPGroup, Oscar.GAPGroup, Oscar.GAPGroup}","page":"Subgroups","title":"is_conjugate","text":"is_conjugate(G::GAPGroup, H::GAPGroup, K::GAPGroup)\n\nReturn whether H and K are conjugate subgroups in G, i.e., whether there exists an element z in  G such that the conjugate group H^z, which is defined as  z^-1 h z h in H , equals K. To also return the element z, use is_conjugate_with_data(G::GAPGroup, H::GAPGroup, K::GAPGroup).\n\nExamples\n\njulia> G = symmetric_group(4);\n\njulia> H = sub(G, [G([2, 1, 3, 4])])[1]\nPermutation group of degree 4\n\njulia> K = sub(G, [G([1, 2, 4, 3])])[1]\nPermutation group of degree 4\n\njulia> is_conjugate(G, H, K)\ntrue\n\njulia> K = sub(G, [G([2, 1, 4, 3])])[1]\nPermutation group of degree 4\n\njulia> is_conjugate(G, H, K)\nfalse\n\n\n\n\n\n\n","category":"method"},{"location":"Groups/subgroups/#is_conjugate_with_data-Tuple{Oscar.GAPGroup, GAPGroupElem, GAPGroupElem}","page":"Subgroups","title":"is_conjugate_with_data","text":"is_conjugate_with_data(G::Group, x::GAPGroupElem, y::GAPGroupElem)\n\nIf x and y are conjugate in G, return (true, z), where inv(z)*x*z == y holds; otherwise, return (false, nothing). If the conjugating element z is not needed, use is_conjugate(G::GAPGroup, x::GAPGroupElem, y::GAPGroupElem).\n\n\n\n\n\n","category":"method"},{"location":"Groups/subgroups/#is_conjugate_with_data-Tuple{Oscar.GAPGroup, Oscar.GAPGroup, Oscar.GAPGroup}","page":"Subgroups","title":"is_conjugate_with_data","text":"is_conjugate_with_data(G::Group, H::Group, K::Group)\n\nIf H and K are conjugate subgroups in G, return (true, z) where H^z = K; otherwise, return (false, nothing). The conjugate group H^z is defined as  z^-1 h z h in H . If the conjugating element z is not needed, use is_conjugate(G::GAPGroup, H::GAPGroup, K::GAPGroup).\n\nExamples\n\njulia> G = symmetric_group(4);\n\njulia> H = sub(G, [G([2, 1, 3, 4])])[1]\nPermutation group of degree 4\n\njulia> K = sub(G, [G([1, 2, 4, 3])])[1]\nPermutation group of degree 4\n\njulia> is_conjugate_with_data(G, H, K)\n(true, (1,3)(2,4))\n\njulia> K = sub(G, [G([2, 1, 4, 3])])[1]\nPermutation group of degree 4\n\njulia> is_conjugate_with_data(G, H, K)\n(false, nothing)\n\n\n\n\n\n\n","category":"method"},{"location":"Groups/subgroups/#centralizer-Tuple{Oscar.GAPGroup, GAPGroupElem}","page":"Subgroups","title":"centralizer","text":"centralizer(G::Group, x::GroupElem)\n\nReturn the centralizer of x in G, i.e., the subgroup of all g in G such that g x equals x g, together with its embedding morphism into G.\n\n\n\n\n\n","category":"method"},{"location":"Groups/subgroups/#centralizer-Tuple{Oscar.GAPGroup, Oscar.GAPGroup}","page":"Subgroups","title":"centralizer","text":"centralizer(G::Group, H::Group)\n\nReturn the centralizer of H in G, i.e., the subgroup of all g in G such that g h equals h g for every h in H, together with its embedding morphism into G.\n\n\n\n\n\n","category":"method"},{"location":"Groups/subgroups/#normalizer-Tuple{Oscar.GAPGroup, GAPGroupElem}","page":"Subgroups","title":"normalizer","text":"normalizer(G::Group, x::GAPGroupElem)\n\nReturn N, f, where N is the normalizer of the cyclic subgroup generated by x in G and f is the embedding morphism of N into G.\n\n\n\n\n\n","category":"method"},{"location":"Groups/subgroups/#normalizer-Tuple{Oscar.GAPGroup, Oscar.GAPGroup}","page":"Subgroups","title":"normalizer","text":"normalizer(G::Group, H::Group)\n\nReturn N, f, where N is the normalizer of H in G, i.e., the largest subgroup of G in which H is normal, and f is the embedding morphism of N into G.\n\n\n\n\n\n","category":"method"},{"location":"Groups/subgroups/#core-Tuple{Oscar.GAPGroup, Oscar.GAPGroup}","page":"Subgroups","title":"core","text":"core(G::Group, H::Group)\n\nReturn C, f, where C is the normal core of H in G, that is, the largest normal subgroup of G that is contained in H, and f is the embedding morphism of C into G.\n\n\n\n\n\n","category":"method"},{"location":"Groups/subgroups/#normal_closure-Tuple{Oscar.GAPGroup, Oscar.GAPGroup}","page":"Subgroups","title":"normal_closure","text":"normal_closure(G::Group, H::Group)\n\nReturn N, f, where N is the normal closure of H in G, that is, the smallest normal subgroup of G that contains H, and f is the embedding morphism of N into G.\n\nNote that H must be a subgroup of G.\n\n\n\n\n\n","category":"method"},{"location":"Groups/subgroups/","page":"Subgroups","title":"Subgroups","text":"GroupConjClass{T<:GAPGroup, S<:Union{GAPGroupElem,GAPGroup}}\nrepresentative(G::GroupConjClass)\nacting_group(G::GroupConjClass)\nnumber_of_conjugacy_classes(G::GAPGroup)\nconjugacy_class(G::GAPGroup, g::GAPGroupElem)\nconjugacy_class(G::GAPGroup, H::GAPGroup)\nconjugacy_classes(G::GAPGroup)\ncomplement_classes\nhall_subgroup_classes\nlow_index_subgroup_classes\nmaximal_subgroup_classes(G::GAPGroup)\nsubgroup_classes(G::GAPGroup)","category":"page"},{"location":"Groups/subgroups/#GroupConjClass","page":"Subgroups","title":"GroupConjClass","text":"GroupConjClass{T, S}\n\nIt can be either the conjugacy class of an element or of a subgroup of type S in a group G of type T.\n\n\n\n\n\n","category":"type"},{"location":"Groups/subgroups/#representative-Tuple{GroupConjClass}","page":"Subgroups","title":"representative","text":"representative(C::GroupConjClass)\n\nReturn a representative of the conjugacy class C.\n\nExamples\n\njulia> G = symmetric_group(4);\n\njulia> C = conjugacy_class(G, G([2, 1, 3, 4]))\nConjugacy class of\n  (1,2) in\n  Sym(4)\n\njulia> representative(C)\n(1,2)\n\n\n\n\n\n","category":"method"},{"location":"Groups/subgroups/#acting_group-Tuple{GroupConjClass}","page":"Subgroups","title":"acting_group","text":"acting_group(C::GroupConjClass)\n\nReturn the acting group of C.\n\nExamples\n\njulia> G = symmetric_group(4);\n\njulia> C = conjugacy_class(G, G([2, 1, 3, 4]))\nConjugacy class of\n  (1,2) in\n  Sym(4)\n\njulia> acting_group(C) === G\ntrue\n\n\n\n\n\n","category":"method"},{"location":"Groups/subgroups/#number_of_conjugacy_classes-Tuple{Oscar.GAPGroup}","page":"Subgroups","title":"number_of_conjugacy_classes","text":"number_of_conjugacy_classes(G::GAPGroup)\n\nReturn the number of conjugacy classes of elements in G.\n\n\n\n\n\n","category":"method"},{"location":"Groups/subgroups/#conjugacy_class-Tuple{Oscar.GAPGroup, GAPGroupElem}","page":"Subgroups","title":"conjugacy_class","text":"conjugacy_class(G::Group, g::GAPGroupElem) -> GroupConjClass\n\nReturn the conjugacy class cc of g in G, where g = representative(cc).\n\nExamples\n\njulia> G = symmetric_group(4);\n\njulia> C = conjugacy_class(G, G([2, 1, 3, 4]))\nConjugacy class of\n  (1,2) in\n  Sym(4)\n\n\n\n\n\n","category":"method"},{"location":"Groups/subgroups/#conjugacy_class-Tuple{Oscar.GAPGroup, Oscar.GAPGroup}","page":"Subgroups","title":"conjugacy_class","text":"conjugacy_class(G::Group, H::Group) -> GroupConjClass\n\nReturn the subgroup conjugacy class cc of H in G, where H = representative(cc).\n\n\n\n\n\n","category":"method"},{"location":"Groups/subgroups/#conjugacy_classes-Tuple{Oscar.GAPGroup}","page":"Subgroups","title":"conjugacy_classes","text":"conjugacy_classes(G::Group)\n\nReturn a vector of all conjugacy classes of elements in G. It is guaranteed that the class of the identity is in the first position.\n\n\n\n\n\n","category":"method"},{"location":"Groups/subgroups/#complement_classes","page":"Subgroups","title":"complement_classes","text":"complement_classes(G::GAPGroup, N::GAPGroup)\n\nReturn a vector of the conjugacy classes of complements of the normal subgroup N in G. This function may throw an error exception if both N and G/N are nonsolvable.\n\nA complement is a subgroup of G which intersects trivially with N and together with N generates G.\n\nExamples\n\njulia> G = symmetric_group(3);\n\njulia> complement_classes(G, derived_subgroup(G)[1])\n1-element Vector{GAPGroupConjClass{PermGroup, PermGroup}}:\n Conjugacy class of permutation group in G\n\njulia> G = dihedral_group(8)\nPc group of order 8\n\njulia> complement_classes(G, center(G)[1])\nGAPGroupConjClass{PcGroup, SubPcGroup}[]\n\n\n\n\n\n","category":"function"},{"location":"Groups/subgroups/#hall_subgroup_classes","page":"Subgroups","title":"hall_subgroup_classes","text":"hall_subgroup_classes(G::Group, P::AbstractVector{<:IntegerUnion})\n\nReturn a vector that contains the conjugacy classes of Hall P-subgroups of the finite group G, for a vector P of primes. A Hall P-subgroup of G is a subgroup the order of which is only divisible by primes in P and whose index in G is coprime to all primes in P.\n\nFor solvable G, Hall P-subgroups exist and are unique up to conjugacy. For nonsolvable G, Hall P-subgroups may not exist or may not be unique up to conjugacy.\n\nExamples\n\njulia> g = dihedral_group(30);\n\njulia> h = hall_subgroup_classes(g, [2, 3]);\n\njulia> (length(h), order(representative(h[1])))\n(1, 6)\n\njulia> g = GL(3, 2)\nGL(3,2)\n\njulia> h = hall_subgroup_classes(g, [2, 3]);\n\njulia> (length(h), order(representative(h[1])))\n(2, 24)\n\njulia> h = hall_subgroup_classes(g, [2, 7]); length(h)\n0\n\n\n\n\n\n","category":"function"},{"location":"Groups/subgroups/#low_index_subgroup_classes","page":"Subgroups","title":"low_index_subgroup_classes","text":"low_index_subgroup_classes(G::GAPGroup, n::Int)\n\nReturn a vector of conjugacy classes of subgroups of index at most n in G.\n\nExamples\n\njulia> G = symmetric_group(5);\n\njulia> low_index_subgroup_classes(G, 5)\n3-element Vector{GAPGroupConjClass{PermGroup, PermGroup}}:\n Conjugacy class of Sym(5) in G\n Conjugacy class of permutation group in G\n Conjugacy class of Alt(5) in G\n\n\n\n\n\n","category":"function"},{"location":"Groups/subgroups/#maximal_subgroup_classes-Tuple{Oscar.GAPGroup}","page":"Subgroups","title":"maximal_subgroup_classes","text":"maximal_subgroup_classes(G::Group)\n\nReturn a vector of all conjugacy classes of maximal subgroups of G.\n\nExamples\n\njulia> G = symmetric_group(3);\n\njulia> maximal_subgroup_classes(G)\n2-element Vector{GAPGroupConjClass{PermGroup, PermGroup}}:\n Conjugacy class of permutation group in G\n Conjugacy class of permutation group in G\n\n\n\n\n\n","category":"method"},{"location":"Groups/subgroups/#subgroup_classes-Tuple{Oscar.GAPGroup}","page":"Subgroups","title":"subgroup_classes","text":"subgroup_classes(G::GAPGroup; order::T = ZZRingElem(-1)) where T <: IntegerUnion\n\nReturn a vector of all conjugacy classes of subgroups of G or, if order is positive, the classes of subgroups of this order.\n\nExamples\n\njulia> G = symmetric_group(3)\nSym(3)\n\njulia> subgroup_classes(G)\n4-element Vector{GAPGroupConjClass{PermGroup, PermGroup}}:\n Conjugacy class of permutation group in G\n Conjugacy class of permutation group in G\n Conjugacy class of permutation group in G\n Conjugacy class of permutation group in G\n\njulia> subgroup_classes(G, order = ZZRingElem(2))\n1-element Vector{GAPGroupConjClass{PermGroup, PermGroup}}:\n Conjugacy class of permutation group in G\n\n\n\n\n\n","category":"method"},{"location":"Groups/subgroups/#Cosets-(left/right/double)","page":"Subgroups","title":"Cosets (left/right/double)","text":"","category":"section"},{"location":"Groups/subgroups/","page":"Subgroups","title":"Subgroups","text":"GroupCoset\ngroup(C::GroupCoset)\nacting_group(C::GroupCoset)\nrepresentative(C::GroupCoset)\nright_coset(H::GAPGroup, g::GAPGroupElem)\nleft_coset(H::GAPGroup, g::GAPGroupElem)\nis_right(C::GroupCoset)\nis_left(C::GroupCoset)\nright_cosets(G::GAPGroup, H::GAPGroup; check::Bool=true)\nleft_cosets(G::GAPGroup, H::GAPGroup; check::Bool=true)\nright_transversal(G::T1, H::T2; check::Bool=true) where T1 <: GAPGroup where T2 <: GAPGroup\nleft_transversal(G::T1, H::T2; check::Bool=true) where T1 <: GAPGroup where T2 <: GAPGroup\nis_bicoset(C::GroupCoset)","category":"page"},{"location":"Groups/subgroups/#GroupCoset","page":"Subgroups","title":"GroupCoset","text":"GroupCoset{TG <: GAPGroup, TH <: GAPGroup, S <: GAPGroupElem}\n\nType of right and left cosets of subgroups in groups.\n\nFor an element g in a group G, and a subgroup H of G, the set Hg =  hg h in H  is a right coset of H in G, and the set gH =  gh h in H  is a left coset of H in G.\n\ngroup(C::GroupCoset) returns G.\nacting_group(C::GroupCoset) returns H.\nrepresentative(C::GroupCoset) returns an element (the same element for each call) of C.\nis_right(C::GroupCoset) and is_left(C::GroupCoset) return whether C is a right or left coset, respectively.\n\nTwo cosets are equal if and only if they are both left or right, respectively, and they contain the same elements.\n\n\n\n\n\n","category":"type"},{"location":"Groups/subgroups/#group-Tuple{GroupCoset}","page":"Subgroups","title":"group","text":"group(C::GroupCoset)\n\nReturn the group G that is the parent of all elements in C. That is, C is a left or right coset of a subgroup of G in G.\n\nExamples\n\njulia> G = symmetric_group(5)\nSym(5)\n\njulia> H = sylow_subgroup(G, 2)[1]\nPermutation group of degree 5 and order 8\n\njulia> C = right_coset(H, gen(G, 1))\nRight coset of permutation group of degree 5 and order 8\n  with representative (1,2,3,4,5)\n  in Sym(5)\n\njulia> group(C) == G\ntrue\n\n\n\n\n\n","category":"method"},{"location":"Groups/subgroups/#acting_group-Tuple{GroupCoset}","page":"Subgroups","title":"acting_group","text":"acting_group(C::GroupCoset)\n\nReturn the group H such that C is Hx (if C is a right coset) or xH (if C is a left coset), for an element x in C.\n\nExamples\n\njulia> G = symmetric_group(5)\nSym(5)\n\njulia> H = symmetric_group(3)\nSym(3)\n\njulia> C = right_coset(H, gen(G, 1))\nRight coset of Sym(3)\n  with representative (1,2,3,4,5)\n  in Sym(5)\n\njulia> acting_group(C) == H\ntrue\n\n\n\n\n\n","category":"method"},{"location":"Groups/subgroups/#representative-Tuple{GroupCoset}","page":"Subgroups","title":"representative","text":"representative(C::GroupCoset)\n\nReturn an element x in group(C) such that C = Hx (if C is a right coset) or xH (if C is a left coset).\n\nExamples\n\njulia> G = symmetric_group(5)\nSym(5)\n\njulia> g = perm(G,[3,4,1,5,2])\n(1,3)(2,4,5)\n\njulia> H = symmetric_group(3)\nSym(3)\n\njulia> Hg = right_coset(H, g)\nRight coset of Sym(3)\n  with representative (1,3)(2,4,5)\n  in Sym(5)\n\njulia> representative(Hg)\n(1,3)(2,4,5)\n\n\n\n\n\n","category":"method"},{"location":"Groups/subgroups/#right_coset-Tuple{Oscar.GAPGroup, GAPGroupElem}","page":"Subgroups","title":"right_coset","text":"right_coset(H::Group, g::GAPGroupElem)\n*(H::Group, g::GAPGroupElem)\n\nReturn the coset Hg.\n\nExamples\n\njulia> G = symmetric_group(5)\nSym(5)\n\njulia> g = perm(G,[3,4,1,5,2])\n(1,3)(2,4,5)\n\njulia> H = symmetric_group(3)\nSym(3)\n\njulia> right_coset(H, g)\nRight coset of Sym(3)\n  with representative (1,3)(2,4,5)\n  in Sym(5)\n\n\n\n\n\n","category":"method"},{"location":"Groups/subgroups/#left_coset-Tuple{Oscar.GAPGroup, GAPGroupElem}","page":"Subgroups","title":"left_coset","text":"left_coset(H::Group, g::GAPGroupElem)\n*(g::GAPGroupElem, H::Group)\n\nReturn the coset gH.\n\nnote: Note\nSince GAP supports right cosets only, the underlying GAP object of left_coset(H,g), if assigned, is the right coset H^(g^-1) * g.\n\nExamples\n\njulia> g = perm([3,4,1,5,2])\n(1,3)(2,4,5)\n\njulia> H = symmetric_group(3)\nSym(3)\n\njulia> gH = left_coset(H, g)\nLeft coset of Sym(3)\n  with representative (1,3)(2,4,5)\n  in Sym(5)\n\n\n\n\n\n","category":"method"},{"location":"Groups/subgroups/#is_right-Tuple{GroupCoset}","page":"Subgroups","title":"is_right","text":"is_right(c::GroupCoset)\n\nReturn whether the coset c is a right coset of its acting domain.\n\n\n\n\n\n","category":"method"},{"location":"Groups/subgroups/#is_left-Tuple{GroupCoset}","page":"Subgroups","title":"is_left","text":"is_left(c::GroupCoset)\n\nReturn whether the coset c is a left coset of its acting domain.\n\n\n\n\n\n","category":"method"},{"location":"Groups/subgroups/#right_cosets-Tuple{Oscar.GAPGroup, Oscar.GAPGroup}","page":"Subgroups","title":"right_cosets","text":"right_cosets(G::GAPGroup, H::GAPGroup; check::Bool=true)\n\nReturn the G-set that describes the right cosets of H in G.\n\nIf check == false, do not check whether H is a subgroup of G.\n\nUse right_transversal to compute the vector of coset representatives.\n\nExamples\n\njulia> G = symmetric_group(4)\nSym(4)\n\njulia> H = symmetric_group(3)\nSym(3)\n\njulia> rc = right_cosets(G, H)\nRight cosets of\n  Sym(3) in\n  Sym(4)\n\njulia> collect(rc)\n4-element Vector{GroupCoset{PermGroup, PermGroup, PermGroupElem}}:\n Right coset of H with representative ()\n Right coset of H with representative (1,4)\n Right coset of H with representative (1,4,2)\n Right coset of H with representative (1,4,3)\n\n\n\n\n\n","category":"method"},{"location":"Groups/subgroups/#left_cosets-Tuple{Oscar.GAPGroup, Oscar.GAPGroup}","page":"Subgroups","title":"left_cosets","text":"left_cosets(G::GAPGroup, H::GAPGroup; check::Bool=true)\n\nReturn the G-set that describes the left cosets of H in G.\n\nIf check == false, do not check whether H is a subgroup of G.\n\nUse left_transversal to compute the vector of coset representatives.\n\nExamples\n\njulia> G = symmetric_group(4)\nSym(4)\n\njulia> H = symmetric_group(3)\nSym(3)\n\njulia> left_cosets(G, H)\nLeft cosets of\n  Sym(3) in\n  Sym(4)\n\n\n\n\n\n","category":"method"},{"location":"Groups/subgroups/#right_transversal-Union{Tuple{T1}, Tuple{T2}, Tuple{T1, T2}} where {T2<:Oscar.GAPGroup, T1<:Oscar.GAPGroup}","page":"Subgroups","title":"right_transversal","text":"right_transversal(G::GAPGroup, H::GAPGroup; check::Bool=true)\n\nReturn a vector containing a complete set of representatives for the right cosets of H in G. This vector is not mutable, and it does not store its entries explicitly, they are created anew with each access to the transversal.\n\nIf check == false, do not check whether H is a subgroup of G.\n\nUse right_cosets to compute the G-set of right cosets.\n\nExamples\n\njulia> G = symmetric_group(4)\nSym(4)\n\njulia> H = symmetric_group(3)\nSym(3)\n\njulia> T = right_transversal(G, H)\nRight transversal of length 4 of\n  Sym(3) in\n  Sym(4)\n\njulia> collect(T)\n4-element Vector{PermGroupElem}:\n ()\n (1,4)\n (1,4,2)\n (1,4,3)\n\n\n\n\n\n","category":"method"},{"location":"Groups/subgroups/#left_transversal-Union{Tuple{T1}, Tuple{T2}, Tuple{T1, T2}} where {T2<:Oscar.GAPGroup, T1<:Oscar.GAPGroup}","page":"Subgroups","title":"left_transversal","text":"left_transversal(G::GAPGroup, H::GAPGroup; check::Bool=true)\n\nReturn a vector containing a complete set of representatives for the left cosets for H in G. This vector is not mutable, and it does not store its entries explicitly, they are created anew with each access to the transversal.\n\nIf check == false, do not check whether H is a subgroup of G.\n\nUse left_cosets to compute the G-set of left cosets.\n\nExamples\n\njulia> G = symmetric_group(4)\nSym(4)\n\njulia> H = symmetric_group(3)\nSym(3)\n\njulia> T = left_transversal(G, H)\nLeft transversal of length 4 of\n  Sym(3) in\n  Sym(4)\n\njulia> collect(T)\n4-element Vector{PermGroupElem}:\n ()\n (1,4)\n (1,2,4)\n (1,3,4)\n\n\n\n\n\n","category":"method"},{"location":"Groups/subgroups/#is_bicoset-Tuple{GroupCoset}","page":"Subgroups","title":"is_bicoset","text":"is_bicoset(C::GroupCoset)\n\nReturn whether C is simultaneously a right coset and a left coset for the same subgroup H. This is the case if and only if the coset representative normalizes acting_group(C).\n\nExamples\n\njulia> G = symmetric_group(5)\nSym(5)\n\njulia> H = symmetric_group(4)\nSym(4)\n\njulia> g = perm(G,[3,4,1,5,2])\n(1,3)(2,4,5)\n\njulia> gH = left_coset(H, g)\nLeft coset of Sym(4)\n  with representative (1,3)(2,4,5)\n  in Sym(5)\n\njulia> is_bicoset(gH)\nfalse\n\njulia> f = perm(G,[2,1,4,3,5])\n(1,2)(3,4)\n\njulia> fH = left_coset(H, f)\nLeft coset of Sym(4)\n  with representative (1,2)(3,4)\n  in Sym(5)\n\njulia> is_bicoset(fH)\ntrue\n\n\n\n\n\n","category":"method"},{"location":"Groups/subgroups/","page":"Subgroups","title":"Subgroups","text":"GroupDoubleCoset{T <: GAPGroup, S <: GAPGroupElem}\ngroup(C::GroupDoubleCoset)\nleft_acting_group(C::GroupDoubleCoset)\nright_acting_group(C::GroupDoubleCoset)\nrepresentative(C::GroupDoubleCoset)\ndouble_coset(G::GAPGroup, g::GAPGroupElem, H::GAPGroup)\ndouble_cosets(G::T, H::GAPGroup, K::GAPGroup; check::Bool=true) where T <: GAPGroup","category":"page"},{"location":"Groups/subgroups/#GroupDoubleCoset","page":"Subgroups","title":"GroupDoubleCoset","text":"GroupDoubleCoset{T<: Group, S <: GAPGroupElem}\n\nType of double cosets of subgroups in groups.\n\nFor an element g in a group G, and two subgroups H, K of G, the set HgK =  hgk h in H k in K  is a H-K-double coset in G.\n\ngroup(C::GroupDoubleCoset) returns G.\nleft_acting_group(C::GroupDoubleCoset) returns H.\nright_acting_group(C::GroupDoubleCoset) returns H.\nrepresentative(C::GroupDoubleCoset) returns an element (the same element for each call) of C.\n\nTwo double cosets are equal if and only if they contain the same elements.\n\n\n\n\n\n","category":"type"},{"location":"Groups/subgroups/#group-Tuple{GroupDoubleCoset}","page":"Subgroups","title":"group","text":"group(C::GroupDoubleCoset)\n\nReturn the group G that is the parent of all elements in C. That is, C is a double coset of two subgroups of G in G.\n\nExamples\n\njulia> G = symmetric_group(5)\nSym(5)\n\njulia> H = symmetric_group(3); K = symmetric_group(2);\n\njulia> HgK = double_coset(H, gen(G, 1), K)\nDouble coset of Sym(3)\n  and Sym(2)\n  with representative (1,2,3,4,5)\n  in Sym(5)\n\njulia> group(HgK) == G\ntrue\n\n\n\n\n\n","category":"method"},{"location":"Groups/subgroups/#left_acting_group-Tuple{GroupDoubleCoset}","page":"Subgroups","title":"left_acting_group","text":"left_acting_group(C::GroupDoubleCoset)\n\nReturn H if C = HxK.\n\nExamples\n\njulia> G = symmetric_group(5)\nSym(5)\n\njulia> H = symmetric_group(3); K = symmetric_group(2);\n\njulia> HgK = double_coset(H, gen(G, 1), K)\nDouble coset of Sym(3)\n  and Sym(2)\n  with representative (1,2,3,4,5)\n  in Sym(5)\n\njulia> left_acting_group(HgK) == H\ntrue\n\n\n\n\n\n","category":"method"},{"location":"Groups/subgroups/#right_acting_group-Tuple{GroupDoubleCoset}","page":"Subgroups","title":"right_acting_group","text":"right_acting_group(C::GroupDoubleCoset)\n\nReturn K if C = HxK.\n\nExamples\n\njulia> G = symmetric_group(5)\nSym(5)\n\njulia> H = symmetric_group(3); K = symmetric_group(2);\n\njulia> HgK = double_coset(H, gen(G, 1), K)\nDouble coset of Sym(3)\n  and Sym(2)\n  with representative (1,2,3,4,5)\n  in Sym(5)\n\njulia> right_acting_group(HgK) == K\ntrue\n\n\n\n\n\n","category":"method"},{"location":"Groups/subgroups/#representative-Tuple{GroupDoubleCoset}","page":"Subgroups","title":"representative","text":"representative(C::GroupDoubleCoset)\n\nReturn an element x of the double coset C = HxK.\n\nExamples\n\njulia> G = symmetric_group(5)\nSym(5)\n\njulia> H = symmetric_group(3); K = symmetric_group(2);\n\njulia> HgK = double_coset(H, gen(G, 1), K)\nDouble coset of Sym(3)\n  and Sym(2)\n  with representative (1,2,3,4,5)\n  in Sym(5)\n\njulia> representative(HgK)\n(1,2,3,4,5)\n\n\n\n\n\n","category":"method"},{"location":"Groups/subgroups/#double_coset-Tuple{Oscar.GAPGroup, GAPGroupElem, Oscar.GAPGroup}","page":"Subgroups","title":"double_coset","text":"double_coset(H::Group, x::GAPGroupElem, K::Group)\n*(H::Group, x::GAPGroupElem, K::Group)\n\nReturn the double coset HxK.\n\nExamples\n\njulia> G = symmetric_group(5)\nSym(5)\n\njulia> g = perm(G,[3,4,5,1,2])\n(1,3,5,2,4)\n\njulia> H = symmetric_group(3)\nSym(3)\n\njulia> K = symmetric_group(2)\nSym(2)\n\njulia> double_coset(H,g,K)\nDouble coset of Sym(3)\n  and Sym(2)\n  with representative (1,3,5,2,4)\n  in Sym(5)\n\n\n\n\n\n","category":"method"},{"location":"Groups/subgroups/#double_cosets-Union{Tuple{T}, Tuple{T, Oscar.GAPGroup, Oscar.GAPGroup}} where T<:Oscar.GAPGroup","page":"Subgroups","title":"double_cosets","text":"double_cosets(G::GAPGroup, H::GAPGroup, K::GAPGroup; check::Bool=true)\n\nReturn a vector of all the double cosets HxK for x in G. If check == false, do not check whether H and K are subgroups of G.\n\nExamples\n\njulia> G = symmetric_group(4)\nSym(4)\n\njulia> H = symmetric_group(3)\nSym(3)\n\njulia> K = symmetric_group(2)\nSym(2)\n\njulia> double_cosets(G,H,K)\n3-element Vector{GroupDoubleCoset{PermGroup, PermGroupElem}}:\n Double coset of H and K with representative ()\n Double coset of H and K with representative (1,4)\n Double coset of H and K with representative (1,4,3)\n\n\n\n\n\n","category":"method"},{"location":"Groups/subgroups/","page":"Subgroups","title":"Subgroups","text":"order(C::Union{GroupCoset,GroupDoubleCoset})\nBase.rand(C::Union{GroupCoset,GroupDoubleCoset})","category":"page"},{"location":"Groups/subgroups/#order-Tuple{Union{GroupCoset, GroupDoubleCoset}}","page":"Subgroups","title":"order","text":"order(::Type{T} = ZZRingElem, C::Union{GroupCoset,GroupDoubleCoset})\n\nReturn the cardinality of the (double) coset C, as an instance of the type T.\n\n\n\n\n\n","category":"method"},{"location":"Groups/subgroups/#rand-Tuple{Union{GroupCoset, GroupDoubleCoset}}","page":"Subgroups","title":"rand","text":"rand(rng::Random.AbstractRNG = Random.GLOBAL_RNG, C::Union{GroupCoset,GroupDoubleCoset})\n\nReturn a random element of the (double) coset C, using the random number generator rng.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/orders/ideals/#NfOrdIdlLink2","page":"Ideals","title":"Ideals","text":"","category":"section"},{"location":"Hecke/manual/orders/ideals/","page":"Ideals","title":"Ideals","text":"CurrentModule = Hecke","category":"page"},{"location":"Hecke/manual/orders/ideals/","page":"Ideals","title":"Ideals","text":"(Integral) ideals in orders are always free Z-module of the same rank as the order, hence have a representation via a Z-basis. This can be made unique by normalising the corresponding matrix to be in reduced row echelon form (HNF).","category":"page"},{"location":"Hecke/manual/orders/ideals/","page":"Ideals","title":"Ideals","text":"For ideals in maximal orders Z_K, we also have a second presentation coming from the Z_K module structure and the fact that Z_K is a Dedekind ring: ideals can be generated by 2 elements, one of which can be any non-zero element in the ideal.","category":"page"},{"location":"Hecke/manual/orders/ideals/","page":"Ideals","title":"Ideals","text":"For efficiency, we will choose the 1st generator to be an integer.","category":"page"},{"location":"Hecke/manual/orders/ideals/","page":"Ideals","title":"Ideals","text":"Ideals here are of type AbsNumFieldOrderIdeal, which is, similar to the elements above, also indexed by the type of the field and their elements: AbsNumFieldOrderIdeal{AbsSimpleNumField,AbsSimpleNumFieldElem} for ideals in simple absolute fields.","category":"page"},{"location":"Hecke/manual/orders/ideals/","page":"Ideals","title":"Ideals","text":"Different to elements, the parentof an ideal is the set of all ideals in the ring, of type AbsNumFieldOrderIdealSet.","category":"page"},{"location":"Hecke/manual/orders/ideals/#Creation","page":"Ideals","title":"Creation","text":"","category":"section"},{"location":"Hecke/manual/orders/ideals/","page":"Ideals","title":"Ideals","text":"ideal(::AbsSimpleNumFieldOrder, ::ZZRingElem)\nideal(::AbsSimpleNumFieldOrder, ::ZZMatrix)\nideal(::AbsSimpleNumFieldOrder, ::AbsSimpleNumFieldOrderElem)\nideal(::AbsSimpleNumFieldOrder, ::ZZRingElem, ::AbsSimpleNumFieldOrderElem)\nideal(::AbsNumFieldOrder, ::ZZRingElem, ::AbsNumFieldOrderElem)\nideal(::AbsNumFieldOrder, ::ZZRingElem)\nideal(::AbsNumFieldOrder, ::AbsNumFieldOrderElem)\n\n*(::AbsSimpleNumFieldOrder, ::AbsSimpleNumFieldOrderElem)\nfactor(::AbsNumFieldOrderIdeal{AbsSimpleNumField, AbsSimpleNumFieldElem})\nfactor(::AbsNumFieldOrderIdealSet{AbsSimpleNumField, AbsSimpleNumFieldElem}, ::AbsSimpleNumFieldElem)\ncoprime_base(::Vector{AbsNumFieldOrderIdeal{AbsSimpleNumField, AbsSimpleNumFieldElem}})","category":"page"},{"location":"Hecke/manual/orders/ideals/#ideal-Tuple{AbsSimpleNumFieldOrder, ZZRingElem}","page":"Ideals","title":"ideal","text":"ideal(O::AbsSimpleNumFieldOrder, a::ZZRingElem) -> AbsNumFieldOrderIdeal\nideal(O::AbsSimpleNumFieldOrder, a::Integer) -> AbsNumFieldOrderIdeal\n\nReturns the ideal of mathcal O which is generated by a.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/orders/ideals/#ideal-Tuple{AbsSimpleNumFieldOrder, ZZMatrix}","page":"Ideals","title":"ideal","text":"ideal(O::AbsSimpleNumFieldOrder, M::ZZMatrix; check::Bool = false, M_in_hnf::Bool = false) -> AbsNumFieldOrderIdeal\n\nCreates the ideal of mathcal O with basis matrix M. If check is set, then it is checked whether M defines an ideal (expensive). If M_in_hnf is set, then it is assumed that M is already in lower left HNF.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/orders/ideals/#ideal-Tuple{AbsSimpleNumFieldOrder, AbsSimpleNumFieldOrderElem}","page":"Ideals","title":"ideal","text":"ideal(O::AbsSimpleNumFieldOrder, x::AbsSimpleNumFieldOrderElem) -> AbsNumFieldOrderIdeal\n\nCreates the principal ideal (x) of mathcal O.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/orders/ideals/#ideal-Tuple{AbsSimpleNumFieldOrder, ZZRingElem, AbsSimpleNumFieldOrderElem}","page":"Ideals","title":"ideal","text":"ideal(O::AbsSimpleNumFieldOrder, x::ZZRingElem, y::AbsSimpleNumFieldOrderElem) -> AbsNumFieldOrderIdeal\nideal(O::AbsSimpleNumFieldOrder, x::Integer, y::AbsSimpleNumFieldOrderElem) -> AbsNumFieldOrderIdeal\n\nCreates the ideal (x y) of mathcal O.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/orders/ideals/#ideal-Tuple{AbsNumFieldOrder, ZZRingElem, AbsNumFieldOrderElem}","page":"Ideals","title":"ideal","text":"ideal(O::AbsSimpleNumFieldOrder, x::ZZRingElem, y::AbsSimpleNumFieldOrderElem) -> AbsNumFieldOrderIdeal\nideal(O::AbsSimpleNumFieldOrder, x::Integer, y::AbsSimpleNumFieldOrderElem) -> AbsNumFieldOrderIdeal\n\nCreates the ideal (x y) of mathcal O.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/orders/ideals/#ideal-Tuple{AbsNumFieldOrder, ZZRingElem}","page":"Ideals","title":"ideal","text":"ideal(O::AbsSimpleNumFieldOrder, a::ZZRingElem) -> AbsNumFieldOrderIdeal\nideal(O::AbsSimpleNumFieldOrder, a::Integer) -> AbsNumFieldOrderIdeal\n\nReturns the ideal of mathcal O which is generated by a.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/orders/ideals/#ideal-Tuple{AbsNumFieldOrder, AbsNumFieldOrderElem}","page":"Ideals","title":"ideal","text":"ideal(O::AbsSimpleNumFieldOrder, x::AbsSimpleNumFieldOrderElem) -> AbsNumFieldOrderIdeal\n\nCreates the principal ideal (x) of mathcal O.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/orders/ideals/#*-Tuple{AbsSimpleNumFieldOrder, AbsSimpleNumFieldOrderElem}","page":"Ideals","title":"*","text":"*(O::AbsSimpleNumFieldOrder, x::AbsSimpleNumFieldOrderElem) -> AbsNumFieldOrderIdeal\n*(x::AbsNumFieldOrderElem, O::AbsNumFieldOrder) -> AbsNumFieldOrderIdeal\n\nReturns the principal ideal (x) of mathcal O.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/orders/ideals/#factor-Tuple{AbsSimpleNumFieldOrderIdeal}","page":"Ideals","title":"factor","text":"factor(a::T) where T <: RingElement -> Fac{T}\n\nReturn a factorization of a into irreducible elements, as a Fac{T}. The irreducible elements in the factorization are pairwise coprime.\n\n\n\n\n\nfactor(A::AbsNumFieldOrderIdeal{AbsSimpleNumField, AbsSimpleNumFieldElem}) -> Dict{AbsNumFieldOrderIdeal{AbsSimpleNumField, AbsSimpleNumFieldElem}, Int}\n\nComputes the prime ideal factorization A as a dictionary, the keys being the prime ideal divisors: If lp = factor_dict(A), then keys(lp) are the prime ideal divisors of A and lp[P] is the P-adic valuation of A for all P in keys(lp).\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/orders/ideals/#factor-Tuple{Hecke.AbsNumFieldOrderIdealSet{AbsSimpleNumField, AbsSimpleNumFieldElem}, AbsSimpleNumFieldElem}","page":"Ideals","title":"factor","text":"factor(I::AbsNumFieldOrderIdealSet{AbsSimpleNumField, AbsSimpleNumFieldElem}, a::AbsSimpleNumFieldElem) -> Dict{AbsNumFieldOrderIdeal{AbsSimpleNumField, AbsSimpleNumFieldElem}, ZZRingElem}\n\nFactors the principal ideal generated by a.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/orders/ideals/#coprime_base-Tuple{Vector{AbsSimpleNumFieldOrderIdeal}}","page":"Ideals","title":"coprime_base","text":"coprime_base(A::Vector{AbsNumFieldOrderIdeal{AbsSimpleNumField, AbsSimpleNumFieldElem}}) -> Vector{AbsNumFieldOrderIdeal{AbsSimpleNumField, AbsSimpleNumFieldElem}}\ncoprime_base(A::Vector{AbsSimpleNumFieldOrderElem}) -> Vector{AbsNumFieldOrderIdeal{AbsSimpleNumField, AbsSimpleNumFieldElem}}\n\nA coprime base for the (principal) ideals in A, i.e. the returned array generated multiplicatively the same ideals as the input and are pairwise coprime.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/orders/ideals/#Arithmetic","page":"Ideals","title":"Arithmetic","text":"","category":"section"},{"location":"Hecke/manual/orders/ideals/","page":"Ideals","title":"Ideals","text":"All the usual operations are supported:","category":"page"},{"location":"Hecke/manual/orders/ideals/","page":"Ideals","title":"Ideals","text":"==, +, *\ndivexact, divides\nlcm, gcd\nin","category":"page"},{"location":"Hecke/manual/orders/ideals/","page":"Ideals","title":"Ideals","text":"intersect(::AbsNumFieldOrderIdeal{AbsSimpleNumField, AbsSimpleNumFieldElem}, ::AbsNumFieldOrderIdeal{AbsSimpleNumField, AbsSimpleNumFieldElem})\ncolon(::AbsNumFieldOrderIdeal{AbsSimpleNumField, AbsSimpleNumFieldElem}, ::AbsNumFieldOrderIdeal{AbsSimpleNumField, AbsSimpleNumFieldElem})\nin(::AbsSimpleNumFieldOrderElem, ::AbsNumFieldOrderIdeal)\nis_power(::AbsNumFieldOrderIdeal, ::Int)\nis_power(::AbsNumFieldOrderIdeal)\nis_invertible(::AbsNumFieldOrderIdeal{AbsSimpleNumField, AbsSimpleNumFieldElem})\nisone(::AbsNumFieldOrderIdeal{AbsSimpleNumField, AbsSimpleNumFieldElem})","category":"page"},{"location":"Hecke/manual/orders/ideals/#intersect-Tuple{AbsSimpleNumFieldOrderIdeal, AbsSimpleNumFieldOrderIdeal}","page":"Ideals","title":"intersect","text":"intersect(x::AbsNumFieldOrderIdeal{AbsSimpleNumField, AbsSimpleNumFieldElem}, y::AbsNumFieldOrderIdeal{AbsSimpleNumField, AbsSimpleNumFieldElem}) -> AbsNumFieldOrderIdeal{AbsSimpleNumField, AbsSimpleNumFieldElem}\n\nReturns x cap y.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/orders/ideals/#colon-Tuple{AbsSimpleNumFieldOrderIdeal, AbsSimpleNumFieldOrderIdeal}","page":"Ideals","title":"colon","text":"colon(a::AbsNumFieldOrderIdeal, b::AbsNumFieldOrderIdeal) -> AbsSimpleNumFieldOrderFractionalIdeal\n\nThe ideal (ab) = x in K  xb subseteq a = hom(b a) where K is the number field.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/orders/ideals/#in-Tuple{AbsSimpleNumFieldOrderElem, AbsNumFieldOrderIdeal}","page":"Ideals","title":"in","text":"in(x::NumFieldOrderElem, y::NumFieldOrderIdeal)\nin(x::NumFieldElem, y::NumFieldOrderIdeal)\nin(x::ZZRingElem, y::NumFieldOrderIdeal)\n\nReturns whether x is contained in y.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/orders/ideals/#is_power-Tuple{AbsNumFieldOrderIdeal, Int64}","page":"Ideals","title":"is_power","text":"is_power(A::AbsNumFieldOrderIdeal, n::Int) -> Bool, AbsNumFieldOrderIdeal\nis_power(A::AbsSimpleNumFieldOrderFractionalIdeal, n::Int) -> Bool, AbsSimpleNumFieldOrderFractionalIdeal\n\nComputes, if possible, an ideal B s.th. B^n==A holds. In this case, true and B are returned.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/orders/ideals/#is_power-Tuple{AbsNumFieldOrderIdeal}","page":"Ideals","title":"is_power","text":"is_power(I::AbsNumFieldOrderIdeal) -> Int, AbsNumFieldOrderIdeal\nis_power(a::AbsSimpleNumFieldOrderFractionalIdeal) -> Int, AbsSimpleNumFieldOrderFractionalIdeal\n\nWrites a = r^e with e maximal. Note: 1 = 1^0.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/orders/ideals/#is_invertible-Tuple{AbsSimpleNumFieldOrderIdeal}","page":"Ideals","title":"is_invertible","text":"is_invertible(A::AbsNumFieldOrderIdeal) -> Bool, AbsSimpleNumFieldOrderFractionalIdeal\n\nReturns true and an inverse of A or false and an ideal B such that A*B subsetneq order(A), if A is not invertible.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/orders/ideals/#isone-Tuple{AbsSimpleNumFieldOrderIdeal}","page":"Ideals","title":"isone","text":"isone(A::AbsNumFieldOrderIdeal) -> Bool\nis_unit(A::AbsNumFieldOrderIdeal) -> Bool\n\nTests if A is the trivial ideal generated by 1.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/orders/ideals/#Class-Group","page":"Ideals","title":"Class Group","text":"","category":"section"},{"location":"Hecke/manual/orders/ideals/","page":"Ideals","title":"Ideals","text":"The group of invertable ideals in any order forms a group and the principal ideals a subgroup.  The finite quotient is called class group for maximal orders and Picard group or ring class group in general.","category":"page"},{"location":"Hecke/manual/orders/ideals/","page":"Ideals","title":"Ideals","text":"class_group(::AbsSimpleNumFieldOrder)\nnarrow_class_group(::AbsSimpleNumFieldOrder)\npicard_group(::AbsSimpleNumFieldOrder)\nring_class_group(::AbsNumFieldOrder)","category":"page"},{"location":"Hecke/manual/orders/ideals/#class_group-Tuple{AbsSimpleNumFieldOrder}","page":"Ideals","title":"class_group","text":"class_group(O::AbsSimpleNumFieldOrder; bound = -1,\n                      redo = false,\n                      GRH = true)   -> FinGenAbGroup, Map\n\nReturns a group A and a map f from A to the set of ideals of O. The inverse of the map is the projection onto the group of ideals modulo the group of principal ideals.\n\nBy default, the correctness is guarenteed only assuming the Generalized Riemann Hypothesis (GRH).\n\nKeyword arguments:\n\nredo: Trigger a recomputation, thus avoiding the cache.\nbound: When specified, this is used for the bound for the factor base.\nGRH: If false, the correctness of the result does not depend on GRH.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/orders/ideals/#narrow_class_group-Tuple{AbsSimpleNumFieldOrder}","page":"Ideals","title":"narrow_class_group","text":"narrow_class_group(O::AbsSimpleNumFieldOrder) -> FinGenAbGroup, Map\n\nComputes the narrow (or strict) class group of O, ie. the group of invertable ideals modulo principal ideals generated by elements that are positive at all real places.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/orders/ideals/#picard_group-Tuple{AbsSimpleNumFieldOrder}","page":"Ideals","title":"picard_group","text":"picard_group(O::AbsSimpleNumFieldOrder) -> FinGenAbGroup, MapClassGrp\n\nReturns the Picard group of O and a map from the group in the set of (invertible) ideals of O.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/orders/ideals/#ring_class_group-Tuple{AbsNumFieldOrder}","page":"Ideals","title":"ring_class_group","text":"ring_class_group(O::AbsNumFieldOrder)\n\nThe ring class group (Picard group) of O.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/orders/ideals/","page":"Ideals","title":"Ideals","text":"using Hecke # hide\nk, a = wildanger_field(3, 13);\nzk = maximal_order(k);\nc, mc = class_group(zk)\nlp = prime_ideals_up_to(zk, 20);\n[ mc \\ I for I = lp]\nmc(c[1])\norder(c[1])\nmc(c[1])^Int(order(c[1]))\nmc \\ ans","category":"page"},{"location":"Hecke/manual/orders/ideals/","page":"Ideals","title":"Ideals","text":"The class group, or more precisely the information used to compute it also allows for principal ideal testing and related tasks. In general, due to the size of the objects, the fac_elem versions are more efficient.","category":"page"},{"location":"Hecke/manual/orders/ideals/","page":"Ideals","title":"Ideals","text":"is_principal(::AbsNumFieldOrderIdeal{AbsSimpleNumField, AbsSimpleNumFieldElem})\nis_principal_with_data(::AbsNumFieldOrderIdeal{AbsSimpleNumField, AbsSimpleNumFieldElem})\nis_principal_fac_elem(::AbsNumFieldOrderIdeal{AbsSimpleNumField,AbsSimpleNumFieldElem})\npower_class(::AbsNumFieldOrderIdeal{AbsSimpleNumField, AbsSimpleNumFieldElem},::ZZRingElem)\npower_product_class(::Vector{AbsNumFieldOrderIdeal{AbsSimpleNumField, AbsSimpleNumFieldElem}}, ::Vector{ZZRingElem})\npower_reduce(::AbsNumFieldOrderIdeal{AbsSimpleNumField,AbsSimpleNumFieldElem},::ZZRingElem)\nclass_group_ideal_relation(::AbsNumFieldOrderIdeal{AbsSimpleNumField,AbsSimpleNumFieldElem}, ::Hecke.ClassGrpCtx)\nfactor_base_bound_grh(::AbsSimpleNumFieldOrder)\nfactor_base_bound_bach(::AbsSimpleNumFieldOrder)\nprime_ideals_up_to","category":"page"},{"location":"Hecke/manual/orders/ideals/#is_principal-Tuple{AbsSimpleNumFieldOrderIdeal}","page":"Ideals","title":"is_principal","text":"is_principal(A::AbsSimpleNumFieldOrderIdeal) -> Bool\nis_principal(A::AbsSimpleNumFieldOrderFractionalIdeal) -> Bool\n\nTests if A is principal.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/orders/ideals/#is_principal_with_data-Tuple{AbsSimpleNumFieldOrderIdeal}","page":"Ideals","title":"is_principal_with_data","text":"is_principal_with_data(A::AbsSimpleNumFieldOrderIdeal) -> Bool, AbsSimpleNumFieldOrderElem\nis_principal_with_data(A::AbsSimpleNumFieldOrderFractionalIdeal) -> Bool, AbsSimpleNumFieldElem\n\nTests if A is principal and returns (mathtttrue alpha) if A = langle alpharangle or (mathttfalse 1) otherwise.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/orders/ideals/#is_principal_fac_elem-Tuple{AbsSimpleNumFieldOrderIdeal}","page":"Ideals","title":"is_principal_fac_elem","text":"is_principal_fac_elem(A::AbsNumFieldOrderIdeal{AbsSimpleNumField, AbsSimpleNumFieldElem}) -> Bool, FacElem{AbsSimpleNumFieldElem, number_field}\n\nTests if A is principal and returns (mathtttrue alpha) if A = langle alpharangle or (mathttfalse 1) otherwise. The generator will be in factored form.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/orders/ideals/#power_class-Tuple{AbsSimpleNumFieldOrderIdeal, ZZRingElem}","page":"Ideals","title":"power_class","text":"power_class(A::AbsNumFieldOrderIdeal{AbsSimpleNumField, AbsSimpleNumFieldElem}, e::ZZRingElem) -> AbsNumFieldOrderIdeal{AbsSimpleNumField, AbsSimpleNumFieldElem}\n\nComputes a (small) ideal in the same class as A^e.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/orders/ideals/#power_product_class-Tuple{Vector{AbsSimpleNumFieldOrderIdeal}, Vector{ZZRingElem}}","page":"Ideals","title":"power_product_class","text":"power_product_class(A::Vector{AbsNumFieldOrderIdeal{AbsSimpleNumField, AbsSimpleNumFieldElem}}, e::Vector{ZZRingElem}) -> AbsNumFieldOrderIdeal{AbsSimpleNumField, AbsSimpleNumFieldElem}\n\nComputes a (small) ideal in the same class as prod A_i^e_i.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/orders/ideals/#power_reduce-Tuple{AbsSimpleNumFieldOrderIdeal, ZZRingElem}","page":"Ideals","title":"power_reduce","text":"power_reduce(A::AbsNumFieldOrderIdeal{AbsSimpleNumField, AbsSimpleNumFieldElem}, e::ZZRingElem) -> AbsNumFieldOrderIdeal{AbsSimpleNumField, AbsSimpleNumFieldElem}, FacElem{AbsSimpleNumFieldElem}\n\nComputes B and alpha in factored form, such that alpha B = A^e B has small norm.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/orders/ideals/#class_group_ideal_relation-Tuple{AbsSimpleNumFieldOrderIdeal, Hecke.ClassGrpCtx}","page":"Ideals","title":"class_group_ideal_relation","text":"class_group_ideal_relation(I::AbsNumFieldOrderIdeal{AbsSimpleNumField, AbsSimpleNumFieldElem}, c::ClassGrpCtx) -> AbsSimpleNumFieldElem, SRow{ZZRingElem}\n\nFinds a number field element alpha such that alpha I factors over the factor base in c.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/orders/ideals/#factor_base_bound_grh-Tuple{AbsSimpleNumFieldOrder}","page":"Ideals","title":"factor_base_bound_grh","text":"factor_base_bound_grh(O::AbsSimpleNumFieldOrder) -> Int\n\nReturns an integer B, such that under GRH the ideal class group of mathcal O is generated by the prime ideals of norm bounded by B.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/orders/ideals/#factor_base_bound_bach-Tuple{AbsSimpleNumFieldOrder}","page":"Ideals","title":"factor_base_bound_bach","text":"factor_base_bound_bach(O::AbsSimpleNumFieldOrder) -> Int\n\nUse the theorem of Bach to find B such that under GRH the ideal class group of mathcal O is generated by the prime ideals of norm bounded by B.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/orders/ideals/#prime_ideals_up_to","page":"Ideals","title":"prime_ideals_up_to","text":"prime_ideals_up_to(O::AbsSimpleNumFieldOrder,\n                   B::Int;\n                   degree_limit::Int = 0, index_divisors::Bool = true) -> Vector{AbsNumFieldOrderIdeal{AbsSimpleNumField, AbsSimpleNumFieldElem}}\n\nComputes the prime ideals mathcal O with norm up to B.\n\nIf degree_limit is a nonzero integer k, then prime ideals mathfrak p with deg(mathfrak p)  k will be discarded. If 'index_divisors' is set to false, only primes not dividing the index of the order will be computed.\n\n\n\n\n\nprime_ideals_up_to(O::AbsSimpleNumFieldOrder,\n                   B::Int;\n                   complete::Bool = false,\n                   degree_limit::Int = 0,\n                   F::Function,\n                   bad::ZZRingElem)\n\nComputes the prime ideals mathcal O with norm up to B.\n\nIf degree_limit is a nonzero integer k, then prime ideals mathfrak p with deg(mathfrak p)  k will be discarded.\n\nThe function F must be a function on prime numbers not dividing bad such that F(p) = deg(mathfrak p) for all prime ideals mathfrak p lying above p.\n\n\n\n\n\n","category":"function"},{"location":"Hecke/manual/orders/ideals/","page":"Ideals","title":"Ideals","text":"I = mc(c[1])\nis_principal(I)\nI = I^Int(order(c[1]))\nis_principal(I)\nis_principal_fac_elem(I)","category":"page"},{"location":"Hecke/manual/orders/ideals/","page":"Ideals","title":"Ideals","text":"The computation of S-units is also tied to the class group:","category":"page"},{"location":"Hecke/manual/orders/ideals/","page":"Ideals","title":"Ideals","text":"torsion_units(::AbsSimpleNumFieldOrder)\ntorsion_unit_group(::AbsSimpleNumFieldOrder)\ntorsion_units_generator(::AbsSimpleNumFieldOrder)\nHecke.torsion_units_gen_order(::AbsSimpleNumFieldOrder)\nunit_group(::AbsSimpleNumFieldOrder)\nunit_group_fac_elem(::AbsSimpleNumFieldOrder)\nsunit_group(::Vector{AbsNumFieldOrderIdeal{AbsSimpleNumField, AbsSimpleNumFieldElem}})\nsunit_group_fac_elem(::Vector{AbsNumFieldOrderIdeal{AbsSimpleNumField, AbsSimpleNumFieldElem}})\nsunit_mod_units_group_fac_elem(::Vector{AbsNumFieldOrderIdeal{AbsSimpleNumField, AbsSimpleNumFieldElem}})","category":"page"},{"location":"Hecke/manual/orders/ideals/#torsion_units-Tuple{AbsSimpleNumFieldOrder}","page":"Ideals","title":"torsion_units","text":"torsion_units(O::AbsSimpleNumFieldOrder) -> Vector{AbsSimpleNumFieldOrderElem}\n\nGiven an order O, compute the torsion units of O.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/orders/ideals/#torsion_unit_group-Tuple{AbsSimpleNumFieldOrder}","page":"Ideals","title":"torsion_unit_group","text":"torsion_unit_group(O::AbsSimpleNumFieldOrder) -> GrpAb, Map\n\nGiven an order mathcal O, returns the torsion units as an abelian group G together with a map G to mathcal O^times.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/orders/ideals/#torsion_units_generator-Tuple{AbsSimpleNumFieldOrder}","page":"Ideals","title":"torsion_units_generator","text":"torsion_units_generator(O::AbsSimpleNumFieldOrder) -> AbsSimpleNumFieldOrderElem\n\nGiven an order O, compute a generator of the torsion units of O.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/orders/ideals/#torsion_units_gen_order-Tuple{AbsSimpleNumFieldOrder}","page":"Ideals","title":"torsion_units_gen_order","text":"torsion_units_gen_order(O::AbsSimpleNumFieldOrder) -> AbsSimpleNumFieldOrderElem\n\nGiven an order O, compute a generator of the torsion units of O as well as its order.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/orders/ideals/#unit_group-Tuple{AbsSimpleNumFieldOrder}","page":"Ideals","title":"unit_group","text":"unit_group(O::AbsSimpleNumFieldOrder) -> FinGenAbGroup, Map\n\nReturns a group U and an isomorphism map f colon U to mathcal O^times. A set of fundamental units of mathcal O can be obtained via [ f(U[1+i]) for i in 1:unit_group_rank(O) ]. f(U[1]) will give a generator for the torsion subgroup.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/orders/ideals/#unit_group_fac_elem-Tuple{AbsSimpleNumFieldOrder}","page":"Ideals","title":"unit_group_fac_elem","text":"unit_group_fac_elem(O::AbsSimpleNumFieldOrder) -> FinGenAbGroup, Map\n\nReturns a group U and an isomorphism map f colon U to mathcal O^times. A set of fundamental units of mathcal O can be obtained via [ f(U[1+i]) for i in 1:unit_group_rank(O) ]. f(U[1]) will give a generator for the torsion subgroup. All elements will be returned in factored form.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/orders/ideals/#sunit_group-Tuple{Vector{AbsSimpleNumFieldOrderIdeal}}","page":"Ideals","title":"sunit_group","text":"sunit_group(I::Vector{AbsNumFieldOrderIdeal{AbsSimpleNumField, AbsSimpleNumFieldElem}}) -> GrpAb, Map\n\nFor an array I of (coprime prime) ideals, find the S-unit group defined by I, ie. the group of non-zero field elements which are only divisible by ideals in I.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/orders/ideals/#sunit_group_fac_elem-Tuple{Vector{AbsSimpleNumFieldOrderIdeal}}","page":"Ideals","title":"sunit_group_fac_elem","text":"sunit_group_fac_elem(I::Vector{AbsNumFieldOrderIdeal{AbsSimpleNumField, AbsSimpleNumFieldElem}}) -> GrpAb, Map\n\nFor an array I of (coprime prime) ideals, find the S-unit group defined by I, ie. the group of non-zero field elements which are only divisible by ideals in I. The map will return elements in factored form.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/orders/ideals/#sunit_mod_units_group_fac_elem-Tuple{Vector{AbsSimpleNumFieldOrderIdeal}}","page":"Ideals","title":"sunit_mod_units_group_fac_elem","text":"sunit_mod_units_group_fac_elem(I::Vector{AbsNumFieldOrderIdeal{AbsSimpleNumField, AbsSimpleNumFieldElem}}) -> GrpAb, Map\n\nFor an array I of (coprime prime) ideals, find the S-unit group defined by I, ie. the group of non-zero field elements which are only divisible by ideals in I modulo the units of the field. The map will return elements in factored form.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/orders/ideals/","page":"Ideals","title":"Ideals","text":"u, mu = unit_group(zk)\nmu(u[2])\nu, mu = unit_group_fac_elem(zk)\nmu(u[2])\nevaluate(ans)\nlp = factor(6*zk)\ns, ms = Hecke.sunit_group(collect(keys(lp)))\nms(s[4])\nnorm(ans)\nfactor(numerator(ans))","category":"page"},{"location":"Hecke/manual/orders/ideals/#Miscaellenous","page":"Ideals","title":"Miscaellenous","text":"","category":"section"},{"location":"Hecke/manual/orders/ideals/","page":"Ideals","title":"Ideals","text":"order(::AbsNumFieldOrderIdeal)\norder(::AbsNumFieldOrderFractionalIdeal)\norder(::RelNumFieldOrderIdeal)\norder(::RelNumFieldOrderFractionalIdeal)\nnf(::AbsNumFieldOrderIdeal)\nbasis(::AbsNumFieldOrderIdeal{AbsSimpleNumField, AbsSimpleNumFieldElem})\nHecke.lll_basis(::AbsNumFieldOrderIdeal{AbsSimpleNumField, AbsSimpleNumFieldElem})\nbasis_matrix(::AbsNumFieldOrderIdeal)\nbasis_mat_inv(::AbsNumFieldOrderIdeal{AbsSimpleNumField, AbsSimpleNumFieldElem})\nHecke.has_princ_gen_special(::AbsNumFieldOrderIdeal{AbsSimpleNumField, AbsSimpleNumFieldElem})\nHecke.principal_generator(::AbsNumFieldOrderIdeal{AbsSimpleNumField, AbsSimpleNumFieldElem})\nHecke.principal_generator_fac_elem(::AbsNumFieldOrderIdeal{AbsSimpleNumField, AbsSimpleNumFieldElem})\nminimum(::AbsNumFieldOrderIdeal{AbsSimpleNumField, AbsSimpleNumFieldElem})\nminimum(::RelNumFieldOrderIdeal)\nminimum(::AbsNumFieldOrderIdeal)\nhas_minimum(::AbsNumFieldOrderIdeal{AbsSimpleNumField, AbsSimpleNumFieldElem})\nnorm(::AbsNumFieldOrderIdeal{AbsSimpleNumField, AbsSimpleNumFieldElem})\nHecke.has_norm(::AbsNumFieldOrderIdeal{AbsSimpleNumField, AbsSimpleNumFieldElem})\nidempotents(::AbsNumFieldOrderIdeal{AbsSimpleNumField, AbsSimpleNumFieldElem}, ::AbsNumFieldOrderIdeal{AbsSimpleNumField, AbsSimpleNumFieldElem})\nis_prime(::AbsNumFieldOrderIdeal{AbsSimpleNumField, AbsSimpleNumFieldElem})\nHecke.is_prime_known(::AbsNumFieldOrderIdeal{AbsSimpleNumField, AbsSimpleNumFieldElem})\nis_ramified(::AbsSimpleNumFieldOrder, ::Union{Int, ZZRingElem})\nramification_index(::AbsNumFieldOrderIdeal{AbsSimpleNumField, AbsSimpleNumFieldElem})\ndegree(::AbsNumFieldOrderIdeal{AbsSimpleNumField, AbsSimpleNumFieldElem})\nvaluation(::AbsSimpleNumFieldElem, ::AbsNumFieldOrderIdeal{AbsSimpleNumField, AbsSimpleNumFieldElem})\nvaluation(::AbsSimpleNumFieldOrderElem, ::AbsNumFieldOrderIdeal{AbsSimpleNumField, AbsSimpleNumFieldElem})\nvaluation(::AbsNumFieldOrderIdeal{AbsSimpleNumField, AbsSimpleNumFieldElem}, ::AbsNumFieldOrderIdeal{AbsSimpleNumField, AbsSimpleNumFieldElem})\nvaluation(::Integer, ::AbsNumFieldOrderIdeal{AbsSimpleNumField, AbsSimpleNumFieldElem})\nvaluation(::ZZRingElem, ::AbsNumFieldOrderIdeal{AbsSimpleNumField, AbsSimpleNumFieldElem})\nvaluation(::AbsSimpleNumFieldOrderFractionalIdeal, ::AbsNumFieldOrderIdeal{AbsSimpleNumField, AbsSimpleNumFieldElem})\nidempotents(::AbsNumFieldOrderIdeal, ::AbsNumFieldOrderIdeal)","category":"page"},{"location":"Hecke/manual/orders/ideals/#order-Tuple{AbsNumFieldOrderIdeal}","page":"Ideals","title":"order","text":"order(::Type{T} = BigInt, G::Group) where T\n\nReturn the order of G as an instance of T. If G is of infinite order, an InfiniteOrderError exception will be thrown. Use is_finite(G) to avoid this kind of exception. If the order does not fit into type T, an InexactError exception will be thrown.\n\n\n\n\n\norder(::Type{T} = BigInt, g::GroupElem) where T\n\nReturn the order of g as an instance of T. If g is of infinite order, an InfiniteOrderError exception will be thrown. Use is_finite_order(G) to avoid this kind of exception. If the order does not fit into type T, an InexactError exception will be thrown.\n\n\n\n\n\norder(I::NumFieldOrderIdeal) -> AbsSimpleNumFieldOrder\n\nReturns the order of I.\n\n\n\n\n\norder(::Type{T} = ZZRingElem, c::CycleType) where T <: IntegerUnion\n\nReturn the order of the permutations with cycle structure c.\n\nExamples\n\njulia> g = symmetric_group(3);\n\njulia> all(x -> order(cycle_structure(x)) == order(x), gens(g))\ntrue\n\n\n\n\n\norder(W::WeylGroup) -> ZZRingELem\norder(::Type{T}, W::WeylGroup) where {T} -> T\n\nReturn the order of W.\n\nIf W is infinite, an InfiniteOrderError exception will be thrown.\n\nwarning: Experimental\nThis function is part of the experimental code in Oscar. Please read here for more details.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/orders/ideals/#order-Tuple{Hecke.AbsNumFieldOrderFractionalIdeal}","page":"Ideals","title":"order","text":"order(a::AbsNumFieldOrderFractionalIdeal) -> AbsNumFieldOrder\n\nThe order that was used to define the ideal a.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/orders/ideals/#order-Tuple{Hecke.RelNumFieldOrderIdeal}","page":"Ideals","title":"order","text":"order(::Type{T} = BigInt, G::Group) where T\n\nReturn the order of G as an instance of T. If G is of infinite order, an InfiniteOrderError exception will be thrown. Use is_finite(G) to avoid this kind of exception. If the order does not fit into type T, an InexactError exception will be thrown.\n\n\n\n\n\norder(::Type{T} = BigInt, g::GroupElem) where T\n\nReturn the order of g as an instance of T. If g is of infinite order, an InfiniteOrderError exception will be thrown. Use is_finite_order(G) to avoid this kind of exception. If the order does not fit into type T, an InexactError exception will be thrown.\n\n\n\n\n\norder(I::NumFieldOrderIdeal) -> AbsSimpleNumFieldOrder\n\nReturns the order of I.\n\n\n\n\n\norder(::Type{T} = ZZRingElem, c::CycleType) where T <: IntegerUnion\n\nReturn the order of the permutations with cycle structure c.\n\nExamples\n\njulia> g = symmetric_group(3);\n\njulia> all(x -> order(cycle_structure(x)) == order(x), gens(g))\ntrue\n\n\n\n\n\norder(W::WeylGroup) -> ZZRingELem\norder(::Type{T}, W::WeylGroup) where {T} -> T\n\nReturn the order of W.\n\nIf W is infinite, an InfiniteOrderError exception will be thrown.\n\nwarning: Experimental\nThis function is part of the experimental code in Oscar. Please read here for more details.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/orders/ideals/#order-Tuple{Hecke.RelNumFieldOrderFractionalIdeal}","page":"Ideals","title":"order","text":"order(a::RelNumFieldOrderFractionalIdeal) -> RelNumFieldOrder\n\nReturns the order of a.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/orders/ideals/#nf-Tuple{AbsNumFieldOrderIdeal}","page":"Ideals","title":"nf","text":"nf(x::NumFieldOrderIdeal) -> AbsSimpleNumField\n\nReturns the number field, of which x is an integral ideal.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/orders/ideals/#basis-Tuple{AbsSimpleNumFieldOrderIdeal}","page":"Ideals","title":"basis","text":"basis(A::AbsNumFieldOrderIdeal) -> Vector{AbsSimpleNumFieldOrderElem}\n\nReturns the basis of A.\n\n\n\n\n\nbasis(I::AbsNumFieldOrderFractionalIdeal) -> Vector{AbsSimpleNumFieldElem}\n\nReturns the mathbf Z-basis of I.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/orders/ideals/#lll_basis-Tuple{AbsSimpleNumFieldOrderIdeal}","page":"Ideals","title":"lll_basis","text":"lll_basis(I::NumFieldOrderIdeal) -> Vector{NumFieldElem}\n\nA basis for I that is reduced using the LLL algorithm for the Minkowski metric.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/orders/ideals/#basis_matrix-Tuple{AbsNumFieldOrderIdeal}","page":"Ideals","title":"basis_matrix","text":"basis_matrix(A::AbsNumFieldOrderIdeal) -> ZZMatrix\n\nReturns the basis matrix of A.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/orders/ideals/#basis_mat_inv-Tuple{AbsSimpleNumFieldOrderIdeal}","page":"Ideals","title":"basis_mat_inv","text":"basis_mat_inv(A::GenOrdIdl) -> FakeFracFldMat\n\nReturn the inverse of the basis matrix of A.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/orders/ideals/#has_princ_gen_special-Tuple{AbsSimpleNumFieldOrderIdeal}","page":"Ideals","title":"has_princ_gen_special","text":"has_princ_gen_special(A::AbsNumFieldOrderIdeal) -> Bool\n\nReturns whether A knows if it is generated by a rational integer.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/orders/ideals/#principal_generator-Tuple{AbsSimpleNumFieldOrderIdeal}","page":"Ideals","title":"principal_generator","text":"principal_generator(A::AbsNumFieldOrderIdeal{AbsSimpleNumField, AbsSimpleNumFieldElem}) -> AbsSimpleNumFieldOrderElem\n\nFor a principal ideal A, find a generator.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/orders/ideals/#principal_generator_fac_elem-Tuple{AbsSimpleNumFieldOrderIdeal}","page":"Ideals","title":"principal_generator_fac_elem","text":"principal_generator_fac_elem(A::AbsNumFieldOrderIdeal{AbsSimpleNumField, AbsSimpleNumFieldElem}) -> FacElem{AbsSimpleNumFieldElem, number_field}\n\nFor a principal ideal A, find a generator in factored form.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/orders/ideals/#minimum-Tuple{AbsSimpleNumFieldOrderIdeal}","page":"Ideals","title":"minimum","text":"minimum(A::AbsNumFieldOrderIdeal) -> ZZRingElem\n\nReturns the smallest non-negative element in A cap mathbf Z.\n\n\n\n\n\n  minimum(A::RelNumFieldOrderIdeal) -> AbsNumFieldOrderIdeal{AbsSimpleNumField, AbsSimpleNumFieldElem}\n  minimum(A::RelNumFieldOrderIdeal) -> RelNumFieldOrderIdeal\n\nReturns the ideal A cap O where O is the maximal order of the coefficient ideals of A.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/orders/ideals/#minimum-Tuple{Hecke.RelNumFieldOrderIdeal}","page":"Ideals","title":"minimum","text":"  minimum(A::RelNumFieldOrderIdeal) -> AbsNumFieldOrderIdeal{AbsSimpleNumField, AbsSimpleNumFieldElem}\n  minimum(A::RelNumFieldOrderIdeal) -> RelNumFieldOrderIdeal\n\nReturns the ideal A cap O where O is the maximal order of the coefficient ideals of A.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/orders/ideals/#minimum-Tuple{AbsNumFieldOrderIdeal}","page":"Ideals","title":"minimum","text":"minimum(A::AbsNumFieldOrderIdeal) -> ZZRingElem\n\nReturns the smallest non-negative element in A cap mathbf Z.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/orders/ideals/#has_minimum-Tuple{AbsSimpleNumFieldOrderIdeal}","page":"Ideals","title":"has_minimum","text":"has_minimum(A::AbsNumFieldOrderIdeal) -> Bool\n\nReturns whether A knows its minimum.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/orders/ideals/#norm-Tuple{AbsSimpleNumFieldOrderIdeal}","page":"Ideals","title":"norm","text":"norm(A::AbsNumFieldOrderIdeal) -> ZZRingElem\n\nReturns the norm of A, that is, the cardinality of mathcal OA, where mathcal O is the order of A.\n\n\n\n\n\nnorm(a::RelNumFieldOrderIdeal) -> AbsNumFieldOrderIdeal{AbsSimpleNumField, AbsSimpleNumFieldElem}\n\nReturns the norm of a.\n\n\n\n\n\nnorm(a::RelNumFieldOrderFractionalIdeal{T, S}) -> S\n\nReturns the norm of a.\n\n\n\n\n\nnorm(a::AlgAssAbsOrdIdl, O::AlgAssAbsOrd; copy::Bool = true) -> QQFieldElem\n\nReturns the norm of a considered as an (possibly fractional) ideal of O.\n\n\n\n\n\nnorm(a::AlgAssRelOrdIdl{S, T, U}, O::AlgAssRelOrd{S, T, U}; copy::Bool = true)\n  where { S, T, U } -> T\n\nReturns the norm of a considered as an (possibly fractional) ideal of O.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/orders/ideals/#has_norm-Tuple{AbsSimpleNumFieldOrderIdeal}","page":"Ideals","title":"has_norm","text":"has_norm(A::AbsNumFieldOrderIdeal) -> Bool\n\nReturns whether A knows its norm.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/orders/ideals/#idempotents-Tuple{AbsSimpleNumFieldOrderIdeal, AbsSimpleNumFieldOrderIdeal}","page":"Ideals","title":"idempotents","text":"idempotents(x::AbsNumFieldOrderIdeal{AbsSimpleNumField, AbsSimpleNumFieldElem}, y::AbsNumFieldOrderIdeal{AbsSimpleNumField, AbsSimpleNumFieldElem}) -> AbsSimpleNumFieldOrderElem, AbsSimpleNumFieldOrderElem\n\nReturns a tuple (e, f) consisting of elements e in x, f in y such that 1 = e + f.\n\nIf the ideals are not coprime, an error is raised.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/orders/ideals/#is_prime-Tuple{AbsSimpleNumFieldOrderIdeal}","page":"Ideals","title":"is_prime","text":"is_prime(A::AbsNumFieldOrderIdeal{AbsSimpleNumField, AbsSimpleNumFieldElem}) -> Bool\n\nReturns whether A is a prime ideal.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/orders/ideals/#is_prime_known-Tuple{AbsSimpleNumFieldOrderIdeal}","page":"Ideals","title":"is_prime_known","text":"is_prime_known(A::AbsNumFieldOrderIdeal{AbsSimpleNumField, AbsSimpleNumFieldElem}) -> Bool\n\nReturns whether A knows if it is prime.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/orders/ideals/#is_ramified-Tuple{AbsSimpleNumFieldOrder, Union{Int64, ZZRingElem}}","page":"Ideals","title":"is_ramified","text":"is_ramified(O::AbsSimpleNumFieldOrder, p::Int) -> Bool\n\nReturns whether the integer p is ramified in mathcal O. It is assumed that p is prime.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/orders/ideals/#ramification_index-Tuple{AbsSimpleNumFieldOrderIdeal}","page":"Ideals","title":"ramification_index","text":"ramification_index(P::AbsNumFieldOrderIdeal{AbsSimpleNumField, AbsSimpleNumFieldElem}) -> Int\n\nThe ramification index of the prime-ideal P.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/orders/ideals/#degree-Tuple{AbsSimpleNumFieldOrderIdeal}","page":"Ideals","title":"degree","text":"degree(P::AbsNumFieldOrderIdeal{AbsSimpleNumField, AbsSimpleNumFieldElem}) -> Int\n\nThe inertia degree of the prime-ideal P.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/orders/ideals/#valuation-Tuple{AbsSimpleNumFieldElem, AbsSimpleNumFieldOrderIdeal}","page":"Ideals","title":"valuation","text":"valuation(a::NumFieldElem, p::AbsNumFieldOrderIdeal{AbsSimpleNumField, AbsSimpleNumFieldElem}) -> ZZRingElem\n\nComputes the mathfrak p-adic valuation of a, that is, the largest i such that a is contained in mathfrak p^i.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/orders/ideals/#valuation-Tuple{AbsSimpleNumFieldOrderElem, AbsSimpleNumFieldOrderIdeal}","page":"Ideals","title":"valuation","text":"valuation(a::AbsSimpleNumFieldElem, p::AbsNumFieldOrderIdeal{AbsSimpleNumField, AbsSimpleNumFieldElem}) -> ZZRingElem\nvaluation(a::AbsSimpleNumFieldOrderElem, p::AbsNumFieldOrderIdeal{AbsSimpleNumField, AbsSimpleNumFieldElem}) -> ZZRingElem\nvaluation(a::ZZRingElem, p::AbsNumFieldOrderIdeal{AbsSimpleNumField, AbsSimpleNumFieldElem}) -> ZZRingElem\n\nComputes the mathfrak p-adic valuation of a, that is, the largest i such that a is contained in mathfrak p^i.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/orders/ideals/#valuation-Tuple{AbsSimpleNumFieldOrderIdeal, AbsSimpleNumFieldOrderIdeal}","page":"Ideals","title":"valuation","text":"valuation(A::AbsNumFieldOrderIdeal{AbsSimpleNumField, AbsSimpleNumFieldElem}, p::AbsNumFieldOrderIdeal{AbsSimpleNumField, AbsSimpleNumFieldElem}) -> ZZRingElem\n\nComputes the mathfrak p-adic valuation of A, that is, the largest i such that A is contained in mathfrak p^i.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/orders/ideals/#valuation-Tuple{Integer, AbsSimpleNumFieldOrderIdeal}","page":"Ideals","title":"valuation","text":"valuation(a::Integer, p::AbsNumFieldOrderIdeal{AbsSimpleNumField, AbsSimpleNumFieldElem}) -> ZZRingElem\n\nComputes the mathfrak p-adic valuation of a, that is, the largest i such that a is contained in mathfrak p^i.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/orders/ideals/#valuation-Tuple{ZZRingElem, AbsSimpleNumFieldOrderIdeal}","page":"Ideals","title":"valuation","text":"valuation(a::AbsSimpleNumFieldElem, p::AbsNumFieldOrderIdeal{AbsSimpleNumField, AbsSimpleNumFieldElem}) -> ZZRingElem\nvaluation(a::AbsSimpleNumFieldOrderElem, p::AbsNumFieldOrderIdeal{AbsSimpleNumField, AbsSimpleNumFieldElem}) -> ZZRingElem\nvaluation(a::ZZRingElem, p::AbsNumFieldOrderIdeal{AbsSimpleNumField, AbsSimpleNumFieldElem}) -> ZZRingElem\n\nComputes the mathfrak p-adic valuation of a, that is, the largest i such that a is contained in mathfrak p^i.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/orders/ideals/#valuation-Tuple{AbsSimpleNumFieldOrderFractionalIdeal, AbsSimpleNumFieldOrderIdeal}","page":"Ideals","title":"valuation","text":"valuation(A::AbsNumFieldOrderFractionalIdeal, p::AbsNumFieldOrderIdeal)\n\nThe valuation of A at p.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/orders/ideals/#idempotents-Tuple{AbsNumFieldOrderIdeal, AbsNumFieldOrderIdeal}","page":"Ideals","title":"idempotents","text":"idempotents(x::AbsNumFieldOrderIdeal{AbsSimpleNumField, AbsSimpleNumFieldElem}, y::AbsNumFieldOrderIdeal{AbsSimpleNumField, AbsSimpleNumFieldElem}) -> AbsSimpleNumFieldOrderElem, AbsSimpleNumFieldOrderElem\n\nReturns a tuple (e, f) consisting of elements e in x, f in y such that 1 = e + f.\n\nIf the ideals are not coprime, an error is raised.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/orders/ideals/#Quotient-Rings","page":"Ideals","title":"Quotient Rings","text":"","category":"section"},{"location":"Hecke/manual/orders/ideals/","page":"Ideals","title":"Ideals","text":"quo(::Union{AbsNumFieldOrder, AlgAssAbsOrd}, ::Union{AbsNumFieldOrderIdeal, AlgAssAbsOrdIdl})\nresidue_ring(::AbsSimpleNumFieldOrder, ::AbsNumFieldOrderIdeal{AbsSimpleNumField, AbsSimpleNumFieldElem})\nresidue_field(::AbsSimpleNumFieldOrder, ::AbsNumFieldOrderIdeal{AbsSimpleNumField, AbsSimpleNumFieldElem}, ::Bool)\nmod(::AbsSimpleNumFieldOrderElem, ::AbsNumFieldOrderIdeal)\ncrt(::AbsSimpleNumFieldOrderElem, ::AbsNumFieldOrderIdeal{AbsSimpleNumField, AbsSimpleNumFieldElem}, ::AbsSimpleNumFieldOrderElem, ::AbsNumFieldOrderIdeal{AbsSimpleNumField, AbsSimpleNumFieldElem})\neuler_phi(::AbsNumFieldOrderIdeal{AbsSimpleNumField, AbsSimpleNumFieldElem})\nHecke.multiplicative_group(::AbsSimpleNumFieldOrderQuoRing)\nHecke.multiplicative_group_generators(::AbsSimpleNumFieldOrderQuoRing)","category":"page"},{"location":"Hecke/manual/orders/ideals/#quo-Tuple{Union{AbsNumFieldOrder, Hecke.AlgAssAbsOrd}, Union{AbsNumFieldOrderIdeal, Hecke.AlgAssAbsOrdIdl}}","page":"Ideals","title":"quo","text":"quo(O::AbsSimpleNumFieldOrder, I::AbsNumFieldOrderIdeal{AbsSimpleNumField, AbsSimpleNumFieldElem}) -> AbsSimpleNumFieldOrderQuoRing, Map\nquo(O::AlgAssAbsOrd, I::AlgAssAbsOrdIdl) -> AbsOrdQuoRing, Map\n\nThe quotient ring OI as a ring together with the section M OI to O. The pointwise inverse of M is the canonical projection Oto OI.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/orders/ideals/#residue_ring-Tuple{AbsSimpleNumFieldOrder, AbsSimpleNumFieldOrderIdeal}","page":"Ideals","title":"residue_ring","text":"residue_ring(O::AbsSimpleNumFieldOrder, I::AbsNumFieldOrderIdeal{AbsSimpleNumField, AbsSimpleNumFieldElem}) -> AbsSimpleNumFieldOrderQuoRing\nresidue_ring(O::AlgAssAbsOrd, I::AlgAssAbsOrdIdl) -> AbsOrdQuoRing\n\nThe quotient ring O modulo I as a new ring.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/orders/ideals/#residue_field-Tuple{AbsSimpleNumFieldOrder, AbsSimpleNumFieldOrderIdeal, Bool}","page":"Ideals","title":"residue_field","text":"residue_field(O::AbsSimpleNumFieldOrder, P::AbsNumFieldOrderIdeal{AbsSimpleNumField, AbsSimpleNumFieldElem}, check::Bool = true) -> Field, Map\n\nReturns the residue field of the prime ideal P together with the projection map. If check is true, the ideal is checked for being prime.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/orders/ideals/#mod-Tuple{AbsSimpleNumFieldOrderElem, AbsNumFieldOrderIdeal}","page":"Ideals","title":"mod","text":"mod(x::AbsSimpleNumFieldOrderElem, I::AbsNumFieldOrderIdeal)\n\nReturns the unique element y of the ambient order of x with x equiv y bmod I and the following property: If a_1dotsca_d in mathbfZ_geq 1 are the diagonal entries of the unique HNF basis matrix of I and (b_1dotscb_d) is the coefficient vector of y, then 0 leq b_i  a_i for 1 leq i leq d.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/orders/ideals/#crt-Tuple{AbsSimpleNumFieldOrderElem, AbsSimpleNumFieldOrderIdeal, AbsSimpleNumFieldOrderElem, AbsSimpleNumFieldOrderIdeal}","page":"Ideals","title":"crt","text":"crt(r1::AbsSimpleNumFieldOrderElem, i1::AbsNumFieldOrderIdeal{AbsSimpleNumField, AbsSimpleNumFieldElem}, r2::AbsSimpleNumFieldOrderElem, i2::AbsNumFieldOrderIdeal{AbsSimpleNumField, AbsSimpleNumFieldElem}) -> AbsSimpleNumFieldOrderElem\n\nFind x such that x equiv r_1 bmod i_1 and x equiv r_2 bmod i_2 using idempotents.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/orders/ideals/#euler_phi-Tuple{AbsSimpleNumFieldOrderIdeal}","page":"Ideals","title":"euler_phi","text":"euler_phi(A::AbsNumFieldOrderIdeal{AbsSimpleNumField, AbsSimpleNumFieldElem}) -> ZZRingElem\n\nThe ideal version of the totient function returns the size of the unit group of the residue ring modulo the ideal.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/orders/ideals/#multiplicative_group-Tuple{AbsSimpleNumFieldOrderQuoRing}","page":"Ideals","title":"multiplicative_group","text":"multiplicative_group(Q::AbsSimpleNumFieldOrderQuoRing) -> FinGenAbGroup, Map{FinGenAbGroup, AbsSimpleNumFieldOrderQuoRing}\nunit_group(Q::AbsSimpleNumFieldOrderQuoRing) -> FinGenAbGroup, Map{FinGenAbGroup, AbsSimpleNumFieldOrderQuoRing}\n\nReturns the unit group of Q as an abstract group A and an isomorphism map f colon A to Q^times.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/orders/ideals/#multiplicative_group_generators-Tuple{AbsSimpleNumFieldOrderQuoRing}","page":"Ideals","title":"multiplicative_group_generators","text":"multiplicative_group_generators(Q::AbsSimpleNumFieldOrderQuoRing) -> Vector{AbsSimpleNumFieldOrderQuoRingElem}\n\nReturn a set of generators for Q^times.\n\n\n\n\n\n","category":"method"},{"location":"CommutativeAlgebra/ModulesOverMultivariateRings/ideals_quorings_as_modules/","page":"Ideals and Quotient Rings as Modules","title":"Ideals and Quotient Rings as Modules","text":"CurrentModule = Oscar","category":"page"},{"location":"CommutativeAlgebra/ModulesOverMultivariateRings/ideals_quorings_as_modules/#Ideals-and-Quotient-Rings-as-Modules","page":"Ideals and Quotient Rings as Modules","title":"Ideals and Quotient Rings as Modules","text":"","category":"section"},{"location":"CommutativeAlgebra/ModulesOverMultivariateRings/ideals_quorings_as_modules/#Ideals-as-Modules","page":"Ideals and Quotient Rings as Modules","title":"Ideals as Modules","text":"","category":"section"},{"location":"CommutativeAlgebra/ModulesOverMultivariateRings/ideals_quorings_as_modules/","page":"Ideals and Quotient Rings as Modules","title":"Ideals and Quotient Rings as Modules","text":"ideal_as_module(I::Union{MPolyIdeal, MPolyQuoIdeal, MPolyLocalizedIdeal, MPolyQuoLocalizedIdeal})","category":"page"},{"location":"CommutativeAlgebra/ModulesOverMultivariateRings/ideals_quorings_as_modules/#ideal_as_module-Tuple{Union{MPolyIdeal, Oscar.MPolyLocalizedIdeal, MPolyQuoIdeal, Oscar.MPolyQuoLocalizedIdeal}}","page":"Ideals and Quotient Rings as Modules","title":"ideal_as_module","text":"ideal_as_module(I::Union{MPolyIdeal, MPolyQuoIdeal, MPolyLocalizedIdeal, MPolyQuoLocalizedIdeal})\n\nReturn I considered as an object of type SubquoModule.\n\nExamples\n\njulia> R, (x, y) = polynomial_ring(QQ, [:x, :y]);\n\njulia> I = ideal(R, [x^2, y^3])\nIdeal generated by\n  x^2\n  y^3\n\njulia> ideal_as_module(I)\nSubmodule with 2 generators\n  1: x^2*e[1]\n  2: y^3*e[1]\nrepresented as subquotient with no relations\n\njulia> S, (x, y) = graded_polynomial_ring(QQ, [:x, :y]);\n\njulia> I = ideal(S, [x^2, y^3])\nIdeal generated by\n  x^2\n  y^3\n\njulia> ideal_as_module(I)\nGraded submodule of S^1 with 2 generators\n  1: x^2*e[1]\n  2: y^3*e[1]\nrepresented as subquotient with no relations\n\n\n\n\n\n","category":"method"},{"location":"CommutativeAlgebra/ModulesOverMultivariateRings/ideals_quorings_as_modules/#Quotient-Rings-as-Modules","page":"Ideals and Quotient Rings as Modules","title":"Quotient Rings as Modules","text":"","category":"section"},{"location":"CommutativeAlgebra/ModulesOverMultivariateRings/ideals_quorings_as_modules/","page":"Ideals and Quotient Rings as Modules","title":"Ideals and Quotient Rings as Modules","text":"quotient_ring_as_module(A::MPolyQuoRing)","category":"page"},{"location":"CommutativeAlgebra/ModulesOverMultivariateRings/ideals_quorings_as_modules/#quotient_ring_as_module-Tuple{MPolyQuoRing}","page":"Ideals and Quotient Rings as Modules","title":"quotient_ring_as_module","text":"quotient_ring_as_module(A::MPolyQuoRing)\n\nReturn A considered as an object of type SubquoModule.\n\nquotient_ring_as_module(I::Union{MPolyIdeal, MPolyQuoIdeal, MPolyLocalizedIdeal, MPolyQuoLocalizedIdeal})\n\nAs above, where A is the quotient of base_ring(I) modulo I.\n\nExamples\n\njulia> R, (x, y) = polynomial_ring(QQ, [:x, :y]);\n\njulia> IR = ideal(R, [x^2, y^3]);\n\njulia> quotient_ring_as_module(IR)\nSubquotient of submodule with 1 generator\n  1: e[1]\nby submodule with 2 generators\n  1: x^2*e[1]\n  2: y^3*e[1]\n\njulia> base_ring(ans)\nMultivariate polynomial ring in 2 variables x, y\n  over rational field\n\njulia> A, _ = quo(R, ideal(R,[x*y]));\n\njulia> AI = ideal(A, [x^2, y^3]);\n\njulia> quotient_ring_as_module(AI)\nSubquotient of submodule with 1 generator\n  1: e[1]\nby submodule with 2 generators\n  1: x^2*e[1]\n  2: y^3*e[1]\n\njulia> base_ring(ans)\nQuotient\n  of multivariate polynomial ring in 2 variables x, y\n    over rational field\n  by ideal (x*y)\n\n\njulia> S, (x, y) = graded_polynomial_ring(QQ, [:x, :y]);\n\njulia> I = ideal(S, [x^2, y^3])\nIdeal generated by\n  x^2\n  y^3\n\njulia> quotient_ring_as_module(I)\nGraded subquotient of graded submodule of S^1 with 1 generator\n  1: e[1]\nby graded submodule of S^1 with 2 generators\n  1: x^2*e[1]\n  2: y^3*e[1]\n\n\n\n\n\n\n","category":"method"},{"location":"NoncommutativeAlgebra/PBWAlgebras/ideals/","page":"Ideals in PBW-algebras","title":"Ideals in PBW-algebras","text":"CurrentModule = Oscar\nDocTestSetup = Oscar.doctestsetup()","category":"page"},{"location":"NoncommutativeAlgebra/PBWAlgebras/ideals/#Ideals-in-PBW-algebras","page":"Ideals in PBW-algebras","title":"Ideals in PBW-algebras","text":"","category":"section"},{"location":"NoncommutativeAlgebra/PBWAlgebras/ideals/#Types","page":"Ideals in PBW-algebras","title":"Types","text":"","category":"section"},{"location":"NoncommutativeAlgebra/PBWAlgebras/ideals/","page":"Ideals in PBW-algebras","title":"Ideals in PBW-algebras","text":"The OSCAR type for ideals in PBW-algebras is of parametrized form PBWAlgIdeal{D, T, S}, where D encodes the direction left, right, or two-sided, and T is the element type of the field over which the PBW-algebra is defined (the type S is added for internal use).","category":"page"},{"location":"NoncommutativeAlgebra/PBWAlgebras/ideals/#Constructors","page":"Ideals in PBW-algebras","title":"Constructors","text":"","category":"section"},{"location":"NoncommutativeAlgebra/PBWAlgebras/ideals/","page":"Ideals in PBW-algebras","title":"Ideals in PBW-algebras","text":"left_ideal(g::Vector{<:PBWAlgElem})\nright_ideal(g::Vector{<:PBWAlgElem})\ntwo_sided_ideal(g::Vector{<:PBWAlgElem})","category":"page"},{"location":"NoncommutativeAlgebra/PBWAlgebras/ideals/#left_ideal-Tuple{Vector{<:PBWAlgElem}}","page":"Ideals in PBW-algebras","title":"left_ideal","text":"left_ideal(g::Vector{<:PBWAlgElem})\n\nGiven a vector g of elements in a PBW-algebra A, say, return the left ideal of A generated by these elements.\n\nleft_ideal(A::PBWAlgRing, g::AbstractVector)\n\nGiven a vector g of elements of A, return the left ideal of A generated by these elements.\n\nExamples\n\njulia> R, (x, y, z) = QQ[:x, :y, :z];\n\njulia> L = [x*y, x*z, y*z + 1];\n\njulia> REL = strictly_upper_triangular_matrix(L);\n\njulia> A, (x, y, z) = pbw_algebra(R, REL, deglex(gens(R)))\n(PBW-algebra over rational field in x, y, z with relations y*x = x*y, z*x = x*z, z*y = y*z + 1, PBWAlgElem{QQFieldElem, Singular.n_Q}[x, y, z])\n\njulia> I = left_ideal(A, [x^2*y^2, x*z+y*z])\nleft_ideal(x^2*y^2, x*z + y*z)\n\n\n\n\n\n","category":"method"},{"location":"NoncommutativeAlgebra/PBWAlgebras/ideals/#right_ideal-Tuple{Vector{<:PBWAlgElem}}","page":"Ideals in PBW-algebras","title":"right_ideal","text":"right_ideal(g::Vector{<:PBWAlgElem})\n\nGiven a vector g of elements in a PBW-algebra A, say, return the right ideal of A generated by these elements.\n\nright_ideal(A::PBWAlgRing, g::AbstractVector)\n\nGiven a vector g of elements of A, return the right ideal of A generated by these elements.\n\n\n\n\n\n","category":"method"},{"location":"NoncommutativeAlgebra/PBWAlgebras/ideals/#two_sided_ideal-Tuple{Vector{<:PBWAlgElem}}","page":"Ideals in PBW-algebras","title":"two_sided_ideal","text":"two_sided_ideal(g::Vector{<:PBWAlgElem})\n\nGiven a vector g of elements in a PBW-algebra A, say, return the two-sided ideal of A generated by these elements.\n\ntwo_sided_ideal(A::PBWAlgRing, g::AbstractVector)\n\nGiven a vector g of elements of A, return the two-sided ideal of A generated by these elements.\n\n\n\n\n\n","category":"method"},{"location":"NoncommutativeAlgebra/PBWAlgebras/ideals/#Gröbner-bases","page":"Ideals in PBW-algebras","title":"Gröbner bases","text":"","category":"section"},{"location":"NoncommutativeAlgebra/PBWAlgebras/ideals/#Data-Associated-to-Ideals","page":"Ideals in PBW-algebras","title":"Data Associated to Ideals","text":"","category":"section"},{"location":"NoncommutativeAlgebra/PBWAlgebras/ideals/","page":"Ideals in PBW-algebras","title":"Ideals in PBW-algebras","text":"If I is an ideal of a PBW-algebra  A, then","category":"page"},{"location":"NoncommutativeAlgebra/PBWAlgebras/ideals/","page":"Ideals in PBW-algebras","title":"Ideals in PBW-algebras","text":"base_ring(I) refers to A,\ngens(I) to the generators of I,\nnumber_of_generators(I) / ngens(I) to the number of these generators, and\ngen(I, k) as well as I[k] to the k-th such generator.","category":"page"},{"location":"NoncommutativeAlgebra/PBWAlgebras/ideals/#Examples","page":"Ideals in PBW-algebras","title":"Examples","text":"","category":"section"},{"location":"NoncommutativeAlgebra/PBWAlgebras/ideals/","page":"Ideals in PBW-algebras","title":"Ideals in PBW-algebras","text":"julia> D, (x, y, dx, dy) = weyl_algebra(QQ, [\"x\", \"y\"])\n(Weyl-algebra over rational field in variables (x, y), PBWAlgElem{QQFieldElem, Singular.n_Q}[x, y, dx, dy])\n\njulia> I = left_ideal(D, [x, dx])\nleft_ideal(x, dx)\n\njulia> base_ring(I)\nWeyl-algebra over rational field in variables (x, y)\n\njulia> gens(I)\n2-element Vector{PBWAlgElem{QQFieldElem, Singular.n_Q}}:\n x\n dx\n\njulia> number_of_generators(I)\n2\n\njulia> gen(I, 2)\ndx\n","category":"page"},{"location":"NoncommutativeAlgebra/PBWAlgebras/ideals/#Operations-on-Ideals","page":"Ideals in PBW-algebras","title":"Operations on Ideals","text":"","category":"section"},{"location":"NoncommutativeAlgebra/PBWAlgebras/ideals/#Simple-Ideal-Operations","page":"Ideals in PBW-algebras","title":"Simple Ideal Operations","text":"","category":"section"},{"location":"NoncommutativeAlgebra/PBWAlgebras/ideals/#Powers-of-Ideal","page":"Ideals in PBW-algebras","title":"Powers of Ideal","text":"","category":"section"},{"location":"NoncommutativeAlgebra/PBWAlgebras/ideals/","page":"Ideals in PBW-algebras","title":"Ideals in PBW-algebras","text":"^(I::PBWAlgIdeal{D, T, S}, k::Int) where {D, T, S}","category":"page"},{"location":"NoncommutativeAlgebra/PBWAlgebras/ideals/#^-Union{Tuple{S}, Tuple{T}, Tuple{D}, Tuple{Oscar.PBWAlgIdeal{D, T, S}, Int64}} where {D, T, S}","page":"Ideals in PBW-algebras","title":"^","text":"^(I::PBWAlgIdeal{D, T, S}, k::Int) where {D, T, S}\n\nGiven a two_sided ideal I, return the k-th power of I.\n\nExamples\n\njulia> D, (x, dx) = weyl_algebra(GF(3), [:x]);\n\njulia> I = two_sided_ideal(D, [x^3])\ntwo_sided_ideal(x^3)\n\njulia> I^2\ntwo_sided_ideal(x^6)\n\n\n\n\n\n","category":"method"},{"location":"NoncommutativeAlgebra/PBWAlgebras/ideals/#Sum-of-Ideals","page":"Ideals in PBW-algebras","title":"Sum of Ideals","text":"","category":"section"},{"location":"NoncommutativeAlgebra/PBWAlgebras/ideals/","page":"Ideals in PBW-algebras","title":"Ideals in PBW-algebras","text":"+(I::PBWAlgIdeal{D, T, S}, J::PBWAlgIdeal{D, T, S}) where {D, T, S}","category":"page"},{"location":"NoncommutativeAlgebra/PBWAlgebras/ideals/#+-Union{Tuple{S}, Tuple{T}, Tuple{D}, Tuple{Oscar.PBWAlgIdeal{D, T, S}, Oscar.PBWAlgIdeal{D, T, S}}} where {D, T, S}","page":"Ideals in PBW-algebras","title":"+","text":"+(I::PBWAlgIdeal{D, T, S}, J::PBWAlgIdeal{D, T, S}) where {D, T, S}\n\nReturn the sum of I and J.\n\n\n\n\n\n","category":"method"},{"location":"NoncommutativeAlgebra/PBWAlgebras/ideals/#Product-of-Ideals","page":"Ideals in PBW-algebras","title":"Product of Ideals","text":"","category":"section"},{"location":"NoncommutativeAlgebra/PBWAlgebras/ideals/","page":"Ideals in PBW-algebras","title":"Ideals in PBW-algebras","text":"*(I::PBWAlgIdeal{DI, T, S}, J::PBWAlgIdeal{DJ, T, S}) where {DI, DJ, T, S}","category":"page"},{"location":"NoncommutativeAlgebra/PBWAlgebras/ideals/#*-Union{Tuple{S}, Tuple{T}, Tuple{DJ}, Tuple{DI}, Tuple{Oscar.PBWAlgIdeal{DI, T, S}, Oscar.PBWAlgIdeal{DJ, T, S}}} where {DI, DJ, T, S}","page":"Ideals in PBW-algebras","title":"*","text":"*(I::PBWAlgIdeal{DI, T, S}, J::PBWAlgIdeal{DJ, T, S}) where {DI, DJ, T, S}\n\nGiven two ideals I and J such that both I and J are two-sided ideals or I and J are a left and a right ideal, respectively, return the product of I and J.\n\nExamples\n\njulia> D, (x, y, dx, dy) = weyl_algebra(GF(3), [:x, :y]);\n\njulia> I = left_ideal(D, [x^3+y^3, x*y^2])\nleft_ideal(x^3 + y^3, x*y^2)\n\njulia> J = right_ideal(D, [dx^3, dy^5])\nright_ideal(dx^3, dy^5)\n\njulia> I*J\ntwo_sided_ideal(x^3*dx^3 + y^3*dx^3, x^3*dy^5 + y^3*dy^5, x*y^2*dx^3, x*y^2*dy^5)\n\n\n\n\n\n","category":"method"},{"location":"NoncommutativeAlgebra/PBWAlgebras/ideals/#Intersection-of-Ideals","page":"Ideals in PBW-algebras","title":"Intersection of Ideals","text":"","category":"section"},{"location":"NoncommutativeAlgebra/PBWAlgebras/ideals/","page":"Ideals in PBW-algebras","title":"Ideals in PBW-algebras","text":"intersect(I::PBWAlgIdeal{D, T, S}, Js::PBWAlgIdeal{D, T, S}...) where {D, T, S}\nintersect(V::Vector{PBWAlgIdeal{D, T, S}}) where {D, T, S}","category":"page"},{"location":"NoncommutativeAlgebra/PBWAlgebras/ideals/#intersect-Union{Tuple{S}, Tuple{T}, Tuple{D}, Tuple{Oscar.PBWAlgIdeal{D, T, S}, Vararg{Oscar.PBWAlgIdeal{D, T, S}}}} where {D, T, S}","page":"Ideals in PBW-algebras","title":"intersect","text":"intersect(I::PBWAlgIdeal{D, T, S}, Js::PBWAlgIdeal{D, T, S}...) where {D, T, S}\nintersect(V::Vector{PBWAlgIdeal{D, T, S}}) where {D, T, S}\n\nReturn the intersection of two or more ideals.\n\nExamples\n\njulia> D, (x, y, dx, dy) = weyl_algebra(QQ, [:x, :y]);\n\njulia> I = intersect(left_ideal(D, [x^2, x*dy, dy^2])+left_ideal(D, [dx]), left_ideal(D, [dy^2-x^3+x]))\nleft_ideal(-x^3 + dy^2 + x)\n\n\n\n\n\n","category":"method"},{"location":"NoncommutativeAlgebra/PBWAlgebras/ideals/#intersect-Union{Tuple{Array{Oscar.PBWAlgIdeal{D, T, S}, 1}}, Tuple{S}, Tuple{T}, Tuple{D}} where {D, T, S}","page":"Ideals in PBW-algebras","title":"intersect","text":"intersect(a::AlgAssAbsOrdIdl, b::AlgAssAbsOrdIdl) -> AlgAssAbsOrdIdl\n\nReturns a cap b.\n\n\n\n\n\nintersect(a::AlgAssRelOrdIdl, b::AlgAssRelOrdIdl) -> AlgAssRelOrdIdl\n\nReturns a cap b.\n\n\n\n\n\nintersect(I::MPolyIdeal{T}, Js::MPolyIdeal{T}...) where T\nintersect(V::Vector{MPolyIdeal{T}}) where T\n\nReturn the intersection of two or more ideals.\n\nExamples\n\njulia> R, (x, y) = polynomial_ring(QQ, [:x, :y])\n(Multivariate polynomial ring in 2 variables over QQ, QQMPolyRingElem[x, y])\n\njulia> I = ideal(R, [x, y])^2;\n\njulia> J = ideal(R, [y^2-x^3+x]);\n\njulia> intersect(I, J)\nIdeal generated by\n  x^3*y - x*y - y^3\n  x^4 - x^2 - x*y^2\n\njulia> intersect([I, J])\nIdeal generated by\n  x^3*y - x*y - y^3\n  x^4 - x^2 - x*y^2\n\n\n\n\n\nintersect(a::MPolyQuoIdeal{T}, bs::MPolyQuoIdeal{T}...) where T\nintersect(V::Vector{MPolyQuoIdeal{T}}) where T\n\nReturn the intersection of two or more ideals.\n\nExamples\n\njulia> R, (x, y) = polynomial_ring(QQ, [:x, :y]);\n\njulia> A, _ = quo(R, ideal(R, [x^2-y^3, x-y]));\n\njulia> a = ideal(A, [y^2])\nIdeal generated by\n  y^2\n\njulia> b = ideal(A, [x])\nIdeal generated by\n  x\n\njulia> intersect(a,b)\nIdeal generated by\n  x*y\n\njulia> intersect([a,b])\nIdeal generated by\n  x*y\n\n\n\n\n\nintersect(I::PBWAlgIdeal{D, T, S}, Js::PBWAlgIdeal{D, T, S}...) where {D, T, S}\nintersect(V::Vector{PBWAlgIdeal{D, T, S}}) where {D, T, S}\n\nReturn the intersection of two or more ideals.\n\nExamples\n\njulia> D, (x, y, dx, dy) = weyl_algebra(QQ, [:x, :y]);\n\njulia> I = intersect(left_ideal(D, [x^2, x*dy, dy^2])+left_ideal(D, [dx]), left_ideal(D, [dy^2-x^3+x]))\nleft_ideal(-x^3 + dy^2 + x)\n\n\n\n\n\nintersect(M::SubquoModule{T}, N::SubquoModule{T}) where T\n\nGiven subquotients M and N such that ambient_module(M) == ambient_module(N), return the intersection of M and N regarded as submodules of the common ambient module.\n\nAdditionally, return the inclusion maps M cap N to M and M cap N to N.\n\nExamples\n\njulia> R, (x, y, z) = polynomial_ring(QQ, [:x, :y, :z])\n(Multivariate polynomial ring in 3 variables over QQ, QQMPolyRingElem[x, y, z])\n\njulia> F = free_module(R, 1)\nFree module of rank 1 over R\n\njulia> AM = R[x;]\n[x]\n\njulia> BM = R[x^2; y^3; z^4]\n[x^2]\n[y^3]\n[z^4]\n\njulia> M = SubquoModule(F, AM, BM)\nSubquotient of submodule with 1 generator\n  1: x*e[1]\nby submodule with 3 generators\n  1: x^2*e[1]\n  2: y^3*e[1]\n  3: z^4*e[1]\n\njulia> AN = R[y;]\n[y]\n\njulia> BN = R[x^2; y^3; z^4]\n[x^2]\n[y^3]\n[z^4]\n\njulia> N = SubquoModule(F, AN, BN)\nSubquotient of submodule with 1 generator\n  1: y*e[1]\nby submodule with 3 generators\n  1: x^2*e[1]\n  2: y^3*e[1]\n  3: z^4*e[1]\n\njulia> intersect(M, N)\n(Subquotient of submodule with 2 generators\n  1: -x*y*e[1]\n  2: x*z^4*e[1]\nby submodule with 3 generators\n  1: x^2*e[1]\n  2: y^3*e[1]\n  3: z^4*e[1], Hom: subquotient of submodule with 2 generators\n  1: -x*y*e[1]\n  2: x*z^4*e[1]\nby submodule with 3 generators\n  1: x^2*e[1]\n  2: y^3*e[1]\n  3: z^4*e[1] -> M, Hom: subquotient of submodule with 2 generators\n  1: -x*y*e[1]\n  2: x*z^4*e[1]\nby submodule with 3 generators\n  1: x^2*e[1]\n  2: y^3*e[1]\n  3: z^4*e[1] -> N)\n\njulia> Rg, (x, y, z) = graded_polynomial_ring(QQ, [:x, :y, :z]);\n\njulia> F = graded_free_module(Rg, 1);\n\njulia> AM = Rg[x;];\n\njulia> BM = Rg[x^2; y^3; z^4];\n\njulia> M = SubquoModule(F, AM, BM)\nGraded subquotient of graded submodule of F with 1 generator\n  1: x*e[1]\nby graded submodule of F with 3 generators\n  1: x^2*e[1]\n  2: y^3*e[1]\n  3: z^4*e[1]\n\njulia> AN = Rg[y;];\n\njulia> BN = Rg[x^2; y^3; z^4];\n\njulia> N = SubquoModule(F, AN, BN)\nGraded subquotient of graded submodule of F with 1 generator\n  1: y*e[1]\nby graded submodule of F with 3 generators\n  1: x^2*e[1]\n  2: y^3*e[1]\n  3: z^4*e[1]\n\njulia> intersect(M, N)\n(Graded subquotient of graded submodule of F with 2 generators\n  1: -x*y*e[1]\n  2: x*z^4*e[1]\nby graded submodule of F with 3 generators\n  1: x^2*e[1]\n  2: y^3*e[1]\n  3: z^4*e[1], Hom: graded subquotient of graded submodule of F with 2 generators\n  1: -x*y*e[1]\n  2: x*z^4*e[1]\nby graded submodule of F with 3 generators\n  1: x^2*e[1]\n  2: y^3*e[1]\n  3: z^4*e[1] -> M, Hom: graded subquotient of graded submodule of F with 2 generators\n  1: -x*y*e[1]\n  2: x*z^4*e[1]\nby graded submodule of F with 3 generators\n  1: x^2*e[1]\n  2: y^3*e[1]\n  3: z^4*e[1] -> N)\n\n\n\n\n\n\n","category":"method"},{"location":"NoncommutativeAlgebra/PBWAlgebras/ideals/#Elimination","page":"Ideals in PBW-algebras","title":"Elimination","text":"","category":"section"},{"location":"NoncommutativeAlgebra/PBWAlgebras/ideals/","page":"Ideals in PBW-algebras","title":"Ideals in PBW-algebras","text":"Let","category":"page"},{"location":"NoncommutativeAlgebra/PBWAlgebras/ideals/","page":"Ideals in PBW-algebras","title":"Ideals in PBW-algebras","text":"A = Klangle x_1 dots  x_n mid x_jx_i = c_ijx_ix_j+d_ij   1leq ij leq n rangle","category":"page"},{"location":"NoncommutativeAlgebra/PBWAlgebras/ideals/","page":"Ideals in PBW-algebras","title":"Ideals in PBW-algebras","text":"be a PBW-algebra. Fix a subset sigmasubset 1dots n, write x_sigma  for the set of variables x_i with iinsigma, and let A_sigma be the K-linear  subspace of A which is generated by the standard monomials in langle x_sigma rangle. Suppose there exists a global monomial ordering  on A which is both admissible for A and an elimination ordering for xsmallsetminus x_sigma. Then A_sigma is a subalgebra of A with d_ijin A_sigma for each pair of indices 1leq ij leq n with ijinsigma. In particular, A_sigma  is a PBW-algebra with admissible ordering _sigma, where _sigma is the restriction of  to the set of standard monomials in  langle x_sigmarangle. Moreover, if Isubset A is a nonzero (left, right, two-sided) ideal, and mathcal G is a (left, right, two-sided) Gröbner basis for I with respect to , then mathcal Gcap A_sigma is a (left, right, two-sided) Gröbner basis for Icap A_sigma with respect to _sigma. We refer to computing Icap A_sigma as eliminating the variables in xsmallsetminus x_sigma from I","category":"page"},{"location":"NoncommutativeAlgebra/PBWAlgebras/ideals/","page":"Ideals in PBW-algebras","title":"Ideals in PBW-algebras","text":"note: Note\nIf the relevant d_ij are all contained in A_sigma, we also say that A_sigma is admissible for elimination.","category":"page"},{"location":"NoncommutativeAlgebra/PBWAlgebras/ideals/","page":"Ideals in PBW-algebras","title":"Ideals in PBW-algebras","text":"note: Note\nA monomial ordering which is both admissible for A and an elimination ordering for xsmallsetminus x_sigma may not exist. ","category":"page"},{"location":"NoncommutativeAlgebra/PBWAlgebras/ideals/","page":"Ideals in PBW-algebras","title":"Ideals in PBW-algebras","text":"eliminate(I::PBWAlgIdeal, V::Vector{<:PBWAlgElem}; ordering = nothing)","category":"page"},{"location":"NoncommutativeAlgebra/PBWAlgebras/ideals/#eliminate-Tuple{Oscar.PBWAlgIdeal, Vector{<:PBWAlgElem}}","page":"Ideals in PBW-algebras","title":"eliminate","text":"eliminate(I::PBWAlgIdeal, V::Vector{<:PBWAlgElem}; ordering = nothing)\n\nGiven a vector V of variables, these variables are eliminated from I. That is, return the ideal generated by all polynomials in I which only involve the remaining variables.\n\neliminate(I::PBWAlgIdeal, V::Vector{Int}; ordering = nothing)\n\nGiven a vector V of indices which specify variables, these variables are eliminated from I. That is, return the ideal generated by all polynomials in I which only involve the remaining variables.\n\nnote: Note\nThe return value is an ideal of the original algebra.\n\nnote: Note\nIf provided, the ordering must be an admissible elimination ordering (this is checked by the function).    If not provided, finding an admissible elimination ordering may involve solving a particular linear programming problem. Here, the function is implemented so that it searches for solutions in a certain range only. If no solution is found in that range, the function will throw an error.\n\nExamples\n\njulia> R, (x, y, z, a) = QQ[:x, :y, :z, :a];\n\njulia> L = [x*y-z, x*z+2*x, x*a, y*z-2*y, y*a, z*a];\n\njulia> REL = strictly_upper_triangular_matrix(L);\n\njulia> A, (x, y, z, a) = pbw_algebra(R, REL, deglex(gens(R)))\n(PBW-algebra over rational field in x, y, z, a with relations y*x = x*y - z, z*x = x*z + 2*x, a*x = x*a, z*y = y*z - 2*y, a*y = y*a, a*z = z*a, PBWAlgElem{QQFieldElem, Singular.n_Q}[x, y, z, a])\n\njulia> f = 4*x*y+z^2-2*z-a;\n\njulia> I = left_ideal(A, [x^2, y^2, z^2-1, f])\nleft_ideal(x^2, y^2, z^2 - 1, 4*x*y + z^2 - 2*z - a)\n\njulia> eliminate(I, [x, y, z])\nleft_ideal(a - 3)\n\njulia> eliminate(I, [1, 2 ,3])\nleft_ideal(a - 3)\n\njulia> try eliminate(I, [z, a]); catch e; e; end\nErrorException(\"no elimination is possible: subalgebra is not admissible\")\n\njulia> R, (p, q) = QQ[:p, :q];\n\njulia> L = [p*q+q^2];\n\njulia> REL = strictly_upper_triangular_matrix(L);\n\njulia> A, (p, q) = pbw_algebra(R, REL, lex(gens(R)))\n(PBW-algebra over rational field in p, q with relations q*p = p*q + q^2, PBWAlgElem{QQFieldElem, Singular.n_Q}[p, q])\n\njulia> I = left_ideal(A, [p, q])\nleft_ideal(p, q)\n\njulia> try eliminate(I, [q]); catch e; e; end   # in fact, no elimination ordering exists\nErrorException(\"could not find elimination ordering\")\n\n\n\n\n\n","category":"method"},{"location":"NoncommutativeAlgebra/PBWAlgebras/ideals/#Tests-on-Ideals","page":"Ideals in PBW-algebras","title":"Tests on Ideals","text":"","category":"section"},{"location":"NoncommutativeAlgebra/PBWAlgebras/ideals/","page":"Ideals in PBW-algebras","title":"Ideals in PBW-algebras","text":"is_zero(I:: PBWAlgIdeal)","category":"page"},{"location":"NoncommutativeAlgebra/PBWAlgebras/ideals/#is_zero-Tuple{Oscar.PBWAlgIdeal}","page":"Ideals in PBW-algebras","title":"is_zero","text":"is_zero(I::PBWAlgIdeal)\n\nReturn true if I is the zero ideal, false otherwise.\n\nExamples\n\njulia> D, (x, y, dx, dy) = weyl_algebra(QQ, [:x, :y])\n(Weyl-algebra over rational field in variables (x, y), PBWAlgElem{QQFieldElem, Singular.n_Q}[x, y, dx, dy])\n\njulia> I = left_ideal(D, [x, dx])\nleft_ideal(x, dx)\n\njulia> is_zero(I)\nfalse\n\n\n\n\n\n","category":"method"},{"location":"NoncommutativeAlgebra/PBWAlgebras/ideals/","page":"Ideals in PBW-algebras","title":"Ideals in PBW-algebras","text":"is_one(I:: PBWAlgIdeal)","category":"page"},{"location":"NoncommutativeAlgebra/PBWAlgebras/ideals/#is_one-Tuple{Oscar.PBWAlgIdeal}","page":"Ideals in PBW-algebras","title":"is_one","text":"is_one(I::PBWAlgIdeal{D}) where D\n\nReturn true if I is generated by 1, false otherwise.\n\nExamples\n\njulia> D, (x, y, dx, dy) = weyl_algebra(QQ, [:x, :y])\n(Weyl-algebra over rational field in variables (x, y), PBWAlgElem{QQFieldElem, Singular.n_Q}[x, y, dx, dy])\n\njulia> I = left_ideal(D, [x, dx])\nleft_ideal(x, dx)\n\njulia> is_one(I)\ntrue\n\njulia> J = left_ideal(D, [y*x])\nleft_ideal(x*y)\n\njulia> is_one(J)\nfalse\n\njulia> K = two_sided_ideal(D, [y*x])\ntwo_sided_ideal(x*y)\n\njulia> is_one(K)\ntrue\n\njulia> D, (x, y, dx, dy) = weyl_algebra(GF(3), [:x, :y]);\n\njulia> I = two_sided_ideal(D, [x^3])\ntwo_sided_ideal(x^3)\n\njulia> is_one(I)\nfalse\n\n\n\n\n\n","category":"method"},{"location":"NoncommutativeAlgebra/PBWAlgebras/ideals/","page":"Ideals in PBW-algebras","title":"Ideals in PBW-algebras","text":"is_subset(I::PBWAlgIdeal{D, T, S}, J::PBWAlgIdeal{D, T, S}) where {D, T, S}","category":"page"},{"location":"NoncommutativeAlgebra/PBWAlgebras/ideals/#is_subset-Union{Tuple{S}, Tuple{T}, Tuple{D}, Tuple{Oscar.PBWAlgIdeal{D, T, S}, Oscar.PBWAlgIdeal{D, T, S}}} where {D, T, S}","page":"Ideals in PBW-algebras","title":"is_subset","text":"is_subset(I::PBWAlgIdeal{D, T, S}, J::PBWAlgIdeal{D, T, S}) where {D, T, S}\n\nReturn true if I is contained in J, false otherwise.\n\nExamples\n\njulia> D, (x, dx) = weyl_algebra(QQ, [:x]);\n\njulia> I = left_ideal(D, [dx^2])\nleft_ideal(dx^2)\n\njulia> J = left_ideal(D, [x*dx^4, x^3*dx^2])\nleft_ideal(x*dx^4, x^3*dx^2)\n\njulia> is_subset(I, J)\ntrue\n\n\n\n\n\n","category":"method"},{"location":"NoncommutativeAlgebra/PBWAlgebras/ideals/","page":"Ideals in PBW-algebras","title":"Ideals in PBW-algebras","text":"==(I::PBWAlgIdeal{D, T, S}, J::PBWAlgIdeal{D, T, S}) where {D, T, S}","category":"page"},{"location":"NoncommutativeAlgebra/PBWAlgebras/ideals/#==-Union{Tuple{S}, Tuple{T}, Tuple{D}, Tuple{Oscar.PBWAlgIdeal{D, T, S}, Oscar.PBWAlgIdeal{D, T, S}}} where {D, T, S}","page":"Ideals in PBW-algebras","title":"==","text":"==(I::PBWAlgIdeal{D, T, S}, J::PBWAlgIdeal{D, T, S}) where {D, T, S}\n\nReturn true if I is equal to J, false otherwise.\n\nExamples\n\njulia> D, (x, dx) = weyl_algebra(QQ, [:x]);\n\njulia> I = left_ideal(D, [dx^2])\nleft_ideal(dx^2)\n\njulia> J = left_ideal(D, [x*dx^4, x^3*dx^2])\nleft_ideal(x*dx^4, x^3*dx^2)\n\njulia> I == J\ntrue\n\n\n\n\n\n","category":"method"},{"location":"NoncommutativeAlgebra/PBWAlgebras/ideals/","page":"Ideals in PBW-algebras","title":"Ideals in PBW-algebras","text":"ideal_membership(f::PBWAlgElem{T, S}, I::PBWAlgIdeal{D, T, S}) where {D, T, S}","category":"page"},{"location":"NoncommutativeAlgebra/PBWAlgebras/ideals/#ideal_membership-Union{Tuple{S}, Tuple{T}, Tuple{D}, Tuple{PBWAlgElem{T, S}, Oscar.PBWAlgIdeal{D, T, S}}} where {D, T, S}","page":"Ideals in PBW-algebras","title":"ideal_membership","text":"ideal_membership(f::PBWAlgElem{T, S}, I::PBWAlgIdeal{D, T, S}) where {D, T, S}\n\nReturn true if f is contained in I, false otherwise. Alternatively, use f in I.\n\nExamples\n\njulia> D, (x, dx) = weyl_algebra(QQ, [:x]);\n\njulia> I = left_ideal(D, [x*dx^4, x^3*dx^2])\nleft_ideal(x*dx^4, x^3*dx^2)\n\njulia> dx^2 in I\ntrue\n\njulia> D, (x, y, dx, dy) = weyl_algebra(QQ, [:x, :y]);\n\njulia> I = two_sided_ideal(D, [x, dx])\ntwo_sided_ideal(x, dx)\n\njulia> one(D) in I\ntrue\n\n\n\n\n\n","category":"method"},{"location":"AlgebraicGeometry/ToricVarieties/ToricDivisorClasses/","page":"Toric Divisor Classes","title":"Toric Divisor Classes","text":"CurrentModule = Oscar","category":"page"},{"location":"AlgebraicGeometry/ToricVarieties/ToricDivisorClasses/#Toric-Divisor-Classes","page":"Toric Divisor Classes","title":"Toric Divisor Classes","text":"","category":"section"},{"location":"AlgebraicGeometry/ToricVarieties/ToricDivisorClasses/#Introduction","page":"Toric Divisor Classes","title":"Introduction","text":"","category":"section"},{"location":"AlgebraicGeometry/ToricVarieties/ToricDivisorClasses/","page":"Toric Divisor Classes","title":"Toric Divisor Classes","text":"Toric divisor classes are equivalence classes of Weil divisors modulo linear equivalence.","category":"page"},{"location":"AlgebraicGeometry/ToricVarieties/ToricDivisorClasses/#Constructors","page":"Toric Divisor Classes","title":"Constructors","text":"","category":"section"},{"location":"AlgebraicGeometry/ToricVarieties/ToricDivisorClasses/#General-constructors","page":"Toric Divisor Classes","title":"General constructors","text":"","category":"section"},{"location":"AlgebraicGeometry/ToricVarieties/ToricDivisorClasses/","page":"Toric Divisor Classes","title":"Toric Divisor Classes","text":"toric_divisor_class(v::NormalToricVarietyType, class::FinGenAbGroupElem)\ntoric_divisor_class(v::NormalToricVarietyType, coeffs::Vector{T}) where {T <: IntegerUnion}\ntoric_divisor_class(td::ToricDivisor)","category":"page"},{"location":"AlgebraicGeometry/ToricVarieties/ToricDivisorClasses/#toric_divisor_class-Tuple{Union{AffineNormalToricVariety, CyclicQuotientSingularity, NormalToricVariety}, FinGenAbGroupElem}","page":"Toric Divisor Classes","title":"toric_divisor_class","text":"toric_divisor_class(v::NormalToricVarietyType, class::FinGenAbGroupElem)\n\nConstruct the toric divisor class associated to a group element of the class group of the normal toric variety v.\n\nExamples\n\njulia> P2 = projective_space(NormalToricVariety, 2)\nNormal toric variety\n\njulia> tdc = toric_divisor_class(P2, class_group(P2)([1]))\nDivisor class on a normal toric variety\n\n\n\n\n\n","category":"method"},{"location":"AlgebraicGeometry/ToricVarieties/ToricDivisorClasses/#toric_divisor_class-Union{Tuple{T}, Tuple{Union{AffineNormalToricVariety, CyclicQuotientSingularity, NormalToricVariety}, Vector{T}}} where T<:Union{Integer, ZZRingElem}","page":"Toric Divisor Classes","title":"toric_divisor_class","text":"toric_divisor_class(v::NormalToricVarietyType, coeffs::Vector{T}) where {T <: IntegerUnion}\n\nConstruct the toric divisor class associated to a list of integers which specify an element of the class group of the normal toric variety v.\n\nExamples\n\njulia> P2 = projective_space(NormalToricVariety, 2)\nNormal toric variety\n\njulia> tdc = toric_divisor_class(P2, class_group(P2)([ZZRingElem(1)]))\nDivisor class on a normal toric variety\n\n\n\n\n\n","category":"method"},{"location":"AlgebraicGeometry/ToricVarieties/ToricDivisorClasses/#toric_divisor_class-Tuple{ToricDivisor}","page":"Toric Divisor Classes","title":"toric_divisor_class","text":"toric_divisor_class(td::ToricDivisor)\n\nConstruct the toric divisor class associated to the element ... of the class group of the normal toric variety v.\n\nExamples\n\njulia> P2 = projective_space(NormalToricVariety, 2)\nNormal toric variety\n\njulia> td = toric_divisor(P2, [1, 2, 3])\nTorus-invariant, non-prime divisor on a normal toric variety\n\njulia> tdc = toric_divisor_class(td)\nDivisor class on a normal toric variety\n\n\n\n\n\n","category":"method"},{"location":"AlgebraicGeometry/ToricVarieties/ToricDivisorClasses/#Addition,-subtraction-and-scalar-multiplication","page":"Toric Divisor Classes","title":"Addition, subtraction and scalar multiplication","text":"","category":"section"},{"location":"AlgebraicGeometry/ToricVarieties/ToricDivisorClasses/","page":"Toric Divisor Classes","title":"Toric Divisor Classes","text":"Toric divisor classes can be added and subtracted via the usual + and - operators. Moreover, multiplication by scalars from the left is supported for scalars which are integers or of type ZZRingElem.","category":"page"},{"location":"AlgebraicGeometry/ToricVarieties/ToricDivisorClasses/#Special-divisor-classes","page":"Toric Divisor Classes","title":"Special divisor classes","text":"","category":"section"},{"location":"AlgebraicGeometry/ToricVarieties/ToricDivisorClasses/","page":"Toric Divisor Classes","title":"Toric Divisor Classes","text":"trivial_divisor_class(v::NormalToricVarietyType)\nanticanonical_divisor_class(v::NormalToricVarietyType)\ncanonical_divisor_class(v::NormalToricVarietyType)","category":"page"},{"location":"AlgebraicGeometry/ToricVarieties/ToricDivisorClasses/#trivial_divisor_class-Tuple{Union{AffineNormalToricVariety, CyclicQuotientSingularity, NormalToricVariety}}","page":"Toric Divisor Classes","title":"trivial_divisor_class","text":"trivial_divisor_class(v::NormalToricVarietyType)\n\nConstruct the trivial divisor class of a normal toric variety.\n\nExamples\n\njulia> v = projective_space(NormalToricVariety, 2)\nNormal toric variety\n\njulia> trivial_divisor_class(v)\nDivisor class on a normal toric variety\n\n\n\n\n\n","category":"method"},{"location":"AlgebraicGeometry/ToricVarieties/ToricDivisorClasses/#anticanonical_divisor_class-Tuple{Union{AffineNormalToricVariety, CyclicQuotientSingularity, NormalToricVariety}}","page":"Toric Divisor Classes","title":"anticanonical_divisor_class","text":"anticanonical_divisor_class(v::NormalToricVarietyType)\n\nConstruct the anticanonical divisor class of a normal toric variety.\n\nExamples\n\njulia> v = projective_space(NormalToricVariety, 2)\nNormal toric variety\n\njulia> anticanonical_divisor_class(v)\nDivisor class on a normal toric variety\n\n\n\n\n\n","category":"method"},{"location":"AlgebraicGeometry/ToricVarieties/ToricDivisorClasses/#canonical_divisor_class-Tuple{Union{AffineNormalToricVariety, CyclicQuotientSingularity, NormalToricVariety}}","page":"Toric Divisor Classes","title":"canonical_divisor_class","text":"canonical_divisor_class(v::NormalToricVarietyType)\n\nConstruct the canonical divisor class of a normal toric variety.\n\nExamples\n\njulia> v = projective_space(NormalToricVariety, 2)\nNormal toric variety\n\njulia> canonical_divisor_class(v)\nDivisor class on a normal toric variety\n\n\n\n\n\n","category":"method"},{"location":"AlgebraicGeometry/ToricVarieties/ToricDivisorClasses/#Properties","page":"Toric Divisor Classes","title":"Properties","text":"","category":"section"},{"location":"AlgebraicGeometry/ToricVarieties/ToricDivisorClasses/","page":"Toric Divisor Classes","title":"Toric Divisor Classes","text":"Equality of toric divisor classes can be tested via ==.","category":"page"},{"location":"AlgebraicGeometry/ToricVarieties/ToricDivisorClasses/","page":"Toric Divisor Classes","title":"Toric Divisor Classes","text":"To check if a toric divisor class is trivial, one can invoke is_trivial.","category":"page"},{"location":"AlgebraicGeometry/ToricVarieties/ToricDivisorClasses/","page":"Toric Divisor Classes","title":"Toric Divisor Classes","text":"is_effective(tdc::ToricDivisorClass)","category":"page"},{"location":"AlgebraicGeometry/ToricVarieties/ToricDivisorClasses/#is_effective-Tuple{ToricDivisorClass}","page":"Toric Divisor Classes","title":"is_effective","text":"is_effective(tdc::ToricDivisorClass)\n\nDetermines whether the toric divisor class tdc is effective, that is if a toric divisor in this divisor class is linearly equivalent to an effective toric divisor.\n\nExamples\n\njulia> P2 = projective_space(NormalToricVariety,2)\nNormal toric variety\n\njulia> tdc = toric_divisor_class(P2, [1])\nDivisor class on a normal toric variety\n\njulia> is_effective(tdc)\ntrue\n\njulia> tdc2 = toric_divisor_class(P2, [-1])\nDivisor class on a normal toric variety\n\njulia> is_effective(tdc2)\nfalse\n\n\n\n\n\n","category":"method"},{"location":"AlgebraicGeometry/ToricVarieties/ToricDivisorClasses/#Attributes","page":"Toric Divisor Classes","title":"Attributes","text":"","category":"section"},{"location":"AlgebraicGeometry/ToricVarieties/ToricDivisorClasses/","page":"Toric Divisor Classes","title":"Toric Divisor Classes","text":"divisor_class(tdc::ToricDivisorClass)\ntoric_variety(tdc::ToricDivisorClass)\ntoric_divisor(tdc::ToricDivisorClass)","category":"page"},{"location":"AlgebraicGeometry/ToricVarieties/ToricDivisorClasses/#divisor_class-Tuple{ToricDivisorClass}","page":"Toric Divisor Classes","title":"divisor_class","text":"divisor_class(tdc::ToricDivisorClass)\n\nReturn the element of the class group corresponding to the toric divisor class tdc.\n\nExamples\n\njulia> P2 = projective_space(NormalToricVariety, 2)\nNormal toric variety\n\njulia> tdc = toric_divisor_class(P2, class_group(P2)([1]))\nDivisor class on a normal toric variety\n\njulia> divisor_class(tdc)\nAbelian group element [1]\n\n\n\n\n\n","category":"method"},{"location":"AlgebraicGeometry/ToricVarieties/ToricDivisorClasses/#toric_variety-Tuple{ToricDivisorClass}","page":"Toric Divisor Classes","title":"toric_variety","text":"toric_variety(tdc::ToricDivisorClass)\n\nReturn the toric variety on which the toric divisor class tdc is defined.\n\nExamples\n\njulia> P2 = projective_space(NormalToricVariety, 2)\nNormal toric variety\n\njulia> tdc = toric_divisor_class(P2, class_group(P2)([1]))\nDivisor class on a normal toric variety\n\njulia> toric_variety(tdc)\nNormal toric variety\n\n\n\n\n\n","category":"method"},{"location":"AlgebraicGeometry/ToricVarieties/ToricDivisorClasses/#toric_divisor-Tuple{ToricDivisorClass}","page":"Toric Divisor Classes","title":"toric_divisor","text":"toric_divisor(tdc::ToricDivisorClass)\n\nConstructs a toric divisor corresponding to the toric divisor class  tdc.\n\nExamples\n\njulia> P2 = projective_space(NormalToricVariety, 2)\nNormal toric variety\n\njulia> tdc = toric_divisor_class(P2, class_group(P2)([1]))\nDivisor class on a normal toric variety\n\njulia> toric_divisor(tdc)\nTorus-invariant, prime divisor on a normal toric variety\n\n\n\n\n\n","category":"method"},{"location":"DeveloperDocumentation/new_developers/#Introduction-for-new-developers","page":"Introduction for new developers","title":"Introduction for new developers","text":"","category":"section"},{"location":"DeveloperDocumentation/new_developers/","page":"Introduction for new developers","title":"Introduction for new developers","text":"This document is meant to get new developers started. It will not go into depth of programming in Julia or working with git, as there are far better resources on these things online.","category":"page"},{"location":"DeveloperDocumentation/new_developers/","page":"Introduction for new developers","title":"Introduction for new developers","text":"note: Pay attention to your GitHub notifications!\nOnce you open a pull request on GitHub you will receive feedback, comments, and questions on GitHub. So please pay attention to your GitHub notifications.","category":"page"},{"location":"DeveloperDocumentation/new_developers/#Important-notes","page":"Introduction for new developers","title":"Important notes","text":"","category":"section"},{"location":"DeveloperDocumentation/new_developers/","page":"Introduction for new developers","title":"Introduction for new developers","text":"If you encounter error messages after rebasing to the current master, chances are that some dependencies need upgrading. Please first try whether executing ]up gets rid of your errors.\nPlease have a look at the Developer Style Guide and the Design Decisions. Adhering to the style guide makes reviewing code easier for us, and hence your new feature can be merged faster.\nLet us know what you are working on early:\nYou can open a draft pull request on GitHub right at the beginning of your work. We are more than happy to look at incomplete prototypes to get an idea of what you are working on. This allows us to assess what kind of problems you might encounter and whether we can mitigate these by making changes to OSCAR.\nFeel free to contact us on Slack.\nHave a look at our community page.\nPlease also read our page on Documenting OSCAR code.\nLook at existing code that does similar things to your project to get an idea of what OSCAR code should look like. Try to look at multiple examples.\nIf you are planning to implement a new feature from scratch, please also read Adding new projects to experimental.","category":"page"},{"location":"DeveloperDocumentation/new_developers/#Overview","page":"Introduction for new developers","title":"Overview","text":"","category":"section"},{"location":"DeveloperDocumentation/new_developers/","page":"Introduction for new developers","title":"Introduction for new developers","text":"In general you have to do the following six steps for submitting changes to the OSCAR source:","category":"page"},{"location":"DeveloperDocumentation/new_developers/","page":"Introduction for new developers","title":"Introduction for new developers","text":"Fork the main Oscar.jl repository. For this go to the Oscar.jl GitHub page and click on \"Fork\" at the upper right.\nClone your forked repository to your local machine. If you have set up ssh access you can do this in the following way:\ngit clone git@github.com:your_github_username/Oscar.jl\nCreate a new branch, usually the naming convention is to use your initials (\"yi\") and then describe your change, for example:\ngit checkout -b yi/new_feature\ngit checkout -b yi/issue1234\ngit checkout -b yi/document_feature\nEdit your source and try out your changes locally (see below). To use your local copy of the sources, start Julia and\n]dev /path/to/local/clone/of/your/fork/of/Oscar.jl\nIf this succeeds, you can enter using Oscar in Julia and it will use your local copy.\nOnce you are done editing, push your branch and open a pull request. It is recommended that you open a draft pull request to the main OSCAR repository as soon as you start working. That way OSCAR developers are aware of work being done and can give feedback early in the process.\nOnce you have finished your work, mark your pull request as ready. It will then be reviewed and, probably after feedback and requests for changes, merged.","category":"page"},{"location":"DeveloperDocumentation/new_developers/#Alternative:-]dev-Oscar","page":"Introduction for new developers","title":"Alternative: ]dev Oscar","text":"","category":"section"},{"location":"DeveloperDocumentation/new_developers/","page":"Introduction for new developers","title":"Introduction for new developers","text":"Alternatively you can call","category":"page"},{"location":"DeveloperDocumentation/new_developers/","page":"Introduction for new developers","title":"Introduction for new developers","text":"]dev Oscar","category":"page"},{"location":"DeveloperDocumentation/new_developers/","page":"Introduction for new developers","title":"Introduction for new developers","text":"in Julia. This will create a directory ~/.julia/dev/Oscar. This directory is a git clone of the central OSCAR repository. You can develop your code here, however you will still have to fork OSCAR, as you have no rights to push to the central repository. You can then add your fork as another remote, have a look at the section on rebasing below for hints.","category":"page"},{"location":"DeveloperDocumentation/new_developers/#The-edit-process","page":"Introduction for new developers","title":"The edit process","text":"","category":"section"},{"location":"DeveloperDocumentation/new_developers/#Editing-the-source","page":"Introduction for new developers","title":"Editing the source","text":"","category":"section"},{"location":"DeveloperDocumentation/new_developers/","page":"Introduction for new developers","title":"Introduction for new developers","text":"The sources can be found in the src folder. Please pay attention to the folder structure and choose sensibly where to place your code (when fixing a bug this is probably a minor question).","category":"page"},{"location":"DeveloperDocumentation/new_developers/#Adding-tests","page":"Introduction for new developers","title":"Adding tests","text":"","category":"section"},{"location":"DeveloperDocumentation/new_developers/","page":"Introduction for new developers","title":"Introduction for new developers","text":"There are two ways to add tests:","category":"page"},{"location":"DeveloperDocumentation/new_developers/","page":"Introduction for new developers","title":"Introduction for new developers","text":"There are combined tests and examples in the docstrings, namely the jldoctest blocks. For these have a closer look at Documenting OSCAR code.\nLarger tests and tests that aren't useful examples are in the test folder. The main file there is test/runtests.jl which then includes other testfiles. ","category":"page"},{"location":"DeveloperDocumentation/new_developers/","page":"Introduction for new developers","title":"Introduction for new developers","text":"Tests that rely on random values should use Oscar.get_seeded_rng, which will return a seeded random number source, and pass this to any functions that need random values.  The code may also directly create and use such a random source. The current seed will be printed at the beginning of the testsuite, it is fixed to 42 in the CI. It can be changed by setting ENV[\"OSCAR_RANDOM_SEED\"] (for the testsuite running in a separate process) or by using Oscar.set_seed! (for the current session, e.g. Oscar.test_module(\"something\", new=false)).","category":"page"},{"location":"DeveloperDocumentation/new_developers/","page":"Introduction for new developers","title":"Introduction for new developers","text":"Oscar.test_module\nOscar.get_seeded_rng","category":"page"},{"location":"DeveloperDocumentation/new_developers/#test_module","page":"Introduction for new developers","title":"test_module","text":"test_module(path::AbstractString; new::Bool = true, timed::Bool=false, ignore=[])\n\nRun the Oscar tests in path:\n\nif path is relative then it will be set to <oscardir>/test/<path>\nif path is a directory, run all test files in that directory and below\nif path or path.jl is a file, run this file\n\nIf a directory contains a runtests.jl file only this file will be executed, otherwise all files will be included independently.\n\nThe optional parameter new takes the values false and true (default). If true, then the tests are run in a new session, otherwise the currently active session is used.\n\nWith the optional parameter timed the function will return a dict mapping file names to a named tuple with compilation times and allocations. This only works for new=false.\n\nThe parameter ignore can be used to pass a list of String or Regex patterns. Test files or folders matching these will be skipped. Strings will be compared as suffixes. This only works for new=false.\n\nFor experimental modules, use test_experimental_module instead.\n\n\n\n\n\n","category":"function"},{"location":"DeveloperDocumentation/new_developers/#get_seeded_rng","page":"Introduction for new developers","title":"get_seeded_rng","text":"get_seeded_rng()\n\nReturn a new random number generator object of type MersenneTwister which is seeded with the global seed value Oscar.rng_seed. This can be used for the testsuite to get more stable output and running times. Using a separate RNG object for each testset (or file) makes sure previous uses don't affect later testcases. It could also be useful for some randomized algorithms. The seed will be initialized with a random value during OSCAR startup but can be set to a fixed value with Oscar.set_seed! as it is done in runtests.jl.\n\n\n\n\n\n","category":"function"},{"location":"DeveloperDocumentation/new_developers/","page":"Introduction for new developers","title":"Introduction for new developers","text":"If a test folder contains a file called setup_tests.jl it is included automatically before each file (directly) in this directory. This can be used to define helper functions that are used in multiple test files, for example test_save_load_roundtrip for serialization.","category":"page"},{"location":"DeveloperDocumentation/new_developers/#Adding-documentation","page":"Introduction for new developers","title":"Adding documentation","text":"","category":"section"},{"location":"DeveloperDocumentation/new_developers/","page":"Introduction for new developers","title":"Introduction for new developers","text":"For more information on docstrings, please read our page on Documenting OSCAR code.  There are two places where documentation can be added:","category":"page"},{"location":"DeveloperDocumentation/new_developers/","page":"Introduction for new developers","title":"Introduction for new developers","text":"In the docstrings above the functions in the src folder;\nIn the documentation files in the docs/src folder. The overall structure is fixed in the file docs/doc.main. If you create a new file in docs/src, you will have to add an entry in docs/doc.main.","category":"page"},{"location":"DeveloperDocumentation/new_developers/","page":"Introduction for new developers","title":"Introduction for new developers","text":"In general, 1 is preferred to 2, i.e. any explanation of the functions and objects should go there and the files in docs/src should remain relatively sparse. Please also pay attention to the documentation section of the Developer Style Guide.","category":"page"},{"location":"DeveloperDocumentation/new_developers/#Further-hints","page":"Introduction for new developers","title":"Further hints","text":"","category":"section"},{"location":"DeveloperDocumentation/new_developers/#Give-[gh](https://github.com/cli/cli)-a-try","page":"Introduction for new developers","title":"Give gh a try","text":"","category":"section"},{"location":"DeveloperDocumentation/new_developers/","page":"Introduction for new developers","title":"Introduction for new developers","text":"Especially if you will be developing a lot, this can speed up your workflow tremendously.","category":"page"},{"location":"DeveloperDocumentation/new_developers/#Use-the-[Revise](https://github.com/timholy/Revise.jl)-package","page":"Introduction for new developers","title":"Use the Revise package","text":"","category":"section"},{"location":"DeveloperDocumentation/new_developers/","page":"Introduction for new developers","title":"Introduction for new developers","text":"Using Revise you can avoid having to restart Julia and reloading OSCAR when editing the code. As a quick summary, first install Revise with:","category":"page"},{"location":"DeveloperDocumentation/new_developers/","page":"Introduction for new developers","title":"Introduction for new developers","text":"using Pkg;\nPkg.add(\"Revise\");","category":"page"},{"location":"DeveloperDocumentation/new_developers/","page":"Introduction for new developers","title":"Introduction for new developers","text":"From then on do","category":"page"},{"location":"DeveloperDocumentation/new_developers/","page":"Introduction for new developers","title":"Introduction for new developers","text":"using Revise, Oscar","category":"page"},{"location":"DeveloperDocumentation/new_developers/","page":"Introduction for new developers","title":"Introduction for new developers","text":"whenever you are using OSCAR in Julia.","category":"page"},{"location":"DeveloperDocumentation/new_developers/#Ask-OSCAR-Related-Questions-in-the-[OSCAR-Slack](https://oscar-system.org/slack).","page":"Introduction for new developers","title":"Ask OSCAR Related Questions in the OSCAR Slack.","text":"","category":"section"},{"location":"DeveloperDocumentation/new_developers/#Use-]up","page":"Introduction for new developers","title":"Use ]up","text":"","category":"section"},{"location":"DeveloperDocumentation/new_developers/","page":"Introduction for new developers","title":"Introduction for new developers","text":"Working with the development version also entails that the packages Oscar depends on need to be up to date. Julia can update these packages if you type ]up in the Julia prompt. Many error messages after updating the source can be resolved by simply updating.","category":"page"},{"location":"DeveloperDocumentation/new_developers/#Style-guide","page":"Introduction for new developers","title":"Style guide","text":"","category":"section"},{"location":"DeveloperDocumentation/new_developers/","page":"Introduction for new developers","title":"Introduction for new developers","text":"Please have a look at the Developer Style Guide to get an overview over naming conventions, code formatting, etc.","category":"page"},{"location":"DeveloperDocumentation/new_developers/#Building-the-documentation","page":"Introduction for new developers","title":"Building the documentation","text":"","category":"section"},{"location":"DeveloperDocumentation/new_developers/","page":"Introduction for new developers","title":"Introduction for new developers","text":"To build and test the documentation, please have a look at Documenting OSCAR code.","category":"page"},{"location":"DeveloperDocumentation/new_developers/#rebasing","page":"Introduction for new developers","title":"Rebasing","text":"","category":"section"},{"location":"DeveloperDocumentation/new_developers/","page":"Introduction for new developers","title":"Introduction for new developers","text":"One way to stay up to date with the current master is rebasing. In order to do this, add the main Oscar.jl repository as a remote, fetch, and then rebase.","category":"page"},{"location":"DeveloperDocumentation/new_developers/","page":"Introduction for new developers","title":"Introduction for new developers","text":"git remote add oscar-system git@github.com:oscar-system/Oscar.jl\ngit fetch oscar-system\ngit rebase oscar-system/master","category":"page"},{"location":"DeveloperDocumentation/new_developers/","page":"Introduction for new developers","title":"Introduction for new developers","text":"Adding the remote only has to be executed once.","category":"page"},{"location":"DeveloperDocumentation/new_developers/#Useful-Julia-functions","page":"Introduction for new developers","title":"Useful Julia functions","text":"","category":"section"},{"location":"DeveloperDocumentation/new_developers/","page":"Introduction for new developers","title":"Introduction for new developers","text":"methods,\nmethodswith,\n@which,\n@less,\n@edit.","category":"page"},{"location":"AlgebraicGeometry/FrameWorks/ArchitectureOfAffineSchemes/","page":"Architecture of affine schemes","title":"Architecture of affine schemes","text":"CurrentModule = Oscar","category":"page"},{"location":"AlgebraicGeometry/FrameWorks/ArchitectureOfAffineSchemes/#Architecture-of-affine-schemes","page":"Architecture of affine schemes","title":"Architecture of affine schemes","text":"","category":"section"},{"location":"AlgebraicGeometry/FrameWorks/ArchitectureOfAffineSchemes/#Requirements-on-rings-and-ideals","page":"Architecture of affine schemes","title":"Requirements on rings and ideals","text":"","category":"section"},{"location":"AlgebraicGeometry/FrameWorks/ArchitectureOfAffineSchemes/","page":"Architecture of affine schemes","title":"Architecture of affine schemes","text":"Any type of ring R to be used within the schemes framework must come with its own ideal type IdealType<:Ideal for which we require the following interface to be implemented:","category":"page"},{"location":"AlgebraicGeometry/FrameWorks/ArchitectureOfAffineSchemes/","page":"Architecture of affine schemes","title":"Architecture of affine schemes","text":"# constructor of ideals in R\nideal(R::RingType, g::Vector{<:RingElem})::Ideal\n\n# constructor for quotient rings\nquo(R::RingType, I::IdealType)::Tuple{<:Ring, <:Map}\n\n# ideal membership test\nin(f::RingElem, I::IdealType)::Bool\n\n# a (fixed) set of generators\ngens(I::IdealType)::Vector{<:RingElem}\n\n# writing an element as linear combination of the generators\ncoordinates(f::RingElem, I::IdealType)::Vector{<:RingElem}","category":"page"},{"location":"AlgebraicGeometry/FrameWorks/ArchitectureOfAffineSchemes/","page":"Architecture of affine schemes","title":"Architecture of affine schemes","text":"The latter function must return a vector v = (a_1dots a_r) of elements in R such that f = a_1 cdot g_1 + dots + a_r cdot g_r where g_1dotsg_r is the set of gens(I). When f does not belong to I, it must error. Note that the ring returned by quo must again be admissible for the AbsAffineScheme interface.","category":"page"},{"location":"AlgebraicGeometry/FrameWorks/ArchitectureOfAffineSchemes/","page":"Architecture of affine schemes","title":"Architecture of affine schemes","text":"With a view towards the use of the ambient_coordinate_ring(X) for computations, it is customary to also implement","category":"page"},{"location":"AlgebraicGeometry/FrameWorks/ArchitectureOfAffineSchemes/","page":"Architecture of affine schemes","title":"Architecture of affine schemes","text":"saturated_ideal(I::IdealType)::MPolyIdeal","category":"page"},{"location":"AlgebraicGeometry/FrameWorks/ArchitectureOfAffineSchemes/","page":"Architecture of affine schemes","title":"Architecture of affine schemes","text":"returning an ideal J in the ambient_coordinate_ring(X) with the property that a in I for some element a in R if and only if lifted_numerator(a) is in J.","category":"page"},{"location":"AlgebraicGeometry/FrameWorks/ArchitectureOfAffineSchemes/#Interplay-between-ambient-coordinate-ring-and-coordinate-ring","page":"Architecture of affine schemes","title":"Interplay between ambient coordinate ring and coordinate ring","text":"","category":"section"},{"location":"AlgebraicGeometry/FrameWorks/ArchitectureOfAffineSchemes/","page":"Architecture of affine schemes","title":"Architecture of affine schemes","text":"Let X be an affine variety. In practice, all computations in the coordinate ring R = OO(X) will be deferred to computations in P = ambient_coordinate_ring(X) in one way or the other; this is another reason to include the ambient affine space in our abstract interface for affine schemes. In order to make the ambient_coordinate_ring(X) accessible for this purpose, we need the following methods to be implemented for elements ain R of type RingElemType:","category":"page"},{"location":"AlgebraicGeometry/FrameWorks/ArchitectureOfAffineSchemes/","page":"Architecture of affine schemes","title":"Architecture of affine schemes","text":"lifted_numerator(a::RingElemType)\nlifted_denominator(a::RingElemType)","category":"page"},{"location":"AlgebraicGeometry/FrameWorks/ArchitectureOfAffineSchemes/","page":"Architecture of affine schemes","title":"Architecture of affine schemes","text":"These must return representatives of the numerator and the denominator of a. Note that the denominator is equal to one(P) in case R cong P or R cong PI.","category":"page"},{"location":"AlgebraicGeometry/FrameWorks/ArchitectureOfAffineSchemes/","page":"Architecture of affine schemes","title":"Architecture of affine schemes","text":"Recall that the coordinates x_i of X are induced by the coordinates of the ambient affine space. Moreover, we will assume that for homomorphisms from R there is a method","category":"page"},{"location":"AlgebraicGeometry/FrameWorks/ArchitectureOfAffineSchemes/","page":"Architecture of affine schemes","title":"Architecture of affine schemes","text":"hom(R::RingType, S::Ring, a::Vector{<:RingElem})","category":"page"},{"location":"AlgebraicGeometry/FrameWorks/ArchitectureOfAffineSchemes/","page":"Architecture of affine schemes","title":"Architecture of affine schemes","text":"where RingType is the type of R and a the images of the coordinates x_i in S. This will be important when we come to morphisms of affine schemes below.","category":"page"},{"location":"AlgebraicGeometry/FrameWorks/ArchitectureOfAffineSchemes/","page":"Architecture of affine schemes","title":"Architecture of affine schemes","text":"Algebraically speaking, embedding the affine scheme X = Spec(R) over 𝕜 into an affine space with coordinate ring P = 𝕜x₁xₙ corresponds to a morphism of rings P  R with the property that for every other (commutative) ring S and any homomorphism φ  R  S there is a morphism ψ  P  S factoring through φ and such that φ is uniquely determined by ψ. Note that the morphism P  R is induced by natural coercions.","category":"page"},{"location":"AlgebraicGeometry/FrameWorks/ArchitectureOfAffineSchemes/#Existing-types-of-affine-schemes-and-how-to-derive-new-types","page":"Architecture of affine schemes","title":"Existing types of affine schemes and how to derive new types","text":"","category":"section"},{"location":"AlgebraicGeometry/FrameWorks/ArchitectureOfAffineSchemes/","page":"Architecture of affine schemes","title":"Architecture of affine schemes","text":"The abstract type for affine schemes is","category":"page"},{"location":"AlgebraicGeometry/FrameWorks/ArchitectureOfAffineSchemes/","page":"Architecture of affine schemes","title":"Architecture of affine schemes","text":"AbsAffineScheme{BaseRingType, RingType<:Ring}","category":"page"},{"location":"AlgebraicGeometry/FrameWorks/ArchitectureOfAffineSchemes/#AbsAffineScheme","page":"Architecture of affine schemes","title":"AbsAffineScheme","text":"AbsAffineScheme{BaseRingType, RingType<:Ring}\n\nAn affine scheme X = Spec(R) with R of type RingType over a ring 𝕜 of type BaseRingType.\n\n\n\n\n\n","category":"type"},{"location":"AlgebraicGeometry/FrameWorks/ArchitectureOfAffineSchemes/","page":"Architecture of affine schemes","title":"Architecture of affine schemes","text":"For any concrete instance of this type, we require the following functions to be implemented:","category":"page"},{"location":"AlgebraicGeometry/FrameWorks/ArchitectureOfAffineSchemes/","page":"Architecture of affine schemes","title":"Architecture of affine schemes","text":"base_ring(X::AbsAffineScheme),\nOO(X::AbsAffineScheme).","category":"page"},{"location":"AlgebraicGeometry/FrameWorks/ArchitectureOfAffineSchemes/","page":"Architecture of affine schemes","title":"Architecture of affine schemes","text":"A concrete instance of this type is","category":"page"},{"location":"AlgebraicGeometry/FrameWorks/ArchitectureOfAffineSchemes/","page":"Architecture of affine schemes","title":"Architecture of affine schemes","text":"AffineScheme{BaseRingType, RingType}","category":"page"},{"location":"AlgebraicGeometry/FrameWorks/ArchitectureOfAffineSchemes/#AffineScheme","page":"Architecture of affine schemes","title":"AffineScheme","text":"AffineScheme{BaseRingType, RingType}\n\nAn affine scheme X = Spec(R) with R a Noetherian ring of type RingType over a base ring 𝕜 of type BaseRingType.\n\n\n\n\n\n","category":"type"},{"location":"AlgebraicGeometry/FrameWorks/ArchitectureOfAffineSchemes/","page":"Architecture of affine schemes","title":"Architecture of affine schemes","text":"It provides an implementation of affine schemes for rings R of type MPolyRing, MPolyQuoRing, MPolyLocRing, and MPolyQuoLocRing defined over the integers or algebraic field extensions of mathbb Q. This minimal implementation can be used internally, when deriving new concrete types MyAffineScheme<:AbsAffineScheme such as, for instance, group schemes, toric schemes, schemes of a particular dimension like curves and surfaces, etc. To this end, one has to store an instance Y of AffineScheme in MyAffineScheme and implement the methods","category":"page"},{"location":"AlgebraicGeometry/FrameWorks/ArchitectureOfAffineSchemes/","page":"Architecture of affine schemes","title":"Architecture of affine schemes","text":"underlying_scheme(X::MyAffineScheme)::AffineScheme # return Y as above","category":"page"},{"location":"AlgebraicGeometry/FrameWorks/ArchitectureOfAffineSchemes/","page":"Architecture of affine schemes","title":"Architecture of affine schemes","text":"Then all methods implemented for AffineScheme are automatically forwarded to any instance of MyAffineScheme.","category":"page"},{"location":"AlgebraicGeometry/FrameWorks/ArchitectureOfAffineSchemes/","page":"Architecture of affine schemes","title":"Architecture of affine schemes","text":"Note: The above method necessarily returns an instance of AffineScheme! Of course, it can be overwritten for any higher type MyAffineScheme<:AbsAffineScheme as needed.","category":"page"},{"location":"AlgebraicGeometry/FrameWorks/ArchitectureOfAffineSchemes/#Existing-types-of-affine-scheme-morphisms-and-how-to-derive-new-types","page":"Architecture of affine schemes","title":"Existing types of affine scheme morphisms and how to derive new types","text":"","category":"section"},{"location":"AlgebraicGeometry/FrameWorks/ArchitectureOfAffineSchemes/","page":"Architecture of affine schemes","title":"Architecture of affine schemes","text":"Any abstract morphism of affine schemes is of the following type:","category":"page"},{"location":"AlgebraicGeometry/FrameWorks/ArchitectureOfAffineSchemes/","page":"Architecture of affine schemes","title":"Architecture of affine schemes","text":"AbsAffineSchemeMor{DomainType<:AbsAffineScheme,\n            CodomainType<:AbsAffineScheme,\n            PullbackType<:Map,\n            MorphismType,\n            BaseMorType\n            }","category":"page"},{"location":"AlgebraicGeometry/FrameWorks/ArchitectureOfAffineSchemes/#AbsAffineSchemeMor","page":"Architecture of affine schemes","title":"AbsAffineSchemeMor","text":"AbsAffineSchemeMor{DomainType<:AbsAffineScheme,\n           CodomainType<:AbsAffineScheme,\n           PullbackType<:Map,\n           MorphismType,\n           BaseMorType\n           }\n\nAbstract type for morphisms f  X  Y of affine schemes where\n\nX = Spec(S) is of type DomainType,\nY = Spec(R) is of type CodomainType,\nf^*  R  S is a ring homomorphism of type PullbackType,\nf itself is of type MorphismType (required for the Map interface),\nif f is defined over a morphism of base schemes BX  BY (e.g. a field extension), then this base scheme morphism is of type BaseMorType; otherwise, this can be set to Nothing.\n\n\n\n\n\n","category":"type"},{"location":"AlgebraicGeometry/FrameWorks/ArchitectureOfAffineSchemes/","page":"Architecture of affine schemes","title":"Architecture of affine schemes","text":"Any such morphism has the attributes domain, codomain and pullback. A concrete and minimalistic implementation exist for the type AffineSchemeMor:","category":"page"},{"location":"AlgebraicGeometry/FrameWorks/ArchitectureOfAffineSchemes/","page":"Architecture of affine schemes","title":"Architecture of affine schemes","text":"AffineSchemeMor{DomainType<:AbsAffineScheme,\n        CodomainType<:AbsAffineScheme,\n        PullbackType<:Map\n        }","category":"page"},{"location":"AlgebraicGeometry/FrameWorks/ArchitectureOfAffineSchemes/#AffineSchemeMor","page":"Architecture of affine schemes","title":"AffineSchemeMor","text":"AffineSchemeMor{DomainType<:AbsAffineScheme,\n        CodomainType<:AbsAffineScheme,\n        PullbackType<:Map\n       }\n\nA morphism f  X  Y of affine schemes X = Spec(S) of type DomainType and Y = Spec(R) of type CodomainType, both defined over the same base_ring, with underlying ring homomorphism f^*  R  S of type PullbackType.\n\n\n\n\n\n","category":"type"},{"location":"AlgebraicGeometry/FrameWorks/ArchitectureOfAffineSchemes/","page":"Architecture of affine schemes","title":"Architecture of affine schemes","text":"This basic functionality consists of","category":"page"},{"location":"AlgebraicGeometry/FrameWorks/ArchitectureOfAffineSchemes/","page":"Architecture of affine schemes","title":"Architecture of affine schemes","text":"compose(f::AbsAffineSchemeMor, g::AbsAffineSchemeMor),\nidentity_map(X::AbsAffineScheme),\nrestrict(f::AbsAffineSchemeMor, X::AbsAffineScheme, Y::AbsAffineScheme; check::Bool=true),\n==(f::AbsAffineSchemeMor, g::AbsAffineSchemeMor),\npreimage(f::AbsAffineSchemeMor, Z::AbsAffineScheme).","category":"page"},{"location":"AlgebraicGeometry/FrameWorks/ArchitectureOfAffineSchemes/","page":"Architecture of affine schemes","title":"Architecture of affine schemes","text":"In particular, for every concrete instance of a type MyAffineScheme<:AbsAffineScheme that implements underlying_scheme, this basic functionality of AffineSchemeMor should run naturally.","category":"page"},{"location":"AlgebraicGeometry/FrameWorks/ArchitectureOfAffineSchemes/","page":"Architecture of affine schemes","title":"Architecture of affine schemes","text":"We may derive higher types of morphisms of affine schemes MyAffineSchemeMor<:AbsAffineSchemeMor by storing an instance g of AffineSchemeMor inside an instance f of MyAffineSchemeMor and implementing","category":"page"},{"location":"AlgebraicGeometry/FrameWorks/ArchitectureOfAffineSchemes/","page":"Architecture of affine schemes","title":"Architecture of affine schemes","text":"underlying_morphism(f::MyAffineSchemeMor)::AffineSchemeMor # return g","category":"page"},{"location":"AlgebraicGeometry/FrameWorks/ArchitectureOfAffineSchemes/","page":"Architecture of affine schemes","title":"Architecture of affine schemes","text":"For example, this allows us to define closed embeddings.","category":"page"},{"location":"PolyhedralGeometry/Polyhedra/polymake/","page":"Polyhedron and polymake's Polytope","title":"Polyhedron and polymake's Polytope","text":"CurrentModule = Oscar\nDocTestSetup = Oscar.doctestsetup()","category":"page"},{"location":"PolyhedralGeometry/Polyhedra/polymake/#Polyhedron-and-polymake's-Polytope","page":"Polyhedron and polymake's Polytope","title":"Polyhedron and polymake's Polytope","text":"","category":"section"},{"location":"PolyhedralGeometry/Polyhedra/polymake/","page":"Polyhedron and polymake's Polytope","title":"Polyhedron and polymake's Polytope","text":"Many polyhedral computations are done through polymake. polymake ([GJ00], polymake.org) is open source software for research in polyhedral geometry and is attached to Julia via Polymake.jl ([KLT20], Polymake.jl). This is visible in the structure Polyhedron via a pointer pm_polytope to the corresponding polymake object. Using Polymake.jl one can apply all functionality of polymake to the polymake object hidden behind this pointer.","category":"page"},{"location":"PolyhedralGeometry/Polyhedra/polymake/","page":"Polyhedron and polymake's Polytope","title":"Polyhedron and polymake's Polytope","text":"Sometimes it can be necessary to directly invoke some polymake functions on an OSCAR Polyhedron object (e.g. because some functionality has not yet been made available via OSCAR's interface). In that case, the following two functions allow extracting the underlying Polymake.jl object from a Polyhedron, respectively wrapping a Polymake.jl object representing a polyhedron into a high-level Polyhedron object.","category":"page"},{"location":"PolyhedralGeometry/Polyhedra/polymake/","page":"Polyhedron and polymake's Polytope","title":"Polyhedron and polymake's Polytope","text":"Polyhedron{T}(p::Polymake.BigObject, f::Field) where T<:scalar_types\npolyhedron(P::Polymake.BigObject)","category":"page"},{"location":"PolyhedralGeometry/Polyhedra/polymake/#Polyhedron-Union{Tuple{T}, Tuple{Polymake.LibPolymake.BigObject, Field}} where T<:Union{Float64, FieldElem}","page":"Polyhedron and polymake's Polytope","title":"Polyhedron","text":"Polyhedron{T}(P::Polymake.BigObject, F::Field) where T<:scalar_types\n\nConstruct a Polyhedron corresponding to a Polymake.BigObject of type Polytope with scalars from Field F.\n\n\n\n\n\n","category":"method"},{"location":"PolyhedralGeometry/Polyhedra/polymake/#polyhedron-Tuple{Polymake.LibPolymake.BigObject}","page":"Polyhedron and polymake's Polytope","title":"polyhedron","text":"polyhedron(P::Polymake.BigObject)\n\nConstruct a Polyhedron corresponding to a Polymake.BigObject of type Polytope. Scalar type and parent field will be detected automatically. To improve type stability and performance, please use Polyhedron{T}(p::Polymake.BigObject, f::Field) where T<:scalar_types instead, where possible.\n\n\n\n\n\n","category":"method"},{"location":"PolyhedralGeometry/Polyhedra/polymake/","page":"Polyhedron and polymake's Polytope","title":"Polyhedron and polymake's Polytope","text":"The following shows all the data currently known for a Polyhedron.","category":"page"},{"location":"PolyhedralGeometry/Polyhedra/polymake/","page":"Polyhedron and polymake's Polytope","title":"Polyhedron and polymake's Polytope","text":"julia> C = cube(3)\nPolytope in ambient dimension 3\n\njulia> C.pm_polytope\ntype: Polytope<Rational>\ndescription: cube of dimension 3\n\nAFFINE_HULL\n\n\nBOUNDED\n\ttrue\n\nCONE_AMBIENT_DIM\n\t4\n\nCONE_DIM\n\t4\n\nFACETS\n  1   1   0   0\n  1  -1   0   0\n  1   0   1   0\n  1   0  -1   0\n  1   0   0   1\n  1   0   0  -1\n\nVERTICES_IN_FACETS\n\t{0 2 4 6}\n\t{1 3 5 7}\n\t{0 1 4 5}\n\t{2 3 6 7}\n\t{0 1 2 3}\n\t{4 5 6 7}\n","category":"page"},{"location":"PolyhedralGeometry/Polyhedra/polymake/","page":"Polyhedron and polymake's Polytope","title":"Polyhedron and polymake's Polytope","text":"polymake allows for an interactive visualization of 3-dimensional polytopes in the browser: Polymake.visual(C.pm_polytope).","category":"page"},{"location":"PolyhedralGeometry/Polyhedra/polymake/","page":"Polyhedron and polymake's Polytope","title":"Polyhedron and polymake's Polytope","text":"warning: Warning\nThere are several design differences between polymake and OSCAR. Polyhedra in polymake and Polymake.jl use homogeneous coordinates. The polyhedra in OSCAR use affine coordinates.  Indices in polymake are zero-based, whereas in OSCAR they are one-based.","category":"page"},{"location":"PolyhedralGeometry/Polyhedra/polymake/","page":"Polyhedron and polymake's Polytope","title":"Polyhedron and polymake's Polytope","text":"The next example shows a purely combinatorial construction of a polytope (here: a square). In spite of being given no coordinates, polymake can check for us that this is a simple polytope; i.e., each vertex is contained in dimension many facets.","category":"page"},{"location":"PolyhedralGeometry/Polyhedra/polymake/","page":"Polyhedron and polymake's Polytope","title":"Polyhedron and polymake's Polytope","text":"julia> Q = Polymake.polytope.Polytope(VERTICES_IN_FACETS=[[0,2],[1,3],[0,1],[2,3]]);\n\njulia> Q.SIMPLE\ntrue\n","category":"page"},{"location":"PolyhedralGeometry/Polyhedra/polymake/","page":"Polyhedron and polymake's Polytope","title":"Polyhedron and polymake's Polytope","text":"However, without coordinates, some operations such as computing the volume cannot work:","category":"page"},{"location":"PolyhedralGeometry/Polyhedra/polymake/","page":"Polyhedron and polymake's Polytope","title":"Polyhedron and polymake's Polytope","text":"julia> Q.VOLUME\npolymake:  WARNING: available properties insufficient to compute 'VOLUME'\n","category":"page"},{"location":"Hecke/manual/quad_forms/basics/#Spaces2","page":"Spaces","title":"Spaces","text":"","category":"section"},{"location":"Hecke/manual/quad_forms/basics/","page":"Spaces","title":"Spaces","text":"CurrentModule = Hecke\nDocTestSetup = quote\n  using Hecke\nend","category":"page"},{"location":"Hecke/manual/quad_forms/basics/#Creation-of-spaces","page":"Spaces","title":"Creation of spaces","text":"","category":"section"},{"location":"Hecke/manual/quad_forms/basics/","page":"Spaces","title":"Spaces","text":"quadratic_space(::NumField, ::Int)\nhermitian_space(::NumField, ::Int)\nquadratic_space(::NumField, ::MatElem)\nhermitian_space(::NumField, ::MatElem)","category":"page"},{"location":"Hecke/manual/quad_forms/basics/#quadratic_space-Tuple{NumField, Int64}","page":"Spaces","title":"quadratic_space","text":"quadratic_space(K::NumField, n::Int; cached::Bool = true) -> QuadSpace\n\nCreate the quadratic space over K with dimension n and Gram matrix equals to the identity matrix.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/quad_forms/basics/#hermitian_space-Tuple{NumField, Int64}","page":"Spaces","title":"hermitian_space","text":"hermitian_space(E::NumField, n::Int; cached::Bool = true) -> HermSpace\n\nCreate the hermitian space over E with dimension n and Gram matrix equals to the identity matrix. The number field E must be a quadratic extension, that is, degree(E) == 2 must hold.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/quad_forms/basics/#quadratic_space-Tuple{NumField, MatElem}","page":"Spaces","title":"quadratic_space","text":"quadratic_space(K::NumField, G::MatElem; cached::Bool = true) -> QuadSpace\n\nCreate the quadratic space over K with Gram matrix G. The matrix G must be square and symmetric.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/quad_forms/basics/#hermitian_space-Tuple{NumField, MatElem}","page":"Spaces","title":"hermitian_space","text":"hermitian_space(E::NumField, gram::MatElem; cached::Bool = true) -> HermSpace\n\nCreate the hermitian space over E with Gram matrix equals to gram. The matrix gram must be square and hermitian with respect to the non-trivial automorphism of E. The number field E must be a quadratic extension, that is, degree(E) == 2 must hold.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/quad_forms/basics/#Examples","page":"Spaces","title":"Examples","text":"","category":"section"},{"location":"Hecke/manual/quad_forms/basics/","page":"Spaces","title":"Spaces","text":"Here are easy examples to see how these constructors work. We will keep the two following spaces for the rest of this section:","category":"page"},{"location":"Hecke/manual/quad_forms/basics/","page":"Spaces","title":"Spaces","text":"using Hecke # hide\nK, a = cyclotomic_real_subfield(7);\nKt, t = K[\"t\"];\nE, b = number_field(t^2-a*t+1, \"b\");\nQ = quadratic_space(K, K[0 1; 1 0])\nH = hermitian_space(E, 3)","category":"page"},{"location":"Hecke/manual/quad_forms/basics/","page":"Spaces","title":"Spaces","text":"","category":"page"},{"location":"Hecke/manual/quad_forms/basics/#Attributes","page":"Spaces","title":"Attributes","text":"","category":"section"},{"location":"Hecke/manual/quad_forms/basics/","page":"Spaces","title":"Spaces","text":"Let (V Phi) be a space over EK. We define its dimension to be its dimension as a vector space over its base ring E and its rank to be the rank of its Gram matrix. If these two invariants agree, the space is said to be regular.","category":"page"},{"location":"Hecke/manual/quad_forms/basics/","page":"Spaces","title":"Spaces","text":"While dealing with lattices, one always works with regular ambient spaces.","category":"page"},{"location":"Hecke/manual/quad_forms/basics/","page":"Spaces","title":"Spaces","text":"The determinant textdet(V Phi) of (V Phi) is defined to be the class of the determinant of its Gram matrix in K^timesN(E^times) (which is similar to K^times(K^times)^2 in the quadratic case). The discriminant textdisc(V Phi) of (V Phi) is defined to be (-1)^(m(m-1)2)textdet(V Phi), where m is the rank of (V Phi).","category":"page"},{"location":"Hecke/manual/quad_forms/basics/","page":"Spaces","title":"Spaces","text":"rank(::AbstractSpace)\ndim(::AbstractSpace)\ngram_matrix(::AbstractSpace)\ninvolution(::AbstractSpace)\nbase_ring(::AbstractSpace)\nfixed_field(::AbstractSpace)\ndet(::AbstractSpace)\ndiscriminant(::AbstractSpace)","category":"page"},{"location":"Hecke/manual/quad_forms/basics/#rank-Tuple{AbstractSpace}","page":"Spaces","title":"rank","text":"rank(V::AbstractSpace) -> Int\n\nReturn the rank of the space V.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/quad_forms/basics/#dim-Tuple{AbstractSpace}","page":"Spaces","title":"dim","text":"dim(V::AbstractSpace) -> Int\n\nReturn the dimension of the space V.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/quad_forms/basics/#gram_matrix-Tuple{AbstractSpace}","page":"Spaces","title":"gram_matrix","text":"gram_matrix(V::AbstractSpace) -> MatElem\n\nReturn the Gram matrix of the space V.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/quad_forms/basics/#involution-Tuple{AbstractSpace}","page":"Spaces","title":"involution","text":"involution(V::AbstractSpace) -> NumFieldHom\n\nReturn the involution of the space V.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/quad_forms/basics/#base_ring-Tuple{AbstractSpace}","page":"Spaces","title":"base_ring","text":"base_ring(V::AbstractSpace) -> NumField\n\nReturn the algebra over which the space V is defined.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/quad_forms/basics/#fixed_field-Tuple{AbstractSpace}","page":"Spaces","title":"fixed_field","text":"fixed_field(V::AbstractSpace) -> NumField\n\nReturn the fixed field of the space V.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/quad_forms/basics/#det-Tuple{AbstractSpace}","page":"Spaces","title":"det","text":"det(V::AbstractSpace) -> FieldElem\n\nReturn the determinant of the space V as an element of its fixed field.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/quad_forms/basics/#discriminant-Tuple{AbstractSpace}","page":"Spaces","title":"discriminant","text":"discriminant(V::AbstractSpace) -> FieldElem\n\nReturn the discriminant of the space V as an element of its fixed field.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/quad_forms/basics/#Examples-2","page":"Spaces","title":"Examples","text":"","category":"section"},{"location":"Hecke/manual/quad_forms/basics/","page":"Spaces","title":"Spaces","text":"So for instance, one could get the following information about the hermitian space H:","category":"page"},{"location":"Hecke/manual/quad_forms/basics/","page":"Spaces","title":"Spaces","text":"using Hecke # hide\nK, a = cyclotomic_real_subfield(7);\nKt, t = K[\"t\"];\nE, b = number_field(t^2-a*t+1, \"b\");\nH = hermitian_space(E, 3);\nrank(H), dim(H)\ngram_matrix(H)\ninvolution(H)\nbase_ring(H)\nfixed_field(H)\ndet(H), discriminant(H)","category":"page"},{"location":"Hecke/manual/quad_forms/basics/","page":"Spaces","title":"Spaces","text":"","category":"page"},{"location":"Hecke/manual/quad_forms/basics/#Predicates","page":"Spaces","title":"Predicates","text":"","category":"section"},{"location":"Hecke/manual/quad_forms/basics/","page":"Spaces","title":"Spaces","text":"Let (V Phi) be a hermitian space over EK (resp. quadratic space K). We say that (V Phi) is definite if EK is CM (resp. K is totally real) and if there exists an orthogonal basis of V for which the diagonal elements of the associated Gram matrix of (V Phi) are either all totally positive or all totally negative. In the former case, V is said to be positive definite, while in the latter case it is negative definite. In all the other cases, we say that V is indefinite.","category":"page"},{"location":"Hecke/manual/quad_forms/basics/","page":"Spaces","title":"Spaces","text":"is_regular(::AbstractSpace)\nis_quadratic(::AbstractSpace)\nis_hermitian(::AbstractSpace)\nis_positive_definite(::AbstractSpace)\nis_negative_definite(::AbstractSpace)\nis_definite(::AbstractSpace)","category":"page"},{"location":"Hecke/manual/quad_forms/basics/#is_regular-Tuple{AbstractSpace}","page":"Spaces","title":"is_regular","text":"is_regular(V::AbstractSpace) -> Bool\n\nReturn whether the space V is regular, that is, if the Gram matrix has full rank.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/quad_forms/basics/#is_quadratic-Tuple{AbstractSpace}","page":"Spaces","title":"is_quadratic","text":"is_quadratic(V::AbstractSpace) -> Bool\n\nReturn whether the space V is quadratic.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/quad_forms/basics/#is_hermitian-Tuple{AbstractSpace}","page":"Spaces","title":"is_hermitian","text":"is_hermitian(V::AbstractSpace) -> Bool\n\nReturn whether the space V is hermitian.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/quad_forms/basics/#is_positive_definite-Tuple{AbstractSpace}","page":"Spaces","title":"is_positive_definite","text":"is_positive_definite(V::AbstractSpace) -> Bool\n\nReturn whether the space V is positive definite.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/quad_forms/basics/#is_negative_definite-Tuple{AbstractSpace}","page":"Spaces","title":"is_negative_definite","text":"is_negative_definite(V::AbstractSpace) -> Bool\n\nReturn whether the space V is negative definite.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/quad_forms/basics/#is_definite-Tuple{AbstractSpace}","page":"Spaces","title":"is_definite","text":"is_definite(V::AbstractSpace) -> Bool\n\nReturn whether the space V is definite.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/quad_forms/basics/","page":"Spaces","title":"Spaces","text":"Note that the is_hermitian function tests whether the space is non-quadratic.","category":"page"},{"location":"Hecke/manual/quad_forms/basics/#Examples-3","page":"Spaces","title":"Examples","text":"","category":"section"},{"location":"Hecke/manual/quad_forms/basics/","page":"Spaces","title":"Spaces","text":"using Hecke # hide\nK, a = cyclotomic_real_subfield(7);\nKt, t = K[\"t\"];\nE, b = number_field(t^2-a*t+1, \"b\");\nQ = quadratic_space(K, K[0 1; 1 0]);\nH = hermitian_space(E, 3);\nis_regular(Q), is_regular(H)\nis_quadratic(Q), is_hermitian(H)\nis_definite(Q), is_positive_definite(H)","category":"page"},{"location":"Hecke/manual/quad_forms/basics/","page":"Spaces","title":"Spaces","text":"","category":"page"},{"location":"Hecke/manual/quad_forms/basics/#Inner-products-and-diagonalization","page":"Spaces","title":"Inner products and diagonalization","text":"","category":"section"},{"location":"Hecke/manual/quad_forms/basics/","page":"Spaces","title":"Spaces","text":"gram_matrix(::AbstractSpace{T}, ::MatElem{S}) where {S, T}\ngram_matrix(::AbstractSpace{T}, ::Vector{Vector{U}}) where {T, U}\ninner_product(::AbstractSpace, ::Vector, ::Vector)\northogonal_basis(::AbstractSpace)\ndiagonal(::AbstractSpace)\ndiagonal_with_transform(::AbstractSpace)\nrestrict_scalars(::AbstractSpace, ::QQField, ::FieldElem)","category":"page"},{"location":"Hecke/manual/quad_forms/basics/#gram_matrix-Union{Tuple{T}, Tuple{S}, Tuple{AbstractSpace{T}, MatElem{S}}} where {S, T}","page":"Spaces","title":"gram_matrix","text":"gram_matrix(V::AbstractSpace, M::MatElem) -> MatElem\n\nReturn the Gram matrix of the rows of M with respect to the Gram matrix of the space V.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/quad_forms/basics/#gram_matrix-Union{Tuple{U}, Tuple{T}, Tuple{AbstractSpace{T}, Array{Vector{U}, 1}}} where {T, U}","page":"Spaces","title":"gram_matrix","text":"gram_matrix(V::AbstractSpace, S::Vector{Vector}) -> MatElem\n\nReturn the Gram matrix of the sequence S with respect to the Gram matrix of the space V.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/quad_forms/basics/#inner_product-Tuple{AbstractSpace, Vector, Vector}","page":"Spaces","title":"inner_product","text":"inner_product(V::AbstractSpace, v::Vector, w::Vector) -> FieldElem\n\nReturn the inner product of v and w with respect to the bilinear form of the space V.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/quad_forms/basics/#orthogonal_basis-Tuple{AbstractSpace}","page":"Spaces","title":"orthogonal_basis","text":"orthogonal_basis(V::AbstractSpace) -> MatElem\n\nReturn a matrix M, such that the rows of M form an orthogonal basis of the space V.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/quad_forms/basics/#diagonal-Tuple{AbstractSpace}","page":"Spaces","title":"diagonal","text":"diagonal(V::AbstractSpace) -> Vector{FieldElem}\n\nReturn a vector of elements a_1dotsca_n such that the space V is isometric to the diagonal space langle a_1dotsca_n rangle.\n\nThe elements are contained in the fixed field of V.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/quad_forms/basics/#diagonal_with_transform-Tuple{AbstractSpace}","page":"Spaces","title":"diagonal_with_transform","text":"diagonal_with_transform(V::AbstractSpace) -> Vector{FieldElem},\n                                                         MatElem{FieldElem}\n\nReturn a vector of elements a_1dotsca_n such that the space V is isometric to the diagonal space langle a_1dotsca_n rangle. The second output is a matrix U whose rows span an orthogonal basis of V for which the Gram matrix is given by the diagonal matrix of the a_i's.\n\nThe elements are contained in the fixed field of V.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/quad_forms/basics/#restrict_scalars-Tuple{AbstractSpace, QQField, FieldElem}","page":"Spaces","title":"restrict_scalars","text":"restrict_scalars(V::AbstractSpace, K::QQField,\n                                   alpha::FieldElem = one(base_ring(V)))\n                                                -> QuadSpace, AbstractSpaceRes\n\nGiven a space (V Phi) and a subfield K of the base algebra E of V, return the quadratic space W obtained by restricting the scalars of (V alphaPhi) to K, together with the map f for extending the scalars back. The form on the restriction is given by Tr circ Phi where Tr E to K is the trace form. The rescaling factor alpha is set to 1 by default.\n\nNote that for now one can only restrict scalars to mathbb Q.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/quad_forms/basics/#Examples-4","page":"Spaces","title":"Examples","text":"","category":"section"},{"location":"Hecke/manual/quad_forms/basics/","page":"Spaces","title":"Spaces","text":"using Hecke # hide\nK, a = cyclotomic_real_subfield(7);\nKt, t = K[\"t\"];\nE, b = number_field(t^2-a*t+1, \"b\");\nQ = quadratic_space(K, K[0 1; 1 0]);\nH = hermitian_space(E, 3);\ngram_matrix(Q, K[1 1; 2 0])\ngram_matrix(H, E[1 0 0; 0 1 0; 0 0 1])\ninner_product(Q, K[1  1], K[0  2])\northogonal_basis(H)\ndiagonal(Q), diagonal(H)","category":"page"},{"location":"Hecke/manual/quad_forms/basics/","page":"Spaces","title":"Spaces","text":"","category":"page"},{"location":"Hecke/manual/quad_forms/basics/#Equivalence","page":"Spaces","title":"Equivalence","text":"","category":"section"},{"location":"Hecke/manual/quad_forms/basics/","page":"Spaces","title":"Spaces","text":"Let (V Phi) and (V Phi) be spaces over the same extension EK. A homomorphism of spaces from V to V is a E-linear mapping f colon V to V such that for all xy in V, one has","category":"page"},{"location":"Hecke/manual/quad_forms/basics/","page":"Spaces","title":"Spaces","text":"   Phi(f(x) f(y)) = Phi(xy)","category":"page"},{"location":"Hecke/manual/quad_forms/basics/","page":"Spaces","title":"Spaces","text":"An automorphism of spaces is called an isometry and a monomorphism is called an embedding.","category":"page"},{"location":"Hecke/manual/quad_forms/basics/","page":"Spaces","title":"Spaces","text":"hasse_invariant(::QuadSpace, p)\nwitt_invariant(::QuadSpace, p)\nis_isometric(::AbstractSpace, ::AbstractSpace)\nis_isometric(::AbstractSpace, ::AbstractSpace, p)\ninvariants(::QuadSpace)","category":"page"},{"location":"Hecke/manual/quad_forms/basics/#hasse_invariant-Tuple{Hecke.QuadSpace, Any}","page":"Spaces","title":"hasse_invariant","text":"hasse_invariant(V::QuadSpace, p::Union{InfPlc, AbsNumFieldOrderIdeal{AbsSimpleNumField, AbsSimpleNumFieldElem}}) -> Int\n\nReturns the Hasse invariant of the quadratic space V at p. This is equal to the product of local Hilbert symbols (a_i a_j)_p, i  j, where V is isometric to langle a_1 dotsc a_nrangle. If V is degenerate return the hasse invariant of V/radical(V).\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/quad_forms/basics/#witt_invariant-Tuple{Hecke.QuadSpace, Any}","page":"Spaces","title":"witt_invariant","text":"witt_invariant(V::QuadSpace, p::Union{InfPlc, AbsNumFieldOrderIdeal{AbsSimpleNumField, AbsSimpleNumFieldElem}}) -> Int\n\nReturns the Witt invariant of the quadratic space V at p.\n\nSee [Definition 3.2.1, Kir16].\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/quad_forms/basics/#is_isometric-Tuple{AbstractSpace, AbstractSpace}","page":"Spaces","title":"is_isometric","text":"is_isometric(L::AbstractSpace, M::AbstractSpace) -> Bool\n\nReturn whether the spaces L and M are isometric.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/quad_forms/basics/#is_isometric-Tuple{AbstractSpace, AbstractSpace, Any}","page":"Spaces","title":"is_isometric","text":"is_isometric(L::AbstractSpace, M::AbstractSpace, p::Union{InfPlc, AbsNumFieldOrderIdeal{AbsSimpleNumField, AbsSimpleNumFieldElem}}) -> Bool\n\nReturn whether the spaces L and M are isometric over the completion at p.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/quad_forms/basics/#invariants-Tuple{Hecke.QuadSpace}","page":"Spaces","title":"invariants","text":"invariants(M::QuadSpace)\n      -> FieldElem, Dict{AbsNumFieldOrderIdeal{AbsSimpleNumField, AbsSimpleNumFieldElem}, Int}, Vector{Tuple{InfPlc, Int}}\n\nReturns a tuple (n, k, d, H, I) of invariants of M, which determine the isometry class completely. Here n is the dimension. The dimension of the kernel is k. The element d is the determinant of a Gram matrix of the non-degenerate part, H contains the non-trivial Hasse invariants and I contains for each real place the negative index of inertia.\n\nNote that d is determined only modulo squares.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/quad_forms/basics/#Examples-5","page":"Spaces","title":"Examples","text":"","category":"section"},{"location":"Hecke/manual/quad_forms/basics/","page":"Spaces","title":"Spaces","text":"For instance, for the case of Q and the totally ramified prime mathfrak p of O_K above 7, one can get:","category":"page"},{"location":"Hecke/manual/quad_forms/basics/","page":"Spaces","title":"Spaces","text":"using Hecke # hide\nK, a = cyclotomic_real_subfield(7);\nQ = quadratic_space(K, K[0 1; 1 0]);\nOK = maximal_order(K);\np = prime_decomposition(OK, 7)[1][1];\nhasse_invariant(Q, p), witt_invariant(Q, p)\nQ2 = quadratic_space(K, K[-1 0; 0 1]);\nis_isometric(Q, Q2, p)\nis_isometric(Q, Q2)\ninvariants(Q2)","category":"page"},{"location":"Hecke/manual/quad_forms/basics/","page":"Spaces","title":"Spaces","text":"","category":"page"},{"location":"Hecke/manual/quad_forms/basics/#Embeddings","page":"Spaces","title":"Embeddings","text":"","category":"section"},{"location":"Hecke/manual/quad_forms/basics/","page":"Spaces","title":"Spaces","text":"Let (V Phi) and (V Phi) be two spaces over the same extension EK, and let sigma colon V to V be an E-linear morphism. sigma is called a representation of V into V if for all x in V","category":"page"},{"location":"Hecke/manual/quad_forms/basics/","page":"Spaces","title":"Spaces","text":"   Phi(sigma(x) sigma(x)) = Phi(xx)","category":"page"},{"location":"Hecke/manual/quad_forms/basics/","page":"Spaces","title":"Spaces","text":"In such a case, V is said to be represented by V and sigma can be seen as an embedding of V into V. This representation property can be also tested locally with respect to the completions at some finite places. Note that in both quadratic and hermitian cases, completions are taken at finite places of the fixed field K.","category":"page"},{"location":"Hecke/manual/quad_forms/basics/","page":"Spaces","title":"Spaces","text":"is_locally_represented_by(::AbstractSpace, ::AbstractSpace, p)\nis_represented_by(::AbstractSpace, ::AbstractSpace)","category":"page"},{"location":"Hecke/manual/quad_forms/basics/#is_locally_represented_by-Tuple{AbstractSpace, AbstractSpace, Any}","page":"Spaces","title":"is_locally_represented_by","text":"is_locally_represented_by(U::T, V::T, p::AbsNumFieldOrderIdeal{AbsSimpleNumField, AbsSimpleNumFieldElem}) where T <: AbstractSpace -> Bool\n\nGiven two spaces U and V over the same algebra E, and a prime ideal p in the maximal order mathcal O_K of their fixed field K, return whether U is represented by V locally at p, i.e. whether U_p embeds in V_p.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/quad_forms/basics/#is_represented_by-Tuple{AbstractSpace, AbstractSpace}","page":"Spaces","title":"is_represented_by","text":"is_represented_by(U::T, V::T) where T <: AbstractSpace -> Bool\n\nGiven two spaces U and V over the same algebra E, return whether U is represented by V, i.e. whether U embeds in V.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/quad_forms/basics/#Examples-6","page":"Spaces","title":"Examples","text":"","category":"section"},{"location":"Hecke/manual/quad_forms/basics/","page":"Spaces","title":"Spaces","text":"Still using the spaces Q and H, we can decide whether some other spaces embed respectively locally or globally into Q or H:","category":"page"},{"location":"Hecke/manual/quad_forms/basics/","page":"Spaces","title":"Spaces","text":"using Hecke # hide\nK, a = cyclotomic_real_subfield(7);\nKt, t = K[\"t\"];\nE, b = number_field(t^2-a*t+1, \"b\");\nQ = quadratic_space(K, K[0 1; 1 0]);\nH = hermitian_space(E, 3);\nOK = maximal_order(K);\np = prime_decomposition(OK, 7)[1][1];\nQ2 = quadratic_space(K, K[-1 0; 0 1]);\nH2 = hermitian_space(E, E[-1 0 0; 0 1 0; 0 0 -1]);\nis_locally_represented_by(Q2, Q, p)\nis_represented_by(Q2, Q)\nis_locally_represented_by(H2, H, p)\nis_represented_by(H2, H)","category":"page"},{"location":"Hecke/manual/quad_forms/basics/","page":"Spaces","title":"Spaces","text":"","category":"page"},{"location":"Hecke/manual/quad_forms/basics/#Categorical-constructions","page":"Spaces","title":"Categorical constructions","text":"","category":"section"},{"location":"Hecke/manual/quad_forms/basics/","page":"Spaces","title":"Spaces","text":"One can construct direct sums of spaces of the same kind. Since those are also direct products, they are called biproducts in this context. Depending on the user usage, one of the following three methods can be called to obtain the direct sum of a finite collection of spaces. Note that the corresponding copies of the original spaces in the direct sum are pairwise orthogonal.","category":"page"},{"location":"Hecke/manual/quad_forms/basics/","page":"Spaces","title":"Spaces","text":"direct_sum(::Vector{AbstractSpace})\ndirect_product(::Vector{AbstractSpace})\nbiproduct(::Vector{AbstractSpace})","category":"page"},{"location":"Hecke/manual/quad_forms/basics/#direct_sum-Tuple{Vector{AbstractSpace}}","page":"Spaces","title":"direct_sum","text":"direct_sum(x::Vararg{T}) where T <: AbstractSpace -> T, Vector{AbstractSpaceMor}\ndirect_sum(x::Vector{T}) where T <: AbstractSpace -> T, Vector{AbstractSpaceMor}\n\nGiven a collection of quadratic or hermitian spaces V_1 ldots V_n, return their direct sum V = V_1 oplus ldots oplus V_n, together with the injections V_i to V.\n\nFor objects of type AbstractSpace, finite direct sums and finite direct products agree and they are therefore called biproducts. If one wants to obtain V as a direct product with the projections V to V_i, one should call direct_product(x). If one wants to obtain V as a biproduct with the injections V_i to V and the projections V to V_i, one should call biproduct(x).\n\n\n\n\n\ndirect_sum(g1::QuadSpaceCls, g2::QuadSpaceCls) -> QuadSpaceCls\n\nReturn the isometry class of the direct sum of two representatives.\n\n\n\n\n\ndirect_sum(M::ModuleFP{T}...; task::Symbol = :sum) where T\n\nGiven modules M_1dots M_n, say, return the direct sum bigoplus_i=1^n M_i.  \n\nAdditionally, return \n\na vector containing the canonical injections  M_itobigoplus_i=1^n M_i if task = :sum (default),\na vector containing the canonical projections  bigoplus_i=1^n M_ito M_i if task = :prod,\ntwo vectors containing the canonical injections and projections, respectively, if task = :both,\nnone of the above maps if task = :none.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/quad_forms/basics/#direct_product-Tuple{Vector{AbstractSpace}}","page":"Spaces","title":"direct_product","text":"direct_product(algebras::StructureConstantAlgebra...; task::Symbol = :sum)\n  -> StructureConstantAlgebra, Vector{AbsAlgAssMor}, Vector{AbsAlgAssMor}\ndirect_product(algebras::Vector{StructureConstantAlgebra}; task::Symbol = :sum)\n  -> StructureConstantAlgebra, Vector{AbsAlgAssMor}, Vector{AbsAlgAssMor}\n\nReturns the algebra A = A_1 times cdots times A_k. task can be \":sum\", \":prod\", \":both\" or \":none\" and determines which canonical maps are computed as well: \":sum\" for the injections, \":prod\" for the projections.\n\n\n\n\n\ndirect_product(x::Vararg{T}) where T <: AbstractSpace -> T, Vector{AbstractSpaceMor}\ndirect_product(x::Vector{T}) where T <: AbstractSpace -> T, Vector{AbstractSpaceMor}\n\nGiven a collection of quadratic or hermitian spaces V_1 ldots V_n, return their direct product V = V_1 times ldots times V_n, together with the projections V to V_i.\n\nFor objects of type AbstractSpace, finite direct sums and finite direct products agree and they are therefore called biproducts. If one wants to obtain V as a direct sum with the injections V_i to V, one should call direct_sum(x). If one wants to obtain V as a biproduct with the injections V_i to V and the projections V to V_i, one should call biproduct(x).\n\n\n\n\n\ndirect_product(F::FreeMod{T}...; task::Symbol = :prod) where T\n\nGiven free modules F_1dots F_n, say, return the direct product prod_i=1^n F_i.\n\nAdditionally, return\n\na vector containing the canonical projections  prod_i=1^n F_ito F_i if task = :prod (default),\na vector containing the canonical injections  F_itoprod_i=1^n F_i if task = :sum,\ntwo vectors containing the canonical projections and injections, respectively, if task = :both,\nnone of the above maps if task = :none.\n\n\n\n\n\ndirect_product(M::ModuleFP{T}...; task::Symbol = :prod) where T\n\nGiven modules M_1dots M_n, say, return the direct product prod_i=1^n M_i.\n\nAdditionally, return\n\na vector containing the canonical projections  prod_i=1^n M_ito M_i if task = :prod (default),\na vector containing the canonical injections  M_itoprod_i=1^n M_i if task = :sum,\ntwo vectors containing the canonical projections and injections, respectively, if task = :both,\nnone of the above maps if task = :none.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/quad_forms/basics/#biproduct-Tuple{Vector{AbstractSpace}}","page":"Spaces","title":"biproduct","text":"biproduct(x::Vararg{T}) where T <: AbstractSpace -> T, Vector{AbstractSpaceMor}, Vector{AbstractSpaceMor}\nbiproduct(x::Vector{T}) where T <: AbstractSpace -> T, Vector{AbstractSpaceMor}, Vector{AbstractSpaceMor}\n\nGiven a collection of quadratic or hermitian spaces V_1 ldots V_n, return their biproduct V = V_1 oplus ldots oplus V_n, together with the injections V_i to V and the projections V to V_i.\n\nFor objects of type AbstractSpace, finite direct sums and finite direct products agree and they are therefore called biproducts. If one wants to obtain V as a direct sum with the injections V_i to V, one should call direct_sum(x). If one wants to obtain V as a direct product with the projections V to V_i, one should call direct_product(x).\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/quad_forms/basics/#Example","page":"Spaces","title":"Example","text":"","category":"section"},{"location":"Hecke/manual/quad_forms/basics/","page":"Spaces","title":"Spaces","text":"using Hecke # hide\nE, b = cyclotomix_field_as_cm_extensions(7);\nH = hermitian_space(E, 3);\nH2 = hermitian_space(E, E[-1 0 0; 0 1 0; 0 0 -1]);\nH3, inj, proj = biproduct(H, H2)\nis_one(matrix(compose(inj[1], proj[1])))\nis_zero(matrix(compose(inj[1], proj[2])))","category":"page"},{"location":"Hecke/manual/quad_forms/basics/#Orthogonality-operations","page":"Spaces","title":"Orthogonality operations","text":"","category":"section"},{"location":"Hecke/manual/quad_forms/basics/","page":"Spaces","title":"Spaces","text":"orthogonal_complement(::AbstractSpace, ::MatElem)\northogonal_projection(::AbstractSpace, ::MatElem)","category":"page"},{"location":"Hecke/manual/quad_forms/basics/#orthogonal_complement-Tuple{AbstractSpace, MatElem}","page":"Spaces","title":"orthogonal_complement","text":"orthogonal_complement(V::AbstractSpace, M::T) where T <: MatElem -> T\n\nGiven a space V and a subspace W with basis matrix M, return a basis matrix of the orthogonal complement of W inside V.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/quad_forms/basics/#orthogonal_projection-Tuple{AbstractSpace, MatElem}","page":"Spaces","title":"orthogonal_projection","text":"orthogonal_projection(V::AbstractSpace, M::T) where T <: MatElem -> AbstractSpaceMor\n\nGiven a space V and a non-degenerate subspace W with basis matrix M, return the endomorphism of V corresponding to the projection onto the complement of W in V.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/quad_forms/basics/#Example-2","page":"Spaces","title":"Example","text":"","category":"section"},{"location":"Hecke/manual/quad_forms/basics/","page":"Spaces","title":"Spaces","text":"using Hecke # hide\nK, a = cyclotomic_real_subfield(7);\nKt, t = K[\"t\"];\nQ = quadratic_space(K, K[0 1; 1 0]);\northogonal_complement(Q, matrix(K, 1, 2, [1 0]))","category":"page"},{"location":"Hecke/manual/quad_forms/basics/","page":"Spaces","title":"Spaces","text":"","category":"page"},{"location":"Hecke/manual/quad_forms/basics/#Isotropic-spaces","page":"Spaces","title":"Isotropic spaces","text":"","category":"section"},{"location":"Hecke/manual/quad_forms/basics/","page":"Spaces","title":"Spaces","text":"Let (V Phi) be a space over EK and let mathfrak p be a place in K. V is said to be isotropic locally at mathfrak p if there exists an element x in V_mathfrak p such that Phi_mathfrak p(xx) = 0, where Phi_mathfrak p is the continuous extension of Phi to V_mathfrak p times V_mathfrak p.","category":"page"},{"location":"Hecke/manual/quad_forms/basics/","page":"Spaces","title":"Spaces","text":"is_isotropic(::AbstractSpace, p)","category":"page"},{"location":"Hecke/manual/quad_forms/basics/#is_isotropic-Tuple{AbstractSpace, Any}","page":"Spaces","title":"is_isotropic","text":"is_isotropic(V::AbstractSpace, p::Union{AbsNumFieldOrderIdeal{AbsSimpleNumField, AbsSimpleNumFieldElem}, InfPlc}) -> Bool\n\nGiven a space V and a place p in the fixed field K of V, return whether the completion of V at p is isotropic.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/quad_forms/basics/#Example-3","page":"Spaces","title":"Example","text":"","category":"section"},{"location":"Hecke/manual/quad_forms/basics/","page":"Spaces","title":"Spaces","text":"using Hecke # hide\nK, a = cyclotomic_real_subfield(7);\nKt, t = K[\"t\"];\nE, b = number_field(t^2-a*t+1, \"b\");\nH = hermitian_space(E, 3);\nOK = maximal_order(K);\np = prime_decomposition(OK, 7)[1][1];\nis_isotropic(H, p)","category":"page"},{"location":"Hecke/manual/quad_forms/basics/","page":"Spaces","title":"Spaces","text":"","category":"page"},{"location":"Hecke/manual/quad_forms/basics/#Hyperbolic-spaces","page":"Spaces","title":"Hyperbolic spaces","text":"","category":"section"},{"location":"Hecke/manual/quad_forms/basics/","page":"Spaces","title":"Spaces","text":"Let (V Phi) be a space over EK and let mathfrak p be a prime ideal of mathcal O_K. V is said to be hyperbolic locally at mathfrak p if the completion V_mathfrak p of V can be decomposed as an orthogonal sum of hyperbolic planes. The hyperbolic plane is the space (H Psi) of rank 2 over EK such that there exists a basis e_1 e_2 of H such that Psi(e_1 e_1) = Psi(e_2 e_2) = 0 and Psi(e_1 e_2) = 1.","category":"page"},{"location":"Hecke/manual/quad_forms/basics/","page":"Spaces","title":"Spaces","text":"is_locally_hyperbolic(::HermSpace, ::AbsNumFieldOrderIdeal{AbsSimpleNumField, AbsSimpleNumFieldElem})","category":"page"},{"location":"Hecke/manual/quad_forms/basics/#is_locally_hyperbolic-Tuple{Hecke.HermSpace, AbsSimpleNumFieldOrderIdeal}","page":"Spaces","title":"is_locally_hyperbolic","text":"is_locally_hyperbolic(V::Hermspace, p::AbsNumFieldOrderIdeal{AbsSimpleNumField, AbsSimpleNumFieldElem}) -> Bool\n\nReturn whether the completion of the hermitian space V over EK at the prime ideal p of mathcal O_K is hyperbolic.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/quad_forms/basics/#Example-4","page":"Spaces","title":"Example","text":"","category":"section"},{"location":"Hecke/manual/quad_forms/basics/","page":"Spaces","title":"Spaces","text":"using Hecke # hide\nK, a = cyclotomic_real_subfield(7);\nKt, t = K[\"t\"];\nE, b = number_field(t^2-a*t+1, \"b\");\nH = hermitian_space(E, 3);\nOK = maximal_order(K);\np = prime_decomposition(OK, 7)[1][1];\nis_locally_hyperbolic(H, p)","category":"page"},{"location":"PolyhedralGeometry/polyhedral_complexes/","page":"Polyhedral Complexes","title":"Polyhedral Complexes","text":"CurrentModule = Oscar","category":"page"},{"location":"PolyhedralGeometry/polyhedral_complexes/#Polyhedral-Complexes","page":"Polyhedral Complexes","title":"Polyhedral Complexes","text":"","category":"section"},{"location":"PolyhedralGeometry/polyhedral_complexes/#Introduction","page":"Polyhedral Complexes","title":"Introduction","text":"","category":"section"},{"location":"PolyhedralGeometry/polyhedral_complexes/","page":"Polyhedral Complexes","title":"Polyhedral Complexes","text":"Let mathbbF be an ordered field; the default is that mathbbF=mathbbQ is the field of rational numbers and other fields are not yet supported everywhere in the implementation.","category":"page"},{"location":"PolyhedralGeometry/polyhedral_complexes/","page":"Polyhedral Complexes","title":"Polyhedral Complexes","text":"A nonempty finite collection mathcalP of polyhedra in mathbbF^n, for n fixed, is a polyhedral complex if","category":"page"},{"location":"PolyhedralGeometry/polyhedral_complexes/","page":"Polyhedral Complexes","title":"Polyhedral Complexes","text":"the set mathcalF is closed with respect to taking faces and\nif CDinmathcalF then Ccap D is a face of both C and D.","category":"page"},{"location":"PolyhedralGeometry/polyhedral_complexes/#Construction","page":"Polyhedral Complexes","title":"Construction","text":"","category":"section"},{"location":"PolyhedralGeometry/polyhedral_complexes/","page":"Polyhedral Complexes","title":"Polyhedral Complexes","text":"To construct a polyhedral complex, you must pass points of each polyhedron in the polyhedral complex, such that the polyhedron is the convex hull thereof, along with an IncidenceMatrix encoding which points generate which polyhedron.","category":"page"},{"location":"PolyhedralGeometry/polyhedral_complexes/","page":"Polyhedral Complexes","title":"Polyhedral Complexes","text":"polyhedral_complex","category":"page"},{"location":"PolyhedralGeometry/polyhedral_complexes/#polyhedral_complex","page":"Polyhedral Complexes","title":"polyhedral_complex","text":"polyhedral_complex(::T, polyhedra, vr, far_vertices, L) where T<:scalar_types\n\nArguments\n\nT: Type or parent Field of scalar to use, defaults to QQFieldElem.\npolyhedra::IncidenceMatrix: An incidence matrix; there is a 1 at position (i,j) if the ith polytope contains point j and 0 otherwise.\nvr::AbstractCollection[PointVector]: The points whose convex hulls make up the polyhedral complex. This matrix also contains the far vertices.\nfar_vertices::Vector{Int}: Vector containing the indices of the rows corresponding to the far vertices in vr.\nL::AbstractCollection[RayVector]: Generators of the lineality space of the polyhedral complex.\n\nA polyhedral complex formed from points, rays, and lineality combined into polyhedra indicated by an incidence matrix, where the columns represent the points and the rows represent the polyhedra.\n\nExamples\n\njulia> IM = incidence_matrix([[1,2,3],[1,3,4]])\n2×4 IncidenceMatrix\n[1, 2, 3]\n[1, 3, 4]\n\n\njulia> vr = [0 0; 1 0; 1 1; 0 1]\n4×2 Matrix{Int64}:\n 0  0\n 1  0\n 1  1\n 0  1\n\njulia> PC = polyhedral_complex(IM, vr)\nPolyhedral complex in ambient dimension 2\n\nPolyhedral complex with rays and lineality:\n\njulia> VR = [0 0 0; 1 0 0; 0 1 0; -1 0 0];\n\njulia> IM = incidence_matrix([[1,2,3],[1,3,4]]);\n\njulia> far_vertices = [2,3,4];\n\njulia> L = [0 0 1];\n\njulia> PC = polyhedral_complex(IM, VR, far_vertices, L)\nPolyhedral complex in ambient dimension 3\n\njulia> lineality_dim(PC)\n1\n\n\n\n\n\npolyhedral_complex(polytopes::AbstractVector{Polyhedron{T}}) where T<:scalar_types\n\nAssemble a polyhedral complex from a non-empty list of polyhedra.\n\n\n\n\n\npolyhedral_complex(F::PolyhedralFan)\n\nTurn a polyhedral fan into a polyhedral complex.\n\n\n\n\n\npolyhedral_complex(TropV::TropicalVariety)\n\nReturn the polyhedral complex of a tropical variety.\n\n\n\n\n\n","category":"function"},{"location":"PolyhedralGeometry/polyhedral_complexes/#Auxiliary-functions","page":"Polyhedral Complexes","title":"Auxiliary functions","text":"","category":"section"},{"location":"PolyhedralGeometry/polyhedral_complexes/","page":"Polyhedral Complexes","title":"Polyhedral Complexes","text":"ambient_dim(PC::PolyhedralComplex)\ncodim(PC::PolyhedralComplex)\ndim(PC::PolyhedralComplex)\nf_vector(PC::PolyhedralComplex)\nis_embedded(PC::PolyhedralComplex)\nis_pure(PC::PolyhedralComplex)\nis_simplicial(PC::PolyhedralComplex)\nlineality_dim(PC::PolyhedralComplex)\nlineality_space(PC::PolyhedralComplex{T}) where T<:scalar_types\nmaximal_polyhedra(PC::PolyhedralComplex{T}) where T<:scalar_types\nminimal_faces(PC::PolyhedralComplex{T}) where T<:scalar_types\nn_maximal_polyhedra(PC::PolyhedralComplex)\nn_polyhedra(PC::PolyhedralComplex)\nn_rays(PC::PolyhedralComplex)\nn_vertices(PC::PolyhedralComplex)\npolyhedra_of_dim\nrays(PC::PolyhedralComplex{T}) where T<:scalar_types\nrays_modulo_lineality(PC::PolyhedralComplex{T}) where T<:scalar_types\nvertices(as::Type{PointVector{T}}, PC::PolyhedralComplex{T}) where {T<:scalar_types}\nvertices_and_rays(PC::PolyhedralComplex{T}) where T<:scalar_types","category":"page"},{"location":"PolyhedralGeometry/polyhedral_complexes/#ambient_dim-Tuple{PolyhedralComplex}","page":"Polyhedral Complexes","title":"ambient_dim","text":"ambient_dim(PC::PolyhedralComplex)\n\nReturn the ambient dimension of PC.\n\nExamples\n\njulia> IM = incidence_matrix([[1,2,3],[1,3,4]])\n2×4 IncidenceMatrix\n[1, 2, 3]\n[1, 3, 4]\n\n\njulia> V = [0 0; 1 0; 1 1; 0 1]\n4×2 Matrix{Int64}:\n 0  0\n 1  0\n 1  1\n 0  1\n\njulia> PC = polyhedral_complex(IM, V)\nPolyhedral complex in ambient dimension 2\n\njulia> ambient_dim(PC)\n2\n\n\n\n\n\n","category":"method"},{"location":"PolyhedralGeometry/polyhedral_complexes/#codim-Tuple{PolyhedralComplex}","page":"Polyhedral Complexes","title":"codim","text":"codim(PC::PolyhedralComplex)\n\nCompute the codimension of a polyhedral complex.\n\nExamples\n\njulia> VR = [0 0; 1 0; -1 0; 0 1];\n\njulia> IM = incidence_matrix([[1,2],[1,3],[1,4]]);\n\njulia> far_vertices = [2,3,4];\n\njulia> PC = polyhedral_complex(IM, VR, far_vertices)\nA polyhedral complex in ambient dimension 2\n\njulia> codim(PC)\n1\n\n\n\n\n\n","category":"method"},{"location":"PolyhedralGeometry/polyhedral_complexes/#dim-Tuple{PolyhedralComplex}","page":"Polyhedral Complexes","title":"dim","text":"dim(PC::PolyhedralComplex)\n\nCompute the dimension of the polyhedral complex.\n\nExamples\n\njulia> IM = incidence_matrix([[1,2,3],[1,3,4]]);\n\njulia> VR = [0 0; 1 0; 1 1; 0 1];\n\njulia> PC = polyhedral_complex(IM, VR)\nPolyhedral complex in ambient dimension 2\n\njulia> dim(PC)\n2\n\n\n\n\n\n","category":"method"},{"location":"PolyhedralGeometry/polyhedral_complexes/#f_vector-Tuple{PolyhedralComplex}","page":"Polyhedral Complexes","title":"f_vector","text":"f_vector(PC::PolyhedralComplex)\n\nCompute the vector (f₀f₁f₂f_dim(PC)) where f_i is the number of faces of PC of dimension i.\n\nExamples\n\njulia> VR = [0 0; 1 0; -1 0; 0 1];\n\njulia> IM = incidence_matrix([[1,2,4],[1,3,4]]);\n\njulia> far_vertices = [2,3,4];\n\njulia> PC = polyhedral_complex(IM, VR, far_vertices);\n\njulia> f_vector(PC)\n3-element Vector{Int64}:\n 1\n 3\n 2\n\n\n\n\n\n","category":"method"},{"location":"PolyhedralGeometry/polyhedral_complexes/#is_embedded-Tuple{PolyhedralComplex}","page":"Polyhedral Complexes","title":"is_embedded","text":"is_embedded(PC::PolyhedralComplex)\n\nReturn true if PC is embedded, i.e. if its vertices can be computed as a subset of some mathbbR^n.\n\nExamples\n\njulia> VR = [0 0; 1 0; -1 0; 0 1];\n\njulia> IM = incidence_matrix([[1,2],[1,3],[1,4]]);\n\njulia> PC = polyhedral_complex(IM, VR)\nPolyhedral complex in ambient dimension 2\n\njulia> is_embedded(PC)\ntrue\n\n\n\n\n\n","category":"method"},{"location":"PolyhedralGeometry/polyhedral_complexes/#is_pure-Tuple{PolyhedralComplex}","page":"Polyhedral Complexes","title":"is_pure","text":"is_pure(PC::PolyhedralComplex)\n\nDetermine whether the polyhedral complex is pure.\n\nExamples\n\njulia> IM = incidence_matrix([[1,2,3],[1,3,4]]);\n\njulia> VR = [0 0; 1 0; 1 1; 0 1];\n\njulia> PC = polyhedral_complex(IM, VR)\nPolyhedral complex in ambient dimension 2\n\njulia> is_pure(PC)\ntrue\n\n\n\n\n\n","category":"method"},{"location":"PolyhedralGeometry/polyhedral_complexes/#is_simplicial-Tuple{PolyhedralComplex}","page":"Polyhedral Complexes","title":"is_simplicial","text":"is_simplicial(PC::PolyhedralComplex)\n\nDetermine whether the polyhedral complex is simplicial.\n\nExamples\n\njulia> IM = incidence_matrix([[1,2,3],[1,3,4]]);\n\njulia> VR = [0 0; 1 0; 1 1; 0 1];\n\njulia> PC = polyhedral_complex(IM, VR)\nPolyhedral complex in ambient dimension 2\n\njulia> is_simplicial(PC)\ntrue\n\n\n\n\n\n","category":"method"},{"location":"PolyhedralGeometry/polyhedral_complexes/#lineality_dim-Tuple{PolyhedralComplex}","page":"Polyhedral Complexes","title":"lineality_dim","text":"lineality_dim(PC::PolyhedralComplex)\n\nReturn the lineality dimension of PC.\n\nExamples\n\njulia> VR = [0 0 0; 1 0 0; 0 1 0; -1 0 0];\n\njulia> IM = incidence_matrix([[1,2,3],[1,3,4]]);\n\njulia> far_vertices = [2,3,4];\n\njulia> L = [0 0 1];\n\njulia> PC = polyhedral_complex(IM, VR, far_vertices, L)\nPolyhedral complex in ambient dimension 3\n\njulia> lineality_dim(PC)\n1\n\n\n\n\n\n","category":"method"},{"location":"PolyhedralGeometry/polyhedral_complexes/#lineality_space-Union{Tuple{PolyhedralComplex{T}}, Tuple{T}} where T<:Union{Float64, FieldElem}","page":"Polyhedral Complexes","title":"lineality_space","text":"lineality_space(PC::PolyhedralComplex)\n\nReturn the lineality space of PC.\n\nExamples\n\njulia> VR = [0 0 0; 1 0 0; 0 1 0; -1 0 0];\n\njulia> IM = incidence_matrix([[1,2,3],[1,3,4]]);\n\njulia> far_vertices = [2,3,4];\n\njulia> L = [0 0 1];\n\njulia> PC = polyhedral_complex(IM, VR, far_vertices, L)\nPolyhedral complex in ambient dimension 3\n\njulia> lineality_space(PC)\n1-element SubObjectIterator{RayVector{QQFieldElem}}:\n [0, 0, 1]\n\n\n\n\n\n","category":"method"},{"location":"PolyhedralGeometry/polyhedral_complexes/#maximal_polyhedra-Union{Tuple{PolyhedralComplex{T}}, Tuple{T}} where T<:Union{Float64, FieldElem}","page":"Polyhedral Complexes","title":"maximal_polyhedra","text":"maximal_polyhedra(PC::PolyhedralComplex)\n\nReturn the maximal polyhedra of PC\n\nOptionally IncidenceMatrix can be passed as a first argument to return the incidence matrix specifying the maximal polyhedra of PC. The indices returned refer to the output of vertices_and_rays.\n\nExamples\n\njulia> IM = incidence_matrix([[1,2,3],[1,3,4]])\n2×4 IncidenceMatrix\n[1, 2, 3]\n[1, 3, 4]\n\n\njulia> VR = [0 0; 1 0; 1 1; 0 1]\n4×2 Matrix{Int64}:\n 0  0\n 1  0\n 1  1\n 0  1\n\njulia> PC = polyhedral_complex(IM, VR, [2])\nPolyhedral complex in ambient dimension 2\n\njulia> maximal_polyhedra(PC)\n2-element SubObjectIterator{Polyhedron{QQFieldElem}}:\n Polyhedron in ambient dimension 2\n Polytope in ambient dimension 2\n\njulia> maximal_polyhedra(IncidenceMatrix, PC)\n2×4 IncidenceMatrix\n[1, 2, 3]\n[1, 3, 4]\n\n\n\n\n\n","category":"method"},{"location":"PolyhedralGeometry/polyhedral_complexes/#minimal_faces-Union{Tuple{PolyhedralComplex{T}}, Tuple{T}} where T<:Union{Float64, FieldElem}","page":"Polyhedral Complexes","title":"minimal_faces","text":"minimal_faces(as, PC::PolyhedralComplex)\n\nReturn the minimal faces of a polyhedral complex as a NamedTuple with two iterators. For a polyhedral complex without lineality, the base_points are the vertices. If PC has lineality L, then every minimal face is an affine translation p+L, where p is only unique modulo L. The return type is a dict, the key :base_points gives an iterator over such p, and the key :lineality_basis lets one access a basis for the lineality space L of PC.\n\nSee also vertices and lineality_space.\n\nExamples\n\njulia> VR = [0 0 0; 1 0 0; 0 1 0; -1 0 0];\n\njulia> IM = incidence_matrix([[1,2,3],[1,3,4]]);\n\njulia> far_vertices = [2,3,4];\n\njulia> L = [0 0 1];\n\njulia> PC = polyhedral_complex(IM, VR, far_vertices, L)\nPolyhedral complex in ambient dimension 3\n\njulia> MFPC = minimal_faces(PC)\n(base_points = PointVector{QQFieldElem}[[0, 0, 0]], lineality_basis = RayVector{QQFieldElem}[[0, 0, 1]])\n\njulia> MFPC.base_points\n1-element SubObjectIterator{PointVector{QQFieldElem}}:\n [0, 0, 0]\n\njulia> MFPC.lineality_basis\n1-element SubObjectIterator{RayVector{QQFieldElem}}:\n [0, 0, 1]\n\n\n\n\n\n","category":"method"},{"location":"PolyhedralGeometry/polyhedral_complexes/#n_maximal_polyhedra-Tuple{PolyhedralComplex}","page":"Polyhedral Complexes","title":"n_maximal_polyhedra","text":"n_maximal_polyhedra(PC::PolyhedralComplex)\n\nReturn the number of maximal polyhedra of PC\n\nExamples\n\njulia> IM = incidence_matrix([[1,2,3],[1,3,4]])\n2×4 IncidenceMatrix\n[1, 2, 3]\n[1, 3, 4]\n\n\njulia> VR = [0 0; 1 0; 1 1; 0 1]\n4×2 Matrix{Int64}:\n 0  0\n 1  0\n 1  1\n 0  1\n\njulia> PC = polyhedral_complex(IM, VR, [2])\nPolyhedral complex in ambient dimension 2\n\njulia> n_maximal_polyhedra(PC)\n2\n\n\n\n\n\n","category":"method"},{"location":"PolyhedralGeometry/polyhedral_complexes/#n_polyhedra-Tuple{PolyhedralComplex}","page":"Polyhedral Complexes","title":"n_polyhedra","text":"n_polyhedra(PC::PolyhedralComplex)\n\nReturn the total number of polyhedra in the polyhedral complex PC.\n\nExamples\n\njulia> VR = [0 0; 1 0; -1 0; 0 1];\n\njulia> IM = incidence_matrix([[1,2,4],[1,3,4]]);\n\njulia> far_vertices = [2,3,4];\n\njulia> PC = polyhedral_complex(IM, VR, far_vertices);\n\njulia> n_polyhedra(PC)\n6\n\n\n\n\n\n","category":"method"},{"location":"PolyhedralGeometry/polyhedral_complexes/#n_rays-Tuple{PolyhedralComplex}","page":"Polyhedral Complexes","title":"n_rays","text":"n_rays(PC::PolyhedralComplex)\n\nReturn the number of rays of PC.\n\nExamples\n\njulia> VR = [0 0; 1 0; -1 0; 0 1];\n\njulia> IM = incidence_matrix([[1,2,4],[1,3,4]]);\n\njulia> far_vertices = [2,3,4];\n\njulia> PC = polyhedral_complex(IM, VR, far_vertices);\n\njulia> n_rays(PC)\n3\n\n\n\n\n\n","category":"method"},{"location":"PolyhedralGeometry/polyhedral_complexes/#n_vertices-Tuple{PolyhedralComplex}","page":"Polyhedral Complexes","title":"n_vertices","text":"n_vertices(PC::PolyhedralComplex)\n\nReturn the number of vertices of PC.\n\nExamples\n\njulia> VR = [0 0; 1 0; -1 0; 0 1];\n\njulia> IM = incidence_matrix([[1,2,4],[1,3,4]]);\n\njulia> far_vertices = [2,3,4];\n\njulia> PC = polyhedral_complex(IM, VR, far_vertices);\n\njulia> n_vertices(PC)\n1\n\n\n\n\n\n","category":"method"},{"location":"PolyhedralGeometry/polyhedral_complexes/#polyhedra_of_dim","page":"Polyhedral Complexes","title":"polyhedra_of_dim","text":"polyhedra_of_dim(PC::PolyhedralComplex, polyhedron_dim::Int)\n\nReturn the polyhedra of a given dimension in the polyhedral complex PC.\n\nExamples\n\njulia> IM = incidence_matrix([[1,2,3],[1,3,4]]);\n\njulia> VR = [0 0; 1 0; 1 1; 0 1];\n\njulia> PC = polyhedral_complex(IM, VR);\n\njulia> P1s = polyhedra_of_dim(PC,1)\n5-element SubObjectIterator{Polyhedron{QQFieldElem}}:\n Polytope in ambient dimension 2\n Polytope in ambient dimension 2\n Polytope in ambient dimension 2\n Polytope in ambient dimension 2\n Polytope in ambient dimension 2\n\njulia> for p in P1s\n       println(dim(p))\n       end\n1\n1\n1\n1\n1\n\n\n\n\n\n","category":"function"},{"location":"PolyhedralGeometry/polyhedral_complexes/#rays-Union{Tuple{PolyhedralComplex{T}}, Tuple{T}} where T<:Union{Float64, FieldElem}","page":"Polyhedral Complexes","title":"rays","text":"rays([as::Type{T} = RayVector,] PC::PolyhedralComplex)\n\nReturn the rays of PC. The rays are defined to be the far vertices, i.e. the one-dimensional faces of the recession cones of its polyhedra, so if PC has lineality, there are no rays.\n\nSee also rays_modulo_lineality and vertices.\n\nOptional arguments for as include\n\nRayVector.\n\nExamples\n\njulia> IM = incidence_matrix([[1,2,3],[1,3,4]]);\n\njulia> VR = [0 0; 1 0; 1 1; 0 1];\n\njulia> PC = polyhedral_complex(IM, VR, [2])\nPolyhedral complex in ambient dimension 2\n\njulia> rays(PC)\n1-element SubObjectIterator{RayVector{QQFieldElem}}:\n [1, 0]\n\njulia> matrix(QQ, rays(RayVector, PC))\n[1   0]\n\nThe following complex has no vertices:\n\njulia> IM = incidence_matrix([[1,2,3],[1,3,4]]);\n\njulia> VR = [0 0 0; 1 0 0; 0 1 0; -1 0 0];\n\njulia> far_vertices = [2,3,4];\n\njulia> L = [0 0 1];\n\njulia> PC = polyhedral_complex(IM, VR, far_vertices, L)\nPolyhedral complex in ambient dimension 3\n\njulia> rays(PC)\n0-element SubObjectIterator{RayVector{QQFieldElem}}\n\n\n\n\n\n","category":"method"},{"location":"PolyhedralGeometry/polyhedral_complexes/#rays_modulo_lineality-Union{Tuple{PolyhedralComplex{T}}, Tuple{T}} where T<:Union{Float64, FieldElem}","page":"Polyhedral Complexes","title":"rays_modulo_lineality","text":"rays_modulo_lineality(as, PC::PolyhedralComplex)\n\nReturn the rays of the recession fan of PC up to lineality as a NamedTuple with two iterators. If PC has lineality L, then the iterator rays_modulo_lineality iterates over representatives of the rays of PC/L. The iterator lineality_basis gives a basis of the lineality space L.\n\nSee also rays and lineality_space.\n\nExamples\n\njulia> VR = [0 0 0; 1 0 0; 0 1 0; -1 0 0];\n\njulia> IM = incidence_matrix([[1,2,3],[1,3,4]]);\n\njulia> far_vertices = [2,3,4];\n\njulia> L = [0 0 1];\n\njulia> PC = polyhedral_complex(IM, VR, far_vertices, L)\nPolyhedral complex in ambient dimension 3\n\njulia> RML = rays_modulo_lineality(PC)\n(rays_modulo_lineality = RayVector{QQFieldElem}[[1, 0, 0], [0, 1, 0], [-1, 0, 0]], lineality_basis = RayVector{QQFieldElem}[[0, 0, 1]])\n\njulia> RML.rays_modulo_lineality\n3-element SubObjectIterator{RayVector{QQFieldElem}}:\n [1, 0, 0]\n [0, 1, 0]\n [-1, 0, 0]\n\njulia> RML.lineality_basis\n1-element SubObjectIterator{RayVector{QQFieldElem}}:\n [0, 0, 1]\n\n\n\n\n\n","category":"method"},{"location":"PolyhedralGeometry/polyhedral_complexes/#vertices-Union{Tuple{T}, Tuple{Type{PointVector{T}}, PolyhedralComplex{T}}} where T<:Union{Float64, FieldElem}","page":"Polyhedral Complexes","title":"vertices","text":"vertices([as::Type{T} = PointVector,] PC::PolyhedralComplex)\n\nReturn an iterator over the vertices of PC in the format defined by as. The vertices are defined to be the zero-dimensional faces, so if P has lineality, there are no vertices, only minimal faces.\n\nSee also minimal_faces and rays.\n\nOptional arguments for as include\n\nPointVector.\n\nExamples\n\njulia> IM = incidence_matrix([[1,2,3],[1,3,4]]);\n\njulia> V = [0 0; 1 0; 1 1; 0 1];\n\njulia> PC = polyhedral_complex(IM, V)\nPolyhedral complex in ambient dimension 2\n\njulia> vertices(PC)\n4-element SubObjectIterator{PointVector{QQFieldElem}}:\n [0, 0]\n [1, 0]\n [1, 1]\n [0, 1]\n\njulia> matrix(QQ, vertices(PointVector, PC))\n[0   0]\n[1   0]\n[1   1]\n[0   1]\n\nThe following complex has no vertices:\n\njulia> IM = incidence_matrix([[1,2,3],[1,3,4]]);\n\njulia> VR = [0 0 0; 1 0 0; 0 1 0; -1 0 0];\n\njulia> far_vertices = [2,3,4];\n\njulia> L = [0 0 1];\n\njulia> PC = polyhedral_complex(IM, VR, far_vertices, L)\nPolyhedral complex in ambient dimension 3\n\njulia> vertices(PC)\n0-element SubObjectIterator{PointVector{QQFieldElem}}\n\n\n\n\n\n","category":"method"},{"location":"PolyhedralGeometry/polyhedral_complexes/#vertices_and_rays-Union{Tuple{PolyhedralComplex{T}}, Tuple{T}} where T<:Union{Float64, FieldElem}","page":"Polyhedral Complexes","title":"vertices_and_rays","text":"vertices_and_rays(PC::PolyhedralComplex)\n\nReturn the vertices and rays of PC as a combined set, up to lineality. This function is mainly a helper function for maximal_polyhedra.\n\nExamples\n\njulia> IM = incidence_matrix([[1,2,3],[1,3,4]]);\n\njulia> VR = [0 0 0; 1 0 0; 0 1 0; -1 0 0];\n\njulia> far_vertices = [2,3,4];\n\njulia> L = [0 0 1];\n\njulia> PC = polyhedral_complex(IM, VR, far_vertices, L)\nPolyhedral complex in ambient dimension 3\n\njulia> for vr in vertices_and_rays(PC)\n       println(\"$vr : $(typeof(vr))\")\n       end\nQQFieldElem[0, 0, 0] : PointVector{QQFieldElem}\nQQFieldElem[1, 0, 0] : RayVector{QQFieldElem}\nQQFieldElem[0, 1, 0] : RayVector{QQFieldElem}\nQQFieldElem[-1, 0, 0] : RayVector{QQFieldElem}\n\n\n\n\n\n","category":"method"},{"location":"CommutativeAlgebra/affine_algebras/","page":"Affine Algebras and Their Ideals","title":"Affine Algebras and Their Ideals","text":"CurrentModule = Oscar\nDocTestSetup = Oscar.doctestsetup()","category":"page"},{"location":"CommutativeAlgebra/affine_algebras/#affine_algebras","page":"Affine Algebras and Their Ideals","title":"Affine Algebras and Their Ideals","text":"","category":"section"},{"location":"CommutativeAlgebra/affine_algebras/","page":"Affine Algebras and Their Ideals","title":"Affine Algebras and Their Ideals","text":"With regard to notation, we use affine algebra as a synonym for quotient of a multivariate polynomial ring by an ideal. More specifically, if R is a multivariate polynomial ring with coefficient ring C, and A=RI is the quotient of R by an ideal I of R, we refer to A as an affine algebra over C, or an affine C-algebra. In this section, we discuss functionality for handling such algebras in OSCAR.","category":"page"},{"location":"CommutativeAlgebra/affine_algebras/","page":"Affine Algebras and Their Ideals","title":"Affine Algebras and Their Ideals","text":"note: Note\nWe emphasize: In this section, we view RI together with its ring structure. Realizing RI as an R-module means to implement it as the quotient of a free R-module of rank 1. See the section on modules.","category":"page"},{"location":"CommutativeAlgebra/affine_algebras/","page":"Affine Algebras and Their Ideals","title":"Affine Algebras and Their Ideals","text":"note: Note\nMost functions discussed here rely on Gröbner basis techniques. In particular, they typically make use of a Gröbner basis for the modulus of the quotient. Nevertheless, the construction of quotients is lazy in the sense that the computation of such a Gröbner basis is delayed until the user performs an operation that indeed requires it. The Gröbner basis is then computed with respect to the monomial ordering entered by the user when creating the quotient; if no ordering is entered, OSCAR will use the default_ordering on the underlying polynomial ring. See the section on Gröbner/Standard Bases for default orderings in OSCAR. Once computed, the Gröbner basis is cached for later reuse.","category":"page"},{"location":"CommutativeAlgebra/affine_algebras/","page":"Affine Algebras and Their Ideals","title":"Affine Algebras and Their Ideals","text":"note: Note\nRecall that Gröbner basis methods are implemented for multivariate polynomial rings over fields (exact fields supported by OSCAR) and, where not indicated otherwise, for multivariate polynomial rings over the integers.","category":"page"},{"location":"CommutativeAlgebra/affine_algebras/","page":"Affine Algebras and Their Ideals","title":"Affine Algebras and Their Ideals","text":"note: Note\nIn OSCAR, elements of a quotient A = RI are not necessarily represented by polynomials which are reduced with regard to I. That is, if fin R is the internal polynomial representative of an element of A, then f may not be the normal form mod I with respect to the default ordering on R (see the section on Gröbner/Standard Bases for normal forms). Operations involving Gröbner basis computations may lead to (partial) reductions. The function simplify discussed in this section computes fully reduced representatives.","category":"page"},{"location":"CommutativeAlgebra/affine_algebras/","page":"Affine Algebras and Their Ideals","title":"Affine Algebras and Their Ideals","text":"note: Note\nEach grading on a multivariate polynomial ring R  in OSCAR  descends to a grading on the affine algebra A = R/I (recall that OSCAR ideals of graded polynomial rings are required to be homogeneous). Functionality for dealing with such gradings and our notation for describing this functionality descend accordingly. This applies, in particular, to the functions is_graded,  is_standard_graded, is_z_graded, is_zm_graded, and is_positively_graded which will not be discussed again here.","category":"page"},{"location":"CommutativeAlgebra/affine_algebras/#Types","page":"Affine Algebras and Their Ideals","title":"Types","text":"","category":"section"},{"location":"CommutativeAlgebra/affine_algebras/","page":"Affine Algebras and Their Ideals","title":"Affine Algebras and Their Ideals","text":"The OSCAR type for quotients of  multivariate polynomial rings is of parametrized form MPolyQuoRing{T}, with elements of type MPolyQuoRingElem{T}. Here, T is the element type of the polynomial ring.","category":"page"},{"location":"CommutativeAlgebra/affine_algebras/#Constructors","page":"Affine Algebras and Their Ideals","title":"Constructors","text":"","category":"section"},{"location":"CommutativeAlgebra/affine_algebras/","page":"Affine Algebras and Their Ideals","title":"Affine Algebras and Their Ideals","text":"quo(R::MPolyRing, I::MPolyIdeal)","category":"page"},{"location":"CommutativeAlgebra/affine_algebras/#quo-Tuple{MPolyRing, MPolyIdeal}","page":"Affine Algebras and Their Ideals","title":"quo","text":"quo(R::MPolyRing, I::MPolyIdeal; ordering::MonomialOrdering = default_ordering(R)) -> MPolyQuoRing, Map\n\nCreate the quotient ring R/I and return the new ring as well as the projection map R to R/I.\n\nquo(R::MPolyRing, V::Vector{MPolyRingElem}; ordering::MonomialOrdering = default_ordering(R)) -> MPolyQuoRing, Map\n\nAs above, where I is the ideal of R generated by the polynomials in V.\n\nnote: Note\nOnce R/I is created,  all computations within R/I relying on division with remainder and/or Gröbner bases are done with respect to ordering.\n\nExamples\n\njulia> R, (x, y) = polynomial_ring(QQ, [:x, :y]);\n\njulia> A, p = quo(R, ideal(R, [x^2-y^3, x-y]));\n\njulia> A\nQuotient\n  of multivariate polynomial ring in 2 variables x, y\n    over rational field\n  by ideal (x^2 - y^3, x - y)\n\njulia> typeof(A)\nMPolyQuoRing{QQMPolyRingElem}\n\njulia> typeof(x)\nQQMPolyRingElem\n\njulia> p\nMap defined by a julia-function with inverse\n  from multivariate polynomial ring in 2 variables over QQ\n  to quotient of multivariate polynomial ring by ideal (x^2 - y^3, x - y)\n\njulia> p(x)\nx\n\njulia> typeof(p(x))\nMPolyQuoRingElem{QQMPolyRingElem}\n\njulia> S, (x, y, z) = graded_polynomial_ring(QQ, [:x, :y, :z]);\n\njulia> B, _ = quo(S, ideal(S, [x^2*z-y^3, x-y]))\n(Quotient of multivariate polynomial ring by ideal (x^2*z - y^3, x - y), Map: S -> B)\n\njulia> typeof(B)\nMPolyQuoRing{MPolyDecRingElem{QQFieldElem, QQMPolyRingElem}}\n\n\n\n\n\n","category":"method"},{"location":"CommutativeAlgebra/affine_algebras/#Data-Associated-to-Affine-Algebras","page":"Affine Algebras and Their Ideals","title":"Data Associated to Affine Algebras","text":"","category":"section"},{"location":"CommutativeAlgebra/affine_algebras/#Basic-Data","page":"Affine Algebras and Their Ideals","title":"Basic Data","text":"","category":"section"},{"location":"CommutativeAlgebra/affine_algebras/","page":"Affine Algebras and Their Ideals","title":"Affine Algebras and Their Ideals","text":"If A=R/I is the quotient of a multivariate polynomial ring R modulo an ideal I of R, then","category":"page"},{"location":"CommutativeAlgebra/affine_algebras/","page":"Affine Algebras and Their Ideals","title":"Affine Algebras and Their Ideals","text":"base_ring(A) refers to R,\nmodulus(A) to I,\ngens(A) to the generators of A,\nnumber_of_generators(A) / ngens(A) to the number of these generators,\ngen(A, i) as well as A[i] to the i-th such generator, and\nordering(A) to the monomial ordering used in the construction of A.","category":"page"},{"location":"CommutativeAlgebra/affine_algebras/#Examples","page":"Affine Algebras and Their Ideals","title":"Examples","text":"","category":"section"},{"location":"CommutativeAlgebra/affine_algebras/","page":"Affine Algebras and Their Ideals","title":"Affine Algebras and Their Ideals","text":"julia> R, (x, y, z) = polynomial_ring(QQ, [:x, :y, :z]);\n\njulia> A, _ = quo(R, ideal(R, [y-x^2, z-x^3]));\n\njulia> base_ring(A)\nMultivariate polynomial ring in 3 variables x, y, z\n  over rational field\n\njulia> modulus(A)\nIdeal generated by\n  -x^2 + y\n  -x^3 + z\n\njulia> gens(A)\n3-element Vector{MPolyQuoRingElem{QQMPolyRingElem}}:\n x\n y\n z\n\njulia> number_of_generators(A)\n3\n\njulia> gen(A, 2)\ny\n\njulia> ordering(A)\ndegrevlex([x, y, z])\n","category":"page"},{"location":"CommutativeAlgebra/affine_algebras/","page":"Affine Algebras and Their Ideals","title":"Affine Algebras and Their Ideals","text":"In the graded case, we additionally have:","category":"page"},{"location":"CommutativeAlgebra/affine_algebras/","page":"Affine Algebras and Their Ideals","title":"Affine Algebras and Their Ideals","text":"grading_group(q::MPolyQuoRing{<:MPolyDecRingElem})","category":"page"},{"location":"CommutativeAlgebra/affine_algebras/#grading_group-Tuple{MPolyQuoRing{<:MPolyDecRingElem}}","page":"Affine Algebras and Their Ideals","title":"grading_group","text":"grading_group(A::MPolyQuoRing{<:MPolyDecRingElem})\n\nIf A is, say, G-graded, return G.\n\nExamples\n\njulia> R, (x, y, z) = graded_polynomial_ring(QQ, [:x, :y, :z]);\n\njulia> A, _ = quo(R, ideal(R, [x^2*z-y^3, x-y]));\n\njulia> grading_group(A)\nZ\n\n\n\n\n\n","category":"method"},{"location":"CommutativeAlgebra/affine_algebras/","page":"Affine Algebras and Their Ideals","title":"Affine Algebras and Their Ideals","text":"monomial_basis(A::MPolyQuoRing, g::FinGenAbGroupElem)","category":"page"},{"location":"CommutativeAlgebra/affine_algebras/#monomial_basis-Tuple{MPolyQuoRing, FinGenAbGroupElem}","page":"Affine Algebras and Their Ideals","title":"monomial_basis","text":"monomial_basis(A::MPolyQuoRing, g::FinGenAbGroupElem)\n\nGiven an affine algebra A over a field which is graded by a free group of type FinGenAbGroup, and given an element g of that group, return a vector of monomials of R such that the residue classes of these monomials form a K-basis of the graded part of A of degree g.\n\nmonomial_basis(A::MPolyQuoRing, W::Vector{<:IntegerUnion})\n\nGiven a mathbb  Z^m-graded affine algebra A over a field and a vector W of m integers, convert W into an element g of the grading group of A and proceed as above.\n\nmonomial_basis(A::MPolyQuoRing, d::IntegerUnion)\n\nGiven a mathbb  Z-graded  affine algebra A over a field and an integer d, convert d into an element g of the grading group of A and proceed as above.\n\nnote: Note\nIf the component of the given degree is not finite dimensional, an error message will be thrown.\n\nExamples\n\njulia> R, (x, y) = graded_polynomial_ring(QQ, [:x, :y]);\n\njulia> I = ideal(R, [x^2])\nIdeal generated by\n  x^2\n\njulia> A, _ = quo(R, I)\n(Quotient of multivariate polynomial ring by ideal (x^2), Map: R -> A)\n\njulia> L = monomial_basis(A, 3)\n2-element Vector{MPolyDecRingElem{QQFieldElem, QQMPolyRingElem}}:\n y^3\n x*y^2\n\n\n\n\n\n","category":"method"},{"location":"CommutativeAlgebra/affine_algebras/","page":"Affine Algebras and Their Ideals","title":"Affine Algebras and Their Ideals","text":"homogeneous_component(A::MPolyQuoRing{<:MPolyDecRingElem}, g::FinGenAbGroupElem)","category":"page"},{"location":"CommutativeAlgebra/affine_algebras/#homogeneous_component-Tuple{MPolyQuoRing{<:MPolyDecRingElem}, FinGenAbGroupElem}","page":"Affine Algebras and Their Ideals","title":"homogeneous_component","text":"homogeneous_component(A::MPolyQuoRing{<:MPolyDecRingElem}, g::FinGenAbGroupElem)\n\nGiven a graded quotient A of a multivariate polynomial ring over a field,  where the grading group is free of type FinGenAbGroup, and given an element g of  that group, return the homogeneous component of A of degree g. Additionally, return the embedding of the component into A.\n\nhomogeneous_component(A::MPolyQuoRing{<:MPolyDecRingElem}, g::Vector{<:IntegerUnion})\n\nGiven a mathbb  Z^m-graded quotient A of a multivariate polynomial ring over a field,  and given a vector g of m integers, convert g into an element of the grading group of A, and return the homogeneous component of A whose degree  is that element. Additionally, return the embedding of the component into A.\n\nhomogeneous_component(A::MPolyQuoRing{<:MPolyDecRingElem}, g::IntegerUnion)\n\nGiven a mathbb  Z-graded quotient A of a multivariate polynomial ring over a field,  and given an integer g, convert g into an element of the grading group of A,  and return the homogeneous component of A whose degree is that element. Additionally, return the embedding of the component into A.\n\nnote: Note\nIf the component is not finite dimensional, an error message will be thrown.\n\nExamples\n\njulia> R, (w, x, y, z) = graded_polynomial_ring(QQ, [:w, :x, :y, :z])\n(Graded multivariate polynomial ring in 4 variables over QQ, MPolyDecRingElem{QQFieldElem, QQMPolyRingElem}[w, x, y, z])\n\njulia> L = homogeneous_component(R, 2);\n\njulia> HC = gens(L[1]);\n\njulia> EMB = L[2]\nMap defined by a julia-function with inverse\n  from R_[2] of dim 10\n  to graded multivariate polynomial ring in 4 variables over QQ\n\njulia> for i in 1:length(HC) println(EMB(HC[i])) end\nz^2\ny*z\ny^2\nx*z\nx*y\nx^2\nw*z\nw*y\nw*x\nw^2\n\njulia> PTC = ideal(R, [-x*z + y^2, -w*z + x*y, -w*y + x^2]);\n\njulia> A, _ = quo(R, PTC);\n\njulia> L = homogeneous_component(A, 2);\n\njulia> HC = gens(L[1]);\n\njulia> EMB = L[2]\nMap defined by a julia-function with inverse\n  from quotient space over QQ with 7 generators and no relations\n  to quotient of multivariate polynomial ring by ideal (-x*z + y^2, -w*z + x*y, -w*y + x^2)\n\njulia> for i in 1:length(HC) println(EMB(HC[i])) end\nz^2\ny*z\nx*z\nw*z\nw*y\nw*x\nw^2\n\njulia> G = abelian_group([0, 0])\nZ^2\n\njulia> W = [G[1], G[1], G[2], G[2], G[2]];\n\njulia> S, x, y = graded_polynomial_ring(QQ, :x => 1:2, :y => 1:3; weights = W);\n\njulia> L = homogeneous_component(S, [2,1]);\n\njulia> HC = gens(L[1]);\n\njulia> EMB = L[2]\nMap defined by a julia-function with inverse\n  from S_[2 1] of dim 9\n  to graded multivariate polynomial ring in 5 variables over QQ\n\njulia> for i in 1:length(HC) println(EMB(HC[i])) end\nx[2]^2*y[3]\nx[2]^2*y[2]\nx[2]^2*y[1]\nx[1]*x[2]*y[3]\nx[1]*x[2]*y[2]\nx[1]*x[2]*y[1]\nx[1]^2*y[3]\nx[1]^2*y[2]\nx[1]^2*y[1]\n\njulia> I = ideal(S, [x[1]*y[1]-x[2]*y[2]]);\n\njulia> A, = quo(S, I);\n\njulia> L = homogeneous_component(A, [2,1]);\n\njulia> HC = gens(L[1]);\n\njulia> EMB = L[2]\nMap defined by a julia-function with inverse\n  from quotient space over QQ with 7 generators and no relations\n  to quotient of multivariate polynomial ring by ideal (x[1]*y[1] - x[2]*y[2])\n\njulia> for i in 1:length(HC) println(EMB(HC[i])) end\nx[2]^2*y[3]\nx[2]^2*y[2]\nx[2]^2*y[1]\nx[1]*x[2]*y[3]\nx[1]*x[2]*y[2]\nx[1]^2*y[3]\nx[1]^2*y[2]\n\n\n\n\n\n","category":"method"},{"location":"CommutativeAlgebra/affine_algebras/#Dimension","page":"Affine Algebras and Their Ideals","title":"Dimension","text":"","category":"section"},{"location":"CommutativeAlgebra/affine_algebras/","page":"Affine Algebras and Their Ideals","title":"Affine Algebras and Their Ideals","text":"dim(A::MPolyQuoRing)","category":"page"},{"location":"CommutativeAlgebra/affine_algebras/#dim-Tuple{MPolyQuoRing}","page":"Affine Algebras and Their Ideals","title":"dim","text":"dim(A::MPolyQuoRing)\n\nReturn the Krull dimension of A.\n\nExamples\n\njulia> R, (x, y, z) = polynomial_ring(QQ, [:x, :y, :z]);\n\njulia> A, _ = quo(R, ideal(R, [y-x^2, z-x^3]));\n\njulia> dim(A)\n1\n\n\n\n\n\n","category":"method"},{"location":"CommutativeAlgebra/affine_algebras/","page":"Affine Algebras and Their Ideals","title":"Affine Algebras and Their Ideals","text":"is_finite_dimensional_vector_space(A::MPolyQuoRing)\nvector_space_dimension(A::MPolyQuoRing)","category":"page"},{"location":"CommutativeAlgebra/affine_algebras/#is_finite_dimensional_vector_space-Tuple{MPolyQuoRing}","page":"Affine Algebras and Their Ideals","title":"is_finite_dimensional_vector_space","text":"is_finite_dimensional_vector_space(A::MPolyQuoRing)\n\nIf, say, A = R/I, where R is a multivariate polynomial ring over a field K, and I is an ideal of R, return true if A is finite-dimensional as a K-vector space, false otherwise.\n\nnote: Note\nA is finite-dimensional as a K-vector space iff it has Krull dimension zero. This condition is checked by the function.\n\nExamples\n\njulia> R, (x, y, z) = polynomial_ring(QQ, [:x, :y, :z]);\n\njulia> A, _ = quo(R, ideal(R, [x^3+y^3+z^3-1, x^2+y^2+z^2-1, x+y+z-1]));\n\njulia> is_finite_dimensional_vector_space(A)\ntrue\n\njulia> A, _ = quo(R, ideal(R, [x]));\n\njulia> is_finite_dimensional_vector_space(A)\nfalse\n\n\n\n\n\n","category":"method"},{"location":"CommutativeAlgebra/affine_algebras/#vector_space_dimension-Tuple{MPolyQuoRing}","page":"Affine Algebras and Their Ideals","title":"vector_space_dimension","text":"vector_space_dimension(A::MPolyQuoRing)\n\nIf, say, A = R/I, where R is a multivariate polynomial ring over a field K, and I is an ideal of R, return the dimension of A as a K-vector space.\n\nnote: Note\nIf A is not finite-dimensional as a K-vector space, an error is thrown.\n\nExamples\n\njulia> R, (x, y, z) = polynomial_ring(QQ, [:x, :y, :z]);\n\njulia> A, _ = quo(R, ideal(R, [x^3+y^3+z^3-1, x^2+y^2+z^2-1, x+y+z-1]));\n\njulia> vector_space_dimension(A)\n6\n\njulia> I = modulus(A)\nIdeal generated by\n  x^3 + y^3 + z^3 - 1\n  x^2 + y^2 + z^2 - 1\n  x + y + z - 1\n\njulia> groebner_basis(I, ordering = lex(base_ring(I)))\nGröbner basis with elements\n  1: z^3 - z^2\n  2: y^2 + y*z - y + z^2 - z\n  3: x + y + z - 1\nwith respect to the ordering\n  lex([x, y, z])\n\n\n\n\n\n","category":"method"},{"location":"CommutativeAlgebra/affine_algebras/","page":"Affine Algebras and Their Ideals","title":"Affine Algebras and Their Ideals","text":"monomial_basis(A::MPolyQuoRing)","category":"page"},{"location":"CommutativeAlgebra/affine_algebras/#monomial_basis-Tuple{MPolyQuoRing}","page":"Affine Algebras and Their Ideals","title":"monomial_basis","text":"monomial_basis(A::MPolyQuoRing)\n\nIf, say, A = R/I, where R is a multivariate polynomial ring over a field K, and I is an ideal of R, return a vector of monomials of R such that the residue classes of these monomials form a basis of A as a K-vector space.\n\nnote: Note\nIf A is not finite-dimensional as a K-vector space, an error is thrown.\n\nExamples\n\njulia> R, (x, y) = graded_polynomial_ring(QQ, [:x, :y]);\n\njulia> I = ideal(R, [x^2, y^3])\nIdeal generated by\n  x^2\n  y^3\n\njulia> A, _ = quo(R, I)\n(Quotient of multivariate polynomial ring by ideal (x^2, y^3), Map: R -> A)\n\njulia> L = monomial_basis(A)\n6-element Vector{MPolyDecRingElem{QQFieldElem, QQMPolyRingElem}}:\n x*y^2\n y^2\n x*y\n y\n x\n 1\n\n\n\n\n\n","category":"method"},{"location":"CommutativeAlgebra/affine_algebras/#Elements-of-Affine-Algebras","page":"Affine Algebras and Their Ideals","title":"Elements of Affine Algebras","text":"","category":"section"},{"location":"CommutativeAlgebra/affine_algebras/#Types-2","page":"Affine Algebras and Their Ideals","title":"Types","text":"","category":"section"},{"location":"CommutativeAlgebra/affine_algebras/","page":"Affine Algebras and Their Ideals","title":"Affine Algebras and Their Ideals","text":"The OSCAR type for elements of quotients of  multivariate polynomial rings is of parametrized form MPolyQuoRing{T}, where T is the element type of the polynomial ring.","category":"page"},{"location":"CommutativeAlgebra/affine_algebras/#Creating-Elements-of-Affine-Algebras","page":"Affine Algebras and Their Ideals","title":"Creating Elements of Affine Algebras","text":"","category":"section"},{"location":"CommutativeAlgebra/affine_algebras/","page":"Affine Algebras and Their Ideals","title":"Affine Algebras and Their Ideals","text":"Elements of an affine algebra A=R/I are created as images of elements of R under the projection map or by directly coercing elements of R into A.","category":"page"},{"location":"CommutativeAlgebra/affine_algebras/#Examples-2","page":"Affine Algebras and Their Ideals","title":"Examples","text":"","category":"section"},{"location":"CommutativeAlgebra/affine_algebras/","page":"Affine Algebras and Their Ideals","title":"Affine Algebras and Their Ideals","text":"julia> R, (x, y) = polynomial_ring(QQ, [:x, :y]);\n\njulia> A, p = quo(R, ideal(R, [x^3*y^2-y^3*x^2, x*y^4-x*y^2]));\n\njulia> f = p(x^3*y^2-y^3*x^2+x*y)\nx^3*y^2 - x^2*y^3 + x*y\n\njulia> typeof(f)\nMPolyQuoRingElem{QQMPolyRingElem}\n\njulia> g = A(x^3*y^2-y^3*x^2+x*y)\nx^3*y^2 - x^2*y^3 + x*y\n\njulia> f == g\ntrue\n","category":"page"},{"location":"CommutativeAlgebra/affine_algebras/#Reducing-Polynomial-Representatives","page":"Affine Algebras and Their Ideals","title":"Reducing Polynomial Representatives","text":"","category":"section"},{"location":"CommutativeAlgebra/affine_algebras/","page":"Affine Algebras and Their Ideals","title":"Affine Algebras and Their Ideals","text":"simplify(f::MPolyQuoRingElem)","category":"page"},{"location":"CommutativeAlgebra/affine_algebras/#simplify-Tuple{MPolyQuoRingElem}","page":"Affine Algebras and Their Ideals","title":"simplify","text":"simplify(f::MPolyQuoRingElem)\n\nIf f is an element of the affine algebra A = R/I, say, replace the internal polynomial representative of f  by its normal form mod I with respect to ordering(A).\n\nExamples\n\njulia> R, (x,) = polynomial_ring(QQ, [:x]);\n\njulia> A, p = quo(R, ideal(R, [x^4]));\n\njulia> f = p(2*x^6 + x^3 + x)\n2*x^6 + x^3 + x\n\njulia> simplify(f)\nx^3 + x\n\njulia> f\nx^3 + x\n\n\n\n\n\n","category":"method"},{"location":"CommutativeAlgebra/affine_algebras/#Tests-on-Elements-of-Affine-Algebras","page":"Affine Algebras and Their Ideals","title":"Tests on Elements of Affine Algebras","text":"","category":"section"},{"location":"CommutativeAlgebra/affine_algebras/","page":"Affine Algebras and Their Ideals","title":"Affine Algebras and Their Ideals","text":"==(f::MPolyQuoRingElem{T}, g::MPolyQuoRingElem{T}) where T","category":"page"},{"location":"CommutativeAlgebra/affine_algebras/#==-Union{Tuple{T}, Tuple{MPolyQuoRingElem{T}, MPolyQuoRingElem{T}}} where T","page":"Affine Algebras and Their Ideals","title":"==","text":"==(f::MPolyQuoRingElem{T}, g::MPolyQuoRingElem{T}) where T\n\nReturn true if f is equal to g, false otherwise.\n\nExamples\n\njulia> R, (x,) = polynomial_ring(QQ, [:x]);\n\njulia> A, p = quo(R, ideal(R, [x^4]));\n\njulia> f = p(x-x^6)\n-x^6 + x\n\njulia> g = p(x)\nx\n\njulia> f == g\ntrue\n\n\n\n\n\n","category":"method"},{"location":"CommutativeAlgebra/affine_algebras/","page":"Affine Algebras and Their Ideals","title":"Affine Algebras and Their Ideals","text":"is_invertible_with_inverse(f::MPolyQuoRingElem)","category":"page"},{"location":"CommutativeAlgebra/affine_algebras/#is_invertible_with_inverse-Tuple{MPolyQuoRingElem}","page":"Affine Algebras and Their Ideals","title":"is_invertible_with_inverse","text":"is_invertible_with_inverse(f::MPolyQuoRingElem)\n\nIf f is invertible with inverse g, say, return (true, g). Otherwise, return (false, f).\n\nExamples\n\njulia> R, c = polynomial_ring(QQ, :c => (1:3));\n\njulia> R, c = grade(R, [1, 2, 3]);\n\njulia> I = ideal(R, [  -c[1]^3 + 2*c[1]*c[2] - c[3], c[1]^4 - 3*c[1]^2*c[2] + 2*c[1]*c[3] + c[2]^2,-c[1]^5 + 4*c[1]^3*c[2] - 3*c[1]^2*c[3] - 3*c[1]*c[2]^2 + 2*c[2]*c[3]]);\n\njulia> A, _ = quo(R, I);\n\njulia> f = A(c[1]^2 - c[1] - c[2] + 1)\nc[1]^2 - c[1] - c[2] + 1\n\njulia> tt, g = is_invertible_with_inverse(f)\n(true, c[1] + c[2] + c[3] + 1)\n\njulia> f*g\n1\n\n\n\n\n\n\n","category":"method"},{"location":"CommutativeAlgebra/affine_algebras/","page":"Affine Algebras and Their Ideals","title":"Affine Algebras and Their Ideals","text":"In the graded case, we additionally have:","category":"page"},{"location":"CommutativeAlgebra/affine_algebras/","page":"Affine Algebras and Their Ideals","title":"Affine Algebras and Their Ideals","text":"is_homogeneous(f::MPolyQuoRingElem{<:MPolyDecRingElem})","category":"page"},{"location":"CommutativeAlgebra/affine_algebras/#is_homogeneous-Tuple{MPolyQuoRingElem{<:MPolyDecRingElem}}","page":"Affine Algebras and Their Ideals","title":"is_homogeneous","text":"is_homogeneous(f::MPolyQuoRingElem{<:MPolyDecRingElem})\n\nGiven an element f of a graded affine algebra, return true if f is homogeneous, false otherwise.\n\nExamples\n\njulia> R, (x, y, z) = graded_polynomial_ring(QQ, [:x, :y, :z]);\n\njulia> A, p = quo(R, ideal(R, [y-x, z^3-x^3]));\n\njulia> f = p(y^2-x^2+z^4)\n-x^2 + y^2 + z^4\n\njulia> is_homogeneous(f)\ntrue\n\njulia> f\nz^4\n\n\n\n\n\n","category":"method"},{"location":"CommutativeAlgebra/affine_algebras/#Data-associated-to-Elements-of-Affine-Algebras","page":"Affine Algebras and Their Ideals","title":"Data associated to Elements of Affine Algebras","text":"","category":"section"},{"location":"CommutativeAlgebra/affine_algebras/","page":"Affine Algebras and Their Ideals","title":"Affine Algebras and Their Ideals","text":"Given an element f of an affine algebra A,","category":"page"},{"location":"CommutativeAlgebra/affine_algebras/","page":"Affine Algebras and Their Ideals","title":"Affine Algebras and Their Ideals","text":"parent(f) refers to A.","category":"page"},{"location":"CommutativeAlgebra/affine_algebras/","page":"Affine Algebras and Their Ideals","title":"Affine Algebras and Their Ideals","text":"In the graded case,  we also have:","category":"page"},{"location":"CommutativeAlgebra/affine_algebras/","page":"Affine Algebras and Their Ideals","title":"Affine Algebras and Their Ideals","text":" homogeneous_components(f::MPolyQuoRingElem{<:MPolyDecRingElem})","category":"page"},{"location":"CommutativeAlgebra/affine_algebras/#homogeneous_components-Tuple{MPolyQuoRingElem{<:MPolyDecRingElem}}","page":"Affine Algebras and Their Ideals","title":"homogeneous_components","text":"homogeneous_components(f::MPolyQuoRingElem{<:MPolyDecRingElem})\n\nGiven an element f of a graded affine algebra, return the homogeneous components of f.\n\nExamples\n\njulia> R, (x, y, z) = graded_polynomial_ring(QQ, [:x, :y, :z]);\n\njulia> A, p = quo(R, ideal(R, [y-x, z^3-x^3]));\n\njulia> f = p(y^2-x^2+x*y*z+z^4)\n-x^2 + x*y*z + y^2 + z^4\n\njulia> homogeneous_components(f)\nDict{FinGenAbGroupElem, MPolyQuoRingElem{MPolyDecRingElem{QQFieldElem, QQMPolyRingElem}}} with 2 entries:\n  [4] => z^4\n  [3] => y^2*z\n\n\n\n\n\n","category":"method"},{"location":"CommutativeAlgebra/affine_algebras/","page":"Affine Algebras and Their Ideals","title":"Affine Algebras and Their Ideals","text":"homogeneous_component(f::MPolyQuoRingElem{<:MPolyDecRingElem}, g::FinGenAbGroupElem)","category":"page"},{"location":"CommutativeAlgebra/affine_algebras/#homogeneous_component-Tuple{MPolyQuoRingElem{<:MPolyDecRingElem}, FinGenAbGroupElem}","page":"Affine Algebras and Their Ideals","title":"homogeneous_component","text":"homogeneous_component(f::MPolyQuoRingElem{<:MPolyDecRingElem}, g::FinGenAbGroupElem)\n\nGiven an element f of a graded affine algebra, and given an element g of the grading group of that algebra, return the homogeneous component of f of degree g.\n\nhomogeneous_component(f::MPolyQuoRingElem{<:MPolyDecRingElem}, g::Vector{<:IntegerUnion})\n\nGiven an element f of a mathbb  Z^m-graded affine algebra A, say, and given a vector g of m integers, convert g into an element of the grading group of A, and return the homogeneous component of f whose degree is that element.\n\nhomogeneous_component(f::MPolyQuoRingElem{<:MPolyDecRingElem}, g::IntegerUnion)\n\nGiven an element f of a mathbb  Z-graded affine algebra A, say, and given an integer g, convert g into an element of the grading group of A, and return the homogeneous component of f whose degree is that element.\n\nExamples\n\njulia> R, (x, y, z) = graded_polynomial_ring(QQ, [:x, :y, :z]);\n\njulia> A, p = quo(R, ideal(R, [y-x, z^3-x^3]));\n\njulia> f = p(y^2-x^2+x*y*z+z^4)\n-x^2 + x*y*z + y^2 + z^4\n\njulia> homogeneous_component(f, 4)\nz^4\n\n\n\n\n\n","category":"method"},{"location":"CommutativeAlgebra/affine_algebras/","page":"Affine Algebras and Their Ideals","title":"Affine Algebras and Their Ideals","text":"degree(f::MPolyQuoRingElem{<:MPolyDecRingElem})","category":"page"},{"location":"CommutativeAlgebra/affine_algebras/#degree-Tuple{MPolyQuoRingElem{<:MPolyDecRingElem}}","page":"Affine Algebras and Their Ideals","title":"degree","text":"degree(f::MPolyQuoRingElem{<:MPolyDecRingElem})\n\nGiven a homogeneous element f of a graded affine algebra, return the degree of f.\n\ndegree(::Type{Vector{Int}}, f::MPolyQuoRingElem{<:MPolyDecRingElem})\n\nGiven a homogeneous element f of a mathbb Z^m-graded affine algebra, return the degree of f, converted to a vector of integer numbers.\n\ndegree(::Type{Int}, f::MPolyQuoRingElem{<:MPolyDecRingElem})\n\nGiven a homogeneous element f of a mathbb Z-graded affine algebra, return the degree of f, converted to an integer number.\n\nExamples\n\njulia> R, (x, y, z) = graded_polynomial_ring(QQ, [:x, :y, :z] );\n\njulia> A, p = quo(R, ideal(R, [y-x, z^3-x^3]))\n(Quotient of multivariate polynomial ring by ideal (-x + y, -x^3 + z^3), Map: R -> A)\n\njulia> f = p(y^2-x^2+z^4)\n-x^2 + y^2 + z^4\n\njulia> degree(f)\n[4]\n\njulia> typeof(degree(f))\nFinGenAbGroupElem\n\njulia> degree(Int, f)\n4\n\njulia> typeof(degree(Int, f))\nInt64\n\n\n\n\n\n","category":"method"},{"location":"CommutativeAlgebra/affine_algebras/#Ideals-in-Affine-Algebras","page":"Affine Algebras and Their Ideals","title":"Ideals in Affine Algebras","text":"","category":"section"},{"location":"CommutativeAlgebra/affine_algebras/#Constructors-2","page":"Affine Algebras and Their Ideals","title":"Constructors","text":"","category":"section"},{"location":"CommutativeAlgebra/affine_algebras/","page":"Affine Algebras and Their Ideals","title":"Affine Algebras and Their Ideals","text":"ideal(Q::MPolyQuoRing{T}, V::Vector{T}) where T <: MPolyRingElem","category":"page"},{"location":"CommutativeAlgebra/affine_algebras/#ideal-Union{Tuple{T}, Tuple{MPolyQuoRing{T}, Vector{T}}} where T<:MPolyRingElem","page":"Affine Algebras and Their Ideals","title":"ideal","text":"ideal(A::MPolyQuoRing{T}, V::Vector{T}) where T <: MPolyRingElem\n\nGiven a (graded) quotient ring A=R/I and a vector V of (homogeneous) polynomials in R, create the ideal of A which is generated by the images of the entries of V.\n\nideal(A::MPolyQuoRing{T}, V::Vector{MPolyQuoRingElem{T}}) where T <: MPolyRingElem\n\nGiven a (graded) quotient ring A and a vector V of (homogeneous) elements of A, create the ideal of A which is generated by the entries of V.\n\nExamples\n\njulia> R, (x, y) = polynomial_ring(QQ, [:x, :y]);\n\njulia> A, _ = quo(R, ideal(R, [x^2-y^3, x-y]));\n\njulia> I = ideal(A, [x^2-y])\nIdeal generated by\n  x^2 - y\n\njulia> S, (x, y, z) = graded_polynomial_ring(QQ, [:x, :y, :z]);\n\njulia> B, _ = quo(S, ideal(S, [x^2*z-y^3, x-y]));\n\njulia> J = ideal(B, [x^2-y^2])\nIdeal generated by\n  x^2 - y^2\n\n\n\n\n\n","category":"method"},{"location":"CommutativeAlgebra/affine_algebras/#Reducing-Polynomial-Representatives-of-Generators","page":"Affine Algebras and Their Ideals","title":"Reducing Polynomial Representatives of Generators","text":"","category":"section"},{"location":"CommutativeAlgebra/affine_algebras/","page":"Affine Algebras and Their Ideals","title":"Affine Algebras and Their Ideals","text":"simplify(a::MPolyQuoIdeal)","category":"page"},{"location":"CommutativeAlgebra/affine_algebras/#simplify-Tuple{MPolyQuoIdeal}","page":"Affine Algebras and Their Ideals","title":"simplify","text":"simplify(a::MPolyQuoIdeal)\n\nIf a is an ideal of the affine algebra A = R/I, say, replace the internal polynomial representative  of each generator of a by its normal form mod I with respect to ordering(A).\n\nExamples\n\njulia> R, (x, y) = polynomial_ring(QQ, [:x, :y]);\n\njulia> A, _ = quo(R, ideal(R, [x^3*y^2-y^3*x^2, x*y^4-x*y^2]));\n\njulia> a = ideal(A, [x^3*y^4-x+y, x*y+y^2*x])\nIdeal generated by\n  x^3*y^4 - x + y\n  x*y^2 + x*y\n\njulia> gens(a)\n2-element Vector{MPolyQuoRingElem{QQMPolyRingElem}}:\n x^3*y^4 - x + y\n x*y^2 + x*y\n\njulia> simplify(a)\nIdeal generated by\n  x^2*y^3 - x + y\n  x*y^2 + x*y\n\njulia> gens(a)\n2-element Vector{MPolyQuoRingElem{QQMPolyRingElem}}:\n x^2*y^3 - x + y\n x*y^2 + x*y\n\n\n\n\n\n","category":"method"},{"location":"CommutativeAlgebra/affine_algebras/#Data-Associated-to-Ideals-in-Affine-Algebras","page":"Affine Algebras and Their Ideals","title":"Data Associated to Ideals in Affine Algebras","text":"","category":"section"},{"location":"CommutativeAlgebra/affine_algebras/#Basic-Data-2","page":"Affine Algebras and Their Ideals","title":"Basic Data","text":"","category":"section"},{"location":"CommutativeAlgebra/affine_algebras/","page":"Affine Algebras and Their Ideals","title":"Affine Algebras and Their Ideals","text":"If a is an ideal of the affine algebra A, then","category":"page"},{"location":"CommutativeAlgebra/affine_algebras/","page":"Affine Algebras and Their Ideals","title":"Affine Algebras and Their Ideals","text":"base_ring(a) refers to A,\ngens(a) to the generators of a,\nnumber_of_generators(a) / ngens(a) to the number of these generators,  and\ngen(a, i) as well as a[i] to the i-th such generator.","category":"page"},{"location":"CommutativeAlgebra/affine_algebras/#Examples-3","page":"Affine Algebras and Their Ideals","title":"Examples","text":"","category":"section"},{"location":"CommutativeAlgebra/affine_algebras/","page":"Affine Algebras and Their Ideals","title":"Affine Algebras and Their Ideals","text":"julia> R, (x, y, z) = polynomial_ring(QQ, [:x, :y, :z]);\n\njulia> A, _ = quo(R, ideal(R, [y-x^2, z-x^3]));\n\njulia> a = ideal(A, [x-y, z^4])\nIdeal generated by\n  x - y\n  z^4\n\njulia> base_ring(a)\nQuotient\n  of multivariate polynomial ring in 3 variables x, y, z\n    over rational field\n  by ideal (-x^2 + y, -x^3 + z)\n\njulia> gens(a)\n2-element Vector{MPolyQuoRingElem{QQMPolyRingElem}}:\n x - y\n z^4\n\njulia> number_of_generators(a)\n2\n\njulia> gen(a, 2)\nz^4\n","category":"page"},{"location":"CommutativeAlgebra/affine_algebras/#Dimension-of-Ideals-in-Affine-Algebras","page":"Affine Algebras and Their Ideals","title":"Dimension of Ideals in Affine Algebras","text":"","category":"section"},{"location":"CommutativeAlgebra/affine_algebras/","page":"Affine Algebras and Their Ideals","title":"Affine Algebras and Their Ideals","text":"dim(a::MPolyQuoIdeal)","category":"page"},{"location":"CommutativeAlgebra/affine_algebras/#dim-Tuple{MPolyQuoIdeal}","page":"Affine Algebras and Their Ideals","title":"dim","text":"dim(a::MPolyQuoIdeal)\n\nReturn the Krull dimension of a.\n\nExamples\n\njulia> R, (x, y, z) = polynomial_ring(QQ, [:x, :y, :z]);\n\njulia> A, _ = quo(R, ideal(R, [y-x^2, z-x^3]));\n\njulia> a = ideal(A, [x-y])\nIdeal generated by\n  x - y\n\njulia> dim(a)\n0\n\n\n\n\n\n","category":"method"},{"location":"CommutativeAlgebra/affine_algebras/#Minimal-Sets-of-Generators","page":"Affine Algebras and Their Ideals","title":"Minimal Sets of Generators","text":"","category":"section"},{"location":"CommutativeAlgebra/affine_algebras/","page":"Affine Algebras and Their Ideals","title":"Affine Algebras and Their Ideals","text":"In the graded case, we have:","category":"page"},{"location":"CommutativeAlgebra/affine_algebras/","page":"Affine Algebras and Their Ideals","title":"Affine Algebras and Their Ideals","text":"minimal_generating_set(I::MPolyQuoIdeal{<:MPolyDecRingElem})","category":"page"},{"location":"CommutativeAlgebra/affine_algebras/#minimal_generating_set-Tuple{MPolyQuoIdeal{<:MPolyDecRingElem}}","page":"Affine Algebras and Their Ideals","title":"minimal_generating_set","text":"minimal_generating_set(I::MPolyQuoIdeal{<:MPolyDecRingElem})\n\nGiven a homogeneous ideal I of a graded affine algebra over a field, return an array containing a minimal set of generators of I. If I is the zero ideal, an empty list is returned.\n\nExamples\n\njulia> R, (x, y, z) = graded_polynomial_ring(QQ, [:x, :y, :z]);\n\njulia> A, p = quo(R, ideal(R, [x-y]));\n\njulia> V = [x, z^2, x^3+y^3, y^4, y*z^5];\n\njulia> a = ideal(A, V);\n\njulia> minimal_generating_set(a)\n2-element Vector{MPolyQuoRingElem{MPolyDecRingElem{QQFieldElem, QQMPolyRingElem}}}:\n y\n z^2\n\njulia> a = ideal(A, [x-y])\nIdeal generated by\n  x - y\n\njulia> minimal_generating_set(a)\nMPolyQuoRingElem{MPolyDecRingElem{QQFieldElem, QQMPolyRingElem}}[]\n\n\n\n\n\n","category":"method"},{"location":"CommutativeAlgebra/affine_algebras/#Operations-on-Ideals-in-Affine-Algebras","page":"Affine Algebras and Their Ideals","title":"Operations on Ideals in Affine Algebras","text":"","category":"section"},{"location":"CommutativeAlgebra/affine_algebras/#Simple-Ideal-Operations-in-Affine-Algebras","page":"Affine Algebras and Their Ideals","title":"Simple Ideal Operations in Affine Algebras","text":"","category":"section"},{"location":"CommutativeAlgebra/affine_algebras/#Powers-of-Ideal","page":"Affine Algebras and Their Ideals","title":"Powers of Ideal","text":"","category":"section"},{"location":"CommutativeAlgebra/affine_algebras/","page":"Affine Algebras and Their Ideals","title":"Affine Algebras and Their Ideals","text":":^(a::MPolyQuoIdeal, m::Int)","category":"page"},{"location":"CommutativeAlgebra/affine_algebras/#^-Tuple{MPolyQuoIdeal, Int64}","page":"Affine Algebras and Their Ideals","title":"^","text":":^(a::MPolyQuoIdeal, m::Int)\n\nReturn the m-th power of a.\n\nExamples\n\njulia> R, (x, y) = polynomial_ring(QQ, [:x, :y]);\n\njulia> A, _ = quo(R, [x^2-y, y^2-x+y]);\n\njulia> a = ideal(A, [x+y])\nIdeal generated by\n  x + y\n\njulia> a^2\nIdeal generated by\n  x^2 + 2*x*y + y^2\n\n\n\n\n\n","category":"method"},{"location":"CommutativeAlgebra/affine_algebras/#Sum-of-Ideals","page":"Affine Algebras and Their Ideals","title":"Sum of Ideals","text":"","category":"section"},{"location":"CommutativeAlgebra/affine_algebras/","page":"Affine Algebras and Their Ideals","title":"Affine Algebras and Their Ideals","text":":+(a::MPolyQuoIdeal{T}, b::MPolyQuoIdeal{T}) where T","category":"page"},{"location":"CommutativeAlgebra/affine_algebras/#+-Union{Tuple{T}, Tuple{MPolyQuoIdeal{T}, MPolyQuoIdeal{T}}} where T","page":"Affine Algebras and Their Ideals","title":"+","text":":+(a::MPolyQuoIdeal{T}, b::MPolyQuoIdeal{T}) where T\n\nReturn the sum of a and b.\n\nExamples\n\njulia> R, (x, y) = polynomial_ring(QQ, [:x, :y]);\n\njulia> A, _ = quo(R, [x^2-y, y^2-x+y]);\n\njulia> a = ideal(A, [x+y])\nIdeal generated by\n  x + y\n\njulia> b = ideal(A, [x^2+y^2, x+y])\nIdeal generated by\n  x^2 + y^2\n  x + y\n\njulia> a+b\nIdeal generated by\n  x + y\n  x^2 + y^2\n\n\n\n\n\n","category":"method"},{"location":"CommutativeAlgebra/affine_algebras/#Product-of-Ideals","page":"Affine Algebras and Their Ideals","title":"Product of Ideals","text":"","category":"section"},{"location":"CommutativeAlgebra/affine_algebras/","page":"Affine Algebras and Their Ideals","title":"Affine Algebras and Their Ideals","text":":*(a::MPolyQuoIdeal{T}, b::MPolyQuoIdeal{T}) where T","category":"page"},{"location":"CommutativeAlgebra/affine_algebras/#*-Union{Tuple{T}, Tuple{MPolyQuoIdeal{T}, MPolyQuoIdeal{T}}} where T","page":"Affine Algebras and Their Ideals","title":"*","text":":*(a::MPolyQuoIdeal{T}, b::MPolyQuoIdeal{T}) where T\n\nReturn the product of a and b.\n\nExamples\n\njulia> R, (x, y) = polynomial_ring(QQ, [:x, :y]);\n\njulia> A, _ = quo(R, [x^2-y, y^2-x+y]);\n\njulia> a = ideal(A, [x+y])\nIdeal generated by\n  x + y\n\njulia> b = ideal(A, [x^2+y^2, x+y])\nIdeal generated by\n  x^2 + y^2\n  x + y\n\njulia> a*b\nIdeal generated by\n  x^3 + x^2*y + x*y^2 + y^3\n  x^2 + 2*x*y + y^2\n\n\n\n\n\n","category":"method"},{"location":"CommutativeAlgebra/affine_algebras/#Intersection-of-Ideals","page":"Affine Algebras and Their Ideals","title":"Intersection of Ideals","text":"","category":"section"},{"location":"CommutativeAlgebra/affine_algebras/","page":"Affine Algebras and Their Ideals","title":"Affine Algebras and Their Ideals","text":"intersect(a::MPolyQuoIdeal{T}, bs::MPolyQuoIdeal{T}...) where T","category":"page"},{"location":"CommutativeAlgebra/affine_algebras/#intersect-Union{Tuple{T}, Tuple{MPolyQuoIdeal{T}, Vararg{MPolyQuoIdeal{T}}}} where T","page":"Affine Algebras and Their Ideals","title":"intersect","text":"intersect(a::MPolyQuoIdeal{T}, bs::MPolyQuoIdeal{T}...) where T\nintersect(V::Vector{MPolyQuoIdeal{T}}) where T\n\nReturn the intersection of two or more ideals.\n\nExamples\n\njulia> R, (x, y) = polynomial_ring(QQ, [:x, :y]);\n\njulia> A, _ = quo(R, ideal(R, [x^2-y^3, x-y]));\n\njulia> a = ideal(A, [y^2])\nIdeal generated by\n  y^2\n\njulia> b = ideal(A, [x])\nIdeal generated by\n  x\n\njulia> intersect(a,b)\nIdeal generated by\n  x*y\n\njulia> intersect([a,b])\nIdeal generated by\n  x*y\n\n\n\n\n\n","category":"method"},{"location":"CommutativeAlgebra/affine_algebras/#Ideal-Quotients","page":"Affine Algebras and Their Ideals","title":"Ideal Quotients","text":"","category":"section"},{"location":"CommutativeAlgebra/affine_algebras/","page":"Affine Algebras and Their Ideals","title":"Affine Algebras and Their Ideals","text":"quotient(a::MPolyQuoIdeal{T}, b::MPolyQuoIdeal{T}) where T","category":"page"},{"location":"CommutativeAlgebra/affine_algebras/#quotient-Union{Tuple{T}, Tuple{MPolyQuoIdeal{T}, MPolyQuoIdeal{T}}} where T","page":"Affine Algebras and Their Ideals","title":"quotient","text":"quotient(a::MPolyQuoIdeal{T}, b::MPolyQuoIdeal{T}) where T\n\nReturn the ideal quotient of a by b. Alternatively, use a:b.\n\nExamples\n\njulia> R, (x, y) = polynomial_ring(QQ, [:x, :y]);\n\njulia> A, _ = quo(R, ideal(R, [x^2-y^3, x-y]));\n\njulia> a = ideal(A, [y^2])\nIdeal generated by\n  y^2\n\njulia> b = ideal(A, [x])\nIdeal generated by\n  x\n\njulia> a:b\nIdeal generated by\n  y\n\n\n\n\n\n","category":"method"},{"location":"CommutativeAlgebra/affine_algebras/#Tests-on-Ideals-in-Affine-Algebras","page":"Affine Algebras and Their Ideals","title":"Tests on Ideals in Affine Algebras","text":"","category":"section"},{"location":"CommutativeAlgebra/affine_algebras/#Basic-Tests","page":"Affine Algebras and Their Ideals","title":"Basic Tests","text":"","category":"section"},{"location":"CommutativeAlgebra/affine_algebras/","page":"Affine Algebras and Their Ideals","title":"Affine Algebras and Their Ideals","text":"is_zero(a::MPolyQuoIdeal)","category":"page"},{"location":"CommutativeAlgebra/affine_algebras/#is_zero-Tuple{MPolyQuoIdeal}","page":"Affine Algebras and Their Ideals","title":"is_zero","text":"is_zero(a::MPolyQuoIdeal)\n\nReturn true if a is the zero ideal, false otherwise.\n\nExamples\n\njulia> R, (x, y) = polynomial_ring(QQ, [:x, :y]);\n\njulia> A, _ = quo(R, [x^2-y, y^2-x+y]);\n\njulia> a = ideal(A, [x^2+y^2, x+y])\nIdeal generated by\n  x^2 + y^2\n  x + y\n\njulia> is_zero(a)\nfalse\n\njulia> b = ideal(A, [x^2-y])\nIdeal generated by\n  x^2 - y\n\njulia> is_zero(b)\ntrue\n\n\n\n\n\n","category":"method"},{"location":"CommutativeAlgebra/affine_algebras/#Containment-of-Ideals-in-Affine-Algebras","page":"Affine Algebras and Their Ideals","title":"Containment of Ideals in Affine Algebras","text":"","category":"section"},{"location":"CommutativeAlgebra/affine_algebras/","page":"Affine Algebras and Their Ideals","title":"Affine Algebras and Their Ideals","text":"is_subset(a::MPolyQuoIdeal{T}, b::MPolyQuoIdeal{T}) where T","category":"page"},{"location":"CommutativeAlgebra/affine_algebras/#is_subset-Union{Tuple{T}, Tuple{MPolyQuoIdeal{T}, MPolyQuoIdeal{T}}} where T","page":"Affine Algebras and Their Ideals","title":"is_subset","text":"is_subset(a::MPolyQuoIdeal{T}, b::MPolyQuoIdeal{T}) where T\n\nReturn true if a is contained in b, false otherwise.\n\nExamples\n\njulia> R, (x, y) = polynomial_ring(QQ, [:x, :y]);\n\njulia> A, _ = quo(R, ideal(R, [x^3*y^2-y^3*x^2, x*y^4-x*y^2]));\n\njulia> a = ideal(A, [x^3*y^4-x+y, x*y+y^2*x])\nIdeal generated by\n  x^3*y^4 - x + y\n  x*y^2 + x*y\n\njulia> b = ideal(A, [x^3*y^3-x+y, x^2*y+y^2*x])\nIdeal generated by\n  x^3*y^3 - x + y\n  x^2*y + x*y^2\n\njulia> is_subset(a,b)\nfalse\n\njulia> is_subset(b,a)\ntrue\n\n\n\n\n\n","category":"method"},{"location":"CommutativeAlgebra/affine_algebras/#Equality-of-Ideals-in-Affine-Algebras","page":"Affine Algebras and Their Ideals","title":"Equality of Ideals in Affine Algebras","text":"","category":"section"},{"location":"CommutativeAlgebra/affine_algebras/","page":"Affine Algebras and Their Ideals","title":"Affine Algebras and Their Ideals","text":"==(a::MPolyQuoIdeal{T}, b::MPolyQuoIdeal{T}) where T","category":"page"},{"location":"CommutativeAlgebra/affine_algebras/#==-Union{Tuple{T}, Tuple{MPolyQuoIdeal{T}, MPolyQuoIdeal{T}}} where T","page":"Affine Algebras and Their Ideals","title":"==","text":"==(a::MPolyQuoIdeal{T}, b::MPolyQuoIdeal{T}) where T\n\nReturn true if a is equal to b, false otherwise.\n\nExamples\n\njulia> R, (x, y) = polynomial_ring(QQ, [:x, :y]);\n\njulia> A, _ = quo(R, ideal(R, [x^3*y^2-y^3*x^2, x*y^4-x*y^2]));\n\njulia> a = ideal(A, [x^3*y^4-x+y, x*y+y^2*x])\nIdeal generated by\n  x^3*y^4 - x + y\n  x*y^2 + x*y\n\njulia> b = ideal(A, [x^3*y^3-x+y, x^2*y+y^2*x])\nIdeal generated by\n  x^3*y^3 - x + y\n  x^2*y + x*y^2\n\njulia> a == b\nfalse\n\n\n\n\n\n","category":"method"},{"location":"CommutativeAlgebra/affine_algebras/#Ideal-Membership","page":"Affine Algebras and Their Ideals","title":"Ideal Membership","text":"","category":"section"},{"location":"CommutativeAlgebra/affine_algebras/","page":"Affine Algebras and Their Ideals","title":"Affine Algebras and Their Ideals","text":"ideal_membership(f::MPolyQuoRingElem{T}, a::MPolyQuoIdeal{T}) where T","category":"page"},{"location":"CommutativeAlgebra/affine_algebras/#ideal_membership-Union{Tuple{T}, Tuple{MPolyQuoRingElem{T}, MPolyQuoIdeal{T}}} where T","page":"Affine Algebras and Their Ideals","title":"ideal_membership","text":"ideal_membership(f::MPolyQuoRingElem{T}, a::MPolyQuoIdeal{T}) where T\n\nReturn true if f is contained in a, false otherwise. Alternatively, use f in a.\n\nExamples\n\njulia> R, (x, y) = polynomial_ring(QQ, [:x, :y]);\n\njulia> A, _ = quo(R, ideal(R, [x^3*y^2-y^3*x^2, x*y^4-x*y^2]));\n\njulia> a = ideal(A, [x^3*y^4-x+y, x*y+y^2*x])\nIdeal generated by\n  x^3*y^4 - x + y\n  x*y^2 + x*y\n\njulia> f = A(x^2*y^3-x+y)\nx^2*y^3 - x + y\n\njulia> f in a\ntrue\n\n\n\n\n\n","category":"method"},{"location":"CommutativeAlgebra/affine_algebras/#Homomorphisms-From-Affine-Algebras","page":"Affine Algebras and Their Ideals","title":"Homomorphisms From Affine Algebras","text":"","category":"section"},{"location":"CommutativeAlgebra/affine_algebras/","page":"Affine Algebras and Their Ideals","title":"Affine Algebras and Their Ideals","text":"If A=RI is an affine C-algebra, and S is any ring, then defining a ring homomorphism overlinephi A to S means to define a ring homomorphism phi R to S such that Isubset ker(phi). Thus, overlinephi  is determined by specifying its restriction to C, and by assigning an image to each generator of A. In OSCAR, such homomorphisms are created as follows:","category":"page"},{"location":"CommutativeAlgebra/affine_algebras/","page":"Affine Algebras and Their Ideals","title":"Affine Algebras and Their Ideals","text":"hom(A::MPolyQuoRing, S::NCRing, coeff_map, images::Vector; check::Bool = true)","category":"page"},{"location":"CommutativeAlgebra/affine_algebras/#hom-Tuple{MPolyQuoRing, NCRing, Any, Vector}","page":"Affine Algebras and Their Ideals","title":"hom","text":"hom(A::MPolyQuoRing, S::NCRing, coeff_map, images::Vector; check::Bool = true)\n\nhom(A::MPolyQuoRing, S::NCRing, images::Vector; check::Bool = true)\n\nGiven a homomorphism coeff_map from C to S, where C is the  coefficient ring of the base ring of A, and given a vector images of ngens(A)  elements of S, return the homomorphism A to S whose restriction  to C is coeff_map, and which sends the i-th generator of A to the  i-th entry of images.\n\nIf no coefficient map is entered, invoke a canonical homomorphism of C to S, if such a homomorphism exists, and throw an error, otherwise.\n\nnote: Note\nThe function returns a well-defined homomorphism A to S iff the given data defines a homomorphism base_ring(A) to S whose kernel contains the modulus of A. This condition is checked by the  function in case check = true (default).\n\nnote: Note\nIn case check = true (default), the function also checks the conditions below:If S is graded, the assigned images must be homogeneous with respect to the given grading.\nIf S is noncommutative, the assigned images must pairwise commute. \n\nExamples\n\njulia> R, (x, y, z) = polynomial_ring(QQ, [:x, :y, :z]);\n\njulia> A, _ = quo(R, ideal(R, [y-x^2, z-x^3]));\n\njulia> S, (s, t) = polynomial_ring(QQ, [:s, :t]);\n\njulia> F = hom(A, S, [s, s^2, s^3])\nRing homomorphism\n  from quotient of multivariate polynomial ring by ideal (-x^2 + y, -x^3 + z)\n  to multivariate polynomial ring in 2 variables over QQ\ndefined by\n  x -> s\n  y -> s^2\n  z -> s^3\n\n\n\n\n\n","category":"method"},{"location":"CommutativeAlgebra/affine_algebras/","page":"Affine Algebras and Their Ideals","title":"Affine Algebras and Their Ideals","text":"Given a ring homomorphism F : A to S as above, domain(F) and codomain(F) refer to A and S, respectively.  Given ring homomorphisms F : A to B and G : B to T as above, compose(F, G) refers to their composition.","category":"page"},{"location":"CommutativeAlgebra/affine_algebras/#Homomorphisms-of-Affine-Algebras","page":"Affine Algebras and Their Ideals","title":"Homomorphisms of Affine Algebras","text":"","category":"section"},{"location":"CommutativeAlgebra/affine_algebras/","page":"Affine Algebras and Their Ideals","title":"Affine Algebras and Their Ideals","text":"The OSCAR homomorphism type AffAlgHom models ring homomorphisms R to S such that the type of both R and S  is a subtype of Union{MPolyRing{T}, MPolyQuoRing{U}}, where T <: FieldElem and U <: MPolyRingElem{T}. Functionality for these homomorphism is discussed in what follows.","category":"page"},{"location":"CommutativeAlgebra/affine_algebras/#Data-Associated-to-Homomorphisms-of-Affine-Algebras","page":"Affine Algebras and Their Ideals","title":"Data Associated to Homomorphisms of Affine Algebras","text":"","category":"section"},{"location":"CommutativeAlgebra/affine_algebras/","page":"Affine Algebras and Their Ideals","title":"Affine Algebras and Their Ideals","text":"preimage(F::MPolyAnyMap, I::Ideal)\nkernel(F::AffAlgHom)","category":"page"},{"location":"CommutativeAlgebra/affine_algebras/#preimage-Tuple{Oscar.MPolyAnyMap, Ideal}","page":"Affine Algebras and Their Ideals","title":"preimage","text":"preimage(F::MPolyAnyMap, I::Ideal)\n\nReturn the preimage of the ideal I under F.\n\n\n\n\n\n","category":"method"},{"location":"CommutativeAlgebra/affine_algebras/#kernel-Tuple{Oscar.MPolyAnyMap{DT, CT, Nothing} where {T<:FieldElem, U1<:MPolyRingElem{T}, U2<:MPolyRingElem{T}, DT<:Union{MPolyRing{T}, MPolyQuoRing{U1}}, CT<:Union{MPolyRing{T}, MPolyQuoRing{U2}}}}","page":"Affine Algebras and Their Ideals","title":"kernel","text":"kernel(F::AffAlgHom)\n\nReturn the kernel of F.\n\n\n\n\n\n","category":"method"},{"location":"CommutativeAlgebra/affine_algebras/#Examples-4","page":"Affine Algebras and Their Ideals","title":"Examples","text":"","category":"section"},{"location":"CommutativeAlgebra/affine_algebras/","page":"Affine Algebras and Their Ideals","title":"Affine Algebras and Their Ideals","text":"julia> D1, (w, x, y, z) = graded_polynomial_ring(QQ, [:w, :x, :y, :z]);\n\njulia> C1, (s,t) = graded_polynomial_ring(QQ, [:s, :t]);\n\njulia> V1 = [s^3, s^2*t, s*t^2, t^3];\n\njulia> para = hom(D1, C1, V1)\nRing homomorphism\n  from graded multivariate polynomial ring in 4 variables over QQ\n  to graded multivariate polynomial ring in 2 variables over QQ\ndefined by\n  w -> s^3\n  x -> s^2*t\n  y -> s*t^2\n  z -> t^3\n\njulia> twistedCubic = kernel(para)\nIdeal generated by\n  -x*z + y^2\n  -w*z + x*y\n  -w*y + x^2\n\njulia> C2, p2 = quo(D1, twistedCubic);\n\njulia> D2, (a, b, c) = graded_polynomial_ring(QQ, [:a, :b, :c]);\n\njulia> V2 = [p2(w-y), p2(x), p2(z)];\n\njulia> proj = hom(D2, C2, V2)\nRing homomorphism\n  from graded multivariate polynomial ring in 3 variables over QQ\n  to quotient of multivariate polynomial ring by ideal (-x*z + y^2, -w*z + x*y, -w*y + x^2)\ndefined by\n  a -> w - y\n  b -> x\n  c -> z\n\njulia> nodalCubic = kernel(proj)\nIdeal generated by\n  -a^2*c + b^3 - 2*b^2*c + b*c^2\n","category":"page"},{"location":"CommutativeAlgebra/affine_algebras/","page":"Affine Algebras and Their Ideals","title":"Affine Algebras and Their Ideals","text":"julia> D3,y = polynomial_ring(QQ, :y => 1:3);\n\njulia> C3, x = polynomial_ring(QQ, :x => 1:3);\n\njulia> V3 = [x[1]*x[2], x[1]*x[3], x[2]*x[3]];\n\njulia> F3 = hom(D3, C3, V3)\nRing homomorphism\n  from multivariate polynomial ring in 3 variables over QQ\n  to multivariate polynomial ring in 3 variables over QQ\ndefined by\n  y[1] -> x[1]*x[2]\n  y[2] -> x[1]*x[3]\n  y[3] -> x[2]*x[3]\n\njulia> sphere = ideal(C3, [x[1]^3 + x[2]^3  + x[3]^3 - 1])\nIdeal generated by\n  x[1]^3 + x[2]^3 + x[3]^3 - 1\n\njulia> steinerRomanSurface = preimage(F3, sphere)\nIdeal generated by\n  y[1]^6*y[2]^6 + 2*y[1]^6*y[2]^3*y[3]^3 + y[1]^6*y[3]^6 + 2*y[1]^3*y[2]^6*y[3]^3 + 2*y[1]^3*y[2]^3*y[3]^6 - y[1]^3*y[2]^3*y[3]^3 + y[2]^6*y[3]^6\n","category":"page"},{"location":"CommutativeAlgebra/affine_algebras/#Tests-on-Homomorphisms-of-Affine-Algebras","page":"Affine Algebras and Their Ideals","title":"Tests on Homomorphisms of Affine Algebras","text":"","category":"section"},{"location":"CommutativeAlgebra/affine_algebras/","page":"Affine Algebras and Their Ideals","title":"Affine Algebras and Their Ideals","text":"is_injective(F::AffAlgHom)\nis_surjective(F::AffAlgHom)\nis_bijective(F::AffAlgHom)\nis_finite(F::AffAlgHom)","category":"page"},{"location":"CommutativeAlgebra/affine_algebras/#is_injective-Tuple{Oscar.MPolyAnyMap{DT, CT, Nothing} where {T<:FieldElem, U1<:MPolyRingElem{T}, U2<:MPolyRingElem{T}, DT<:Union{MPolyRing{T}, MPolyQuoRing{U1}}, CT<:Union{MPolyRing{T}, MPolyQuoRing{U2}}}}","page":"Affine Algebras and Their Ideals","title":"is_injective","text":"is_injective(F::AffAlgHom)\n\nReturn true if F is injective, false otherwise.\n\n\n\n\n\n","category":"method"},{"location":"CommutativeAlgebra/affine_algebras/#is_surjective-Tuple{Oscar.MPolyAnyMap{DT, CT, Nothing} where {T<:FieldElem, U1<:MPolyRingElem{T}, U2<:MPolyRingElem{T}, DT<:Union{MPolyRing{T}, MPolyQuoRing{U1}}, CT<:Union{MPolyRing{T}, MPolyQuoRing{U2}}}}","page":"Affine Algebras and Their Ideals","title":"is_surjective","text":"is_surjective(F::AffAlgHom)\n\nReturn true if F is surjective, false otherwise.\n\n\n\n\n\n","category":"method"},{"location":"CommutativeAlgebra/affine_algebras/#is_bijective-Tuple{Oscar.MPolyAnyMap{DT, CT, Nothing} where {T<:FieldElem, U1<:MPolyRingElem{T}, U2<:MPolyRingElem{T}, DT<:Union{MPolyRing{T}, MPolyQuoRing{U1}}, CT<:Union{MPolyRing{T}, MPolyQuoRing{U2}}}}","page":"Affine Algebras and Their Ideals","title":"is_bijective","text":"is_bijective(F::AffAlgHom)\n\nReturn true if F is bijective, false otherwise.\n\n\n\n\n\n","category":"method"},{"location":"CommutativeAlgebra/affine_algebras/#is_finite-Tuple{Oscar.MPolyAnyMap{DT, CT, Nothing} where {T<:FieldElem, U1<:MPolyRingElem{T}, U2<:MPolyRingElem{T}, DT<:Union{MPolyRing{T}, MPolyQuoRing{U1}}, CT<:Union{MPolyRing{T}, MPolyQuoRing{U2}}}}","page":"Affine Algebras and Their Ideals","title":"is_finite","text":"is_finite(F::AffAlgHom)\n\nReturn true if F is finite, false otherwise.\n\n\n\n\n\n","category":"method"},{"location":"CommutativeAlgebra/affine_algebras/#Examples-5","page":"Affine Algebras and Their Ideals","title":"Examples","text":"","category":"section"},{"location":"CommutativeAlgebra/affine_algebras/","page":"Affine Algebras and Their Ideals","title":"Affine Algebras and Their Ideals","text":"julia> D, (x, y, z) = polynomial_ring(QQ, [:x, :y, :z]);\n\njulia> S, (a, b, c) = polynomial_ring(QQ, [:a, :b, :c]);\n\njulia> C, p = quo(S, ideal(S, [c-b^3]));\n\njulia> V = [p(2*a + b^6), p(7*b - a^2), p(c^2)];\n\njulia> F = hom(D, C, V)\nRing homomorphism\n  from multivariate polynomial ring in 3 variables over QQ\n  to quotient of multivariate polynomial ring by ideal (-b^3 + c)\ndefined by\n  x -> 2*a + c^2\n  y -> -a^2 + 7*b\n  z -> c^2\n\njulia> is_surjective(F)\ntrue\n\njulia> D1, _ = quo(D, kernel(F));\n\njulia> F1 = hom(D1, C, V);\n\njulia> is_bijective(F1)\ntrue\n","category":"page"},{"location":"CommutativeAlgebra/affine_algebras/","page":"Affine Algebras and Their Ideals","title":"Affine Algebras and Their Ideals","text":"julia> R, (x, y, z) = polynomial_ring(QQ, [ :x, :y, :z]);\n\njulia> C, (s, t) = polynomial_ring(QQ, [:s, :t]);\n\njulia> V = [s*t, t, s^2];\n\njulia> paraWhitneyUmbrella = hom(R, C, V)\nRing homomorphism\n  from multivariate polynomial ring in 3 variables over QQ\n  to multivariate polynomial ring in 2 variables over QQ\ndefined by\n  x -> s*t\n  y -> t\n  z -> s^2\n\njulia> D, _ = quo(R, kernel(paraWhitneyUmbrella));\n\njulia> is_finite(hom(D, C, V))\ntrue","category":"page"},{"location":"CommutativeAlgebra/affine_algebras/#Inverting-Homomorphisms-of-Affine-Algebras","page":"Affine Algebras and Their Ideals","title":"Inverting Homomorphisms of Affine Algebras","text":"","category":"section"},{"location":"CommutativeAlgebra/affine_algebras/","page":"Affine Algebras and Their Ideals","title":"Affine Algebras and Their Ideals","text":"inverse(F::AffAlgHom)","category":"page"},{"location":"CommutativeAlgebra/affine_algebras/#inverse-Tuple{Oscar.MPolyAnyMap{DT, CT, Nothing} where {T<:FieldElem, U1<:MPolyRingElem{T}, U2<:MPolyRingElem{T}, DT<:Union{MPolyRing{T}, MPolyQuoRing{U1}}, CT<:Union{MPolyRing{T}, MPolyQuoRing{U2}}}}","page":"Affine Algebras and Their Ideals","title":"inverse","text":"inverse(F::AffAlgHom)\n\nIf F is bijective, return its inverse.\n\nExamples\n\njulia> D1, (x, y, z) = polynomial_ring(QQ, [:x, :y, :z]);\n\njulia> D, _ = quo(D1, [y-x^2, z-x^3]);\n\njulia> C, (t,) = polynomial_ring(QQ, [:t]);\n\njulia> F = hom(D, C, [t, t^2, t^3]);\n\njulia> is_bijective(F)\ntrue\n\njulia> G = inverse(F)\nRing homomorphism\n  from multivariate polynomial ring in 1 variable over QQ\n  to quotient of multivariate polynomial ring by ideal (-x^2 + y, -x^3 + z)\ndefined by\n  t -> x\n\njulia> G(t)\nx\n\n\n\n\n\n","category":"method"},{"location":"CommutativeAlgebra/affine_algebras/#Algebraic-Independence","page":"Affine Algebras and Their Ideals","title":"Algebraic Independence","text":"","category":"section"},{"location":"CommutativeAlgebra/affine_algebras/","page":"Affine Algebras and Their Ideals","title":"Affine Algebras and Their Ideals","text":"is_algebraically_independent(V::Vector{T}) where T <: Union{MPolyRingElem, MPolyQuoRingElem}\nis_algebraically_independent_with_relations(V::Vector{T}) where T <: Union{MPolyRingElem, MPolyQuoRingElem}","category":"page"},{"location":"CommutativeAlgebra/affine_algebras/#is_algebraically_independent-Union{Tuple{Vector{T}}, Tuple{T}} where T<:Union{MPolyRingElem, MPolyQuoRingElem}","page":"Affine Algebras and Their Ideals","title":"is_algebraically_independent","text":"is_algebraically_independent(V::Vector{T}) where T <: Union{MPolyRingElem, MPolyQuoRingElem}\n\nGiven a vector V of elements of a multivariate polynomial ring over a field K, say, or of a quotient of such a ring, return true if the elements of V are algebraically independent over K, and false otherwise.\n\nExamples\n\njulia> R, (x, y) = polynomial_ring(QQ, [:x, :y]);\n\njulia> V = [x, y, x^2+y^3]\n3-element Vector{QQMPolyRingElem}:\n x\n y\n x^2 + y^3\n\njulia> is_algebraically_independent(V)\nfalse\n\njulia> A, p = quo(R, [x*y]);\n\njulia> is_algebraically_independent([p(x), p(y)])\nfalse\n\n\n\n\n\n","category":"method"},{"location":"CommutativeAlgebra/affine_algebras/#is_algebraically_independent_with_relations-Union{Tuple{Vector{T}}, Tuple{T}} where T<:Union{MPolyRingElem, MPolyQuoRingElem}","page":"Affine Algebras and Their Ideals","title":"is_algebraically_independent_with_relations","text":"is_algebraically_independent_with_relations(V::Vector{T}) where T <: Union{MPolyRingElem, MPolyQuoRingElem}\n\nGiven a vector V of elements of a multivariate polynomial ring over a field K, say, or of a quotient of such a ring, return (true, Ideal (0)) if the elements of V are algebraically independent over K. Otherwise, return false together with the ideal of K-algebra relations.\n\nExamples\n\njulia> R, (x, y) = polynomial_ring(QQ, [:x, :y]);\n\njulia> V = [x, y, x^2+y^3]\n3-element Vector{QQMPolyRingElem}:\n x\n y\n x^2 + y^3\n\njulia> is_algebraically_independent_with_relations(V)\n(false, Ideal (t1^2 + t2^3 - t3))\n\njulia> A, p = quo(R, [x*y]);\n\njulia> is_algebraically_independent_with_relations([p(x), p(y)])\n(false, Ideal (t1*t2))\n\n\n\n\n\n","category":"method"},{"location":"CommutativeAlgebra/affine_algebras/#Subalgebras","page":"Affine Algebras and Their Ideals","title":"Subalgebras","text":"","category":"section"},{"location":"CommutativeAlgebra/affine_algebras/#Subalgebra-Membership","page":"Affine Algebras and Their Ideals","title":"Subalgebra Membership","text":"","category":"section"},{"location":"CommutativeAlgebra/affine_algebras/","page":"Affine Algebras and Their Ideals","title":"Affine Algebras and Their Ideals","text":"subalgebra_membership(f::T, V::Vector{T}) where T <: Union{MPolyRingElem, MPolyQuoRingElem}","category":"page"},{"location":"CommutativeAlgebra/affine_algebras/#subalgebra_membership-Union{Tuple{T}, Tuple{T, Vector{T}}} where T<:Union{MPolyRingElem, MPolyQuoRingElem}","page":"Affine Algebras and Their Ideals","title":"subalgebra_membership","text":"subalgebra_membership(f::T, V::Vector{T}) where T <: Union{MPolyRingElem, MPolyQuoRingElem}\n\nGiven an element f of a multivariate polynomial ring over a field, or of a quotient of such a ring, and given a vector V of further elements of that ring, consider the subalgebra generated by the entries of V in the given ring. If f is contained in the subalgebra, return (true, h), where h is giving the polynomial relation. Return, (false, 0), otherwise.\n\nExamples\n\njulia> R, x = polynomial_ring(QQ, :x => 1:3);\n\njulia> f = x[1]^6*x[2]^6-x[1]^6*x[3]^6;\n\njulia> V = [x[1]^3*x[2]^3-x[1]^3*x[3]^3, x[1]^3*x[2]^3+x[1]^3*x[3]^3]\n2-element Vector{QQMPolyRingElem}:\n x[1]^3*x[2]^3 - x[1]^3*x[3]^3\n x[1]^3*x[2]^3 + x[1]^3*x[3]^3\n\njulia> subalgebra_membership(f, V)\n(true, t1*t2)\n\n\n\n\n\n","category":"method"},{"location":"CommutativeAlgebra/affine_algebras/#Minimal-Subalgebra-Generators","page":"Affine Algebras and Their Ideals","title":"Minimal Subalgebra Generators","text":"","category":"section"},{"location":"CommutativeAlgebra/affine_algebras/","page":"Affine Algebras and Their Ideals","title":"Affine Algebras and Their Ideals","text":"minimal_subalgebra_generators(V::Vector{T}; check::Bool = true) where {T <: Union{MPolyDecRingElem, MPolyQuoRingElem{<: MPolyDecRingElem}}}","category":"page"},{"location":"CommutativeAlgebra/affine_algebras/#minimal_subalgebra_generators-Union{Tuple{Vector{T}}, Tuple{T}} where T<:Union{MPolyDecRingElem, MPolyQuoRingElem{<:MPolyDecRingElem}}","page":"Affine Algebras and Their Ideals","title":"minimal_subalgebra_generators","text":"minimal_subalgebra_generators(V::Vector{T}; check::Bool = true) where T <: Union{MPolyRingElem, MPolyQuoRingElem}\n\nGiven a vector V of homogeneous elements of a positively graded multivariate polynomial ring, or of a quotient of such a ring, return a subset of the elements in V of minimal cardinality which, in the given ring, generate the same subalgebra as all elements in V.\n\nIf check is true (default), the conditions on V and the given ring are checked.\n\nExamples\n\njulia> R, (x, y) = graded_polynomial_ring(QQ, [:x, :y]);\n\njulia> V = [x, y, x^2+y^2]\n3-element Vector{MPolyDecRingElem{QQFieldElem, QQMPolyRingElem}}:\n x\n y\n x^2 + y^2\n\njulia> minimal_subalgebra_generators(V)\n2-element Vector{MPolyDecRingElem{QQFieldElem, QQMPolyRingElem}}:\n x\n y\n\n\n\n\n\n","category":"method"},{"location":"CommutativeAlgebra/affine_algebras/#Noether-Normalization","page":"Affine Algebras and Their Ideals","title":"Noether Normalization","text":"","category":"section"},{"location":"CommutativeAlgebra/affine_algebras/","page":"Affine Algebras and Their Ideals","title":"Affine Algebras and Their Ideals","text":"noether_normalization(A::MPolyQuoRing)","category":"page"},{"location":"CommutativeAlgebra/affine_algebras/#noether_normalization-Tuple{MPolyQuoRing}","page":"Affine Algebras and Their Ideals","title":"noether_normalization","text":"noether_normalization(A::MPolyQuoRing)\n\nGiven an affine algebra A=RI over a field K, return a triple (VFG) such that:\n\nV is a vector of d=dim A elements of A, represented by linear forms l_iin R, and such that KVhookrightarrow A is a Noether normalization for A;\nF A=RI to B = Rphi(I) is an isomorphism, induced by a linear change phi of coordinates of R which maps the l_i to the the last d variables of R;\nG = F^-1\n\nwarning: Warning\nThe algorithm may not terminate over a small finite field. If it terminates, the result is correct.\n\n\n\n\n\n","category":"method"},{"location":"CommutativeAlgebra/affine_algebras/#Examples-6","page":"Affine Algebras and Their Ideals","title":"Examples","text":"","category":"section"},{"location":"CommutativeAlgebra/affine_algebras/","page":"Affine Algebras and Their Ideals","title":"Affine Algebras and Their Ideals","text":"julia> R, (x, y, z) = polynomial_ring(QQ, [:x, :y, :z]);\n\njulia> A, _ = quo(R, ideal(R, [x*y, x*z]));\n\njulia> L = noether_normalization(A);\n\njulia> L[1]\n2-element Vector{MPolyQuoRingElem{QQMPolyRingElem}}:\n -2*x + y\n -5*y + z\n\njulia> L[2]\nRing homomorphism\n  from quotient of multivariate polynomial ring by ideal (x*y, x*z)\n  to quotient of multivariate polynomial ring by ideal (2*x^2 + x*y, 10*x^2 + 5*x*y + x*z)\ndefined by\n  x -> x\n  y -> 2*x + y\n  z -> 10*x + 5*y + z\n\njulia> L[3]\nRing homomorphism\n  from quotient of multivariate polynomial ring by ideal (2*x^2 + x*y, 10*x^2 + 5*x*y + x*z)\n  to quotient of multivariate polynomial ring by ideal (x*y, x*z)\ndefined by\n  x -> x\n  y -> -2*x + y\n  z -> -5*y + z\n","category":"page"},{"location":"CommutativeAlgebra/affine_algebras/#Normalization","page":"Affine Algebras and Their Ideals","title":"Normalization","text":"","category":"section"},{"location":"CommutativeAlgebra/affine_algebras/","page":"Affine Algebras and Their Ideals","title":"Affine Algebras and Their Ideals","text":"normalization(A::MPolyQuoRing)","category":"page"},{"location":"CommutativeAlgebra/affine_algebras/#normalization-Tuple{MPolyQuoRing}","page":"Affine Algebras and Their Ideals","title":"normalization","text":"normalization(A::MPolyQuoRing; algorithm = :equidimDec)\n\nFind the normalization of a reduced affine algebra over a perfect field K. That is, given the quotient A=RI of a multivariate polynomial ring R over K modulo a radical ideal I, compute the integral closure overlineA of A in its total ring of fractions Q(A), together with the embedding f A to overlineA.\n\nImplemented Algorithms and how to Read the Output\n\nThe function relies on the algorithm of Greuel, Laplagne, and Seelisch which proceeds by finding a suitable decomposition I=I_1capdotscap I_r into radical ideals I_k, together with maps A = RI to A_k=overlineRI_k which give rise to the normalization map of A:\n\nAhookrightarrow A_1times dotstimes A_r=overlineA\n\nFor each k, the function specifies two representations of A_k: It returns an array of triples (A_k f_k mathfrak a_k), where A_k is represented as an affine K-algebra, and f_k as a map of affine K-algebras. The third entry mathfrak a_k is a tuple (d_k J_k), consisting of an element d_kin A and an ideal J_ksubset A, such that frac1d_kJ_k = A_k as A-submodules of the total ring of fractions of A.\n\nBy default (algorithm = :equidimDec), as a first step on its way to find the decomposition I=I_1capdotscap I_r, the algorithm computes an equidimensional decomposition of the radical ideal I. Alternatively, if specified by algorithm = :primeDec, the algorithm computes I=I_1capdotscap I_r as the prime decomposition of the radical ideal I. If specified by algorithm = :isPrime, assume that I is prime.\n\nSee [GLS10].\n\nwarning: Warning\nThe function does not check whether A is reduced. Use is_reduced(A) in case you are unsure (this may take some time).\n\nExamples\n\njulia> R, (x, y) = polynomial_ring(QQ, [:x, :y]);\n\njulia> A, _ = quo(R, ideal(R, [(x^2-y^3)*(x^2+y^2)*x]));\n\njulia> L = normalization(A);\n\njulia> size(L)\n(2,)\n\njulia> LL = normalization(A, algorithm = :primeDec);\n\njulia> size(LL)\n(3,)\n\njulia> LL[1][1]\nQuotient\n  of multivariate polynomial ring in 3 variables T(1), x, y\n    over rational field\n  by ideal (-T(1)*y + x, -T(1)*x + y^2, T(1)^2 - y, -x^2 + y^3)\n\njulia> LL[1][2]\nRing homomorphism\n  from quotient of multivariate polynomial ring by ideal (x^5 - x^3*y^3 + x^3*y^2 - x*y^5)\n  to quotient of multivariate polynomial ring by ideal (-T(1)*y + x, -T(1)*x + y^2, T(1)^2 - y, -x^2 + y^3)\ndefined by\n  x -> x\n  y -> y\n\njulia> LL[1][3]\n(y, Ideal (x, y))\n\n\n\n\n\n","category":"method"},{"location":"CommutativeAlgebra/affine_algebras/","page":"Affine Algebras and Their Ideals","title":"Affine Algebras and Their Ideals","text":"normalization_with_delta(A::MPolyQuoRing)","category":"page"},{"location":"CommutativeAlgebra/affine_algebras/#normalization_with_delta-Tuple{MPolyQuoRing}","page":"Affine Algebras and Their Ideals","title":"normalization_with_delta","text":"normalization_with_delta(A::MPolyQuoRing; algorithm::Symbol = :equidimDec)\n\nCompute the normalization\n\nAhookrightarrow A_1times dotstimes A_r=overlineA\n\nof A as does normalize(A), but return additionally the delta invariant of A, that is, the dimension\n\ndim_K(overlineAA)\n\nHow to Read the Output\n\nThe return value is a tuple whose first element is normalize(A), whose second element is an array containing the delta invariants of the A_k, and whose third element is the (total) delta invariant of A. The return value -1 in the third element indicates that the delta invariant is infinite.\n\nExamples\n\njulia> R, (x, y) = polynomial_ring(QQ, [:x, :y]);\n\njulia> A, _ = quo(R, ideal(R, [(x^2-y^3)*(x^2+y^2)*x]));\n\njulia> L = normalization_with_delta(A);\n\njulia> L[2]\n3-element Vector{Int64}:\n 1\n 1\n 0\n\njulia> L[3]\n13\n\njulia> R, (x, y, z) = polynomial_ring(QQ, [:x, :y, :z]);\n\njulia> A, _ = quo(R, ideal(R, [z^3-x*y^4]));\n\njulia> L = normalization_with_delta(A);\n\njulia> L[3]\n-1\n\n\n\n\n\n","category":"method"},{"location":"CommutativeAlgebra/affine_algebras/#Integral-Bases","page":"Affine Algebras and Their Ideals","title":"Integral Bases","text":"","category":"section"},{"location":"CommutativeAlgebra/affine_algebras/","page":"Affine Algebras and Their Ideals","title":"Affine Algebras and Their Ideals","text":"integral_basis(f::MPolyRingElem, i::Int)","category":"page"},{"location":"CommutativeAlgebra/affine_algebras/#integral_basis-Tuple{MPolyRingElem, Int64}","page":"Affine Algebras and Their Ideals","title":"integral_basis","text":"integral_basis(f::MPolyRingElem, i::Int; algorithm::Symbol = :normal_local)\n\nGiven a polynomial f in two variables with coefficients in a perfect field K, and given an integer iin12 specifying one of the variables, f must be irreducible and monic in the specified variable: Say, finmathbb Kxy is monic in y. Then the normalization of A = Kxylangle f rangle, that is, the integral closure overlineA of A in its quotient field, is a free module over Kx of finite rank, and any set of free generators for overlineA over Kx is called an integral basis for overlineA over Kx. The function returns a pair (d V), where d is an element of A, and V is a vector of elements in A, such that the fractions vd vin V, form an integral basis for overlineA over Kx.\n\nBy default (algorithm = :normal_local), the function relies on the local-to-global approach to normalization presented in [BDLPSS13]. Alternatively, if specified by algorithm = :normal_global, the global normalization algorithm in [GLS10] is used. If K = mathbb Q, it is recommended to apply the algorithm in [BDLP19], which makes use of Puiseux expansions and Hensel lifting (algorithm = :hensel).\n\nnote: Note\nThe conditions on f are automatically checked.\n\nExamples\n\njulia> R, (x, y) = polynomial_ring(QQ, [:x, :y]);\n\njulia> f = (y^2-2)^2 + x^5\nx^5 + y^4 - 4*y^2 + 4\n\njulia> integral_basis(f, 2)\n(x^2, MPolyQuoRingElem{QQMPolyRingElem}[x^2, x^2*y, y^2 - 2, y^3 - 2*y])\n\n\n\n\n\n","category":"method"},{"location":"CommutativeAlgebra/affine_algebras/#Tests-on-Affine-Algebras","page":"Affine Algebras and Their Ideals","title":"Tests on Affine Algebras","text":"","category":"section"},{"location":"CommutativeAlgebra/affine_algebras/#Reducedness-Test","page":"Affine Algebras and Their Ideals","title":"Reducedness Test","text":"","category":"section"},{"location":"CommutativeAlgebra/affine_algebras/","page":"Affine Algebras and Their Ideals","title":"Affine Algebras and Their Ideals","text":"is_reduced(A::MPolyQuoRing)","category":"page"},{"location":"CommutativeAlgebra/affine_algebras/#is_reduced-Tuple{MPolyQuoRing}","page":"Affine Algebras and Their Ideals","title":"is_reduced","text":"is_reduced(A::MPolyQuoRing)\n\nGiven an affine algebra A, return true if A is reduced, false otherwise.\n\nwarning: Warning\nThe function computes the radical of the modulus of A. This may take some time.\n\nExamples\n\njulia> R, (x,) = polynomial_ring(QQ, [:x]);\n\njulia> A, _ = quo(R, ideal(R, [x^4]));\n\njulia> is_reduced(A)\nfalse\n\n\n\n\n\n","category":"method"},{"location":"CommutativeAlgebra/affine_algebras/#Normality-Test","page":"Affine Algebras and Their Ideals","title":"Normality Test","text":"","category":"section"},{"location":"CommutativeAlgebra/affine_algebras/","page":"Affine Algebras and Their Ideals","title":"Affine Algebras and Their Ideals","text":"is_normal(A::MPolyQuoRing)","category":"page"},{"location":"CommutativeAlgebra/affine_algebras/#is_normal-Tuple{MPolyQuoRing}","page":"Affine Algebras and Their Ideals","title":"is_normal","text":"is_normal(A::MPolyQuoRing; check::Bool=true) -> Bool\n\nGiven an affine algebra A over a perfect field, return true if A is normal, and false otherwise.\n\nnote: Note\nThis function performs the first step of the normalization algorithm of Greuel, Laplagne, and Seelisch [GLS10] and may, thus, be more efficient than computing the full normalization of A.\n\nwarning: Warning\nIf check is true, the function checks whether A is indeed reduced. This may take some time.\n\nExamples\n\njulia> R, (x, y, z) = polynomial_ring(QQ, [:x, :y, :z]);\n\njulia> A, _ = quo(R, ideal(R, [z^2-x*y]));\n\njulia> is_normal(A)\ntrue\n\n\n\n\n\n","category":"method"},{"location":"CommutativeAlgebra/affine_algebras/#Cohen-Macaulayness-Test","page":"Affine Algebras and Their Ideals","title":"Cohen-Macaulayness Test","text":"","category":"section"},{"location":"CommutativeAlgebra/affine_algebras/","page":"Affine Algebras and Their Ideals","title":"Affine Algebras and Their Ideals","text":"is_cohen_macaulay(A::MPolyQuoRing)","category":"page"},{"location":"CommutativeAlgebra/affine_algebras/#is_cohen_macaulay-Tuple{MPolyQuoRing}","page":"Affine Algebras and Their Ideals","title":"is_cohen_macaulay","text":"is_cohen_macaulay(A::MPolyQuoRing)\n\nGiven a mathbb Z-graded affine algebra A = R/I over a field, say, K, where the grading is inherited from the standard mathbb Z-grading on the polynomial ring R, return true if A is a Cohen-Macaulay ring, false otherwise.\n\nExamples\n\njulia> R, (w, x, y, z) = graded_polynomial_ring(QQ, [:w, :x, :y, :z]);\n\njulia> I = ideal(R, [x*z-y^2, w*z-x*y, w*y-x^2]);\n\njulia> A, _ = quo(R, I);\n\njulia> is_cohen_macaulay(A)\ntrue\n\njulia> R, (x, y, z) = graded_polynomial_ring(QQ, [:x, :y, :z]);\n\njulia> I = ideal(R, [x*z, y*z]);\n\njulia> A, _ = quo(R, I);\n\njulia> is_cohen_macaulay(A)\nfalse\n\n\n\n\n\n","category":"method"},{"location":"CommutativeAlgebra/affine_algebras/#Hilbert-Series-and-Hilbert-Polynomial","page":"Affine Algebras and Their Ideals","title":"Hilbert Series and Hilbert Polynomial","text":"","category":"section"},{"location":"CommutativeAlgebra/affine_algebras/","page":"Affine Algebras and Their Ideals","title":"Affine Algebras and Their Ideals","text":"Given a multivariate polynomial ring R over a field K together with a (multi)grading on R by a finitely generated abelian group G, let I be an ideal of R which is homogeneous with respect to this grading. Then the affine K-algebra A=RI inherits the grading: A = bigoplus_gin G A_g. Suppose now that R is positively graded by G. That is, G is free and each graded piece R_g has finite dimension. Then also A_g is a finite dimensional K-vector space for each g, and we have the well-defined Hilbert function of A,","category":"page"},{"location":"CommutativeAlgebra/affine_algebras/","page":"Affine Algebras and Their Ideals","title":"Affine Algebras and Their Ideals","text":"H(A underlinephantomd) G to mathbbN  gmapsto dim_K(A_g)","category":"page"},{"location":"CommutativeAlgebra/affine_algebras/","page":"Affine Algebras and Their Ideals","title":"Affine Algebras and Their Ideals","text":"The Hilbert series of A is the generating function","category":"page"},{"location":"CommutativeAlgebra/affine_algebras/","page":"Affine Algebras and Their Ideals","title":"Affine Algebras and Their Ideals","text":"H_A(mathbb t)=sum_gin G H(A g) mathbb t^g","category":"page"},{"location":"CommutativeAlgebra/affine_algebras/","page":"Affine Algebras and Their Ideals","title":"Affine Algebras and Their Ideals","text":"(see  Section 8.2 in [MS05] for a formal discussion extending the classical case of mathbb Z-gradings with positive weights to the more general case of multigradings). As in the classical case, the infinitely many values of the Hilbert function can be expressed in finite terms by representing the Hilbert series as a rational function (see Theorem 8.20 in [MS05] for a precise statement).","category":"page"},{"location":"CommutativeAlgebra/affine_algebras/","page":"Affine Algebras and Their Ideals","title":"Affine Algebras and Their Ideals","text":"By a result of Macaulay, if A = RI is an affine algebra, and L_(I) is the leading ideal of I with respect to a global monomial ordering , then the Hilbert function of A equals that of RL_(I) (see Theorem 15.26 in [Eis95]). Thus, using Gröbner bases, the computation of Hilbert series can be reduced to the case where the modulus of the affine algebra is a monomial ideal. In the latter case, we face a problem of combinatorial nature, and there are various strategies of how to proceed (see [KR05]). The functions hilbert_series, hilbert_series_reduced, hilbert_series_expanded, hilbert_function, hilbert_polynomial, and degree address the case of mathbb Z-gradings with positive weights, relying on corresponding Singular functionality. The functions multi_hilbert_series, multi_hilbert_series_reduced, and multi_hilbert_function offer a variety of different strategies and allow one to handle positive gradings in general.","category":"page"},{"location":"CommutativeAlgebra/affine_algebras/#\\mathbb-Z-Gradings-With-Positive-Weights","page":"Affine Algebras and Their Ideals","title":"mathbb Z-Gradings With Positive Weights","text":"","category":"section"},{"location":"CommutativeAlgebra/affine_algebras/","page":"Affine Algebras and Their Ideals","title":"Affine Algebras and Their Ideals","text":"Let R=Kx_1 dots x_n be a polynomial ring in n variables over a field K. Assign positive integer weights w_i to the variables x_i, and grade R=bigoplus_din mathbb Z R_d=bigoplus_dgeq 0 R_d according to the corresponding weighted degree. Let I be an ideal of R which is homogeneous with respect to this grading. Then the affine K-algebra A=RI inherits the grading: A = bigoplus_dgeq 0 A_d, where each graded piece A_d is a finite dimensional K-vector space. In this situation, the Hilbert function of A is of type","category":"page"},{"location":"CommutativeAlgebra/affine_algebras/","page":"Affine Algebras and Their Ideals","title":"Affine Algebras and Their Ideals","text":"H(A underlinephantomd) mathbbN to mathbbN d mapsto dim_K(d)","category":"page"},{"location":"CommutativeAlgebra/affine_algebras/","page":"Affine Algebras and Their Ideals","title":"Affine Algebras and Their Ideals","text":"and the Hilbert series of A is the formal power series","category":"page"},{"location":"CommutativeAlgebra/affine_algebras/","page":"Affine Algebras and Their Ideals","title":"Affine Algebras and Their Ideals","text":"H_A(t)=sum_dgeq 0 H(A d) t^dinmathbb Zt","category":"page"},{"location":"CommutativeAlgebra/affine_algebras/","page":"Affine Algebras and Their Ideals","title":"Affine Algebras and Their Ideals","text":"The Hilbert series can be written as a rational function p(t)q(t), with denominator","category":"page"},{"location":"CommutativeAlgebra/affine_algebras/","page":"Affine Algebras and Their Ideals","title":"Affine Algebras and Their Ideals","text":"q(t) = (1-t^w_1)cdots (1-t^w_n)","category":"page"},{"location":"CommutativeAlgebra/affine_algebras/","page":"Affine Algebras and Their Ideals","title":"Affine Algebras and Their Ideals","text":"In the standard mathbb Z-graded case, where the weights on the variables are all 1, the Hilbert function is of polynomial nature: There exists  a unique polynomial P_A(t)inmathbbQt, the Hilbert polynomial, which satisfies H(Md)=P_M(d) for all d gg 0. Furthermore, the degree of A is defined as the dimension of A over K if this dimension is finite, and as the integer d such that the leading term of the Hilbert polynomial has the form d t^ee, otherwise.","category":"page"},{"location":"CommutativeAlgebra/affine_algebras/","page":"Affine Algebras and Their Ideals","title":"Affine Algebras and Their Ideals","text":"hilbert_series(A::MPolyQuoRing)\nhilbert_series_reduced(A::MPolyQuoRing)\nhilbert_series_expanded(A::MPolyQuoRing, d::Int)\nhilbert_function(A::MPolyQuoRing, d::Int)\nhilbert_polynomial(A::MPolyQuoRing)\ndegree(A::MPolyQuoRing)","category":"page"},{"location":"CommutativeAlgebra/affine_algebras/#hilbert_series-Tuple{MPolyQuoRing}","page":"Affine Algebras and Their Ideals","title":"hilbert_series","text":"hilbert_series(A::MPolyQuoRing; backend::Symbol=:Singular, algorithm::Symbol=:BayerStillmanA)\n\nGiven a mathbb Z-graded affine algebra A = RI over a field K, where the grading is inherited from a mathbb Z-grading on the polynomial ring R defined by assigning positive integer weights to the variables, return a pair (pq), say, of univariate polynomials p qinmathbb Zt such that pq represents the Hilbert series of A as a rational function with denominator\n\nq = (1-t^w_1)cdots (1-t^w_n)\n\nwhere n is the number of variables of R, and w_1 dots w_n are the assigned weights.\n\nSee also hilbert_series_reduced.\n\nnote: Note\nThe advanced user can select different backends for the computation (:Singular and :Abbott for the moment), as well as different algorithms. The latter might be ignored for certain backends.\n\nExamples\n\njulia> R, (w, x, y, z) = graded_polynomial_ring(QQ, [:w, :x, :y, :z]);\n\njulia> A, _ = quo(R, ideal(R, [w*y-x^2, w*z-x*y, x*z-y^2]));\n\njulia> hilbert_series(A)\n(2*t^3 - 3*t^2 + 1, (-t + 1)^4)\n\njulia> R, (x, y, z) = graded_polynomial_ring(QQ, [:x, :y, :z], [1, 2, 3]);\n\njulia> A, _ = quo(R, ideal(R, [x*y*z]));\n\njulia> hilbert_series(A)\n(-t^6 + 1, (-t^2 + 1)^1*(-t + 1)^1*(-t^3 + 1)^1)\n\n\n\n\n\n","category":"method"},{"location":"CommutativeAlgebra/affine_algebras/#hilbert_series_reduced-Tuple{MPolyQuoRing}","page":"Affine Algebras and Their Ideals","title":"hilbert_series_reduced","text":"hilbert_series_reduced(A::MPolyQuoRing)\n\nGiven a mathbb Z-graded affine algebra A = RI over a field K, where the grading is inherited from a mathbb Z-grading on the polynomial ring R defined by assigning positive integer weights to the variables, return a pair (pq), say, of univariate polynomials p qinmathbb Zt such that pq represents the Hilbert series of A as a rational function written in lowest terms.\n\nSee also hilbert_series.\n\nExamples\n\njulia> R, (w, x, y, z) = graded_polynomial_ring(QQ, [:w, :x, :y, :z]);\n\njulia> A, _ = quo(R, ideal(R, [w*y-x^2, w*z-x*y, x*z-y^2]));\n\njulia> hilbert_series_reduced(A)\n(2*t + 1, t^2 - 2*t + 1)\n\njulia> R, (x, y, z) = graded_polynomial_ring(QQ, [:x, :y, :z], [1, 2, 3]);\n\njulia> A, _ = quo(R, ideal(R, [x*y*z]));\n\njulia> hilbert_series(A)\n(-t^6 + 1, (-t^2 + 1)^1*(-t + 1)^1*(-t^3 + 1)^1)\n\njulia> hilbert_series_reduced(A)\n(t^2 - t + 1, t^2 - 2*t + 1)\n\n\n\n\n\n","category":"method"},{"location":"CommutativeAlgebra/affine_algebras/#hilbert_series_expanded-Tuple{MPolyQuoRing, Int64}","page":"Affine Algebras and Their Ideals","title":"hilbert_series_expanded","text":"hilbert_series_expanded(A::MPolyQuoRing, d::Int)\n\nGiven a mathbb Z-graded affine algebra A = RI over a field K, where the grading is inherited from a mathbb Z-grading on the polynomial ring R defined by assigning positive integer weights to the variables, return the Hilbert series of A to precision d.\n\nExamples\n\njulia> R, (w, x, y, z) = graded_polynomial_ring(QQ, [:w, :x, :y, :z]);\n\njulia> A, _ = quo(R, ideal(R, [w*y-x^2, w*z-x*y, x*z-y^2]));\n\njulia> hilbert_series_expanded(A, 7)\n1 + 4*t + 7*t^2 + 10*t^3 + 13*t^4 + 16*t^5 + 19*t^6 + 22*t^7 + O(t^8)\n\njulia> R, (x, y, z) = graded_polynomial_ring(QQ, [:x, :y, :z], [1, 2, 3]);\n\njulia> A, _ = quo(R, ideal(R, [x*y*z]));\n\njulia> hilbert_series_expanded(A, 5)\n1 + t + 2*t^2 + 3*t^3 + 4*t^4 + 5*t^5 + O(t^6)\n\n\n\n\n\n","category":"method"},{"location":"CommutativeAlgebra/affine_algebras/#hilbert_function-Tuple{MPolyQuoRing, Int64}","page":"Affine Algebras and Their Ideals","title":"hilbert_function","text":"hilbert_function(A::MPolyQuoRing, d::Int)\n\nGiven a mathbb Z-graded affine algebra A = RI over a field K, where the grading is inherited from a mathbb Z-grading on the polynomial ring R defined by assigning positive integer weights to the variables, return the value H(A d) where\n\nH(A underlinephantomd) mathbbN to mathbbN  d  mapsto dim_K A_d\n\nis the Hilbert function of A.\n\nExamples\n\njulia> R, (w, x, y, z) = graded_polynomial_ring(QQ, [:w, :x, :y, :z]);\n\njulia> A, _ = quo(R, ideal(R, [w*y-x^2, w*z-x*y, x*z-y^2]));\n\njulia> hilbert_function(A,7)\n22\n\njulia> R, (x, y, z) = graded_polynomial_ring(QQ, [:x, :y, :z], [1, 2, 3]);\n\njulia> A, _ = quo(R, ideal(R, [x*y*z]));\n\njulia> hilbert_function(A, 5)\n5\n\n\n\n\n\n","category":"method"},{"location":"CommutativeAlgebra/affine_algebras/#hilbert_polynomial-Tuple{MPolyQuoRing}","page":"Affine Algebras and Their Ideals","title":"hilbert_polynomial","text":"hilbert_polynomial(A::MPolyQuoRing)\n\nGiven a mathbb Z-graded affine algebra A = RI over a field K, where the grading is inherited from the standard mathbb Z-grading on the polynomial ring R, return the Hilbert polynomial of A.\n\nExamples\n\njulia> R, (w, x, y, z) = graded_polynomial_ring(QQ, [:w, :x, :y, :z]);\n\njulia> A, _ = quo(R, ideal(R, [w*y-x^2, w*z-x*y, x*z-y^2]));\n\njulia> hilbert_polynomial(A)\n3*t + 1\n\n\n\n\n\n","category":"method"},{"location":"CommutativeAlgebra/affine_algebras/#degree-Tuple{MPolyQuoRing}","page":"Affine Algebras and Their Ideals","title":"degree","text":"degree(A::MPolyQuoRing)\n\nGiven a mathbb Z-graded affine algebra A = RI over a field K, where the grading is inherited from the standard mathbb Z-grading on the polynomial ring R, return the degree of A.\n\nExamples\n\njulia> R, (w, x, y, z) = graded_polynomial_ring(QQ, [:w, :x, :y, :z]);\n\njulia> A, _ = quo(R, ideal(R, [w*y-x^2, w*z-x*y, x*z-y^2]));\n\njulia> degree(A)\n3\n\n\n\n\n\n","category":"method"},{"location":"CommutativeAlgebra/affine_algebras/#Positive-Gradings-in-General","page":"Affine Algebras and Their Ideals","title":"Positive Gradings in General","text":"","category":"section"},{"location":"CommutativeAlgebra/affine_algebras/","page":"Affine Algebras and Their Ideals","title":"Affine Algebras and Their Ideals","text":"multi_hilbert_series(A::MPolyQuoRing; algorithm::Symbol=:BayerStillmanA)\nmulti_hilbert_series_reduced(A::MPolyQuoRing; algorithm::Symbol=:BayerStillmanA)\nmulti_hilbert_function(A::MPolyQuoRing, g::FinGenAbGroupElem)","category":"page"},{"location":"CommutativeAlgebra/affine_algebras/#multi_hilbert_series-Tuple{MPolyQuoRing}","page":"Affine Algebras and Their Ideals","title":"multi_hilbert_series","text":"multi_hilbert_series(A::MPolyQuoRing; algorithm::Symbol=:BayerStillmanA, parent::Union{Nothing,Ring}=nothing)\n\nReturn the Hilbert series of the graded affine algebra A.\n\nnote: Note\nThe advanced user can select an algorithm for the computation; see the code for details.\n\nExamples\n\njulia> W = [1 1 1; 0 0 -1];\n\njulia> R, x = graded_polynomial_ring(QQ, :x => 1:3, W)\n(Graded multivariate polynomial ring in 3 variables over QQ, MPolyDecRingElem{QQFieldElem, QQMPolyRingElem}[x[1], x[2], x[3]])\n\njulia> I = ideal(R, [x[1]^3*x[2], x[2]*x[3]^2, x[2]^2*x[3], x[3]^4]);\n\njulia> A, _ = quo(R, I);\n\njulia> H = multi_hilbert_series(A);\n\njulia> H[1][1]\n-t[1]^7*t[2]^-2 + t[1]^6*t[2]^-1 + t[1]^6*t[2]^-2 + t[1]^5*t[2]^-4 - t[1]^4 + t[1]^4*t[2]^-2 - t[1]^4*t[2]^-4 - t[1]^3*t[2]^-1 - t[1]^3*t[2]^-2 + 1\n\njulia> H[1][2]\n(-t[1] + 1)^2*(-t[1]*t[2]^-1 + 1)^1\n\njulia> H[2][1]\nZ^2\n\njulia> H[2][2]\nIdentity map\n  of Z^2\n\njulia> G = abelian_group(ZZMatrix([1 -1]));\n\njulia> g = gen(G, 1)\nAbelian group element [0, 1]\n\njulia> W = [g, g, g, g];\n\njulia> R, (w, x, y, z) = graded_polynomial_ring(QQ, [:w, :x, :y, :z], W);\n\njulia> A, _ = quo(R, ideal(R, [w*y-x^2, w*z-x*y, x*z-y^2]));\n\njulia> (num, den), (H, iso) = multi_hilbert_series(A);\n\njulia> num\n2*t^3 - 3*t^2 + 1\n\njulia> den\n(-t + 1)^4\n\njulia> H\nZ\n\njulia> iso\nMap\n  from Z\n  to finitely generated abelian group with 2 generators and 1 relation\n\n\n\n\n\n","category":"method"},{"location":"CommutativeAlgebra/affine_algebras/#multi_hilbert_series_reduced-Tuple{MPolyQuoRing}","page":"Affine Algebras and Their Ideals","title":"multi_hilbert_series_reduced","text":"multi_hilbert_series_reduced(A::MPolyQuoRing; algorithm::Symbol=:BayerStillmanA)\n\nReturn the reduced Hilbert series of the positively graded affine algebra A.\n\nnote: Note\nThe advanced user can select a algorithm for the computation; see the code for details.\n\nExamples\n\njulia> W = [1 1 1; 0 0 -1];\n\njulia> R, x = graded_polynomial_ring(QQ, :x => 1:3, W)\n(Graded multivariate polynomial ring in 3 variables over QQ, MPolyDecRingElem{QQFieldElem, QQMPolyRingElem}[x[1], x[2], x[3]])\n\njulia> I = ideal(R, [x[1]^3*x[2], x[2]*x[3]^2, x[2]^2*x[3], x[3]^4]);\n\njulia> A, _ = quo(R, I);\n\njulia> H = multi_hilbert_series_reduced(A);\n\n\njulia> H[1][1]\n-t[1]^5*t[2]^-1 + t[1]^3 + t[1]^3*t[2]^-3 + t[1]^2 + t[1]^2*t[2]^-1 + t[1]^2*t[2]^-2 + t[1] + t[1]*t[2]^-1 + 1\n\njulia> H[1][2]\n-t[1] + 1\n\njulia> H[2][1]\nZ^2\n\njulia> H[2][2]\nIdentity map\n  of Z^2\n\njulia> G = abelian_group(ZZMatrix([1 -1]));\n\njulia> g = gen(G, 1)\nAbelian group element [0, 1]\n\njulia> W = [g, g, g, g];\n\njulia> R, (w, x, y, z) = graded_polynomial_ring(QQ, [:w, :x, :y, :z], W);\n\njulia> A, _ = quo(R, ideal(R, [w*y-x^2, w*z-x*y, x*z-y^2]));\n\njulia> H = multi_hilbert_series_reduced(A);\n\njulia> H[1][1]\n2*t + 1\n\njulia> H[1][2]\nt^2 - 2*t + 1\n\njulia> H[2][1]\nZ\n\njulia> H[2][2]\nMap\n  from Z\n  to finitely generated abelian group with 2 generators and 1 relation\n\n\n\n\n\n","category":"method"},{"location":"CommutativeAlgebra/affine_algebras/#multi_hilbert_function-Tuple{MPolyQuoRing, FinGenAbGroupElem}","page":"Affine Algebras and Their Ideals","title":"multi_hilbert_function","text":"multi_hilbert_function(A::MPolyQuoRing, g::FinGenAbGroupElem)\n\nGiven a positively graded affine algebra A over a field K with grading group G, say, and given an element g of G, return the value H(A g) of the Hilbert function\n\nH(A underlinephantomd) G to mathbbN  gmapsto dim_K(A_g)\n\nmulti_hilbert_function(A::MPolyQuoRing, g::Vector{<:IntegerUnion})\n\nGiven a positively mathbb  Z^m-graded affine algebra A over a field K, and given a vector g of m integers, convert g into an element of the grading group of A, and return the value H(A g) as above.\n\nmulti_hilbert_function(A::MPolyQuoRing, g::IntegerUnion)\n\nGiven a positively mathbb  Z-graded affine algebra A over a field K, and given an integer g, convert g into an element of the grading group of A, and return the value H(A g) as above.\n\nExamples\n\njulia> W = [1 1 1; 0 0 -1];\n\njulia> R, x = graded_polynomial_ring(QQ, :x => 1:3, W)\n(Graded multivariate polynomial ring in 3 variables over QQ, MPolyDecRingElem{QQFieldElem, QQMPolyRingElem}[x[1], x[2], x[3]])\n\njulia> I = ideal(R, [x[1]^3*x[2], x[2]*x[3]^2, x[2]^2*x[3], x[3]^4]);\n\njulia> A, _ = quo(R, I);\n\njulia> multi_hilbert_function(A::MPolyQuoRing, [1, 0])\n2\n\njulia> R, (w, x, y, z) = graded_polynomial_ring(QQ, [:w, :x, :y, :z], [-1, -1, -1, -1]);\n\njulia> A, _ = quo(R, ideal(R, [w*y-x^2, w*z-x*y, x*z-y^2]));\n\njulia> multi_hilbert_function(A, -7)\n22\n\njulia> G = abelian_group(ZZMatrix([1 -1]));\n\njulia> g = gen(G, 1);\n\njulia> W = [g, g, g, g];\n\njulia> R, (w, x, y, z) = graded_polynomial_ring(QQ, [:w, :x, :y, :z], W);\n\njulia> A, _ = quo(R, ideal(R, [w*y-x^2, w*z-x*y, x*z-y^2]));\n\njulia> multi_hilbert_function(A, 7*g)\n22\n\n\n\n\n\n","category":"method"},{"location":"AlgebraicGeometry/Surfaces/ParametrizationSurfaces/","page":"Rational Parametrization of Rational Surfaces","title":"Rational Parametrization of Rational Surfaces","text":"CurrentModule = Oscar","category":"page"},{"location":"AlgebraicGeometry/Surfaces/ParametrizationSurfaces/#Rational-Parametrization-of-Rational-Surfaces","page":"Rational Parametrization of Rational Surfaces","title":"Rational Parametrization of Rational Surfaces","text":"","category":"section"},{"location":"AlgebraicGeometry/Surfaces/ParametrizationSurfaces/","page":"Rational Parametrization of Rational Surfaces","title":"Rational Parametrization of Rational Surfaces","text":"What we present here relies on the function adjunction_process discussed in the previous section.","category":"page"},{"location":"AlgebraicGeometry/Surfaces/ParametrizationSurfaces/#Parametrization","page":"Rational Parametrization of Rational Surfaces","title":"Parametrization","text":"","category":"section"},{"location":"AlgebraicGeometry/Surfaces/ParametrizationSurfaces/","page":"Rational Parametrization of Rational Surfaces","title":"Rational Parametrization of Rational Surfaces","text":"parametrization(X::AbsProjectiveVariety)","category":"page"},{"location":"AlgebraicGeometry/Surfaces/ParametrizationSurfaces/#parametrization-Tuple{AbsProjectiveVariety}","page":"Rational Parametrization of Rational Surfaces","title":"parametrization","text":"parametrization(X::AbsProjectiveVariety)\n\nGiven a smooth rational surface X which is linearly normal in the given embedding, return a rational parametrization of X.\n\nnote: Note\nThe function does not check whether X is smooth. If you are uncertain, enter is_smooth(X) first.\n\nnote: Note\nThe function does not check rationality. In fact, at current state, OSCAR does not offer a direct check for this.\n\nnote: Note\nThe function makes use of the adjunction process. It returns an error message if the terminal object of the adjunction process is not the projective plane. See the OSCAR documentation for information on the adjunction process.\n\nExamples\n\njulia> X = bordiga()\nProjective variety\n  in projective 4-space over GF(31991) with coordinates [x, y, z, u, v]\ndefined by ideal with 4 generators\n\njulia> dim(X)\n2\n\njulia> codim(X)\n2\n\njulia> phi = parametrization(X);\n\njulia> domain(phi)\nMultivariate polynomial ring in 5 variables over GF(31991) graded by\n  x -> [1]\n  y -> [1]\n  z -> [1]\n  u -> [1]\n  v -> [1]\n\njulia> codomain(phi)\nMultivariate polynomial ring in 3 variables over GF(31991) graded by\n  z[1] -> [1]\n  z[2] -> [1]\n  z[3] -> [1]\n\njulia> [degree(phi(x)) for x in gens(ambient_coordinate_ring(X))]\n5-element Vector{FinGenAbGroupElem}:\n [4]\n [4]\n [4]\n [4]\n [4]\n\n\n\n\n\n","category":"method"},{"location":"AlgebraicGeometry/Surfaces/ParametrizationSurfaces/#Contact","page":"Rational Parametrization of Rational Surfaces","title":"Contact","text":"","category":"section"},{"location":"AlgebraicGeometry/Surfaces/ParametrizationSurfaces/","page":"Rational Parametrization of Rational Surfaces","title":"Rational Parametrization of Rational Surfaces","text":"Please direct questions about this part of OSCAR to the following people:","category":"page"},{"location":"AlgebraicGeometry/Surfaces/ParametrizationSurfaces/","page":"Rational Parametrization of Rational Surfaces","title":"Rational Parametrization of Rational Surfaces","text":"Wolfram Decker.","category":"page"},{"location":"AlgebraicGeometry/Surfaces/ParametrizationSurfaces/","page":"Rational Parametrization of Rational Surfaces","title":"Rational Parametrization of Rational Surfaces","text":"You can ask questions in the OSCAR Slack.","category":"page"},{"location":"AlgebraicGeometry/Surfaces/ParametrizationSurfaces/","page":"Rational Parametrization of Rational Surfaces","title":"Rational Parametrization of Rational Surfaces","text":"Alternatively, you can raise an issue on github.","category":"page"},{"location":"Hecke/manual/number_fields/intro/","page":"Introduction","title":"Introduction","text":"CurrentModule = Hecke","category":"page"},{"location":"Hecke/manual/number_fields/intro/#NumberFieldsLink","page":"Introduction","title":"Introduction","text":"","category":"section"},{"location":"Hecke/manual/number_fields/intro/","page":"Introduction","title":"Introduction","text":"By definition, mathematically a number field is just a finite extension of the rational mathbfQ. In Hecke, a number field L is recursively defined as being the field of rational numbers mathbfQ or a finite extension of a number field K. In the second case, the extension can be defined in the one of the following two ways:","category":"page"},{"location":"Hecke/manual/number_fields/intro/","page":"Introduction","title":"Introduction","text":"We have L = Kx(f), where f in Kx is an irreducible polynomial (simple extension), or\nWe have L = Kx_1dotscx_n(f_1(x_1)dotscf_n(x_n)), where f_1dotscf_n in Kx are univariate polynomials (non-simple extension).","category":"page"},{"location":"Hecke/manual/number_fields/intro/","page":"Introduction","title":"Introduction","text":"In both cases we refer to K as the base field of the number field L. Another useful dichotomy comes from the type of the base field. We call L an absolute number field, if the base field is equal to the rational numbers mathbfQ.","category":"page"},{"location":"AbstractAlgebra/matrix_algebras/","page":"Generic matrix algebras","title":"Generic matrix algebras","text":"CurrentModule = AbstractAlgebra\nDocTestSetup = AbstractAlgebra.doctestsetup()","category":"page"},{"location":"AbstractAlgebra/matrix_algebras/#Generic-matrix-algebras","page":"Generic matrix algebras","title":"Generic matrix algebras","text":"","category":"section"},{"location":"AbstractAlgebra/matrix_algebras/","page":"Generic matrix algebras","title":"Generic matrix algebras","text":"AbstractAlgebra.jl allows the creation of an algebra (ring) of mtimes m matrices over a computable, commutative ring.","category":"page"},{"location":"AbstractAlgebra/matrix_algebras/","page":"Generic matrix algebras","title":"Generic matrix algebras","text":"Functions specific to generic matrix algebras of mtimes m matrices are implemented in src/generic/MatRing.jl. The remaining functionality is in the file src/generic/Matrix.jl.","category":"page"},{"location":"AbstractAlgebra/matrix_algebras/","page":"Generic matrix algebras","title":"Generic matrix algebras","text":"As well as implementing the entire Matrix interface, including the optional functionality, there are many additional generic algorithms implemented for matrix algebras.","category":"page"},{"location":"AbstractAlgebra/matrix_algebras/","page":"Generic matrix algebras","title":"Generic matrix algebras","text":"Almost all of the functionality specified for generic matrices is available for matrix algebras. The exceptions are functions such as solve and nullspace which may return non-square matrices, or which don't accept square matrices.","category":"page"},{"location":"AbstractAlgebra/matrix_algebras/","page":"Generic matrix algebras","title":"Generic matrix algebras","text":"All of the generic functionality is part of the Generic submodule of AbstractAlgebra.jl. This is exported by default, so it is not necessary to qualify names of functions.","category":"page"},{"location":"AbstractAlgebra/matrix_algebras/#Types-and-parent-objects","page":"Generic matrix algebras","title":"Types and parent objects","text":"","category":"section"},{"location":"AbstractAlgebra/matrix_algebras/","page":"Generic matrix algebras","title":"Generic matrix algebras","text":"Generic matrices in AbstractAlgebra.jl have type Generic.MatRingElem{T} for matrices in a matrix algebra, where T is the type of elements of the matrix. Internally, generic matrices are implemented using an object wrapping a Julia two dimensional array, though they are not themselves Julia arrays. See the file src/generic/GenericTypes.jl for details.","category":"page"},{"location":"AbstractAlgebra/matrix_algebras/","page":"Generic matrix algebras","title":"Generic matrix algebras","text":"Parents of generic matrices in a matrix algebra have type Generic.MatRing{T}.","category":"page"},{"location":"AbstractAlgebra/matrix_algebras/","page":"Generic matrix algebras","title":"Generic matrix algebras","text":"Note that matrix algebras are noncommutative rings. Thus their types belong to NCRing and NCRingElem. They cannot be used in constructions which require a commutative ring (Ring and RingElem respectively).","category":"page"},{"location":"AbstractAlgebra/matrix_algebras/","page":"Generic matrix algebras","title":"Generic matrix algebras","text":"The generic matrix algebra matrix types belong to the abstract type MatRingElem{T} and the parent types belong to  MatRing{T} Note that both of these require disambiguation from the concrete types in Generic of the same name.","category":"page"},{"location":"AbstractAlgebra/matrix_algebras/","page":"Generic matrix algebras","title":"Generic matrix algebras","text":"The degree and base ring R of a generic matrix are stored in its parent object, however to allow creation of matrices without first creating the matrix space parent, generic matrices in Julia do not contain a reference to their parent. They contain the row and column numbers (or degree, in the case of matrix algebras) and the base ring on a per matrix basis. The parent object can then be reconstructed from this data on demand.","category":"page"},{"location":"AbstractAlgebra/matrix_algebras/#Matrix-algebra-constructors","page":"Generic matrix algebras","title":"Matrix algebra constructors","text":"","category":"section"},{"location":"AbstractAlgebra/matrix_algebras/","page":"Generic matrix algebras","title":"Generic matrix algebras","text":"A matrix algebra in AbstractAlgebra.jl represents a collection of all matrices with given degree and base ring.","category":"page"},{"location":"AbstractAlgebra/matrix_algebras/","page":"Generic matrix algebras","title":"Generic matrix algebras","text":"In order to construct matrices in AbstractAlgebra.jl, one must construct the matrix algebra itself. This is accomplished with the following constructor.","category":"page"},{"location":"AbstractAlgebra/matrix_algebras/","page":"Generic matrix algebras","title":"Generic matrix algebras","text":"matrix_ring(R::Ring, degree::Int)","category":"page"},{"location":"AbstractAlgebra/matrix_algebras/","page":"Generic matrix algebras","title":"Generic matrix algebras","text":"Construct the algebra of matrices with the given degree over the given base ring.","category":"page"},{"location":"AbstractAlgebra/matrix_algebras/","page":"Generic matrix algebras","title":"Generic matrix algebras","text":"Here are some examples of creating matrix algebras and making use of the resulting parent objects to coerce various elements into the matrix algebra.","category":"page"},{"location":"AbstractAlgebra/matrix_algebras/","page":"Generic matrix algebras","title":"Generic matrix algebras","text":"Examples","category":"page"},{"location":"AbstractAlgebra/matrix_algebras/","page":"Generic matrix algebras","title":"Generic matrix algebras","text":"julia> R, t = polynomial_ring(QQ, :t)\n(Univariate polynomial ring in t over rationals, t)\n\njulia> S = matrix_ring(R, 3)\nMatrix ring of degree 3\n  over univariate polynomial ring in t over rationals\n\njulia> A = S()\n[0   0   0]\n[0   0   0]\n[0   0   0]\n\njulia> B = S(12)\n[12    0    0]\n[ 0   12    0]\n[ 0    0   12]\n\njulia> C = S(R(11))\n[11    0    0]\n[ 0   11    0]\n[ 0    0   11]\n","category":"page"},{"location":"AbstractAlgebra/matrix_algebras/#Matrix-algebra-element-constructors","page":"Generic matrix algebras","title":"Matrix algebra element constructors","text":"","category":"section"},{"location":"AbstractAlgebra/matrix_algebras/","page":"Generic matrix algebras","title":"Generic matrix algebras","text":"The following additional constructors are provided for constructing various kinds of matrices in a matrix algebra.","category":"page"},{"location":"AbstractAlgebra/matrix_algebras/","page":"Generic matrix algebras","title":"Generic matrix algebras","text":"identity_matrix(::Generic.MatRingElem{T}) where T <: RingElement","category":"page"},{"location":"AbstractAlgebra/matrix_algebras/#identity_matrix-Union{Tuple{AbstractAlgebra.Generic.MatRingElem{T}}, Tuple{T}} where T<:RingElement","page":"Generic matrix algebras","title":"identity_matrix","text":"identity_matrix(M::MatElem{T}) where T <: NCRingElement\n\nConstruct the identity matrix in the same matrix space as M, i.e. with ones down the diagonal and zeroes elsewhere. M must be square. This is an alias for one(M).\n\n\n\n\n\nidentity_matrix(M::MatRingElem{T}) where T <: RingElement\n\nReturn the identity matrix over the same base ring as M and with the same dimensions.\n\n\n\n\n\n","category":"method"},{"location":"AbstractAlgebra/matrix_algebras/","page":"Generic matrix algebras","title":"Generic matrix algebras","text":"Examples","category":"page"},{"location":"AbstractAlgebra/matrix_algebras/","page":"Generic matrix algebras","title":"Generic matrix algebras","text":"S = matrix_ring(ZZ, 2)\nM = zero(S)\n\nP = identity_matrix(M)","category":"page"},{"location":"AbstractAlgebra/matrix_algebras/#Matrix-algebra-functionality-provided-by-AbstractAlgebra.jl","page":"Generic matrix algebras","title":"Matrix algebra functionality provided by AbstractAlgebra.jl","text":"","category":"section"},{"location":"AbstractAlgebra/matrix_algebras/","page":"Generic matrix algebras","title":"Generic matrix algebras","text":"Most of the generic matrix functionality described in the generic matrix section of the documentation is available for both matrix spaces and matrix algebras. Exceptions include functions that do not return or accept square matrices or which cannot specify a parent. Such functions include solve and nullspace which can't be provided for matrix algebras.","category":"page"},{"location":"AbstractAlgebra/matrix_algebras/","page":"Generic matrix algebras","title":"Generic matrix algebras","text":"In addition to the functionality described for matrix spaces, matrix algebras support all noncommutative ring operations, and matrix algebras can be used as a base ring for other generic constructs that accept a noncommutative base ring (NCRing).","category":"page"},{"location":"AbstractAlgebra/matrix_algebras/","page":"Generic matrix algebras","title":"Generic matrix algebras","text":"In this section we describe functionality provided for matrix algebras only.","category":"page"},{"location":"AbstractAlgebra/matrix_algebras/#Basic-matrix-functionality","page":"Generic matrix algebras","title":"Basic matrix functionality","text":"","category":"section"},{"location":"AbstractAlgebra/matrix_algebras/","page":"Generic matrix algebras","title":"Generic matrix algebras","text":"As well as the Ring and Matrix interfaces, the following functions are provided to manipulate matrices.","category":"page"},{"location":"AbstractAlgebra/matrix_algebras/","page":"Generic matrix algebras","title":"Generic matrix algebras","text":"degree(::Generic.MatRingElem)","category":"page"},{"location":"AbstractAlgebra/matrix_algebras/#degree-Tuple{AbstractAlgebra.Generic.MatRingElem}","page":"Generic matrix algebras","title":"degree","text":"degree(a::MatRingElem{T}) where T <: RingElement\n\nReturn the degree n of the given matrix algebra.\n\n\n\n\n\n","category":"method"},{"location":"AbstractAlgebra/matrix_algebras/","page":"Generic matrix algebras","title":"Generic matrix algebras","text":"Examples","category":"page"},{"location":"AbstractAlgebra/matrix_algebras/","page":"Generic matrix algebras","title":"Generic matrix algebras","text":"julia> R, t = polynomial_ring(QQ, :t)\n(Univariate polynomial ring in t over rationals, t)\n\njulia> S = matrix_ring(R, 3)\nMatrix ring of degree 3\n  over univariate polynomial ring in t over rationals\n\njulia> A = S([t + 1 t R(1); t^2 t t; R(-2) t + 2 t^2 + t + 1])\n[t + 1       t             1]\n[  t^2       t             t]\n[   -2   t + 2   t^2 + t + 1]\n\njulia> n = degree(A)\n3\n","category":"page"},{"location":"Hecke/manual/abelian/maps/","page":"Morphisms","title":"Morphisms","text":"CurrentModule = Hecke\nDocTestSetup = quote\n    using Hecke\nend","category":"page"},{"location":"Hecke/manual/abelian/maps/#Maps","page":"Morphisms","title":"Maps","text":"","category":"section"},{"location":"Hecke/manual/abelian/maps/","page":"Morphisms","title":"Morphisms","text":"Maps between abelian groups are mainly of type FinGenAbGroupHom. They allow normal map operations such as image, preimage, domain, codomain and can be created in a variety of situations.","category":"page"},{"location":"Hecke/manual/abelian/maps/","page":"Morphisms","title":"Morphisms","text":"Maps between abelian groups can be constructed via","category":"page"},{"location":"Hecke/manual/abelian/maps/","page":"Morphisms","title":"Morphisms","text":"images of the generators\npairs of elements\nvia composition\nand isomorphism/ inclusion testing","category":"page"},{"location":"Hecke/manual/abelian/maps/","page":"Morphisms","title":"Morphisms","text":"hom_direct_sum(G::FinGenAbGroup, H::FinGenAbGroup, A::Matrix{ <: Map{FinGenAbGroup, FinGenAbGroup}})\nis_isomorphic(G::FinGenAbGroup, H::FinGenAbGroup)","category":"page"},{"location":"Hecke/manual/abelian/maps/#hom_direct_sum-Tuple{FinGenAbGroup, FinGenAbGroup, Matrix{<:Map{FinGenAbGroup, FinGenAbGroup}}}","page":"Morphisms","title":"hom_direct_sum","text":"hom_direct_sum(G::FinGenAbGroup, H::FinGenAbGroup, A::Matrix{ <: Map{FinGenAbGroup, FinGenAbGroup}}) -> Map\n\nGiven groups G and H that are created as direct products as well as a matrix A containing maps Aij  G_i to H_j, return the induced homomorphism.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/abelian/maps/#is_isomorphic-Tuple{FinGenAbGroup, FinGenAbGroup}","page":"Morphisms","title":"is_isomorphic","text":"is_isomorphic(G::FinGenAbGroup, H::FinGenAbGroup) -> Bool\n\nReturn whether G and H are isomorphic.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/abelian/maps/","page":"Morphisms","title":"Morphisms","text":"using Hecke # hide\nG = free_abelian_group(2)\nh = hom(G, G, [gen(G, 2), 3*gen(G, 1)])\nh(gen(G, 1))\nh(gen(G, 2))","category":"page"},{"location":"Hecke/manual/abelian/maps/","page":"Morphisms","title":"Morphisms","text":"Homomorphisms also allow addition and subtraction corresponding to the pointwise operation:","category":"page"},{"location":"Hecke/manual/abelian/maps/","page":"Morphisms","title":"Morphisms","text":"using Hecke # hide\nG = free_abelian_group(2)\nh = hom(G, G, [2*gen(G, 2), 3*gen(G, 1)])\n(h+h)(gen(G, 1))","category":"page"},{"location":"Nemo/qadic/","page":"Qadics","title":"Qadics","text":"CurrentModule = Nemo\nDocTestSetup = quote\n    using Nemo\nend","category":"page"},{"location":"Nemo/qadic/#Qadics","page":"Qadics","title":"Qadics","text":"","category":"section"},{"location":"Nemo/qadic/","page":"Qadics","title":"Qadics","text":"Q-adic fields, that is, unramified extensions of p-adic fields, are provided in Nemo by Flint. This allows construction of q-adic fields for any prime power q.","category":"page"},{"location":"Nemo/qadic/","page":"Qadics","title":"Qadics","text":"Q-adic fields are constructed using the qadic_field function.","category":"page"},{"location":"Nemo/qadic/","page":"Qadics","title":"Qadics","text":"The types of q-adic fields in Nemo are given in the following table, along with the libraries that provide them and the associated types of the parent objects.","category":"page"},{"location":"Nemo/qadic/","page":"Qadics","title":"Qadics","text":"Library Field Element type Parent type\nFlint mathbbQ_q QadicFieldElem QadicField","category":"page"},{"location":"Nemo/qadic/","page":"Qadics","title":"Qadics","text":"All the q-adic field types belong to the Field abstract type and the q-adic field element types belong to the FieldElem abstract type.","category":"page"},{"location":"Nemo/qadic/#P-adic-functionality","page":"Qadics","title":"P-adic functionality","text":"","category":"section"},{"location":"Nemo/qadic/","page":"Qadics","title":"Qadics","text":"Q-adic fields in Nemo provide all the functionality described in AbstractAlgebra for fields:.","category":"page"},{"location":"Nemo/qadic/","page":"Qadics","title":"Qadics","text":"https://nemocas.github.io/AbstractAlgebra.jl/stable/field","category":"page"},{"location":"Nemo/qadic/","page":"Qadics","title":"Qadics","text":"Below, we document all the additional function that is provide by Nemo for q-adic fields.","category":"page"},{"location":"Nemo/qadic/#Constructors","page":"Qadics","title":"Constructors","text":"","category":"section"},{"location":"Nemo/qadic/","page":"Qadics","title":"Qadics","text":"In order to construct q-adic field elements in Nemo, one must first construct the q-adic field itself. This is accomplished with one of the following constructors.","category":"page"},{"location":"Nemo/qadic/","page":"Qadics","title":"Qadics","text":"qadic_field\nunramified_extension","category":"page"},{"location":"Nemo/qadic/#qadic_field","page":"Qadics","title":"qadic_field","text":"qadic_field(p::Integer, d::Int, var::String = \"a\"; precision::Int=64, cached::Bool=true, check::Bool=true)\nqadic_field(p::ZZRingElem, d::Int, var::String = \"a\"; precision::Int=64, cached::Bool=true, check::Bool=true)\n\nReturn an unramified extension K of degree d of a p-adic field for the given prime p. The generator of K is printed as var.\n\nThe default absolute precision of elements of K may be set with precision.\n\nSee also unramified_extension.\n\n\n\n\n\n","category":"function"},{"location":"Nemo/qadic/#unramified_extension","page":"Qadics","title":"unramified_extension","text":"unramified_extension(Qp::PadicField, d::Int, var::String = \"a\"; precision::Int=64, cached::Bool=true)\n\nReturn an unramified extension K of degree d of the given p-adic field Qp. The generator of K is printed as var.\n\nThe default absolute precision of elements of K may be set with precision.\n\n\n\n\n\n","category":"function"},{"location":"Nemo/qadic/","page":"Qadics","title":"Qadics","text":"Here are some examples of creating q-adic fields and making use of the resulting parent objects to coerce various elements into those fields.","category":"page"},{"location":"Nemo/qadic/","page":"Qadics","title":"Qadics","text":"Examples","category":"page"},{"location":"Nemo/qadic/","page":"Qadics","title":"Qadics","text":"julia> R, p = qadic_field(7, 1, precision = 30);\n\njulia> S, _ = qadic_field(ZZ(65537), 1, precision = 30);\n\njulia> a = R()\n0\n\njulia> b = S(1)\n65537^0 + O(65537^30)\n\njulia> c = S(ZZ(123))\n123*65537^0 + O(65537^30)\n\njulia> d = R(ZZ(1)//7^2)\n7^-2 + O(7^28)","category":"page"},{"location":"Nemo/qadic/#Big-oh-notation","page":"Qadics","title":"Big-oh notation","text":"","category":"section"},{"location":"Nemo/qadic/","page":"Qadics","title":"Qadics","text":"Elements of p-adic fields can  be constructed using the big-oh notation. For this purpose we define the following functions.","category":"page"},{"location":"Nemo/qadic/","page":"Qadics","title":"Qadics","text":"O(::QadicField, ::Integer)\nO(::QadicField, ::ZZRingElem)\nO(::QadicField, ::QQFieldElem)","category":"page"},{"location":"Nemo/qadic/#O-Tuple{QadicField, Integer}","page":"Qadics","title":"O","text":"O(R::QadicField, m::Integer)\n\nConstruct the value 0 + O(p^n) given m = p^n. An exception results if m is not found to be a power of p = prime(R).\n\n\n\n\n\n","category":"method"},{"location":"Nemo/qadic/#O-Tuple{QadicField, ZZRingElem}","page":"Qadics","title":"O","text":"O(R::QadicField, m::ZZRingElem)\n\nConstruct the value 0 + O(p^n) given m = p^n. An exception results if m is not found to be a power of p = prime(R).\n\n\n\n\n\n","category":"method"},{"location":"Nemo/qadic/#O-Tuple{QadicField, QQFieldElem}","page":"Qadics","title":"O","text":"O(R::QadicField, m::QQFieldElem)\n\nConstruct the value 0 + O(p^n) given m = p^n. An exception results if m is not found to be a power of p = prime(R).\n\n\n\n\n\n","category":"method"},{"location":"Nemo/qadic/","page":"Qadics","title":"Qadics","text":"The O(p^n) construction can be used to construct q-adic values of precision n by adding it to integer values representing the q-adic value modulo p^n as in the examples.","category":"page"},{"location":"Nemo/qadic/","page":"Qadics","title":"Qadics","text":"Examples","category":"page"},{"location":"Nemo/qadic/","page":"Qadics","title":"Qadics","text":"julia> R, _ = qadic_field(7, 1, precision = 30);\n\njulia> S, _ = qadic_field(ZZ(65537), 1, precision = 30);\n\njulia> c = 1 + 2*7 + 4*7^2 + O(R, 7^3)\n7^0 + 2*7^1 + 4*7^2 + O(7^3)\n\njulia> d = 13 + 357*ZZ(65537) + O(S, ZZ(65537)^12)\n13*65537^0 + 357*65537^1 + O(65537^12)\n\njulia> f = ZZ(1)//7^2 + ZZ(2)//7 + 3 + 4*7 + O(R, 7^2)\n7^-2 + 2*7^-1 + 3*7^0 + 4*7^1 + O(7^2)","category":"page"},{"location":"Nemo/qadic/","page":"Qadics","title":"Qadics","text":"Beware that the expression 1 + 2*p + 3*p^2 + O(R, p^n) is actually computed as a normal Julia expression. Therefore if {Int} values are used instead of Flint integers or Julia bignums, overflow may result in evaluating the value.","category":"page"},{"location":"Nemo/qadic/#Basic-manipulation","page":"Qadics","title":"Basic manipulation","text":"","category":"section"},{"location":"Nemo/qadic/","page":"Qadics","title":"Qadics","text":"prime(::QadicField)","category":"page"},{"location":"Nemo/qadic/#prime-Tuple{QadicField}","page":"Qadics","title":"prime","text":"prime(R::QadicField)\n\nReturn the prime p for the given q-adic field.\n\n\n\n\n\n","category":"method"},{"location":"Nemo/qadic/","page":"Qadics","title":"Qadics","text":"precision(::QadicFieldElem)","category":"page"},{"location":"Nemo/qadic/#precision-Tuple{QadicFieldElem}","page":"Qadics","title":"precision","text":"precision(a::QadicFieldElem)\n\nReturn the precision of the given q-adic field element, i.e. if the element is known to O(p^n) this function will return n.\n\n\n\n\n\n","category":"method"},{"location":"Nemo/qadic/","page":"Qadics","title":"Qadics","text":"valuation(::QadicFieldElem)","category":"page"},{"location":"Nemo/qadic/#valuation-Tuple{QadicFieldElem}","page":"Qadics","title":"valuation","text":"valuation(a::QadicFieldElem)\n\nReturn the valuation of the given q-adic field element, i.e. if the given element is divisible by p^n but not a higher power of q then the function will return n.\n\n\n\n\n\n","category":"method"},{"location":"Nemo/qadic/","page":"Qadics","title":"Qadics","text":"lift(::QQPolyRing, ::QadicFieldElem)\nlift(::ZZPolyRing, ::QadicFieldElem)","category":"page"},{"location":"Nemo/qadic/#lift-Tuple{QQPolyRing, QadicFieldElem}","page":"Qadics","title":"lift","text":"lift(R::QQPolyRing, a::QadicFieldElem)\n\nReturn a lift of the given q-adic field element to mathbbQx.\n\n\n\n\n\n","category":"method"},{"location":"Nemo/qadic/#lift-Tuple{ZZPolyRing, QadicFieldElem}","page":"Qadics","title":"lift","text":"lift(R::ZZPolyRing, a::QadicFieldElem)\n\nReturn a lift of the given q-adic field element to mathbbZx if possible.\n\n\n\n\n\n","category":"method"},{"location":"Nemo/qadic/","page":"Qadics","title":"Qadics","text":"Examples","category":"page"},{"location":"Nemo/qadic/","page":"Qadics","title":"Qadics","text":"R, _ = qadic_field(7, 1, precision = 30);\n\na = 1 + 2*7 + 4*7^2 + O(R, 7^3)\nb = 7^2 + 3*7^3 + O(R, 7^5)\nc = R(2)\n\nk = precision(a)\nm = prime(R)\nn = valuation(b)\nQx, x = QQ[\"x\"]\np = lift(Qx, a)\nZy, y = ZZ[\"y\"]\nq = lift(Zy, divexact(a, b))","category":"page"},{"location":"Nemo/qadic/#Square-root","page":"Qadics","title":"Square root","text":"","category":"section"},{"location":"Nemo/qadic/","page":"Qadics","title":"Qadics","text":"Base.sqrt(::QadicFieldElem)","category":"page"},{"location":"Nemo/qadic/#sqrt-Tuple{QadicFieldElem}","page":"Qadics","title":"sqrt","text":"Base.sqrt(f::PolyRingElem{T}; check::Bool=true) where T <: RingElement\n\nReturn the square root of f. By default the function checks the input is square and raises an exception if not. If check=false this check is omitted.\n\n\n\n\n\nBase.sqrt(a::FracElem{T}; check::Bool=true) where T <: RingElem\n\nReturn the square root of a. By default the function will throw an exception if the input is not square. If check=false this test is omitted.\n\n\n\n\n\nsqrt(a::FieldElem)\n\nReturn the square root of the element a. By default the function will throw an exception if the input is not square. If check=false this test is omitted.\n\n\n\n\n\nsqrt(a::Generic.PuiseuxSeriesElem{T}; check::Bool=true) where T <: RingElement\n\nReturn the square root of the given Puiseux series a. By default the function will throw an exception if the input is not square. If check=false this test is omitted.\n\n\n\n\n\n","category":"method"},{"location":"Nemo/qadic/","page":"Qadics","title":"Qadics","text":"Examples","category":"page"},{"location":"Nemo/qadic/","page":"Qadics","title":"Qadics","text":"julia> R, _ = qadic_field(7, 1, precision = 30);\n\njulia> a = 1 + 7 + 2*7^2 + O(R, 7^3)\n7^0 + 7^1 + 2*7^2 + O(7^3)\n\njulia> b = 2 + 3*7 + O(R, 7^5)\n2*7^0 + 3*7^1 + O(7^5)\n\njulia> c = 7^2 + 2*7^3 + O(R, 7^4)\n7^2 + 2*7^3 + O(7^4)\n\njulia> d = sqrt(a)\n7^0 + 4*7^1 + 3*7^2 + O(7^3)\n\njulia> f = sqrt(b)\n4*7^0 + 7^1 + 5*7^2 + 5*7^3 + 6*7^4 + O(7^5)\n\njulia> f = sqrt(c)\n7^1 + 7^2 + O(7^3)\n\njulia> g = sqrt(R(121))\n4*7^0 + 7^1 + O(7^30)","category":"page"},{"location":"Nemo/qadic/#Special-functions","page":"Qadics","title":"Special functions","text":"","category":"section"},{"location":"Nemo/qadic/","page":"Qadics","title":"Qadics","text":"Base.exp(::QadicFieldElem)","category":"page"},{"location":"Nemo/qadic/#exp-Tuple{QadicFieldElem}","page":"Qadics","title":"exp","text":"exp(a::QadicFieldElem)\n\nReturn the p-adic exponential of a, assuming the p-adic exponential function converges at a.\n\n\n\n\n\n","category":"method"},{"location":"Nemo/qadic/","page":"Qadics","title":"Qadics","text":"log(::QadicFieldElem)","category":"page"},{"location":"Nemo/qadic/#log-Tuple{QadicFieldElem}","page":"Qadics","title":"log","text":"log(a::QadicFieldElem)\n\nReturn the p-adic logarithm of a, assuming the p-adic logarithm converges at a.\n\n\n\n\n\n","category":"method"},{"location":"Nemo/qadic/","page":"Qadics","title":"Qadics","text":"teichmuller(::QadicFieldElem)","category":"page"},{"location":"Nemo/qadic/#teichmuller-Tuple{QadicFieldElem}","page":"Qadics","title":"teichmuller","text":"teichmuller(a::QadicFieldElem)\n\nReturn the Teichmuller lift of the q-adic value a. We require the valuation of a to be non-negative. The precision of the output will be the same as the precision of the input. For convenience, if a is congruent to zero modulo q we return zero. If the input is not valid an exception is thrown.\n\n\n\n\n\n","category":"method"},{"location":"Nemo/qadic/","page":"Qadics","title":"Qadics","text":"frobenius(::QadicFieldElem, ::Int)","category":"page"},{"location":"Nemo/qadic/#frobenius-Tuple{QadicFieldElem, Int64}","page":"Qadics","title":"frobenius","text":"frobenius(a::QadicFieldElem, e::Int = 1)\n\nReturn the image of the e-th power of Frobenius on the q-adic value a. The precision of the output will be the same as the precision of the input.\n\n\n\n\n\n","category":"method"},{"location":"Nemo/qadic/","page":"Qadics","title":"Qadics","text":"Examples","category":"page"},{"location":"Nemo/qadic/","page":"Qadics","title":"Qadics","text":"julia> R, _ = qadic_field(7, 1, precision = 30);\n\njulia> a = 1 + 7 + 2*7^2 + O(R, 7^3)\n7^0 + 7^1 + 2*7^2 + O(7^3)\n\njulia> b = 2 + 5*7 + 3*7^2 + O(R, 7^3)\n2*7^0 + 5*7^1 + 3*7^2 + O(7^3)\n\njulia> c = 3*7 + 2*7^2 + O(R, 7^5)\n3*7^1 + 2*7^2 + O(7^5)\n\njulia> c = exp(c)\n7^0 + 3*7^1 + 3*7^2 + 4*7^3 + 4*7^4 + O(7^5)\n\njulia> d = log(a)\n7^1 + 5*7^2 + O(7^3)\n\njulia> c = exp(R(0))\n7^0 + O(7^30)\n\njulia> d = log(R(1))\n0\n\njulia> f = teichmuller(b)\n2*7^0 + 4*7^1 + 6*7^2 + O(7^3)\n\njulia> g = frobenius(a, 2)\n7^0 + 7^1 + 2*7^2 + O(7^3)","category":"page"},{"location":"TropicalGeometry/groebner_theory/#Groebner-theory","page":"Groebner theory","title":"Groebner theory","text":"","category":"section"},{"location":"TropicalGeometry/groebner_theory/#Introduction","page":"Groebner theory","title":"Introduction","text":"","category":"section"},{"location":"TropicalGeometry/groebner_theory/","page":"Groebner theory","title":"Groebner theory","text":"Tropical algebraic geometry incorporates the valuation of the underlying ground field, and therefore so does its Groebner theory. Tropical Groebner theory is a generalization of its classical counterpart to fields with valuation, and the classical Groebner theory is a specialization of tropical Groebner theory to fields with trivial valuation.  Instead of monomial orderings there are term orderings which take the valuation into account, and initial forms and ideals live over the residue field.  For details, see Chapter 2.4 in [MS15].","category":"page"},{"location":"TropicalGeometry/groebner_theory/#Groebner-bases","page":"Groebner theory","title":"Groebner bases","text":"","category":"section"},{"location":"TropicalGeometry/groebner_theory/","page":"Groebner theory","title":"Groebner theory","text":"Groebner bases in [MS15] are only defined for homogeneous ideals and they are finite sets whose initial forms generate the initial ideal.  Groebner bases in OSCAR are defined for all ideals and they are finite generating sets whose initial forms generate the initial ideal. For homogeneous ideals generating the initial ideal implies generating the original ideal, so both notions coincide. For principal and binomial ideals the algorithm simply returns its input.","category":"page"},{"location":"TropicalGeometry/groebner_theory/","page":"Groebner theory","title":"Groebner theory","text":"groebner_basis(I::MPolyIdeal, nu::TropicalSemiringMap, w::Vector{<:Union{QQFieldElem,ZZRingElem,Rational,Integer}})","category":"page"},{"location":"TropicalGeometry/groebner_theory/#groebner_basis-Tuple{MPolyIdeal, TropicalSemiringMap, Vector{<:Union{Integer, QQFieldElem, ZZRingElem, Rational}}}","page":"Groebner theory","title":"groebner_basis","text":"groebner_basis(I::MPolyIdeal, nu::TropicalSemiringMap, w::AbstractVector{<:Union{QQFieldElem,ZZRingElem,Rational,Integer}})\n\nReturn a (tropical) Groebner basis of I with respect to the tropical semiring map nu and weight vector w.\n\nExamples\n\njulia> R,(x,y) = QQ[:x, :y];\n\njulia> I = ideal([x^3-5*x^2*y,3*y^3-2*x^2*y]);\n\njulia> nu = tropical_semiring_map(QQ,2);\n\njulia> w = [0,0];\n\njulia> groebner_basis(I,nu,w)\n2-element Vector{QQMPolyRingElem}:\n x^3 - 5*x^2*y\n -2*x^2*y + 3*y^3\n\n\n\n\n\n\n","category":"method"},{"location":"TropicalGeometry/groebner_theory/#Initial-forms-and-initial-ideals","page":"Groebner theory","title":"Initial forms and initial ideals","text":"","category":"section"},{"location":"TropicalGeometry/groebner_theory/","page":"Groebner theory","title":"Groebner theory","text":"initial(f::MPolyRingElem, nu::TropicalSemiringMap, w::AbstractVector{<:Union{QQFieldElem,ZZRingElem,Rational,Integer}})\ninitial(I::MPolyIdeal, nu::TropicalSemiringMap, w::AbstractVector{<:Union{QQFieldElem,ZZRingElem,Rational,Integer}}; skip_groebner_basis_computation::Bool=false)","category":"page"},{"location":"TropicalGeometry/groebner_theory/#initial-Tuple{MPolyRingElem, TropicalSemiringMap, AbstractVector{<:Union{Integer, QQFieldElem, ZZRingElem, Rational}}}","page":"Groebner theory","title":"initial","text":"initial(f::MPolyRingElem, nu::TropicalSemiringMap, w::Vector)\n\nReturn the initial form of f with respect to the tropical semiring map nu and weight vector w.\n\nExamples (trivial and p-adic valuation)\n\njulia> R,(x,y) = QQ[:x, :y];\n\njulia> nu_0 = tropical_semiring_map(QQ,max);\n\njulia> nu_2 = tropical_semiring_map(QQ,2);\n\njulia> w = [0,0];\n\njulia> f = x+y+2;\n\njulia> initial(f,nu_2,w) # polynomial over GF(2)\nx + y\n\njulia> initial(f,nu_0,w) # polynomial over QQ\nx + y + 2\n\n\nExamples (t-adic valuation)\n\njulia> K,t = rational_function_field(GF(2),\"t\");\n\njulia> nu_t = tropical_semiring_map(K,t,max);\n\njulia> R,(x,y) = K[:x, :y];\n\njulia> w = [1,1];\n\njulia> f = t*x+t*y+1;\n\njulia> initial(f,nu_t,w) # polynomial over GF(2)\nx + y + 1\n\n\n\n\n\n\n","category":"method"},{"location":"TropicalGeometry/groebner_theory/#initial-Tuple{MPolyIdeal, TropicalSemiringMap, AbstractVector{<:Union{Integer, QQFieldElem, ZZRingElem, Rational}}}","page":"Groebner theory","title":"initial","text":"initial(I::MPolyIdeal, nu::TropicalSemiringMap, w::Vector; skip_groebner_basis_computation::Bool=false)\n\nReturn the initial ideal of I with respect to the tropical semiring map nu and weight vector w.  If skip_groebner_basis_computation=true, skips the necessary Groebner basis computation and returns the ideal generated by the initial forms of gens(I).\n\nExamples\n\njulia> R,(x,y) = QQ[:x, :y];\n\njulia> I = ideal([x^3-5*x^2*y,3*y^3-2*x^2*y]);\n\njulia> nu_2 = tropical_semiring_map(QQ,2);\n\njulia> nu_0 = tropical_semiring_map(QQ);\n\njulia> w = [0,0];\n\njulia> initial(I,nu_2,w)\nIdeal generated by\n  x^3 + x^2*y\n  y^3\n\njulia> initial(I,nu_0,w)\nIdeal generated by\n  x^3 - 5*x^2*y\n  -2*x^2*y + 3*y^3\n\n\n\n\n\n","category":"method"},{"location":"AlgebraicGeometry/Curves/ProjectivePlaneCurves/","page":"Projective Plane Curves","title":"Projective Plane Curves","text":"CurrentModule = Oscar","category":"page"},{"location":"AlgebraicGeometry/Curves/ProjectivePlaneCurves/#Projective-Plane-Curves","page":"Projective Plane Curves","title":"Projective Plane Curves","text":"","category":"section"},{"location":"AlgebraicGeometry/Curves/ProjectivePlaneCurves/","page":"Projective Plane Curves","title":"Projective Plane Curves","text":"ProjectivePlaneCurve","category":"page"},{"location":"AlgebraicGeometry/Curves/ProjectivePlaneCurves/#ProjectivePlaneCurve","page":"Projective Plane Curves","title":"ProjectivePlaneCurve","text":"ProjectivePlaneCurve <: AbsProjectiveCurve\n\nA reduced curve in the projective plane.\n\nExamples\n\njulia> R, (x,y,z) = graded_polynomial_ring(QQ, [:x, :y, :z]);\n\njulia> C = plane_curve(y^3*x^6 - y^6*x^2*z)\nProjective plane curve\n  defined by 0 = x^5*y - x*y^4*z\n\n\n\n\n\n\n","category":"type"},{"location":"AlgebraicGeometry/Curves/ProjectivePlaneCurves/","page":"Projective Plane Curves","title":"Projective Plane Curves","text":"Projective plane curves are modeled in Oscar as projective algebraic sets. See AbsProjectiveAlgebraicSet(@ref). In addition to the methods for algebraic sets and curves the following methods special to plane curves are available.","category":"page"},{"location":"AlgebraicGeometry/Curves/ProjectivePlaneCurves/","page":"Projective Plane Curves","title":"Projective Plane Curves","text":"defining_equation(C::ProjectivePlaneCurve{S,MPolyQuoRing{T}}) where {S,T}\ndegree(C::ProjectivePlaneCurve)\ncommon_components(C::S, D::S) where {S<:ProjectivePlaneCurve}\nmultiplicity(C::ProjectivePlaneCurve, P::AbsProjectiveRationalPoint)\ntangent_lines(C::ProjectivePlaneCurve, P::AbsProjectiveRationalPoint)\nintersection_multiplicity(C::S, D::S, P::AbsProjectiveRationalPoint) where S <: ProjectivePlaneCurve\nis_transverse_intersection(C::S, D::S, P::AbsProjectiveRationalPoint) where S <: ProjectivePlaneCurve","category":"page"},{"location":"AlgebraicGeometry/Curves/ProjectivePlaneCurves/#defining_equation-Union{Tuple{ProjectivePlaneCurve{S, MPolyQuoRing{T}}}, Tuple{T}, Tuple{S}} where {S, T}","page":"Projective Plane Curves","title":"defining_equation","text":"defining_equation(C::AffinePlaneCurve)\n\nReturn the defining equation of C.\n\n\n\n\n\ndefining_equation(C::ProjectivePlaneCurve)\n\nReturn the defining equation of the (reduced) plane curve C.\n\n\n\n\n\n","category":"method"},{"location":"AlgebraicGeometry/Curves/ProjectivePlaneCurves/#degree-Tuple{ProjectivePlaneCurve}","page":"Projective Plane Curves","title":"degree","text":"degree(C::ProjectivePlaneCurve)\n\nReturn the degree of the defining polynomial of C.\n\n\n\n\n\n","category":"method"},{"location":"AlgebraicGeometry/Curves/ProjectivePlaneCurves/#common_components-Union{Tuple{S}, Tuple{S, S}} where S<:ProjectivePlaneCurve","page":"Projective Plane Curves","title":"common_components","text":"common_components(C::S, D::S) where {S<:ProjectivePlaneCurve}\n\nReturn the projective plane curve consisting of the common components of C and D, or an empty vector if they do not have a common component.\n\n\n\n\n\n","category":"method"},{"location":"AlgebraicGeometry/Curves/ProjectivePlaneCurves/#multiplicity-Tuple{ProjectivePlaneCurve, Oscar.AbsProjectiveRationalPoint}","page":"Projective Plane Curves","title":"multiplicity","text":"multiplicity(C::ProjectivePlaneCurve{S}, P::AbsProjectiveRationalPoint)\n\nReturn the multiplicity of C at P.\n\n\n\n\n\n","category":"method"},{"location":"AlgebraicGeometry/Curves/ProjectivePlaneCurves/#tangent_lines-Tuple{ProjectivePlaneCurve, Oscar.AbsProjectiveRationalPoint}","page":"Projective Plane Curves","title":"tangent_lines","text":"tangent_lines(C::ProjectivePlaneCurve{S}, P::AbsProjectiveRationalPoint) where S <: FieldElem\n\nReturn the tangent lines at P to C with their multiplicity.\n\n\n\n\n\n","category":"method"},{"location":"AlgebraicGeometry/Curves/ProjectivePlaneCurves/#intersection_multiplicity-Union{Tuple{S}, Tuple{S, S, Oscar.AbsProjectiveRationalPoint}} where S<:ProjectivePlaneCurve","page":"Projective Plane Curves","title":"intersection_multiplicity","text":"intersection_multiplicity(C::S, D::S, P::AbsProjectiveRationalPoint) where S <: ProjectivePlaneCurve\n\nReturn the intersection multiplicity of C and D at P.\n\n\n\n\n\n","category":"method"},{"location":"AlgebraicGeometry/Curves/ProjectivePlaneCurves/#is_transverse_intersection-Union{Tuple{S}, Tuple{S, S, Oscar.AbsProjectiveRationalPoint}} where S<:ProjectivePlaneCurve","page":"Projective Plane Curves","title":"is_transverse_intersection","text":"is_transverse_intersection(C::S, D::S, P::AbsProjectiveRationalPoint) where S <: ProjectivePlaneCurve\n\nReturn true if C and D intersect transversally at P and false otherwise.\n\n\n\n\n\n","category":"method"},{"location":"CommutativeAlgebra/ModulesOverMultivariateRings/complexes/","page":"Chain and Cochain Complexes","title":"Chain and Cochain Complexes","text":"CurrentModule = Oscar\nDocTestSetup = Oscar.doctestsetup()","category":"page"},{"location":"CommutativeAlgebra/ModulesOverMultivariateRings/complexes/#Chain-and-Cochain-Complexes","page":"Chain and Cochain Complexes","title":"Chain and Cochain Complexes","text":"","category":"section"},{"location":"CommutativeAlgebra/ModulesOverMultivariateRings/complexes/","page":"Chain and Cochain Complexes","title":"Chain and Cochain Complexes","text":"The general OSCAR type ComplexOfMorphisms{T} allows one to model both chain complexes and cochain complexes (the T refers to the type of the differentials of the complex). In the context of commutative algebra, we handle complexes of modules and module homomorphisms over multivariate polynomial rings. In this section, we first show how to create such complexes. Then we discuss functionality for dealing with the constructed complexes, mainly focusing on chain complexes. Cochain complexes can be handled similarly.","category":"page"},{"location":"CommutativeAlgebra/ModulesOverMultivariateRings/complexes/#Constructors","page":"Chain and Cochain Complexes","title":"Constructors","text":"","category":"section"},{"location":"CommutativeAlgebra/ModulesOverMultivariateRings/complexes/","page":"Chain and Cochain Complexes","title":"Chain and Cochain Complexes","text":"chain_complex(V::ModuleFPHom...; seed::Int = 0)","category":"page"},{"location":"CommutativeAlgebra/ModulesOverMultivariateRings/complexes/#chain_complex-Tuple{Vararg{ModuleFPHom}}","page":"Chain and Cochain Complexes","title":"chain_complex","text":"chain_complex(V::ModuleFPHom...; seed::Int = 0)\n\nGiven a tuple V of module homorphisms between successive modules over a multivariate polynomial ring,  return the chain complex defined by these homomorphisms.\n\nchain_complex(V::Vector{<:ModuleFPHom}; seed::Int = 0)\n\nGiven a vector V of module homorphisms between successive modules over a multivariate polynomial ring,  return the chain complex defined by these homomorphisms.\n\nnote: Note\nThe integer seed indicates the lowest homological degree of a module in the complex.\n\nnote: Note\nThe function checks whether successive homomorphisms indeed compose to zero.\n\n\n\n\n\n","category":"method"},{"location":"CommutativeAlgebra/ModulesOverMultivariateRings/complexes/","page":"Chain and Cochain Complexes","title":"Chain and Cochain Complexes","text":"cochain_complex(V::ModuleFPHom...; ssed::Int = 0)","category":"page"},{"location":"CommutativeAlgebra/ModulesOverMultivariateRings/complexes/#cochain_complex-Tuple{Vararg{ModuleFPHom}}","page":"Chain and Cochain Complexes","title":"cochain_complex","text":"cochain_complex(V::ModuleFPHom...; seed::Int = 0)\n\nGiven a tuple V of module homorphisms between successive modules over a multivariate polynomial ring,  return the cochain complex defined by these homomorphisms.\n\ncochain_complex(V::Vector{<:ModuleFPHom}; seed::Int = 0)\n\nGiven a vector V of module homorphisms between successive modules over a multivariate polynomial ring,  return the cochain complex defined by these homomorphisms.\n\nnote: Note\nThe integer seed indicates the lowest cohomological degree of a module of the complex.\n\nnote: Note\nThe function checks whether successive homomorphisms indeed compose to zero.\n\n\n\n\n\n","category":"method"},{"location":"CommutativeAlgebra/ModulesOverMultivariateRings/complexes/#Data-Associated-to-Complexes","page":"Chain and Cochain Complexes","title":"Data Associated to Complexes","text":"","category":"section"},{"location":"CommutativeAlgebra/ModulesOverMultivariateRings/complexes/","page":"Chain and Cochain Complexes","title":"Chain and Cochain Complexes","text":"Given a complex C,","category":"page"},{"location":"CommutativeAlgebra/ModulesOverMultivariateRings/complexes/","page":"Chain and Cochain Complexes","title":"Chain and Cochain Complexes","text":"range(C) refers to the range of C,\nobj(C, i) and C[i] to the i-th module of C, and\nmap(C, i) to the i-th differential of C.","category":"page"},{"location":"CommutativeAlgebra/ModulesOverMultivariateRings/complexes/#Examples","page":"Chain and Cochain Complexes","title":"Examples","text":"","category":"section"},{"location":"CommutativeAlgebra/ModulesOverMultivariateRings/complexes/","page":"Chain and Cochain Complexes","title":"Chain and Cochain Complexes","text":"julia> R, (x,) = polynomial_ring(QQ, [:x]);\n\njulia> F = free_module(R, 1);\n\njulia> A, _ = quo(F, [x^4*F[1]]);\n\njulia> B, _ = quo(F, [x^3*F[1]]);\n\njulia> a = hom(A, B, [x^2*B[1]]);\n\njulia> b = hom(B, B, [x^2*B[1]]);\n\njulia> C = chain_complex([a, b]; seed = 3)\nC_3 <---- C_4 <---- C_5\n\njulia> range(C)\n5:-1:3\n\njulia> C[5]\nSubquotient of submodule with 1 generator\n  1: e[1]\nby submodule with 1 generator\n  1: x^4*e[1]\n\njulia> delta = map(C, 5)\nModule homomorphism\n  from A\n  to B\n\njulia> matrix(delta)\n[x^2]","category":"page"},{"location":"CommutativeAlgebra/ModulesOverMultivariateRings/complexes/#Operations-on-Complexes","page":"Chain and Cochain Complexes","title":"Operations on Complexes","text":"","category":"section"},{"location":"CommutativeAlgebra/ModulesOverMultivariateRings/complexes/","page":"Chain and Cochain Complexes","title":"Chain and Cochain Complexes","text":"shift(C::ComplexOfMorphisms{T}, d::Int) where T","category":"page"},{"location":"CommutativeAlgebra/ModulesOverMultivariateRings/complexes/","page":"Chain and Cochain Complexes","title":"Chain and Cochain Complexes","text":"Return the complex obtained from C by shifting the homological degrees d steps, with maps multiplied by (-1)^d.","category":"page"},{"location":"CommutativeAlgebra/ModulesOverMultivariateRings/complexes/#Examples-2","page":"Chain and Cochain Complexes","title":"Examples","text":"","category":"section"},{"location":"CommutativeAlgebra/ModulesOverMultivariateRings/complexes/","page":"Chain and Cochain Complexes","title":"Chain and Cochain Complexes","text":"julia> R, (x,) = polynomial_ring(QQ, [:x]);\n\njulia> F = free_module(R, 1);\n\njulia> A, _ = quo(F, [x^4*F[1]]);\n\njulia> B, _ = quo(F, [x^3*F[1]]);\n\njulia> a = hom(A, B, [x^2*B[1]]);\n\njulia> b = hom(B, B, [x^2*B[1]]);\n\njulia> C = chain_complex([a, b]; seed = 3);\n\njulia> range(C)\n5:-1:3\n\njulia> D = shift(C, 3);\n\njulia> range(D)\n8:-1:6","category":"page"},{"location":"CommutativeAlgebra/ModulesOverMultivariateRings/complexes/","page":"Chain and Cochain Complexes","title":"Chain and Cochain Complexes","text":"hom(C::ComplexOfMorphisms{ModuleFP}, M::ModuleFP)","category":"page"},{"location":"CommutativeAlgebra/ModulesOverMultivariateRings/complexes/#hom-Tuple{ComplexOfMorphisms{ModuleFP}, ModuleFP}","page":"Chain and Cochain Complexes","title":"hom","text":"hom(C::ComplexOfMorphisms{ModuleFP}, M::ModuleFP)\n\nReturn the complex obtained by applying textHom(- M) to C.\n\nIf C is a chain complex, return a cochain complex. If C is a cochain complex, return a chain complex.\n\nExamples\n\njulia> R, (x,) = polynomial_ring(QQ, [:x]);\n\njulia> F = free_module(R, 1);\n\njulia> A, _ = quo(F, [x^4*F[1]]);\n\njulia> B, _ = quo(F, [x^3*F[1]]);\n\njulia> a = hom(A, B, [x^2*B[1]]);\n\njulia> b = hom(B, B, [x^2*B[1]]);\n\njulia> C = chain_complex([a, b]; seed = 3);\n\njulia> range(C)\n5:-1:3\n\njulia> D = hom(C, A);\n\njulia> range(D)\n3:5\n\n\n\n\n\n","category":"method"},{"location":"CommutativeAlgebra/ModulesOverMultivariateRings/complexes/","page":"Chain and Cochain Complexes","title":"Chain and Cochain Complexes","text":"hom_without_reversing_direction(C::ComplexOfMorphisms{ModuleFP}, M::ModuleFP)","category":"page"},{"location":"CommutativeAlgebra/ModulesOverMultivariateRings/complexes/#hom_without_reversing_direction-Tuple{ComplexOfMorphisms{ModuleFP}, ModuleFP}","page":"Chain and Cochain Complexes","title":"hom_without_reversing_direction","text":"hom_without_reversing_direction(C::ComplexOfMorphisms{ModuleFP}, M::ModuleFP)\n\nReturn the complex obtained by applying textHom(- M) to C.\n\nIf C is a chain complex, return a chain complex. If C is a cochain complex, return a cochain complex.\n\nExamples\n\njulia> R, (x,) = polynomial_ring(QQ, [:x]);\n\njulia> F = free_module(R, 1);\n\njulia> A, _ = quo(F, [x^4*F[1]]);\n\njulia> B, _ = quo(F, [x^3*F[1]]);\n\njulia> a = hom(A, B, [x^2*B[1]]);\n\njulia> b = hom(B, B, [x^2*B[1]]);\n\njulia> C = chain_complex([a, b]; seed = 3);\n\njulia> range(C)\n5:-1:3\n\njulia> D = hom_without_reversing_direction(C, A);\n\njulia> range(D)\n-3:-1:-5\n\n\n\n\n\n","category":"method"},{"location":"CommutativeAlgebra/ModulesOverMultivariateRings/complexes/","page":"Chain and Cochain Complexes","title":"Chain and Cochain Complexes","text":"hom(M::ModuleFP, C::ComplexOfMorphisms{ModuleFP})","category":"page"},{"location":"CommutativeAlgebra/ModulesOverMultivariateRings/complexes/#hom-Tuple{ModuleFP, ComplexOfMorphisms{ModuleFP}}","page":"Chain and Cochain Complexes","title":"hom","text":"hom(M::ModuleFP, C::ComplexOfMorphisms{ModuleFP})\n\nReturn the complex obtained by applying textHom(M, -) to C.\n\n\n\n\n\n","category":"method"},{"location":"CommutativeAlgebra/ModulesOverMultivariateRings/complexes/","page":"Chain and Cochain Complexes","title":"Chain and Cochain Complexes","text":"tensor_product(C::ComplexOfMorphisms{ModuleFP}, M::ModuleFP)","category":"page"},{"location":"CommutativeAlgebra/ModulesOverMultivariateRings/complexes/#tensor_product-Tuple{ComplexOfMorphisms{ModuleFP}, ModuleFP}","page":"Chain and Cochain Complexes","title":"tensor_product","text":"tensor_product(C::ComplexOfMorphisms{<:ModuleFP}, M::ModuleFP)\n\nReturn the complex obtained by applying bullet otimes M to C.\n\n\n\n\n\n","category":"method"},{"location":"CommutativeAlgebra/ModulesOverMultivariateRings/complexes/","page":"Chain and Cochain Complexes","title":"Chain and Cochain Complexes","text":"tensor_product(M::ModuleFP, C::ComplexOfMorphisms{ModuleFP})","category":"page"},{"location":"CommutativeAlgebra/ModulesOverMultivariateRings/complexes/#tensor_product-Tuple{ModuleFP, ComplexOfMorphisms{ModuleFP}}","page":"Chain and Cochain Complexes","title":"tensor_product","text":"tensor_product(M::ModuleFP, C::ComplexOfMorphisms{ModuleFP})\n\nReturn the complex obtained by applying M otimes bullet to C.\n\n\n\n\n\n","category":"method"},{"location":"CommutativeAlgebra/ModulesOverMultivariateRings/complexes/#Tests-on-Complexes","page":"Chain and Cochain Complexes","title":"Tests on Complexes","text":"","category":"section"},{"location":"CommutativeAlgebra/ModulesOverMultivariateRings/complexes/","page":"Chain and Cochain Complexes","title":"Chain and Cochain Complexes","text":"The functions below check properties of complexes:","category":"page"},{"location":"CommutativeAlgebra/ModulesOverMultivariateRings/complexes/","page":"Chain and Cochain Complexes","title":"Chain and Cochain Complexes","text":"is_chain_complex(C::ComplexOfMorphisms{ModuleFP})","category":"page"},{"location":"CommutativeAlgebra/ModulesOverMultivariateRings/complexes/","page":"Chain and Cochain Complexes","title":"Chain and Cochain Complexes","text":"is_cochain_complex(C::ComplexOfMorphisms{ModuleFP})","category":"page"},{"location":"CommutativeAlgebra/ModulesOverMultivariateRings/complexes/","page":"Chain and Cochain Complexes","title":"Chain and Cochain Complexes","text":"is_exact(C::ComplexOfMorphisms{ModuleFP})","category":"page"},{"location":"CommutativeAlgebra/ModulesOverMultivariateRings/complexes/#Examples-3","page":"Chain and Cochain Complexes","title":"Examples","text":"","category":"section"},{"location":"CommutativeAlgebra/ModulesOverMultivariateRings/complexes/","page":"Chain and Cochain Complexes","title":"Chain and Cochain Complexes","text":"julia> R, (x,) = polynomial_ring(QQ, [:x]);\n\njulia> F = free_module(R, 1);\n\njulia> A, _ = quo(F, [x^4*F[1]]);\n\njulia> B, _ = quo(F, [x^3*F[1]]);\n\njulia> a = hom(A, B, [x^2*B[1]]);\n\njulia> b = hom(B, B, [x^2*B[1]]);\n\njulia> R, (x,) = polynomial_ring(QQ, [:x]);\n\njulia> C = chain_complex([a, b]);\n\njulia> is_cochain_complex(C)\nfalse","category":"page"},{"location":"CommutativeAlgebra/ModulesOverMultivariateRings/complexes/#Maps-of-Complexes","page":"Chain and Cochain Complexes","title":"Maps of Complexes","text":"","category":"section"},{"location":"CommutativeAlgebra/ModulesOverMultivariateRings/complexes/#Types","page":"Chain and Cochain Complexes","title":"Types","text":"","category":"section"},{"location":"CommutativeAlgebra/ModulesOverMultivariateRings/complexes/#Constructors-2","page":"Chain and Cochain Complexes","title":"Constructors","text":"","category":"section"},{"location":"InvariantTheory/intro/","page":"Introduction","title":"Introduction","text":"CurrentModule = Oscar","category":"page"},{"location":"InvariantTheory/intro/#invariant_theory","page":"Introduction","title":"Introduction","text":"","category":"section"},{"location":"InvariantTheory/intro/","page":"Introduction","title":"Introduction","text":"The invariant theory part of OSCAR provides functionality for computing polynomial invariants of group actions, focusing on finite groups, tori, and linearly reductive groups, respectively.","category":"page"},{"location":"InvariantTheory/intro/","page":"Introduction","title":"Introduction","text":"The basic setting in this context consists of a group G, a field K, a vector space V over K of finite dimension n and  a representation rho G to textGL(V) of G on V. The induced right action on the dual vector space V^ast,","category":"page"},{"location":"InvariantTheory/intro/","page":"Introduction","title":"Introduction","text":"V^ast  times G to V^ast (f pi)mapsto f      pi  = fcirc rho(pi)","category":"page"},{"location":"InvariantTheory/intro/","page":"Introduction","title":"Introduction","text":"extends to a right action of G on the graded symmetric algebra","category":"page"},{"location":"InvariantTheory/intro/","page":"Introduction","title":"Introduction","text":"KV=S(V^*)=bigoplus_dgeq 0 S^d V^*","category":"page"},{"location":"InvariantTheory/intro/","page":"Introduction","title":"Introduction","text":"which preserves the grading.","category":"page"},{"location":"InvariantTheory/intro/","page":"Introduction","title":"Introduction","text":"note: Note\nIn OSCAR, group actions are by convention assumed to be right actions and we follow this convention with our definition above. Note, however, that the left action given by pi      f =  f circ rho(pi^-1) is quite common in the literature.","category":"page"},{"location":"InvariantTheory/intro/","page":"Introduction","title":"Introduction","text":"The invariants of G are the fixed points of the action defined above, its invariant ring is the graded subalgebra","category":"page"},{"location":"InvariantTheory/intro/","page":"Introduction","title":"Introduction","text":"KV^G=fin KV mid f      pi =f text  for any  piin G subset KV","category":"page"},{"location":"InvariantTheory/intro/","page":"Introduction","title":"Introduction","text":"Explicitly, fixing a basis of V and its dual basis, say, x_1 dots x_n of V^*, we may identify operatornameGL(V) cong operatornameGL_n(K) and KVcong Kx_1 dots x_n. Then the action of an element pi in G with rho(pi) = (a_i j) on a polynomial fin Kx_1dots x_n is given as follows:","category":"page"},{"location":"InvariantTheory/intro/","page":"Introduction","title":"Introduction","text":"(f      pi)  (x_1 dots x_n) = fbigl(sum_j a_1 jx_j dots sum_j a_n jx_jbigr)","category":"page"},{"location":"InvariantTheory/intro/","page":"Introduction","title":"Introduction","text":"Accordingly, KV^G may be regarded as a graded subalgebra of Kx_1 dots x_n:","category":"page"},{"location":"InvariantTheory/intro/","page":"Introduction","title":"Introduction","text":"KV^G cong Kx_1 dots x_n^G =fin Kx_1 dots x_n mid f      pi =f text  for any  piin G","category":"page"},{"location":"InvariantTheory/intro/","page":"Introduction","title":"Introduction","text":"The main objective of invariant theory in OSCAR is the computation of K-algebra generators for invariant rings.","category":"page"},{"location":"InvariantTheory/intro/","page":"Introduction","title":"Introduction","text":"note: Note\nIf KV^G is finitely generated as a K-algebra, then any minimal system of homogeneous generators is called a fundamental system of invariants for KV^G. By Nakayama's lemma, the number of elements in such a system is uniquely determined as the embedding dimension of KV^G. Similarly, the degrees of these elements are uniquely determined.","category":"page"},{"location":"InvariantTheory/intro/","page":"Introduction","title":"Introduction","text":"note: Note\nIf KV^G is finitely generated as a K-algebra, then KV^G admits a graded Noether normalization, that is, a Noether normalization Kp_1 dots p_m subset KV^G with p_1 dots p_m homogeneous. Given any such Noether normalization, p_1 dots p_m is called a homogeneous system of parameters or a system of primary invariants for KV^G, and  any minimal system s_0=1 s_1dots s_l of homogeneous generators of KV^G as a Kp_1 dots p_m-module is called a system of secondary invariants for KV^G with respect to p_1 dots p_m. A secondary invariant s_ineq 1 is called irreducible if it cannot be written as a polynomial expression in the primary invariants and the other secondary invariants. The  irreducible secondary invariants form a minimal system of homogeneous generators for KV^G as a Kp_1 dots p_m-algebra. Somewhat abusing notation, we call every minimal system of homogeneous generators for KV^G as a Kp_1 dots p_m-algebra a system of irreducible secondary invariants.","category":"page"},{"location":"InvariantTheory/intro/","page":"Introduction","title":"Introduction","text":"note: Note\nFor the invariant rings handled by OSCAR, the assumption that KV^G is finitely generated as a K-algebra will be guaranteed by theoretical results. In addition, where not mentioned otherwise, the following will hold:There exists a Reynolds operator mathcal R KV to KV. That is, mathcal R is a K-linear graded map which projects KV onto KV^G, and which is a KV^G-module homomorphism.\nThe ring KV^G is Cohen-Macaulay. Equivalently, KV^G is a free module (of finite rank) over any of its graded Noether normalizations.","category":"page"},{"location":"InvariantTheory/intro/","page":"Introduction","title":"Introduction","text":"The textbook","category":"page"},{"location":"InvariantTheory/intro/","page":"Introduction","title":"Introduction","text":"[DK15]","category":"page"},{"location":"InvariantTheory/intro/","page":"Introduction","title":"Introduction","text":"and the survey article","category":"page"},{"location":"InvariantTheory/intro/","page":"Introduction","title":"Introduction","text":"[DJ98]","category":"page"},{"location":"InvariantTheory/intro/","page":"Introduction","title":"Introduction","text":"provide details on theory and algorithms as well as references.","category":"page"},{"location":"InvariantTheory/intro/#Contact","page":"Introduction","title":"Contact","text":"","category":"section"},{"location":"InvariantTheory/intro/","page":"Introduction","title":"Introduction","text":"Please direct questions about this part of OSCAR to the following people:","category":"page"},{"location":"InvariantTheory/intro/","page":"Introduction","title":"Introduction","text":"Wolfram Decker,\nMax Horn,\nJohannes Schmitt.","category":"page"},{"location":"InvariantTheory/intro/","page":"Introduction","title":"Introduction","text":"You can ask questions in the OSCAR Slack.","category":"page"},{"location":"InvariantTheory/intro/","page":"Introduction","title":"Introduction","text":"Alternatively, you can raise an issue on github.","category":"page"},{"location":"Nemo/puiseux/","page":"Puiseux series","title":"Puiseux series","text":"CurrentModule = Nemo\nDocTestSetup = quote\n    using Nemo\nend","category":"page"},{"location":"Nemo/puiseux/#Puiseux-series","page":"Puiseux series","title":"Puiseux series","text":"","category":"section"},{"location":"Nemo/puiseux/","page":"Puiseux series","title":"Puiseux series","text":"Nemo allows the creation of Puiseux series over any computable ring R. Puiseux series are series of the form a_jx^jm + a_j+1x^(j+1)m + cdots + a_k-1x^(k-1)m + O(x^km) where m is a positive integer, a_i in R and the relative precision k - j is at most equal to some specified precision n.","category":"page"},{"location":"Nemo/puiseux/","page":"Puiseux series","title":"Puiseux series","text":"There are two different kinds of implementation: a generic one for the case where no specific implementation exists (provided by AbstractAlgebra.jl), and efficient implementations of Puiseux series over numerous specific rings, usually provided by C/C++ libraries.","category":"page"},{"location":"Nemo/puiseux/","page":"Puiseux series","title":"Puiseux series","text":"The following table shows each of the Puiseux series types available in Nemo, the base ring R, and the Julia/Nemo types for that kind of series (the type information is mainly of concern to developers).","category":"page"},{"location":"Nemo/puiseux/","page":"Puiseux series","title":"Puiseux series","text":"Base ring Library Element type Parent type\nGeneric ring R AbstractAlgebra.jl `Generic.PuiseuxSeriesRingElem{T} Generic.PuiseuxSeriesRing{T}\nGeneric field K AbstractAlgebra.jl `Generic.PuiseuxSeriesFieldElem{T} Generic.PuiseuxSeriesField{T}\nmathbbZ Flint FlintPuiseuxSeriesRingElem{ZZLaurentSeriesRingElem} FlintPuiseuxSeriesRing{ZZLaurentSeriesRingElem}","category":"page"},{"location":"Nemo/puiseux/","page":"Puiseux series","title":"Puiseux series","text":"For convenience, FlintPuiseuxSeriesRingElem and FlintPuiseuxSeriesFieldElem both belong to a union type called FlintPuiseuxSeriesElem.","category":"page"},{"location":"Nemo/puiseux/","page":"Puiseux series","title":"Puiseux series","text":"The maximum relative precision, the string representation of the variable and the base ring R of a generic power series are stored in the parent object. ","category":"page"},{"location":"Nemo/puiseux/","page":"Puiseux series","title":"Puiseux series","text":"Note that unlike most other Nemo types, Puiseux series are parameterised by the type of the underlying Laurent series type (which must exist before Nemo can make use of it), instead of the type of the coefficients.","category":"page"},{"location":"Nemo/puiseux/#Puiseux-power-series","page":"Puiseux series","title":"Puiseux power series","text":"","category":"section"},{"location":"Nemo/puiseux/","page":"Puiseux series","title":"Puiseux series","text":"Puiseux series have their maximum relative precision capped at some value prec_max. This refers to the maximum precision of the underlying Laurent series. See the description of the generic Puiseux series in AbstractAlgebra.jl for details.","category":"page"},{"location":"Nemo/puiseux/","page":"Puiseux series","title":"Puiseux series","text":"There are numerous important things to be aware of when working with Puiseux series, or series in general. Please refer to the documentation of generic Puiseux series and  series in general in AbstractAlgebra.jl for details.","category":"page"},{"location":"Nemo/puiseux/#Puiseux-series-functionality","page":"Puiseux series","title":"Puiseux series functionality","text":"","category":"section"},{"location":"Nemo/puiseux/","page":"Puiseux series","title":"Puiseux series","text":"Puiseux series rings in Nemo implement all the same functionality that is available for AbstractAlgebra series rings, with the exception of the pol_length and polcoeff functions:","category":"page"},{"location":"Nemo/puiseux/","page":"Puiseux series","title":"Puiseux series","text":"https://nemocas.github.io/AbstractAlgebra.jl/stable/series","category":"page"},{"location":"Nemo/puiseux/","page":"Puiseux series","title":"Puiseux series","text":"In addition, generic Puiseux series are provided by AbstractAlgebra.jl","category":"page"},{"location":"Nemo/puiseux/","page":"Puiseux series","title":"Puiseux series","text":"We list below only the functionality that differs from that described in AbstractAlgebra, for specific rings provided by Nemo.","category":"page"},{"location":"Nemo/puiseux/#Special-functions","page":"Puiseux series","title":"Special functions","text":"","category":"section"},{"location":"Nemo/puiseux/","page":"Puiseux series","title":"Puiseux series","text":"Base.sqrt(a::FlintPuiseuxSeriesElem{ZZLaurentSeriesRingElem})","category":"page"},{"location":"Nemo/puiseux/#sqrt-Tuple{FlintPuiseuxSeriesElem{ZZLaurentSeriesRingElem}}","page":"Puiseux series","title":"sqrt","text":"Base.sqrt(f::PolyRingElem{T}; check::Bool=true) where T <: RingElement\n\nReturn the square root of f. By default the function checks the input is square and raises an exception if not. If check=false this check is omitted.\n\n\n\n\n\nBase.sqrt(a::FracElem{T}; check::Bool=true) where T <: RingElem\n\nReturn the square root of a. By default the function will throw an exception if the input is not square. If check=false this test is omitted.\n\n\n\n\n\nsqrt(a::Generic.PuiseuxSeriesElem{T}; check::Bool=true) where T <: RingElement\n\nReturn the square root of the given Puiseux series a. By default the function will throw an exception if the input is not square. If check=false this test is omitted.\n\n\n\n\n\n","category":"method"},{"location":"Nemo/puiseux/","page":"Puiseux series","title":"Puiseux series","text":"Base.exp(a::FlintPuiseuxSeriesElem{ZZLaurentSeriesRingElem})","category":"page"},{"location":"Nemo/puiseux/#exp-Tuple{FlintPuiseuxSeriesElem{ZZLaurentSeriesRingElem}}","page":"Puiseux series","title":"exp","text":"exp(a::AbsPowerSeriesRingElem)\n\nReturn the exponential of the power series a.\n\n\n\n\n\nexp(a::RelPowerSeriesRingElem)\n\nReturn the exponential of the power series a.\n\n\n\n\n\nexp(a::Generic.LaurentSeriesElem)\n\nReturn the exponential of the power series a.\n\n\n\n\n\nexp(a::Generic.PuiseuxSeriesElem{T}) where T <: RingElement\n\nReturn the exponential of the given Puiseux series a.\n\n\n\n\n\n","category":"method"},{"location":"Nemo/puiseux/","page":"Puiseux series","title":"Puiseux series","text":"eta_qexp(x::FlintPuiseuxSeriesElem{ZZLaurentSeriesRingElem})","category":"page"},{"location":"Nemo/puiseux/#eta_qexp-Tuple{FlintPuiseuxSeriesElem{ZZLaurentSeriesRingElem}}","page":"Puiseux series","title":"eta_qexp","text":"eta_qexp(x::FlintPuiseuxSeriesElem{ZZLaurentSeriesRingElem})\n\nReturn the q-series for eta evaluated at x, which must currently be a rational power of the generator of the Puiseux series ring.\n\n\n\n\n\n","category":"method"},{"location":"Nemo/puiseux/","page":"Puiseux series","title":"Puiseux series","text":"Examples","category":"page"},{"location":"Nemo/puiseux/","page":"Puiseux series","title":"Puiseux series","text":"julia> S, z = puiseux_series_ring(ZZ, 30, \"z\")\n(Puiseux series ring in z over ZZ, z + O(z^31))\n\njulia> a = 1 + z + 3z^2 + O(z^5)\n1 + z + 3*z^2 + O(z^5)\n\njulia> h = sqrt(a^2)\n1 + z + 3*z^2 + O(z^5)\n\njulia> k = eta_qexp(z)\nz^(1//24) - z^(25//24) + O(z^(31//24))","category":"page"},{"location":"DeveloperDocumentation/serialization/#dev_serialization","page":"Serialization","title":"Serialization","text":"","category":"section"},{"location":"DeveloperDocumentation/serialization/","page":"Serialization","title":"Serialization","text":"This document summarizes the serialization efforts of OSCAR, how it works, and what our long-term vision is. Serialization broadly speaking is the process of reading and writing data. There are many reasons for this feature in OSCAR, but the main reason is communication on mathematics by mathematicians.","category":"page"},{"location":"DeveloperDocumentation/serialization/","page":"Serialization","title":"Serialization","text":"We implement our serialization in accordance with the MaRDI file format specification described here. Which means we use a JSON extension to serialize data.","category":"page"},{"location":"DeveloperDocumentation/serialization/#How-it-works","page":"Serialization","title":"How it works","text":"","category":"section"},{"location":"DeveloperDocumentation/serialization/","page":"Serialization","title":"Serialization","text":"The mechanism for saving and loading is very simple. It is implemented via two methods save and load, and works in the following manner:","category":"page"},{"location":"DeveloperDocumentation/serialization/","page":"Serialization","title":"Serialization","text":"julia> save(\"/tmp/fourtitwo.mrdi\", 42);\n\njulia> load(\"/tmp/fourtitwo.mrdi\")\n42\n","category":"page"},{"location":"DeveloperDocumentation/serialization/","page":"Serialization","title":"Serialization","text":"The filename hints to the MaRDI file format, which employs JSON.  The file looks as follows:","category":"page"},{"location":"DeveloperDocumentation/serialization/","page":"Serialization","title":"Serialization","text":"{\n  \"_ns\": {\n    \"Oscar\": [\n      \"https://github.com/oscar-system/Oscar.jl\",\n      \"0.14.0-DEV-8fe2abbe39890a7d3324adcba7f91812119c586a\"\n    ]\n  },\n  \"_type\": \"Base.Int\",\n  \"data\": \"42\"\n}","category":"page"},{"location":"DeveloperDocumentation/serialization/","page":"Serialization","title":"Serialization","text":"It contains the precise version of OSCAR used for this serialization. The content is \"42\", it represents a Base.Int, according to the _type field.","category":"page"},{"location":"DeveloperDocumentation/serialization/#Implementation","page":"Serialization","title":"Implementation","text":"","category":"section"},{"location":"DeveloperDocumentation/serialization/","page":"Serialization","title":"Serialization","text":"To list and describe all implementations and encodings of all types in OSCAR is not a possible feat due to the arbitrarily deep and nested type structures available in OSCAR, we point any developer looking to understand the encodings of certain types to the OSCAR source code. All files for serialization can be found in the folder src/Serialization. The convention of the files there follows the overall structure of OSCAR, i.e. the file src/Serialization/PolyhedralGeometry.jl contains functions for serializing objects of the polyhedral geometry section.","category":"page"},{"location":"DeveloperDocumentation/serialization/","page":"Serialization","title":"Serialization","text":"We include a basic example of the encoding for a QQPolyRingElem so one can get a taste before delving into the source code. Here we store the polynomial x^3 + 2x + 1//2. The encoding for polynomials is to store a list of tuples, where each entry in the list represents a term of the polynomial and where the first entry of the tuple is the exponent and the second entry is the coefficient. Here we serialize a univariate polynomial so the first entries are always integers, in general this may be an array of integers. The coefficients here are elements of QQ however in general the coefficients themselves may be described as polynomials of the generators of some field extension, i.e. the second entry may again be a list of tuples and so on. The nested structure of the coefficient will depend on the description of the field extension.","category":"page"},{"location":"DeveloperDocumentation/serialization/","page":"Serialization","title":"Serialization","text":"{\n  \"_ns\": {\n    \"Oscar\": [\n      \"https://github.com/oscar-system/Oscar.jl\",\n      \"1.1.0-DEV-6f7e717c759f5fc281b64f665c28f58578013c21\"\n    ]\n  },\n  \"_refs\": {\n    \"e6c5972c-4052-4408-a408-0f4f11f21e49\": {\n      \"_type\": \"PolyRing\",\n      \"data\": {\n        \"base_ring\": {\n          \"_type\": \"QQField\"\n        },\n        \"symbols\": [\n          \"x\"\n        ]\n      }\n    }\n  },\n  \"_type\": {\n    \"name\": \"PolyRingElem\",\n    \"params\": \"e6c5972c-4052-4408-a408-0f4f11f21e49\"\n  },\n  \"data\": [  [      \"0\",      \"1//2\"    ],\n\t     [      \"1\",      \"2\"       ],\n\t     [      \"3\",      \"1\"       ]  ]\n}\n","category":"page"},{"location":"DeveloperDocumentation/serialization/","page":"Serialization","title":"Serialization","text":"When trying to understand an encoding of a particular type in OSCAR it is always best to make a minimal example and store it. Then use a pretty printer to format the JSON, and have it close by while going through the source code.","category":"page"},{"location":"DeveloperDocumentation/serialization/#Description-of-the-saving-and-loading-mechanisms","page":"Serialization","title":"Description of the saving and loading mechanisms","text":"","category":"section"},{"location":"DeveloperDocumentation/serialization/","page":"Serialization","title":"Serialization","text":"We require that any types serialized through OSCAR are registered using @register_serialization_type. This is to ensure user safety during the load process by avoiding code evaluation.","category":"page"},{"location":"DeveloperDocumentation/serialization/","page":"Serialization","title":"Serialization","text":"@register_serialization_type","category":"page"},{"location":"DeveloperDocumentation/serialization/#@register_serialization_type","page":"Serialization","title":"@register_serialization_type","text":"@register_serialization_type NewType \"String Representation of type\" uses_id uses_params [:attr1, :attr2]\n\n@register_serialization_type is a macro to ensure that the string we generate matches exactly the expression passed as first argument, and does not change in unexpected ways when import/export statements are adjusted.\n\nPassing a string argument will override how the type is stored as a string.\n\nWhen setting uses_id the object will be stored as a reference and will be referred to throughout the serialization sessions using a UUID. This should typically only be used for types that do not have a fixed normal form for example PolyRing and MPolyRing.\n\nUsing the uses_params flag will serialize the object with a more structured type description which will make the serialization more efficient see the discussion on save_type_params / load_type_params below.\n\nPassing a vector of symbols that correspond to attributes of type indicates which attributes will be serialized when using save with with_attrs=true.\n\n\n\n\n\n","category":"macro"},{"location":"DeveloperDocumentation/serialization/","page":"Serialization","title":"Serialization","text":"There are three pairs of saving and loading functions that are used during serialization:","category":"page"},{"location":"DeveloperDocumentation/serialization/","page":"Serialization","title":"Serialization","text":"save_typed_object, load_typed_object\nsave_object, load_object\nsave_type_params, load_type_params","category":"page"},{"location":"DeveloperDocumentation/serialization/#save_type_object-/-load_type_object","page":"Serialization","title":"save_type_object / load_type_object","text":"","category":"section"},{"location":"DeveloperDocumentation/serialization/","page":"Serialization","title":"Serialization","text":"For the most part these functions should not be touched, they are high level functions and are used to (de)serialize the object with its type information as well as its data. The data and type nodes are set in save_typed_object resulting in a \"data branch\" and \"type branch\". The usage of these functions can be used inside save_object / load_object and save_type_params / load_type_params. However using save_typed_object inside a save_object implementation will lead to a verbose format and should at some point be moved to save_type_params. Their implementation can be found in the main.jl file.","category":"page"},{"location":"DeveloperDocumentation/serialization/#save_object-/-load_object","page":"Serialization","title":"save_object / load_object","text":"","category":"section"},{"location":"DeveloperDocumentation/serialization/","page":"Serialization","title":"Serialization","text":"These functions should be the first functions to be overloaded when implementing the serialization of a new type. The functions save_data_dict and save_data_array are helpers functions that structure the serialization.","category":"page"},{"location":"DeveloperDocumentation/serialization/","page":"Serialization","title":"Serialization","text":"The examples show how they can be used to save data using the structure of an array or dict. Each nested call to save_data_dict or save_data_array should be called with a key that can be passed as the second parameter.","category":"page"},{"location":"DeveloperDocumentation/serialization/#Examples","page":"Serialization","title":"Examples","text":"","category":"section"},{"location":"DeveloperDocumentation/serialization/#Example-1","page":"Serialization","title":"Example 1","text":"","category":"section"},{"location":"DeveloperDocumentation/serialization/","page":"Serialization","title":"Serialization","text":"function save_object(s::SerializerState, obj::NewType)\n  save_data_array(s) do\n    save_object(s, obj.1)\n    save_object(s, obj.2)\n   save_data_dict(s) do\n      save_object(s, obj.3, :key1)\n      save_object(s, obj.4, :key2)\n    end\n  end\nend","category":"page"},{"location":"DeveloperDocumentation/serialization/","page":"Serialization","title":"Serialization","text":"This will result in a data format that looks like this.","category":"page"},{"location":"DeveloperDocumentation/serialization/","page":"Serialization","title":"Serialization","text":"[\n  obj.1,\n  obj.2,\n  {\n    \"key1\": obj.3,\n    \"key2\": obj.4\n  }\n]","category":"page"},{"location":"DeveloperDocumentation/serialization/","page":"Serialization","title":"Serialization","text":"With the corresponding loading function similar to this.","category":"page"},{"location":"DeveloperDocumentation/serialization/","page":"Serialization","title":"Serialization","text":"function load_object(s::DeserializerState, ::Type{<:NewType})\n  (obj1, obj2, obj3_4) = load_array_node(s) do (i, entry)\n    if entry isa JSON3.Object\n      obj3 = load_object(s, Obj3Type, :key1)\n      obj4 = load_object(s, Obj3Type, :key2)\n      return OtherType(obj3, obj4)\n    else\n      if p(entry) == c\n        load_object(s, Obj1Type)\n      else\n        load_object(s, Obj2Type)\n      end\n    end\n  end\n  return NewType(obj1, obj2, obj3_4)\nend","category":"page"},{"location":"DeveloperDocumentation/serialization/#Example-2","page":"Serialization","title":"Example 2","text":"","category":"section"},{"location":"DeveloperDocumentation/serialization/","page":"Serialization","title":"Serialization","text":"function save_object(s::SerializerState, obj::NewType)\n  save_data_dict(s) do\n    save_object(s, obj.1, :key1)\n    save_data_array(s, :key2) do\n      save_object(s, obj.3)\n      save_typed_object(s, obj.4) # This is ok\n    end\n  end\nend","category":"page"},{"location":"DeveloperDocumentation/serialization/","page":"Serialization","title":"Serialization","text":"This will result in a data format that looks like this.","category":"page"},{"location":"DeveloperDocumentation/serialization/","page":"Serialization","title":"Serialization","text":"{\n  \"key1\": obj.1,\n  \"key2\":[\n    obj.3,\n    {\n      \"type\": \"Type of obj.4\",\n      \"data\": obj.4\n    }\n  ]\n}","category":"page"},{"location":"DeveloperDocumentation/serialization/","page":"Serialization","title":"Serialization","text":"The corresponding loading function would look something like this.","category":"page"},{"location":"DeveloperDocumentation/serialization/","page":"Serialization","title":"Serialization","text":"function load_object(s::DeserializerState, ::Type{<:NewType}, params::ParamsObj)\n   obj1 = load_object(s, Obj1Type, params[1], :key1)\n\n   (obj3, obj4) = load_array_node(s, :key2) do (i, entry)\n     if i == 1\n       load_object(s, Obj3Type, params[2])\n     else\n       load_typed_object(s)\n     end\n   end\n   return NewType(obj1, OtherType(obj3, obj4))\n end","category":"page"},{"location":"DeveloperDocumentation/serialization/","page":"Serialization","title":"Serialization","text":"This is ok","category":"page"},{"location":"DeveloperDocumentation/serialization/","page":"Serialization","title":"Serialization","text":"function save_object(s::SerializerState, obj:NewType)\n  save_object(s, obj.1)\nend","category":"page"},{"location":"DeveloperDocumentation/serialization/","page":"Serialization","title":"Serialization","text":"While this will throw an error","category":"page"},{"location":"DeveloperDocumentation/serialization/","page":"Serialization","title":"Serialization","text":"function save_object(s::SerializerState, obj:NewType)\n  save_object(s, obj.1, :key)\nend","category":"page"},{"location":"DeveloperDocumentation/serialization/","page":"Serialization","title":"Serialization","text":"If you insist on having a key you should use a save_data_dict.","category":"page"},{"location":"DeveloperDocumentation/serialization/","page":"Serialization","title":"Serialization","text":"function save_object(s::SerializerState, obj:NewType)\n  save_data_dict(s) do\n    save_object(s, obj.1, :key)\n  end\nend\n\nfunction load_object(s::SerializerState, ::Type{<:NewType})\n  load_node(s, :key) do x\n    info = do_something(x)\n\n    if info\n      load_object(s, OtherType)\n    else\n      load_object(s, AnotherType)\n    end\n  end\nend","category":"page"},{"location":"DeveloperDocumentation/serialization/","page":"Serialization","title":"Serialization","text":"Note for now save_typed_object must be wrapped in either a save_data_array or save_data_dict. Otherwise you will get a key override error.","category":"page"},{"location":"DeveloperDocumentation/serialization/#save_type_params-/-load_type_params","page":"Serialization","title":"save_type_params / load_type_params","text":"","category":"section"},{"location":"DeveloperDocumentation/serialization/","page":"Serialization","title":"Serialization","text":"The serialization mechanism stores data in the format of a tree, with the exception that some nodes may point to a shared reference. The \"data branch\" is anything that is a child node of a data node, whereas the \"type branch\" is any information that is stored in a node that is a child of a type node. Avoiding type information inside the data branch will lead to a more efficient serialization format. When the uses_params is set when registering the type with @register_serialization_type (de)serialization will use save_type_params / load_type_params to format the type information. In general we expect that implementing a save_type_params and load_type_params should not always be necessary. Many types will serialize their types in a similar fashion for example serialization of a FieldElem will use the save_type_params / load_type_params from RingElem since in both cases the only parameter needed for such types is their parent.","category":"page"},{"location":"DeveloperDocumentation/serialization/#Import-helper","page":"Serialization","title":"Import helper","text":"","category":"section"},{"location":"DeveloperDocumentation/serialization/","page":"Serialization","title":"Serialization","text":"When implementing the serialization of a new type in a module that is not Oscar (e.g. in a submodule of Oscar) it is necessary to import the a lot of helper functions (see the examples above). To ease this process, the @import_all_serialization_functions macro can be used.","category":"page"},{"location":"DeveloperDocumentation/serialization/","page":"Serialization","title":"Serialization","text":"Oscar.@import_all_serialization_functions","category":"page"},{"location":"DeveloperDocumentation/serialization/#@import_all_serialization_functions","page":"Serialization","title":"@import_all_serialization_functions","text":"Oscar.@import_all_serialization_functions\n\nThis macro imports all serialization related functions that one may need for implementing serialization for custom types from Oscar into the current module. One can instead import the functions individually if needed but this macro is provided for convenience.\n\n\n\n\n\n","category":"macro"},{"location":"DeveloperDocumentation/serialization/#Serializers","page":"Serialization","title":"Serializers","text":"","category":"section"},{"location":"DeveloperDocumentation/serialization/","page":"Serialization","title":"Serialization","text":"The code for the different types of serializers and their states is found in the serializers.jl file. Different serializers have different use cases, the default serializer JSONSerializer is used for writing to a file. Currently the only other serializer is the IPCSerializer which at the moment is quite similar to the JSONSerializer except that it does not store the refs of any types that are registered with the uses_id flag. When using the IPCSerializer it is left up to the user to guarantee that any refs required by a process are sent prior.","category":"page"},{"location":"DeveloperDocumentation/serialization/#Upgrades","page":"Serialization","title":"Upgrades","text":"","category":"section"},{"location":"DeveloperDocumentation/serialization/","page":"Serialization","title":"Serialization","text":"All upgrade scripts can be found in the src/Serialization/Upgrades folder. The mechanics of upgrading are found in the main.jl file where the Oscar.upgrade function provides the core functionality. Upgrading is triggered during load when the version of the file format to be loaded is older than the current Oscar version.","category":"page"},{"location":"DeveloperDocumentation/serialization/","page":"Serialization","title":"Serialization","text":"Oscar.upgrade\nOscar.upgrade_data","category":"page"},{"location":"DeveloperDocumentation/serialization/#upgrade","page":"Serialization","title":"upgrade","text":"upgrade(format_version::VersionNumber, dict::Dict)\n\nFinds the first version where an upgrade can be applied and then incrementally upgrades to each intermediate version until the structure of the current version has been achieved.\n\n\n\n\n\n","category":"function"},{"location":"DeveloperDocumentation/serialization/#upgrade_data","page":"Serialization","title":"upgrade_data","text":"upgrade_data(upgrade::Function, s::UpgradeState, dict::Dict)\n\nupgrade_data is a helper function that provides functionality for recursing on the tree structure. It is independent of any particular file format version and can be used in any upgrade script.\n\n\n\n\n\n","category":"function"},{"location":"DeveloperDocumentation/serialization/#Upgrade-Scripts","page":"Serialization","title":"Upgrade Scripts","text":"","category":"section"},{"location":"DeveloperDocumentation/serialization/","page":"Serialization","title":"Serialization","text":"All upgrade scripts should be contained in a file named after the version they upgrade to. For example a script that upgrades to Oscar version 0.13.0 should be named 0.13.0.jl.","category":"page"},{"location":"DeveloperDocumentation/serialization/","page":"Serialization","title":"Serialization","text":"Oscar.UpgradeScript","category":"page"},{"location":"DeveloperDocumentation/serialization/#UpgradeScript","page":"Serialization","title":"UpgradeScript","text":"UpgradeScript(version::VersionNumber, script::Function)\n\nAny upgrade scripts should be created using the UpgradeScript constructor and then pushed to the upgrade_scripts_set. The name of the function is not particularly important however one should be assigned so that it can be used for recursion if necessary for upgrade. The upgrade script should be independent from any Oscar code and should rely solely on julia core functionality so to avoid conflicts with any future Oscar code deprecations.\n\nExamples\n\npush!(upgrade_scripts_set, UpgradeScript(\n  v\"0.13.0\",\n  function upgrade_0_13_0(s::UpgradeState, dict::Dict)\n      ...\n  end\n))\n\n\n\n\n\n","category":"type"},{"location":"DeveloperDocumentation/serialization/#Challenges","page":"Serialization","title":"Challenges","text":"","category":"section"},{"location":"DeveloperDocumentation/serialization/","page":"Serialization","title":"Serialization","text":"This section documents the various challenges we (will) encounter while implementing this feature.","category":"page"},{"location":"DeveloperDocumentation/serialization/","page":"Serialization","title":"Serialization","text":"OSCAR is based on several subsystems, some of which already have their own serialization. We want this to be compatible, if possible in both directions.\nMany mathematical objects need context to be understood. A polynomial needs the ring it lives in, a group element needs the surrounding group, a divisor needs the underlying variety, etc. We will need a way to store this context along the objects.\nContext should not be stored twice: A matrix of polynomials should only store the surrounding ring once.\nSupport other data formats: It has been proposed to not only support JSON, but binary formats needed for HPC communication as well. It is unclear whether this needs a separate implementation.\nVersioning and upgrading: Work on OSCAR will change what its objects look like. Nevertheless, we still want to be able load data written by older versions of OSCAR. For this we intend to develop an upgrade mechanism.","category":"page"},{"location":"DeveloperDocumentation/serialization/","page":"Serialization","title":"Serialization","text":"Another important point is the wider mathematical context of the data and code. For data associated to a publication, this context is provided by the paper.","category":"page"},{"location":"DeveloperDocumentation/serialization/#Goals","page":"Serialization","title":"Goals","text":"","category":"section"},{"location":"DeveloperDocumentation/serialization/","page":"Serialization","title":"Serialization","text":"The general goal is to make mathematical data FAIR, a goal for which we cooperate with the MaRDI project.","category":"page"},{"location":"DeveloperDocumentation/serialization/","page":"Serialization","title":"Serialization","text":"The ramifications of making mathematical data FAIR are manifold.","category":"page"},{"location":"DeveloperDocumentation/serialization/","page":"Serialization","title":"Serialization","text":"It becomes easier to exchange data and code with fellow mathematicians, enhancing communication and boosting research.\nComputer experiments and new implementations require a lot of work and hence deserve to be recognized in form of a publication. Standardizing data plays an important role for this process.\nFuture generations of mathematicians will be able to reuse both data and code if we establish a FAIR culture.","category":"page"},{"location":"DeveloperDocumentation/serialization/#External-Implementations","page":"Serialization","title":"External Implementations","text":"","category":"section"},{"location":"DeveloperDocumentation/serialization/","page":"Serialization","title":"Serialization","text":"Any external body implementing a save/load following the .mrdi format specification and using the OSCAR namespace should be sure to check validity against our schema defined here.","category":"page"},{"location":"DeveloperDocumentation/serialization/","page":"Serialization","title":"Serialization","text":"We make no attempt whatsoever to verify the mathematics of the file, and neither should anyone implementing a save/load. Loading should not throw a parse error if the mathematics of the file is incorrect, the file should be parsed and allow the computer algebra system to throw the error. We cannot guarantee that any file that has been manipulated by hand is still valid and should be validated against the schema. In the same way we cannot guarantee that any files created externally are valid in terms of the mathematics either, these will not lead to a parse error but instead will be handle as though the incorrect input has been passed to one of the Oscar functions.","category":"page"},{"location":"DeveloperDocumentation/serialization/","page":"Serialization","title":"Serialization","text":"External implementations should not be expected to read or write all possible Oscar types. It is perfectly valid for external implementations to throw parse errors when a certain file format is unexpected. For example Oscar will parse a QQFieldElem that has data value \"0 0 7 // - 1 0\" as -7//10, even though this is not how it is serialized. We feel we should not restrict users when deserializing to formats that may have issues deserializing the same format externally.","category":"page"},{"location":"DeveloperDocumentation/serialization/","page":"Serialization","title":"Serialization","text":"Allowing extensions to JSON is not recommended, this is to keep the scope of possible software that can parse the given JSON as large as possible. For example some JSON extensions allow comments in the files, Oscar cannot parse such JSONs and we recommend that any comments should be placed in the meta field.","category":"page"},{"location":"DeveloperDocumentation/serialization/","page":"Serialization","title":"Serialization","text":"When writing UUIDs, adhere to version four UUIDs specified by RFC 4122.","category":"page"},{"location":"CommutativeAlgebra/rings/","page":"Creating Multivariate Rings","title":"Creating Multivariate Rings","text":"CurrentModule = Oscar\nDocTestSetup = Oscar.doctestsetup()","category":"page"},{"location":"CommutativeAlgebra/rings/#Creating-Multivariate-Rings","page":"Creating Multivariate Rings","title":"Creating Multivariate Rings","text":"","category":"section"},{"location":"CommutativeAlgebra/rings/","page":"Creating Multivariate Rings","title":"Creating Multivariate Rings","text":"In this section, for the convenience of the reader, we recall from the chapters on rings and fields how to create multivariate polynomial rings and their elements, adding illustrating examples. At the same time, we introduce and illustrate a ring type for modelling multivariate polynomial rings with gradings.","category":"page"},{"location":"CommutativeAlgebra/rings/#Types","page":"Creating Multivariate Rings","title":"Types","text":"","category":"section"},{"location":"CommutativeAlgebra/rings/","page":"Creating Multivariate Rings","title":"Creating Multivariate Rings","text":"OSCAR provides types for dense univariate and sparse multivariate polynomials. The univariate ring types belong to the abstract type PolyRing{T}, their elements have abstract type PolyRingElem{T}. The multivariate ring types belong to the abstract type MPolyRing{T}, their elements have abstract type MPolyRingElem{T}. Here, T is the element type of the coefficient ring of the polynomial ring.","category":"page"},{"location":"CommutativeAlgebra/rings/#Constructors","page":"Creating Multivariate Rings","title":"Constructors","text":"","category":"section"},{"location":"CommutativeAlgebra/rings/","page":"Creating Multivariate Rings","title":"Creating Multivariate Rings","text":"The basic constructor below allows one to build multivariate polynomial rings:","category":"page"},{"location":"CommutativeAlgebra/rings/","page":"Creating Multivariate Rings","title":"Creating Multivariate Rings","text":"polynomial_ring(C::Ring, xs::AbstractVector{<:VarName}; cached::Bool = true)","category":"page"},{"location":"CommutativeAlgebra/rings/","page":"Creating Multivariate Rings","title":"Creating Multivariate Rings","text":"Given a ring C and a vector xs of  Symbols, Strings, or Characters, return  a tuple R, vars, say, which consists of a polynomial ring R with coefficient ring C and a vector vars of generators (variables) which print according to the entries of xs.","category":"page"},{"location":"CommutativeAlgebra/rings/","page":"Creating Multivariate Rings","title":"Creating Multivariate Rings","text":"note: Note\nCaching is used to ensure that a given ring constructed from given parameters is unique in the system. For example, there is only one ring of multivariate polynomials over  mathbbZ with variables printing as x, y, z.","category":"page"},{"location":"CommutativeAlgebra/rings/#Examples","page":"Creating Multivariate Rings","title":"Examples","text":"","category":"section"},{"location":"CommutativeAlgebra/rings/","page":"Creating Multivariate Rings","title":"Creating Multivariate Rings","text":"julia> R, (x, y, z) = polynomial_ring(ZZ, [:x, :y, :z])\n(Multivariate polynomial ring in 3 variables over ZZ, ZZMPolyRingElem[x, y, z])\n\njulia> typeof(R)\nZZMPolyRing\n\njulia> typeof(x)\nZZMPolyRingElem\n\njulia> S, (a, b, c) = polynomial_ring(ZZ, [:x, :y, :z])\n(Multivariate polynomial ring in 3 variables over ZZ, ZZMPolyRingElem[x, y, z])\n\njulia> T, _ = polynomial_ring(ZZ, [:x, :y, :z])\n(Multivariate polynomial ring in 3 variables over ZZ, ZZMPolyRingElem[x, y, z])\n\njulia> R === S === T\ntrue\n","category":"page"},{"location":"CommutativeAlgebra/rings/","page":"Creating Multivariate Rings","title":"Creating Multivariate Rings","text":"julia> R1, _ = polynomial_ring(ZZ, [:x, :y, :z]);\n\njulia> R2, _ = polynomial_ring(ZZ, [\"x\", \"y\", \"z\"]);\n\njulia> R3, _ = polynomial_ring(ZZ, ['x', 'y', 'z']);\n\njulia> R1 === R2 === R3\ntrue\n","category":"page"},{"location":"CommutativeAlgebra/rings/","page":"Creating Multivariate Rings","title":"Creating Multivariate Rings","text":"julia> R1, x = polynomial_ring(QQ, [:x])\n(Multivariate polynomial ring in 1 variable over QQ, QQMPolyRingElem[x])\n\njulia> typeof(x)\nVector{QQMPolyRingElem} (alias for Array{QQMPolyRingElem, 1})\n\njulia> R2, (x,) = polynomial_ring(QQ, [:x])\n(Multivariate polynomial ring in 1 variable over QQ, QQMPolyRingElem[x])\n\njulia> typeof(x)\nQQMPolyRingElem\n\njulia> R3, x = polynomial_ring(QQ, :x)\n(Univariate polynomial ring in x over QQ, x)\n\njulia> typeof(x)\nQQPolyRingElem\n","category":"page"},{"location":"CommutativeAlgebra/rings/","page":"Creating Multivariate Rings","title":"Creating Multivariate Rings","text":"julia> T, x = polynomial_ring(GF(3), [\"x[1]\", \"x[2]\"]);\n\njulia> x\n2-element Vector{FqMPolyRingElem}:\n x[1]\n x[2]\n","category":"page"},{"location":"CommutativeAlgebra/rings/","page":"Creating Multivariate Rings","title":"Creating Multivariate Rings","text":"The constructor illustrated below allows for the convenient handling of variables with multi-indices:","category":"page"},{"location":"CommutativeAlgebra/rings/","page":"Creating Multivariate Rings","title":"Creating Multivariate Rings","text":"julia> R, x, y, z = polynomial_ring(QQ, :x => (1:3, 1:4), :y => 1:2, :z => (1:1, 1:1, 1:1));\n\njulia> x\n3×4 Matrix{QQMPolyRingElem}:\n x[1, 1]  x[1, 2]  x[1, 3]  x[1, 4]\n x[2, 1]  x[2, 2]  x[2, 3]  x[2, 4]\n x[3, 1]  x[3, 2]  x[3, 3]  x[3, 4]\n\njulia> y\n2-element Vector{QQMPolyRingElem}:\n y[1]\n y[2]\n\njulia> z\n1×1×1 Array{QQMPolyRingElem, 3}:\n[:, :, 1] =\n z[1, 1, 1]\n","category":"page"},{"location":"CommutativeAlgebra/rings/#Coefficient-Rings","page":"Creating Multivariate Rings","title":"Coefficient Rings","text":"","category":"section"},{"location":"CommutativeAlgebra/rings/","page":"Creating Multivariate Rings","title":"Creating Multivariate Rings","text":"Gröbner and standard bases are implemented for multivariate polynomial rings over the fields and rings below:","category":"page"},{"location":"CommutativeAlgebra/rings/#The-field-of-rational-numbers-\\mathbb{Q}","page":"Creating Multivariate Rings","title":"The field of rational numbers mathbbQ","text":"","category":"section"},{"location":"CommutativeAlgebra/rings/","page":"Creating Multivariate Rings","title":"Creating Multivariate Rings","text":"julia> QQ\nRational field\n","category":"page"},{"location":"CommutativeAlgebra/rings/#Finite-fields-\\mathbb{F_p},-p-a-prime","page":"Creating Multivariate Rings","title":"Finite fields mathbbF_p, p a prime","text":"","category":"section"},{"location":"CommutativeAlgebra/rings/","page":"Creating Multivariate Rings","title":"Creating Multivariate Rings","text":"julia> GF(3)\nPrime field of characteristic 3\n\njulia> GF(ZZ(2)^127 - 1)\nPrime field of characteristic 170141183460469231731687303715884105727\n","category":"page"},{"location":"CommutativeAlgebra/rings/#Finite-fields-\\mathbb{F}_{pn}-with-pn-elements,-p-a-prime","page":"Creating Multivariate Rings","title":"Finite fields mathbbF_p^n with p^n elements, p a prime","text":"","category":"section"},{"location":"CommutativeAlgebra/rings/","page":"Creating Multivariate Rings","title":"Creating Multivariate Rings","text":"julia> finite_field(2, 70, \"a\")\n(Finite field of degree 70 and characteristic 2, a)\n","category":"page"},{"location":"CommutativeAlgebra/rings/#Simple-algebraic-extensions-of-\\mathbb{Q}-or-\\mathbb{F}_p","page":"Creating Multivariate Rings","title":"Simple algebraic extensions of mathbbQ or mathbbF_p","text":"","category":"section"},{"location":"CommutativeAlgebra/rings/","page":"Creating Multivariate Rings","title":"Creating Multivariate Rings","text":"julia> T, t = polynomial_ring(QQ, :t)\n(Univariate polynomial ring in t over QQ, t)\n\njulia> K, a = number_field(t^2 + 1, \"a\")\n(Number field of degree 2 over QQ, a)\n\njulia> F = GF(3)\nPrime field of characteristic 3\n\njulia> T, t = polynomial_ring(F, :t)\n(Univariate polynomial ring in t over F, t)\n\njulia> K, a = finite_field(t^2 + 1, \"a\")\n(Finite field of degree 2 and characteristic 3, a)\n","category":"page"},{"location":"CommutativeAlgebra/rings/#Purely-transcendental-extensions-of-\\mathbb{Q}-or-\\mathbb{F}_p","page":"Creating Multivariate Rings","title":"Purely transcendental extensions of mathbbQ or mathbbF_p","text":"","category":"section"},{"location":"CommutativeAlgebra/rings/","page":"Creating Multivariate Rings","title":"Creating Multivariate Rings","text":"julia> T, t = polynomial_ring(QQ, :t)\n(Univariate polynomial ring in t over QQ, t)\n\njulia> QT = fraction_field(T)\nFraction field\n  of univariate polynomial ring in t over QQ\n\njulia> parent(t)\nUnivariate polynomial ring in t over QQ\n\njulia> parent(1//t)\nFraction field\n  of univariate polynomial ring in t over QQ\n\njulia> T, (s, t) = polynomial_ring(GF(3), [:s, :t]);\n\njulia> QT = fraction_field(T)\nFraction field\n  of multivariate polynomial ring in 2 variables over GF(3)\n","category":"page"},{"location":"CommutativeAlgebra/rings/#The-ring-of-integers-\\mathbb{Z}","page":"Creating Multivariate Rings","title":"The ring of integers mathbbZ","text":"","category":"section"},{"location":"CommutativeAlgebra/rings/","page":"Creating Multivariate Rings","title":"Creating Multivariate Rings","text":"julia> ZZ\nInteger ring\n","category":"page"},{"location":"CommutativeAlgebra/rings/#Gradings","page":"Creating Multivariate Rings","title":"Gradings","text":"","category":"section"},{"location":"CommutativeAlgebra/rings/","page":"Creating Multivariate Rings","title":"Creating Multivariate Rings","text":"Given a polynomial ring R = Cx_1 dots x_n, we may endow R with various gradings. The standard mathbb Z-grading  on R is the decomposition R=bigoplus_din mathbb Z R_d=bigoplus_dgeq 0 R_d by the usual degree of polynomials. More general mathbb Z-gradings are obtained by assigning integer weights to the variables and considering the corresponding weighted degrees. Even more generally, we may consider multigradings: Given a finitely generated abelian group G, a multigrading on R by G, or a G-grading, or simply a grading, corresponds to a semigroup homomorphism phi mathbb N^n to G: Given phi, the degree of a monomial x^alpha is the image deg(x^alpha)=phi(alpha)in G; the induced G-grading on R is the decomposition R = bigoplus_gin G R_g satisfying R_gcdot R_hsubset R_g+h, where R_g is the free C-module generated by the monomials of degree g. This grading is determined by assigning the weights deg(x_i) to the x_i. In other words, it is determined by  the weight vector W = (deg(x_1) dots deg(x_n))in G^n","category":"page"},{"location":"CommutativeAlgebra/rings/","page":"Creating Multivariate Rings","title":"Creating Multivariate Rings","text":"We refer to the textbooks [MS05] and [KR05] for details on multigradings. With respect to notation, we follow the former book.","category":"page"},{"location":"CommutativeAlgebra/rings/","page":"Creating Multivariate Rings","title":"Creating Multivariate Rings","text":"note: Note\nGiven a G-grading on R, we refer to G as the grading group of R. Moreover, we then say that R is G-graded, or simply that R is graded. If R is a polynomial ring over a field, we say that a G-grading on R is positive if G is free and each graded part R_g, gin G, has finite dimension. We then also say that R is positively graded (by G). Note that the positivity condition can be equivalently expressed by asking that G is free and that the degree zero part consists of the constants only (see Theorem 8.6 in [MS05]).","category":"page"},{"location":"CommutativeAlgebra/rings/","page":"Creating Multivariate Rings","title":"Creating Multivariate Rings","text":"note: Note\nGiven a  G-grading on R in OSCAR, we say that R is mathbb Z^m-graded if is_free(G) && number_of_generators(G) == rank(G) == m evaluates to true. In this case, conversion routines allow one to switch back and forth between elements of G and integer vectors of length m. Specifically, if R is mathbb Z-graded, that is, is_free(G) && number_of_generators(G) == rank(G) == 1 evaluates to true,  elements of G may be converted to integers and vice versa.","category":"page"},{"location":"CommutativeAlgebra/rings/#Types-2","page":"Creating Multivariate Rings","title":"Types","text":"","category":"section"},{"location":"CommutativeAlgebra/rings/","page":"Creating Multivariate Rings","title":"Creating Multivariate Rings","text":"Multivariate rings with gradings are modeled by objects of type MPolyDecRing{T, S}  :< MPolyRing{T}, with elements of type MPolyRingElem_dec{T, S}  :< MPolyRingElem{T}. Here, S is the element type of the multivariate ring, and  T is the element type of its coefficient ring as above.","category":"page"},{"location":"CommutativeAlgebra/rings/","page":"Creating Multivariate Rings","title":"Creating Multivariate Rings","text":"note: Note\nThe types MPolyDecRing{T, S} and MPolyRingElem_dec{T, S} are also meant to eventually model multivariate rings with filtrations and their elements.","category":"page"},{"location":"CommutativeAlgebra/rings/","page":"Creating Multivariate Rings","title":"Creating Multivariate Rings","text":"The following function allows one, in particular, to distinguish between graded and filtered rings.","category":"page"},{"location":"CommutativeAlgebra/rings/","page":"Creating Multivariate Rings","title":"Creating Multivariate Rings","text":"is_graded(R::MPolyRing)","category":"page"},{"location":"CommutativeAlgebra/rings/#is_graded-Tuple{MPolyRing}","page":"Creating Multivariate Rings","title":"is_graded","text":"is_graded(R::MPolyRing)\n\nReturn true if R is graded, false otherwise.\n\n\n\n\n\n","category":"method"},{"location":"CommutativeAlgebra/rings/#Constructors-for-Graded-Rings","page":"Creating Multivariate Rings","title":"Constructors for Graded Rings","text":"","category":"section"},{"location":"CommutativeAlgebra/rings/","page":"Creating Multivariate Rings","title":"Creating Multivariate Rings","text":"There are two basic ways of creating multivariate rings with gradings: While the grade function allows one to create a graded ring by assigning a grading to a polynomial ring already constructed, the graded_polynomial_ring function is meant to create a graded polynomial ring all at once.","category":"page"},{"location":"CommutativeAlgebra/rings/","page":"Creating Multivariate Rings","title":"Creating Multivariate Rings","text":"grade(R::MPolyRing, W::Vector{FinGenAbGroupElem})","category":"page"},{"location":"CommutativeAlgebra/rings/#grade-Tuple{MPolyRing, Vector{FinGenAbGroupElem}}","page":"Creating Multivariate Rings","title":"grade","text":"grade(R::MPolyRing, W::Vector{FinGenAbGroupElem})\n\nGiven a vector W of ngens(R) elements of a finitely presented group G, say, create a G-graded ring by assigning the entries of W as weights to the variables of R. Return the new ring as an object of type MPolyDecRing, together with the vector of variables.\n\nExamples\n\njulia> R, (t, x, y) = polynomial_ring(QQ, [:t, :x, :y])\n(Multivariate polynomial ring in 3 variables over QQ, QQMPolyRingElem[t, x, y])\n\njulia> typeof(R)\nQQMPolyRing\n\njulia>  typeof(x)\nQQMPolyRingElem\n\njulia> G = abelian_group([0])\nZ\n\njulia> g = gen(G, 1)\nAbelian group element [1]\n\njulia> S, (t, x, y) = grade(R, [-g, g, g])\n(Graded multivariate polynomial ring in 3 variables over QQ, MPolyDecRingElem{QQFieldElem, QQMPolyRingElem}[t, x, y])\n\njulia> typeof(S)\nMPolyDecRing{QQFieldElem, QQMPolyRing}\n\njulia> S isa MPolyRing\ntrue\n\njulia> typeof(x)\nMPolyDecRingElem{QQFieldElem, QQMPolyRingElem}\n\njulia> R, x, y = polynomial_ring(QQ, :x => 1:2, :y => 1:3)\n(Multivariate polynomial ring in 5 variables over QQ, QQMPolyRingElem[x[1], x[2]], QQMPolyRingElem[y[1], y[2], y[3]])\n\njulia> G = abelian_group([0, 0])\nZ^2\n\njulia> g = gens(G)\n2-element Vector{FinGenAbGroupElem}:\n [1, 0]\n [0, 1]\n\njulia> W = [g[1], g[1], g[2], g[2], g[2]];\n\njulia> S, _ = grade(R, W)\n(Graded multivariate polynomial ring in 5 variables over QQ, MPolyDecRingElem{QQFieldElem, QQMPolyRingElem}[x[1], x[2], y[1], y[2], y[3]])\n\njulia> typeof(x[1])\nQQMPolyRingElem\n\njulia> x = map(S, x)\n2-element Vector{MPolyDecRingElem{QQFieldElem, QQMPolyRingElem}}:\n x[1]\n x[2]\n\njulia> y = map(S, y)\n3-element Vector{MPolyDecRingElem{QQFieldElem, QQMPolyRingElem}}:\n y[1]\n y[2]\n y[3]\n\njulia> typeof(x[1])\nMPolyDecRingElem{QQFieldElem, QQMPolyRingElem}\n\njulia> R, x = polynomial_ring(QQ, :x => 1:5)\n(Multivariate polynomial ring in 5 variables over QQ, QQMPolyRingElem[x[1], x[2], x[3], x[4], x[5]])\n\njulia> G = abelian_group([0, 0, 2, 2])\nFinitely generated abelian group\n  with 4 generators and 4 relations and relation matrix\n  [0   0   0   0]\n  [0   0   0   0]\n  [0   0   2   0]\n  [0   0   0   2]\n\njulia> g = gens(G);\n\njulia> W = [g[1]+g[3]+g[4], g[2]+g[4], g[1]+g[3], g[2], g[1]+g[2]]\n5-element Vector{FinGenAbGroupElem}:\n [1, 0, 1, 1]\n [0, 1, 0, 1]\n [1, 0, 1, 0]\n [0, 1, 0, 0]\n [1, 1, 0, 0]\n\njulia> S, x = grade(R, W)\n(Graded multivariate polynomial ring in 5 variables over QQ, MPolyDecRingElem{QQFieldElem, QQMPolyRingElem}[x[1], x[2], x[3], x[4], x[5]])\n\n\n\n\n\n","category":"method"},{"location":"CommutativeAlgebra/rings/","page":"Creating Multivariate Rings","title":"Creating Multivariate Rings","text":"grade(R::MPolyRing, W::Vector{<:Vector{<:IntegerUnion}})","category":"page"},{"location":"CommutativeAlgebra/rings/#grade-Tuple{MPolyRing, Vector{<:Vector{<:Union{Integer, ZZRingElem}}}}","page":"Creating Multivariate Rings","title":"grade","text":"grade(R::MPolyRing, W::AbstractVector{<:AbstractVector{<:IntegerUnion}})\n\nGiven a vector W of ngens(R) integer vectors of the same size m, say, create a free abelian group of type FinGenAbGroup given by m free generators, and convert the vectors in W to elements of that group. Then create a mathbb Z^m-graded ring by assigning the group elements as weights to the variables of R, and return the new ring, together with the vector of variables.\n\ngrade(R::MPolyRing, W::Union{ZZMatrix, AbstractMatrix{<:IntegerUnion}})\n\nAs above, converting the columns of W.\n\nExamples\n\njulia> R, x, y = polynomial_ring(QQ, :x => 1:2, :y => 1:3)\n(Multivariate polynomial ring in 5 variables over QQ, QQMPolyRingElem[x[1], x[2]], QQMPolyRingElem[y[1], y[2], y[3]])\n\njulia> W = [1 1 0 0 0; 0 0 1 1 1]\n2×5 Matrix{Int64}:\n 1  1  0  0  0\n 0  0  1  1  1\n\njulia> grade(R, W)\n(Graded multivariate polynomial ring in 5 variables over QQ, MPolyDecRingElem{QQFieldElem, QQMPolyRingElem}[x[1], x[2], y[1], y[2], y[3]])\n\n\n\n\n\n","category":"method"},{"location":"CommutativeAlgebra/rings/","page":"Creating Multivariate Rings","title":"Creating Multivariate Rings","text":"grade(R::MPolyRing, W::Vector{<:IntegerUnion})","category":"page"},{"location":"CommutativeAlgebra/rings/#grade-Tuple{MPolyRing, Vector{<:Union{Integer, ZZRingElem}}}","page":"Creating Multivariate Rings","title":"grade","text":"grade(R::MPolyRing, W::AbstractVector{<:IntegerUnion})\n\nGiven a vector W of ngens(R) integers, create a free abelian group of type FinGenAbGroup given by one free generator, and convert the entries of W to elements of that group. Then create a mathbb Z-graded ring by assigning the group elements as weights to the variables of R, and return the new ring, together with the vector of variables.\n\ngrade(R::MPolyRing)\n\nAs above, where the grading is the standard mathbb Z-grading on R.\n\nExamples\n\njulia> R, (x, y, z) = polynomial_ring(QQ, [:x, :y, :z])\n(Multivariate polynomial ring in 3 variables over QQ, QQMPolyRingElem[x, y, z])\n\njulia> W = [1, 2, 3];\n\njulia> S, (x, y, z) = grade(R, W)\n(Graded multivariate polynomial ring in 3 variables over QQ, MPolyDecRingElem{QQFieldElem, QQMPolyRingElem}[x, y, z])\n\njulia> T, (x, y, z) = grade(R)\n(Graded multivariate polynomial ring in 3 variables over QQ, MPolyDecRingElem{QQFieldElem, QQMPolyRingElem}[x, y, z])\n\n\n\n\n\n","category":"method"},{"location":"CommutativeAlgebra/rings/","page":"Creating Multivariate Rings","title":"Creating Multivariate Rings","text":"graded_polynomial_ring(C::Ring, V::Vector{String}, W)","category":"page"},{"location":"CommutativeAlgebra/rings/#graded_polynomial_ring-Tuple{Ring, Vector{String}, Any}","page":"Creating Multivariate Rings","title":"graded_polynomial_ring","text":"graded_polynomial_ring(C::Ring, args...; weights, kwargs...)\n\nCreate a multivariate polynomial_ring with coefficient ring C and variables as described by args... (using the exact same syntax as polynomial_ring), and grade this ring according to the data provided by the keyword argument weights. Return the graded ring as an object of type MPolyDecRing, together with the variables.\n\nIf weights is omitted the grading is the standard mathbb Z-grading, i.e. all variables are graded with weight 1.\n\nExamples\n\njulia> W = [[1, 0], [0, 1], [1, 0], [4, 1]]\n4-element Vector{Vector{Int64}}:\n [1, 0]\n [0, 1]\n [1, 0]\n [4, 1]\n\njulia> R, x = graded_polynomial_ring(QQ, 4, :x; weights = W)\n(Graded multivariate polynomial ring in 4 variables over QQ, MPolyDecRingElem{QQFieldElem, QQMPolyRingElem}[x1, x2, x3, x4])\n\njulia> S, (x, y, z) = graded_polynomial_ring(QQ, [:x, :y, :z]; weights = [1, 2, 3])\n(Graded multivariate polynomial ring in 3 variables over QQ, MPolyDecRingElem{QQFieldElem, QQMPolyRingElem}[x, y, z])\n\njulia> T, x = graded_polynomial_ring(QQ, :x => 1:3)\n(Graded multivariate polynomial ring in 3 variables over QQ, MPolyDecRingElem{QQFieldElem, QQMPolyRingElem}[x[1], x[2], x[3]])\n\njulia> T, x, y = graded_polynomial_ring(QQ, :x => 1:3, :y => (1:2, 1:2); weights=1:7)\n(Graded multivariate polynomial ring in 7 variables over QQ, MPolyDecRingElem{QQFieldElem, QQMPolyRingElem}[x[1], x[2], x[3]], MPolyDecRingElem{QQFieldElem, QQMPolyRingElem}[y[1, 1] y[1, 2]; y[2, 1] y[2, 2]])\n\n\n\n\n\n","category":"method"},{"location":"CommutativeAlgebra/rings/#Tests-on-Graded-Rings","page":"Creating Multivariate Rings","title":"Tests on Graded Rings","text":"","category":"section"},{"location":"CommutativeAlgebra/rings/","page":"Creating Multivariate Rings","title":"Creating Multivariate Rings","text":"is_standard_graded(R::MPolyDecRing)","category":"page"},{"location":"CommutativeAlgebra/rings/#is_standard_graded-Tuple{MPolyDecRing}","page":"Creating Multivariate Rings","title":"is_standard_graded","text":"is_standard_graded(R::MPolyDecRing)\n\nReturn true if R is standard mathbb Z-graded, false otherwise.\n\nExamples\n\njulia> S, (x, y, z) = graded_polynomial_ring(QQ, [:x, :y, :z]; weights = [1, 2, 3])\n(Graded multivariate polynomial ring in 3 variables over QQ, MPolyDecRingElem{QQFieldElem, QQMPolyRingElem}[x, y, z])\n\njulia> is_standard_graded(S)\nfalse\n\n\n\n\n\n","category":"method"},{"location":"CommutativeAlgebra/rings/","page":"Creating Multivariate Rings","title":"Creating Multivariate Rings","text":"is_z_graded(R::MPolyDecRing)","category":"page"},{"location":"CommutativeAlgebra/rings/#is_z_graded-Tuple{MPolyDecRing}","page":"Creating Multivariate Rings","title":"is_z_graded","text":"is_z_graded(R::MPolyDecRing)\n\nReturn true if R is mathbb Z-graded, false otherwise.\n\nnote: Note\nWriting G = grading_group(R), we say that R is mathbb Z-graded if G is free abelian of rank 1, and ngens(G) == 1.\n\nExamples\n\njulia> S, (x, y, z) = graded_polynomial_ring(QQ, [:x, :y, :z]; weights = [1, 2, 3])\n(Graded multivariate polynomial ring in 3 variables over QQ, MPolyDecRingElem{QQFieldElem, QQMPolyRingElem}[x, y, z])\n\njulia> is_z_graded(S)\ntrue\n\n\n\n\n\n","category":"method"},{"location":"CommutativeAlgebra/rings/","page":"Creating Multivariate Rings","title":"Creating Multivariate Rings","text":"is_zm_graded(R::MPolyDecRing)","category":"page"},{"location":"CommutativeAlgebra/rings/#is_zm_graded-Tuple{MPolyDecRing}","page":"Creating Multivariate Rings","title":"is_zm_graded","text":"is_zm_graded(R::MPolyDecRing)\n\nReturn true if R is mathbb Z^m-graded for some m, false otherwise.\n\nnote: Note\nWriting G = grading_group(R), we say that R is mathbb Z^m-graded G is free abelian of rank m, and ngens(G) == m.\n\nExamples\n\njulia> G = abelian_group([0, 0, 2, 2])\nFinitely generated abelian group\n  with 4 generators and 4 relations and relation matrix\n  [0   0   0   0]\n  [0   0   0   0]\n  [0   0   2   0]\n  [0   0   0   2]\n\njulia> W = [G[1]+G[3]+G[4], G[2]+G[4], G[1]+G[3], G[2], G[1]+G[2]];\n\njulia> S, x = graded_polynomial_ring(QQ, :x => 1:5; weights=W)\n(Graded multivariate polynomial ring in 5 variables over QQ, MPolyDecRingElem{QQFieldElem, QQMPolyRingElem}[x[1], x[2], x[3], x[4], x[5]])\n\njulia> is_zm_graded(S)\nfalse\n\njulia> G = abelian_group(ZZMatrix([1 -1]));\n\njulia> g = gen(G, 1)\nAbelian group element [0, 1]\n\njulia> W = [g, g, g, g];\n\njulia> R, (w, x, y, z) = graded_polynomial_ring(QQ, [:w, :x, :y, :z], W);\n\njulia> is_free(G)\ntrue\n\njulia> is_zm_graded(R)\nfalse\n\n\n\n\n\n","category":"method"},{"location":"CommutativeAlgebra/rings/","page":"Creating Multivariate Rings","title":"Creating Multivariate Rings","text":"is_positively_graded(R::MPolyDecRing)","category":"page"},{"location":"CommutativeAlgebra/rings/#is_positively_graded-Tuple{MPolyDecRing}","page":"Creating Multivariate Rings","title":"is_positively_graded","text":"is_positively_graded(R::MPolyDecRing)\n\nReturn true if R is positively graded, false otherwise.\n\nnote: Note\nWe say that R is positively graded by a finitely generated abelian group G if the coefficient ring of R is a field, G is free, and each graded part R_g, gin G, has finite dimension.\n\nExamples\n\njulia> S, (t, x, y) = graded_polynomial_ring(QQ, [:t, :x, :y]; weights = [-1, 1, 1])\n(Graded multivariate polynomial ring in 3 variables over QQ, MPolyDecRingElem{QQFieldElem, QQMPolyRingElem}[t, x, y])\n\njulia> is_positively_graded(S)\nfalse\n\njulia> G = abelian_group([0, 2])\nFinitely generated abelian group\n  with 2 generators and 2 relations and relation matrix\n  [0   0]\n  [0   2]\n\njulia> W = [gen(G, 1)+gen(G, 2), gen(G, 1)]\n2-element Vector{FinGenAbGroupElem}:\n [1, 1]\n [1, 0]\n\njulia> S, (x, y) = graded_polynomial_ring(QQ, [:x, :y]; weights = W)\n(Graded multivariate polynomial ring in 2 variables over QQ, MPolyDecRingElem{QQFieldElem, QQMPolyRingElem}[x, y])\n\njulia> is_positively_graded(S)\nfalse\n\n\n\n\n\n","category":"method"},{"location":"CommutativeAlgebra/rings/#Data-Associated-to-Multivariate-Rings","page":"Creating Multivariate Rings","title":"Data Associated to Multivariate Rings","text":"","category":"section"},{"location":"CommutativeAlgebra/rings/","page":"Creating Multivariate Rings","title":"Creating Multivariate Rings","text":"Given a multivariate polynomial ring R with coefficient ring C,","category":"page"},{"location":"CommutativeAlgebra/rings/","page":"Creating Multivariate Rings","title":"Creating Multivariate Rings","text":"coefficient_ring(R) refers to C,\ngens(R) to the generators (variables) of R,\nnumber_of_generators(R) / ngens(R) to the number of these generators, and\ngen(R, i) as well as R[i] to the i-th such generator.","category":"page"},{"location":"CommutativeAlgebra/rings/#Examples-2","page":"Creating Multivariate Rings","title":"Examples","text":"","category":"section"},{"location":"CommutativeAlgebra/rings/","page":"Creating Multivariate Rings","title":"Creating Multivariate Rings","text":"julia> R, (x, y, z) = polynomial_ring(QQ, [:x, :y, :z])\n(Multivariate polynomial ring in 3 variables over QQ, QQMPolyRingElem[x, y, z])\n\njulia> coefficient_ring(R)\nRational field\n\njulia> gens(R)\n3-element Vector{QQMPolyRingElem}:\n x\n y\n z\n\njulia> gen(R, 2)\ny\n\njulia> R[3]\nz\n\njulia> number_of_generators(R)\n3\n","category":"page"},{"location":"CommutativeAlgebra/rings/","page":"Creating Multivariate Rings","title":"Creating Multivariate Rings","text":"In the graded case, we additionally have:","category":"page"},{"location":"CommutativeAlgebra/rings/","page":"Creating Multivariate Rings","title":"Creating Multivariate Rings","text":"grading_group(R::MPolyDecRing)","category":"page"},{"location":"CommutativeAlgebra/rings/#grading_group-Tuple{MPolyDecRing}","page":"Creating Multivariate Rings","title":"grading_group","text":"grading_group(R::MPolyDecRing)\n\nIf R is, say, G-graded, then return G.\n\nExamples\n\njulia> R, (x, y, z) = graded_polynomial_ring(QQ, [:x, :y, :z], [1, 2, 3])\n(Graded multivariate polynomial ring in 3 variables over QQ, MPolyDecRingElem{QQFieldElem, QQMPolyRingElem}[x, y, z])\n\njulia> grading_group(R)\nZ\n\n\n\n\n\n","category":"method"},{"location":"CommutativeAlgebra/rings/","page":"Creating Multivariate Rings","title":"Creating Multivariate Rings","text":"monomial_basis(R::MPolyDecRing, g::FinGenAbGroupElem)","category":"page"},{"location":"CommutativeAlgebra/rings/#monomial_basis-Tuple{MPolyDecRing, FinGenAbGroupElem}","page":"Creating Multivariate Rings","title":"monomial_basis","text":"monomial_basis(R::MPolyDecRing, g::FinGenAbGroupElem)\n\nGiven a polynomial ring R over a field which is graded by a free group of type FinGenAbGroup, and given an element g of that group, return the monomials of degree g in R.\n\nmonomial_basis(R::MPolyDecRing, W::Vector{<:IntegerUnion})\n\nGiven a mathbb  Z^m-graded polynomial ring R over a field and a vector W of m integers, convert W into an element g of the grading group of R and proceed as above.\n\nmonomial_basis(R::MPolyDecRing, d::IntegerUnion)\n\nGiven a mathbb  Z-graded polynomial ring R over a field and an integer d, convert d into an element g of the grading group of R and proceed as above.\n\nnote: Note\nIf the component of the given degree is not finite dimensional, an error message will be thrown.\n\nExamples\n\njulia> T, (x, y, z) = graded_polynomial_ring(QQ, [:x, :y, :z]);\n\njulia> G = grading_group(T)\nZ\n\njulia> L = monomial_basis(T, 2)\n6-element Vector{MPolyDecRingElem{QQFieldElem, QQMPolyRingElem}}:\n z^2\n y*z\n y^2\n x*z\n x*y\n x^2\n\n\n\n\n\n","category":"method"},{"location":"CommutativeAlgebra/rings/","page":"Creating Multivariate Rings","title":"Creating Multivariate Rings","text":"homogeneous_component(R::MPolyDecRing, g::FinGenAbGroupElem)","category":"page"},{"location":"CommutativeAlgebra/rings/#homogeneous_component-Tuple{MPolyDecRing, FinGenAbGroupElem}","page":"Creating Multivariate Rings","title":"homogeneous_component","text":"homogeneous_component(R::MPolyDecRing, g::FinGenAbGroupElem)\n\nGiven a polynomial ring R over a field which is graded by a free group, and given an element g of that group, return the homogeneous component of R of degree g as a standard vector space. Additionally, return the map which sends an element of that vector space to the corresponding monomial in R.\n\nhomogeneous_component(R::MPolyDecRing, W::Vector{<:IntegerUnion})\n\nGiven a mathbb  Z^m-graded polynomial ring R over a field, and given a vector W of m integers, convert W into an element g of the grading group of R and proceed as above.\n\nhomogeneous_component(R::MPolyDecRing, d::IntegerUnion)\n\nGiven a mathbb  Z-graded polynomial ring R over a field, and given an integer d, convert d into an element g of the grading group of R proceed as above.\n\nnote: Note\nIf the component is not finite dimensional, an error will be thrown.\n\nExamples\n\njulia> W = [1 1 0 0 0; 0 0 1 1 1]\n2×5 Matrix{Int64}:\n 1  1  0  0  0\n 0  0  1  1  1\n\njulia> S, _ = graded_polynomial_ring(QQ, :x => 1:2, :y => 1:3; weights = W);\n\njulia> G = grading_group(S)\nZ^2\n\njulia> L = homogeneous_component(S, [1, 1]);\n\njulia> L[1]\nS_[1 1] of dim 6\n\njulia> FG = gens(L[1]);\n\njulia> EMB = L[2]\nMap defined by a julia-function with inverse\n  from S_[1 1] of dim 6\n  to graded multivariate polynomial ring in 5 variables over QQ\n\njulia> for i in 1:length(FG) println(EMB(FG[i])) end\nx[2]*y[3]\nx[2]*y[2]\nx[2]*y[1]\nx[1]*y[3]\nx[1]*y[2]\nx[1]*y[1]\n\n\n\n\n\n","category":"method"},{"location":"CommutativeAlgebra/rings/","page":"Creating Multivariate Rings","title":"Creating Multivariate Rings","text":"forget_grading(R::MPolyDecRing)","category":"page"},{"location":"CommutativeAlgebra/rings/#forget_grading-Tuple{MPolyDecRing}","page":"Creating Multivariate Rings","title":"forget_grading","text":"forget_grading(R::MPolyDecRing)\n\nReturn the ungraded undecorated ring.\n\n\n\n\n\n","category":"method"},{"location":"CommutativeAlgebra/rings/#Elements-of-Multivariate-Rings","page":"Creating Multivariate Rings","title":"Elements of Multivariate Rings","text":"","category":"section"},{"location":"CommutativeAlgebra/rings/#Constructors-2","page":"Creating Multivariate Rings","title":"Constructors","text":"","category":"section"},{"location":"CommutativeAlgebra/rings/","page":"Creating Multivariate Rings","title":"Creating Multivariate Rings","text":"One way to create elements of a multivariate  polynomial ring is to build up polynomials from the generators (variables) of the ring using basic arithmetic as shown below:","category":"page"},{"location":"CommutativeAlgebra/rings/#Examples-3","page":"Creating Multivariate Rings","title":"Examples","text":"","category":"section"},{"location":"CommutativeAlgebra/rings/","page":"Creating Multivariate Rings","title":"Creating Multivariate Rings","text":"julia> R, (x, y, z) = polynomial_ring(QQ, [:x, :y, :z])\n(Multivariate polynomial ring in 3 variables over QQ, QQMPolyRingElem[x, y, z])\n\njulia> f = 3*x^2+y*z\n3*x^2 + y*z\n\njulia> typeof(f)\nQQMPolyRingElem\n\njulia> S, (x, y, z) = grade(R)\n(Graded multivariate polynomial ring in 3 variables over QQ, MPolyDecRingElem{QQFieldElem, QQMPolyRingElem}[x, y, z])\n\njulia> g = 3*x^2+y*z\n3*x^2 + y*z\n\njulia> typeof(g)\nMPolyDecRingElem{QQFieldElem, QQMPolyRingElem}\n\njulia> g == S(f)\ntrue\n","category":"page"},{"location":"CommutativeAlgebra/rings/","page":"Creating Multivariate Rings","title":"Creating Multivariate Rings","text":"Alternatively, there is the following constructor:","category":"page"},{"location":"CommutativeAlgebra/rings/","page":"Creating Multivariate Rings","title":"Creating Multivariate Rings","text":"(R::MPolyRing{T})(c::Vector{T}, e::Vector{Vector{Int}}) where T <: RingElem","category":"page"},{"location":"CommutativeAlgebra/rings/","page":"Creating Multivariate Rings","title":"Creating Multivariate Rings","text":"Its return value is the element of  R  whose nonzero coefficients are specified by the elements of c, with exponent vectors given by the elements of e.","category":"page"},{"location":"CommutativeAlgebra/rings/#Examples-4","page":"Creating Multivariate Rings","title":"Examples","text":"","category":"section"},{"location":"CommutativeAlgebra/rings/","page":"Creating Multivariate Rings","title":"Creating Multivariate Rings","text":"julia> R, (x, y, z) = polynomial_ring(QQ, [:x, :y, :z])\n(Multivariate polynomial ring in 3 variables over QQ, QQMPolyRingElem[x, y, z])\n\njulia> f = 3*x^2+y*z\n3*x^2 + y*z\n\njulia> g = R(QQ.([3, 1]), [[2, 0, 0], [0, 1, 1]])\n3*x^2 + y*z\n\njulia> f == g\ntrue\n","category":"page"},{"location":"CommutativeAlgebra/rings/","page":"Creating Multivariate Rings","title":"Creating Multivariate Rings","text":"An often more effective way to create polynomials is to use the MPoly build context as indicated below:","category":"page"},{"location":"CommutativeAlgebra/rings/","page":"Creating Multivariate Rings","title":"Creating Multivariate Rings","text":"julia> R, (x, y) = polynomial_ring(QQ, [:x, :y])\n(Multivariate polynomial ring in 2 variables over QQ, QQMPolyRingElem[x, y])\n\njulia> B = MPolyBuildCtx(R)\nBuilder for an element of R\n\njulia> for i = 1:5 push_term!(B, QQ(i), [i, i-1]) end\n\njulia> finish(B)\n5*x^5*y^4 + 4*x^4*y^3 + 3*x^3*y^2 + 2*x^2*y + x\n","category":"page"},{"location":"CommutativeAlgebra/rings/#Special-Elements","page":"Creating Multivariate Rings","title":"Special Elements","text":"","category":"section"},{"location":"CommutativeAlgebra/rings/","page":"Creating Multivariate Rings","title":"Creating Multivariate Rings","text":"Given a multivariate polynomial ring R, zero(R) and one(R) refer to the additive and multiplicative identity of R, respectively. Relevant test calls on an element f of R are  iszero(f) and isone(f).","category":"page"},{"location":"CommutativeAlgebra/rings/#Data-Associated-to-Elements-of-Multivariate-Rings","page":"Creating Multivariate Rings","title":"Data Associated to Elements of Multivariate Rings","text":"","category":"section"},{"location":"CommutativeAlgebra/rings/","page":"Creating Multivariate Rings","title":"Creating Multivariate Rings","text":"Given an element f of a multivariate polynomial ring R or a graded version of such a ring, ","category":"page"},{"location":"CommutativeAlgebra/rings/","page":"Creating Multivariate Rings","title":"Creating Multivariate Rings","text":"parent(f) refers to R, and\ntotal_degree(f) to the total degree of f.","category":"page"},{"location":"CommutativeAlgebra/rings/","page":"Creating Multivariate Rings","title":"Creating Multivariate Rings","text":"note: Note\nGiven a set of variables x = x_1 ldots x_n, the total degree of a monomial x^alpha=x_1^alpha_1cdots x_n^alpha_nintextMon_n(x) is the sum of the alpha_i. The total degree of a polynomial f  is the maximum of the total degrees of its monomials. In particular, the notion of total degree ignores the weights given to the variables in the graded case.","category":"page"},{"location":"CommutativeAlgebra/rings/","page":"Creating Multivariate Rings","title":"Creating Multivariate Rings","text":"For iterators which allow one to recover the monomials  (terms, dots) of f we refer to the subsection Monomials, Terms, and More of the section on Gröbner/Standard Bases.","category":"page"},{"location":"CommutativeAlgebra/rings/#Examples-5","page":"Creating Multivariate Rings","title":"Examples","text":"","category":"section"},{"location":"CommutativeAlgebra/rings/","page":"Creating Multivariate Rings","title":"Creating Multivariate Rings","text":"julia> R, (x, y) = polynomial_ring(GF(5), [:x, :y])\n(Multivariate polynomial ring in 2 variables over GF(5), FqMPolyRingElem[x, y])\n\njulia> c = map(GF(5), [1, 2, 3])\n3-element Vector{FqFieldElem}:\n 1\n 2\n 3\n\njulia> e = [[3, 2], [1, 0], [0, 1]]\n3-element Vector{Vector{Int64}}:\n [3, 2]\n [1, 0]\n [0, 1]\n\njulia> f = R(c, e)\nx^3*y^2 + 2*x + 3*y\n\njulia> parent(f)\nMultivariate polynomial ring in 2 variables x, y\n  over prime field of characteristic 5\n\njulia> total_degree(f)\n5","category":"page"},{"location":"CommutativeAlgebra/rings/","page":"Creating Multivariate Rings","title":"Creating Multivariate Rings","text":"Further functionality is available in the graded case:","category":"page"},{"location":"CommutativeAlgebra/rings/","page":"Creating Multivariate Rings","title":"Creating Multivariate Rings","text":"homogeneous_components(f::MPolyDecRingElem{T, S}) where {T, S}","category":"page"},{"location":"CommutativeAlgebra/rings/#homogeneous_components-Union{Tuple{MPolyDecRingElem{T, S}}, Tuple{S}, Tuple{T}} where {T, S}","page":"Creating Multivariate Rings","title":"homogeneous_components","text":"homogeneous_components(f::MPolyDecRingElem{T, S}) where {T, S}\n\nGiven an element f of a graded multivariate ring, return the homogeneous components of f.\n\nExamples\n\njulia> R, (x, y, z) = graded_polynomial_ring(QQ, [:x, :y, :z], [1, 2, 3])\n(Graded multivariate polynomial ring in 3 variables over QQ, MPolyDecRingElem{QQFieldElem, QQMPolyRingElem}[x, y, z])\n\njulia> f = x^2+y+z\nx^2 + y + z\n\njulia> homogeneous_components(f)\nDict{FinGenAbGroupElem, MPolyDecRingElem{QQFieldElem, QQMPolyRingElem}} with 2 entries:\n  [2] => x^2 + y\n  [3] => z\n\njulia> G = abelian_group([0, 0, 2, 2])\nFinitely generated abelian group\n  with 4 generators and 4 relations and relation matrix\n  [0   0   0   0]\n  [0   0   0   0]\n  [0   0   2   0]\n  [0   0   0   2]\n\njulia> W = [G[1]+G[3]+G[4], G[2]+G[4], G[1]+G[3], G[2], G[1]+G[2]];\n\njulia> S, x = graded_polynomial_ring(QQ, :x => 1:5; weights=W)\n(Graded multivariate polynomial ring in 5 variables over QQ, MPolyDecRingElem{QQFieldElem, QQMPolyRingElem}[x[1], x[2], x[3], x[4], x[5]])\n\njulia> f = x[1]^2+x[3]^2+x[5]^2\nx[1]^2 + x[3]^2 + x[5]^2\n\njulia> homogeneous_components(f)\nDict{FinGenAbGroupElem, MPolyDecRingElem{QQFieldElem, QQMPolyRingElem}} with 2 entries:\n  [2, 2, 0, 0] => x[5]^2\n  [2, 0, 0, 0] => x[1]^2 + x[3]^2\n\n\n\n\n\n","category":"method"},{"location":"CommutativeAlgebra/rings/","page":"Creating Multivariate Rings","title":"Creating Multivariate Rings","text":"homogeneous_component(f::MPolyDecRingElem, g::FinGenAbGroupElem)","category":"page"},{"location":"CommutativeAlgebra/rings/#homogeneous_component-Tuple{MPolyDecRingElem, FinGenAbGroupElem}","page":"Creating Multivariate Rings","title":"homogeneous_component","text":"homogeneous_component(f::MPolyDecRingElem, g::FinGenAbGroupElem)\n\nGiven an element f of a graded multivariate ring, and given an element g of the grading group of that ring, return the homogeneous component of f of degree g.\n\nhomogeneous_component(f::MPolyDecRingElem, g::Vector{<:IntegerUnion})\n\nGiven an element f of a mathbb  Z^m-graded multivariate ring R, say, and given a vector g of m integers, convert g into an element of the grading group of R, and return the homogeneous component of f whose degree is that element.\n\nhomogeneous_component(f::MPolyDecRingElem, g::IntegerUnion)\n\nGiven an element f of a mathbb  Z-graded multivariate ring R, say, and given an integer g, convert g into an element of the grading group of R, and return the homogeneous component of f whose degree is that element.\n\nExamples\n\njulia> G = abelian_group([0, 0, 2, 2])\nFinitely generated abelian group\n  with 4 generators and 4 relations and relation matrix\n  [0   0   0   0]\n  [0   0   0   0]\n  [0   0   2   0]\n  [0   0   0   2]\n\njulia> W = [G[1]+G[3]+G[4], G[2]+G[4], G[1]+G[3], G[2], G[1]+G[2]];\n\njulia> S, x = graded_polynomial_ring(QQ, :x => 1:5; weights=W)\n(Graded multivariate polynomial ring in 5 variables over QQ, MPolyDecRingElem{QQFieldElem, QQMPolyRingElem}[x[1], x[2], x[3], x[4], x[5]])\n\njulia> f = x[1]^2+x[3]^2+x[5]^2\nx[1]^2 + x[3]^2 + x[5]^2\n\njulia> homogeneous_component(f, 2*G[1])\nx[1]^2 + x[3]^2\n\njulia> W = [[1, 0], [0, 1], [1, 0], [4, 1]]\n4-element Vector{Vector{Int64}}:\n [1, 0]\n [0, 1]\n [1, 0]\n [4, 1]\n\njulia> R, x = graded_polynomial_ring(QQ, :x => 1:4; weights=W)\n(Graded multivariate polynomial ring in 4 variables over QQ, MPolyDecRingElem{QQFieldElem, QQMPolyRingElem}[x[1], x[2], x[3], x[4]])\n\njulia> f = x[1]^2*x[2]+x[4]\nx[1]^2*x[2] + x[4]\n\njulia> homogeneous_component(f, [2, 1])\nx[1]^2*x[2]\n\njulia> R, (x, y, z) = graded_polynomial_ring(QQ, [:x, :y, :z]; weights=[1, 2, 3])\n(Graded multivariate polynomial ring in 3 variables over QQ, MPolyDecRingElem{QQFieldElem, QQMPolyRingElem}[x, y, z])\n\njulia> f = x^2+y+z\nx^2 + y + z\n\njulia> homogeneous_component(f, 1)\n0\n\njulia> homogeneous_component(f, 2)\nx^2 + y\n\njulia> homogeneous_component(f, 3)\nz\n\n\n\n\n\n","category":"method"},{"location":"CommutativeAlgebra/rings/","page":"Creating Multivariate Rings","title":"Creating Multivariate Rings","text":"is_homogeneous(f::MPolyDecRingElem)","category":"page"},{"location":"CommutativeAlgebra/rings/#is_homogeneous-Tuple{MPolyDecRingElem}","page":"Creating Multivariate Rings","title":"is_homogeneous","text":"is_homogeneous(f::MPolyDecRingElem)\n\nGiven an element f of a graded multivariate ring, return true if f is homogeneous, false otherwise.\n\nExamples\n\njulia> R, (x, y, z) = graded_polynomial_ring(QQ, [:x, :y, :z], [1, 2, 3])\n(Graded multivariate polynomial ring in 3 variables over QQ, MPolyDecRingElem{QQFieldElem, QQMPolyRingElem}[x, y, z])\n\njulia> f = x^2+y*z\nx^2 + y*z\n\njulia> is_homogeneous(f)\nfalse\n\njulia> W = [1 2 1 0; 3 4 0 1]\n2×4 Matrix{Int64}:\n 1  2  1  0\n 3  4  0  1\n\njulia> S, (w, x, y, z) = graded_polynomial_ring(QQ, [:w, :x, :y, :z], W)\n(Graded multivariate polynomial ring in 4 variables over QQ, MPolyDecRingElem{QQFieldElem, QQMPolyRingElem}[w, x, y, z])\n\njulia> F = w^3*y^3*z^3 + w^2*x*y^2*z^2 + w*x^2*y*z + x^3\nw^3*y^3*z^3 + w^2*x*y^2*z^2 + w*x^2*y*z + x^3\n\njulia> is_homogeneous(F)\ntrue\n\n\n\n\n\n","category":"method"},{"location":"CommutativeAlgebra/rings/","page":"Creating Multivariate Rings","title":"Creating Multivariate Rings","text":"degree(f::MPolyDecRingElem)","category":"page"},{"location":"CommutativeAlgebra/rings/#degree-Tuple{MPolyDecRingElem}","page":"Creating Multivariate Rings","title":"degree","text":"degree(f::MPolyDecRingElem)\n\nGiven a homogeneous element f of a graded multivariate ring, return the degree of f.\n\ndegree(::Type{Vector{Int}}, f::MPolyDecRingElem)\n\nGiven a homogeneous element f of a mathbb Z^m-graded multivariate ring, return the degree of f, converted to a vector of integer numbers.\n\ndegree(::Type{Int}, f::MPolyDecRingElem)\n\nGiven a homogeneous element f of a mathbb Z-graded multivariate ring, return the degree of f, converted to an integer number.\n\nExamples\n\njulia> G = abelian_group([0, 0, 2, 2])\nFinitely generated abelian group\n  with 4 generators and 4 relations and relation matrix\n  [0   0   0   0]\n  [0   0   0   0]\n  [0   0   2   0]\n  [0   0   0   2]\n\njulia> W = [G[1]+G[3]+G[4], G[2]+G[4], G[1]+G[3], G[2], G[1]+G[2]];\n\njulia> S, x = graded_polynomial_ring(QQ, :x => 1:5; weights=W)\n(Graded multivariate polynomial ring in 5 variables over QQ, MPolyDecRingElem{QQFieldElem, QQMPolyRingElem}[x[1], x[2], x[3], x[4], x[5]])\n\njulia> f = x[2]^2+2*x[4]^2\nx[2]^2 + 2*x[4]^2\n\njulia> degree(f)\nAbelian group element [0, 2, 0, 0]\n\njulia> W = [[1, 0], [0, 1], [1, 0], [4, 1]]\n4-element Vector{Vector{Int64}}:\n [1, 0]\n [0, 1]\n [1, 0]\n [4, 1]\n\njulia> R, x = graded_polynomial_ring(QQ, :x => 1:4, W)\n(Graded multivariate polynomial ring in 4 variables over QQ, MPolyDecRingElem{QQFieldElem, QQMPolyRingElem}[x[1], x[2], x[3], x[4]])\n\njulia> f = x[1]^4*x[2]+x[4]\nx[1]^4*x[2] + x[4]\n\njulia> degree(f)\n[4 1]\n\njulia> degree(Vector{Int}, f)\n2-element Vector{Int64}:\n 4\n 1\n\njulia>  R, (x, y, z) = graded_polynomial_ring(QQ, [:x, :y, :z], [1, 2, 3])\n(Graded multivariate polynomial ring in 3 variables over QQ, MPolyDecRingElem{QQFieldElem, QQMPolyRingElem}[x, y, z])\n\njulia> f = x^6+y^3+z^2\nx^6 + y^3 + z^2\n\njulia> degree(f)\n[6]\n\njulia> typeof(degree(f))\nFinGenAbGroupElem\n\njulia> degree(Int, f)\n6\n\njulia> typeof(degree(Int, f))\nInt64\n\n\n\n\n\n","category":"method"},{"location":"CommutativeAlgebra/rings/","page":"Creating Multivariate Rings","title":"Creating Multivariate Rings","text":"forget_grading(f::MPolyDecRingElem)","category":"page"},{"location":"CommutativeAlgebra/rings/#forget_grading-Tuple{MPolyDecRingElem}","page":"Creating Multivariate Rings","title":"forget_grading","text":"forget_grading(f::MPolyDecRingElem)\n\nReturn the element in the underlying ungraded ring.\n\n\n\n\n\n","category":"method"},{"location":"CommutativeAlgebra/rings/#Homomorphisms-From-Multivariate-Rings","page":"Creating Multivariate Rings","title":"Homomorphisms From Multivariate Rings","text":"","category":"section"},{"location":"CommutativeAlgebra/rings/","page":"Creating Multivariate Rings","title":"Creating Multivariate Rings","text":"If R is a multivariate polynomial ring, and S is any ring, then a ring homomorphism R to S is determined by specifying its restriction to the coefficient ring of R, and by assigning an image to each variable of R. In OSCAR, such homomorphisms are created by using the following constructor:","category":"page"},{"location":"CommutativeAlgebra/rings/","page":"Creating Multivariate Rings","title":"Creating Multivariate Rings","text":"hom(R::MPolyRing, S::NCRing, coeff_map, images::Vector; check::Bool = true)","category":"page"},{"location":"CommutativeAlgebra/rings/#hom-Tuple{MPolyRing, NCRing, Any, Vector}","page":"Creating Multivariate Rings","title":"hom","text":"hom(R::MPolyRing, S::NCRing, coeff_map, images::Vector; check::Bool = true)\n\nhom(R::MPolyRing, S::NCRing, images::Vector; check::Bool = true)\n\nGiven a homomorphism coeff_map from C to S, where C is the  coefficient ring of R, and given a vector images of nvars(R)  elements of S, return the homomorphism R to S whose restriction  to C is coeff_map, and which sends the i-th variable of R to the  i-th entry of images.\n\nIf no coefficient map is entered, invoke a canonical homomorphism of C to S, if such a homomorphism exists, and throw an error, otherwise.\n\nnote: Note\nIn case check = true (default), the function checks the conditions below:If S is graded, the assigned images must be homogeneous with respect to the given grading.\nIf S is noncommutative, the assigned images must pairwise commute. \n\nExamples\n\njulia> K, a = finite_field(2, 2, \"a\");\n\njulia> R, (x, y) = polynomial_ring(K, [:x, :y]);\n\njulia> F = hom(R, R, z -> z^2, [y, x])\nRing homomorphism\n  from multivariate polynomial ring in 2 variables over K\n  to multivariate polynomial ring in 2 variables over K\ndefined by\n  x -> y\n  y -> x\nwith map on coefficients\n  #1\n\njulia> F(a * y)\n(a + 1)*x\n\njulia> Qi, i = quadratic_field(-1)\n(Imaginary quadratic field defined by x^2 + 1, sqrt(-1))\n\njulia> S, (x, y) = polynomial_ring(Qi, [:x, :y]);\n\njulia> G = hom(S, S, hom(Qi, Qi, -i), [x^2, y^2])\nRing homomorphism\n  from multivariate polynomial ring in 2 variables over Qi\n  to multivariate polynomial ring in 2 variables over Qi\ndefined by\n  x -> x^2\n  y -> y^2\nwith map on coefficients\n  Map: Qi -> Qi\n\njulia> G(x+i*y)\nx^2 - sqrt(-1)*y^2\n\njulia> R, (x, y) = polynomial_ring(ZZ, [:x, :y]);\n\njulia> f = 3*x^2+2*x+1;\n\njulia> S, (x, y) = polynomial_ring(GF(2), [:x, :y]);\n\njulia> H = hom(R, S, gens(S))\nRing homomorphism\n  from multivariate polynomial ring in 2 variables over ZZ\n  to multivariate polynomial ring in 2 variables over GF(2)\ndefined by\n  x -> x\n  y -> y\n\njulia> H(f)\nx^2 + 1\n\n\n\n\n\n","category":"method"},{"location":"CommutativeAlgebra/rings/","page":"Creating Multivariate Rings","title":"Creating Multivariate Rings","text":"Given a ring homomorphism F from R to S as above, domain(F) and codomain(F) refer to R and S, respectively.","category":"page"},{"location":"CommutativeAlgebra/rings/","page":"Creating Multivariate Rings","title":"Creating Multivariate Rings","text":"note: Note\nThe OSCAR homomorphism type AffAlgHom models ring homomorphisms R to S such that the type of both R and S  is a subtype of Union{MPolyRing{T}, MPolyQuoRing{U}}, where T <: FieldElem and U <: MPolyRingElem{T}. Functionality for these homomorphism is discussed in the section on affine algebras.","category":"page"},{"location":"CommutativeAlgebra/GroebnerBases/orderings/","page":"Monomial Orderings","title":"Monomial Orderings","text":"CurrentModule = Oscar\nDocTestSetup = Oscar.doctestsetup()","category":"page"},{"location":"CommutativeAlgebra/GroebnerBases/orderings/#monomial_orderings","page":"Monomial Orderings","title":"Monomial Orderings","text":"","category":"section"},{"location":"CommutativeAlgebra/GroebnerBases/orderings/","page":"Monomial Orderings","title":"Monomial Orderings","text":"Given a coefficient ring C as in the previous section, let Cx=Cx_1 ldots x_n be the polynomial ring over C in the set of variables x=x_1 ldots x_n. Monomials in x=x_1 ldots x_n are written using multi–indices: If alpha=(alpha_1 ldots alpha_n)in mathbbN^n, set x^alpha=x_1^alpha_1cdots x_n^alpha_n and","category":"page"},{"location":"CommutativeAlgebra/GroebnerBases/orderings/","page":"Monomial Orderings","title":"Monomial Orderings","text":"textMon_n(x) =  textMon(x_1 ldots x_n) = x^alpha mid alpha in mathbbN^n","category":"page"},{"location":"CommutativeAlgebra/GroebnerBases/orderings/","page":"Monomial Orderings","title":"Monomial Orderings","text":"A monomial ordering on textMon_n(x) is a total  ordering  on textMon_n(x) such that","category":"page"},{"location":"CommutativeAlgebra/GroebnerBases/orderings/","page":"Monomial Orderings","title":"Monomial Orderings","text":"x^alpha  x^beta Longrightarrow x^gamma x^alpha  x^gamma  x^beta\n text for all  alpha beta gamma in mathbb N^n","category":"page"},{"location":"CommutativeAlgebra/GroebnerBases/orderings/","page":"Monomial Orderings","title":"Monomial Orderings","text":"A monomial ordering  on textMon_n(x) is called","category":"page"},{"location":"CommutativeAlgebra/GroebnerBases/orderings/","page":"Monomial Orderings","title":"Monomial Orderings","text":"global if x^alpha  1 for all alpha not = (0 dots 0),\nlocal if  x^alpha  1 for all alpha not = (0 dots 0), and\nmixed if it is neither global nor local.","category":"page"},{"location":"CommutativeAlgebra/GroebnerBases/orderings/","page":"Monomial Orderings","title":"Monomial Orderings","text":"note: Note\nA monomial ordering on textMon_n(x) is global iff it is a well-ordering.\nTo give a monomial ordering on textMon_n(x) means to give a total ordering  on $ \\mathbb{N}^n$ such that  alpha  beta implies $ \\gamma + \\alpha > \\gamma  + \\beta$ for all alpha  beta gamma in mathbbN^n  Rather than speaking of a monomial ordering on textMon_n(x), we may, thus, also speak of a  (global, local, mixed) monomial ordering on mathbbN^n.","category":"page"},{"location":"CommutativeAlgebra/GroebnerBases/orderings/","page":"Monomial Orderings","title":"Monomial Orderings","text":"note: Note\nBy a result of Robbiano, every monomial ordering can be realized as a matrix ordering.","category":"page"},{"location":"CommutativeAlgebra/GroebnerBases/orderings/","page":"Monomial Orderings","title":"Monomial Orderings","text":"note: Note\nThe lexicograpical monomial ordering specifies the default way of storing and displaying multivariate polynomials in OSCAR (terms are sorted in descending order). The other orderings which can be attached to a multivariate polynomial ring are the degree lexicographical ordering  and the degree reverse lexicographical ordering. Independently of the attached orderings, Gröbner bases can be computed with respect to any monomial ordering. See the section on Gröbner bases.","category":"page"},{"location":"CommutativeAlgebra/GroebnerBases/orderings/","page":"Monomial Orderings","title":"Monomial Orderings","text":"In this section, we show how to create monomial orderings in OSCAR. ","category":"page"},{"location":"CommutativeAlgebra/GroebnerBases/orderings/","page":"Monomial Orderings","title":"Monomial Orderings","text":"note: Note\nFor the convenient construction of block orderings on the set of monomials in the variables of a given multivariate polynomial ring, we allow to construct orderings on the monomials in blocks of variables, viewing these orderings as partial orderings on the monomials in all variables.","category":"page"},{"location":"CommutativeAlgebra/GroebnerBases/orderings/","page":"Monomial Orderings","title":"Monomial Orderings","text":"Here are some illustrating examples:","category":"page"},{"location":"CommutativeAlgebra/GroebnerBases/orderings/#Examples","page":"Monomial Orderings","title":"Examples","text":"","category":"section"},{"location":"CommutativeAlgebra/GroebnerBases/orderings/","page":"Monomial Orderings","title":"Monomial Orderings","text":"julia> S, (w, x) = polynomial_ring(QQ, [:w, :x])\n(Multivariate polynomial ring in 2 variables over QQ, QQMPolyRingElem[w, x])\n\njulia> o = lex([w, x])\nlex([w, x])\n\njulia> canonical_matrix(o)\n[1   0]\n[0   1]\n\njulia> R, (w, x, y, z) = polynomial_ring(QQ, [:w, :x, :y, :z])\n(Multivariate polynomial ring in 4 variables over QQ, QQMPolyRingElem[w, x, y, z])\n\njulia> o1 = degrevlex([w, x])\ndegrevlex([w, x])\n\njulia> is_global(o1)\ntrue\n\njulia> canonical_matrix(o1)\n[1    1   0   0]\n[0   -1   0   0]\n\njulia> o2 = neglex([y, z])\nneglex([y, z])\n\njulia> is_local(o2)\ntrue\n\njulia> canonical_matrix(o2)\n[0   0   -1    0]\n[0   0    0   -1]\n\njulia> o3 = o1*o2\ndegrevlex([w, x])*neglex([y, z])\n\njulia> canonical_matrix(o3)\n[1    1    0    0]\n[0   -1    0    0]\n[0    0   -1    0]\n[0    0    0   -1]\n\njulia> is_mixed(o3)\ntrue","category":"page"},{"location":"CommutativeAlgebra/GroebnerBases/orderings/#Monomial-Comparisons","page":"Monomial Orderings","title":"Monomial Comparisons","text":"","category":"section"},{"location":"CommutativeAlgebra/GroebnerBases/orderings/","page":"Monomial Orderings","title":"Monomial Orderings","text":"The cmp function should be used for comparing two monomials with regard to a monomial ordering.","category":"page"},{"location":"CommutativeAlgebra/GroebnerBases/orderings/","page":"Monomial Orderings","title":"Monomial Orderings","text":"cmp(ord::MonomialOrdering, a::MPolyRingElem, b::MPolyRingElem)","category":"page"},{"location":"CommutativeAlgebra/GroebnerBases/orderings/#cmp-Tuple{MonomialOrdering, MPolyRingElem, MPolyRingElem}","page":"Monomial Orderings","title":"cmp","text":"cmp(ord::MonomialOrdering, a::MPolyRingElem, b::MPolyRingElem)\n\ncmp(ord::ModuleOrdering, a::FreeModElem{T}, b::FreeModElem{T}) where T <: MPolyRingElem\n\nCompare monomials a and b with regard to the ordering ord: Return -1 for a < b and 1 for a > b and 0 for a == b. An error is thrown if ord is a partial ordering that does not distinguish a from b.\n\nExamples\n\njulia> R, (x, y, z) = polynomial_ring(QQ, [:x, :y, :z]);\n\njulia> cmp(lex([x,y]), x, one(R))\n1\n\njulia> try cmp(lex([x,y]), z, one(R)); catch e; e; end\nErrorException(\"z and 1 are incomparable with respect to lex([x, y])\")\n\njulia> cmp(lex([x,y,z]), z, one(R))\n1\n\njulia> F = free_module(R, 2)\nFree module of rank 2 over R\n\njulia> cmp(lex(R)*lex(F), F[1], F[2])\n-1\n\n\n\n\n\n","category":"method"},{"location":"CommutativeAlgebra/GroebnerBases/orderings/#Matrix-Orderings","page":"Monomial Orderings","title":"Matrix Orderings","text":"","category":"section"},{"location":"CommutativeAlgebra/GroebnerBases/orderings/","page":"Monomial Orderings","title":"Monomial Orderings","text":"Given a matrix Min textMat(ktimes nmathbb R) of rank n, with rows m_1dotsm_k, the matrix ordering defined by M is obtained by setting","category":"page"},{"location":"CommutativeAlgebra/GroebnerBases/orderings/","page":"Monomial Orderings","title":"Monomial Orderings","text":"x^alpha_M x^beta  Leftrightarrow  exists 1leq ileq k  m_1alpha=m_1betaldots \nm_i-1alpha =m_i-1beta m_ialpham_ibeta","category":"page"},{"location":"CommutativeAlgebra/GroebnerBases/orderings/","page":"Monomial Orderings","title":"Monomial Orderings","text":"(here, alpha and beta are regarded as column vectors).","category":"page"},{"location":"CommutativeAlgebra/GroebnerBases/orderings/","page":"Monomial Orderings","title":"Monomial Orderings","text":"note: Note\nBy a theorem of Robbiano, every monomial ordering arises as a matrix ordering as above with Min textGL(nmathbb R).","category":"page"},{"location":"CommutativeAlgebra/GroebnerBases/orderings/","page":"Monomial Orderings","title":"Monomial Orderings","text":"note: Note\nTo create matrix orderings, OSCAR allows for matrices with integer coefficients as input matrices.","category":"page"},{"location":"CommutativeAlgebra/GroebnerBases/orderings/","page":"Monomial Orderings","title":"Monomial Orderings","text":"note: Note\nFor orderings such as lex and degrevlex which are  predefined in OSCAR, using the predefined version is much faster than using a representation as a matrix ordering.","category":"page"},{"location":"CommutativeAlgebra/GroebnerBases/orderings/","page":"Monomial Orderings","title":"Monomial Orderings","text":"matrix_ordering(R::MPolyRing, M::Union{Matrix{T}, MatElem{T}}; check::Bool = true) where T","category":"page"},{"location":"CommutativeAlgebra/GroebnerBases/orderings/#matrix_ordering-Union{Tuple{T}, Tuple{MPolyRing, Union{MatElem{T}, Matrix{T}}}} where T","page":"Monomial Orderings","title":"matrix_ordering","text":"matrix_ordering(R::MPolyRing, M::Union{Matrix{T}, MatElem{T}}; check::Bool = true) where T -> MonomialOrdering\n\nGiven an integer matrix M such that nvars(R) = ncols(M) = rank(M),  return the matrix ordering on the set of variables of R which is defined by M.\n\nmatrix_ordering(V::AbstractVector{<:MPolyRingElem}, M::Union{Matrix{T}, MatElem{T}}; check::Bool = true) where T -> MonomialOrdering\n\nGiven a vector V of variables and an integer matrix M such that length(V) = ncols(M) = rank(M),  return the matrix ordering on the set of monomials in the given variables which is defined by M.\n\nnote: Note\nThe matrix M need not be square.\n\nnote: Note\nIf check = false is supplied, the rank check is omitted, and the resulting ordering may only be partial.\n\nExamples\n\njulia> R, (w, x, y, z) = QQ[:w, :x, :y, :z];\n\njulia> M =[1 1 1 1; 0 -1 -1 -1; 0 0 -1 -1; 0 0 0 -1]\n4×4 Matrix{Int64}:\n 1   1   1   1\n 0  -1  -1  -1\n 0   0  -1  -1\n 0   0   0  -1\n\njulia> o1 = matrix_ordering(R, M)\nmatrix_ordering([w, x, y, z], [1 1 1 1; 0 -1 -1 -1; 0 0 -1 -1; 0 0 0 -1])\n\njulia> N =[1 1; 0 -1]\n2×2 Matrix{Int64}:\n 1   1\n 0  -1\n\njulia> o2 = matrix_ordering([w, x], N)\nmatrix_ordering([w, x], [1 1; 0 -1])\n\njulia> canonical_matrix(o2)\n[1    1   0   0]\n[0   -1   0   0]\n\njulia> o3 = matrix_ordering(gens(R)[3:4], N)\nmatrix_ordering([y, z], [1 1; 0 -1])\n\njulia> o3 = matrix_ordering(gens(R)[3:4], N)\nmatrix_ordering([y, z], [1 1; 0 -1])\n\njulia> canonical_matrix(o3)\n[0   0   1    1]\n[0   0   0   -1]\n\n\n\n\n\n","category":"method"},{"location":"CommutativeAlgebra/GroebnerBases/orderings/","page":"Monomial Orderings","title":"Monomial Orderings","text":"As already shown above, OSCAR provides functions to recover defining matrices from given monomial orderings:","category":"page"},{"location":"CommutativeAlgebra/GroebnerBases/orderings/","page":"Monomial Orderings","title":"Monomial Orderings","text":"matrix(ord::MonomialOrdering)","category":"page"},{"location":"CommutativeAlgebra/GroebnerBases/orderings/#matrix-Tuple{MonomialOrdering}","page":"Monomial Orderings","title":"matrix","text":"matrix(ord::MonomialOrdering)\n\nReturn a matrix defining ord as a matrix ordering.\n\nExamples\n\njulia> R, (x, y, z) = polynomial_ring(QQ, [:x, :y, :z]);\n\njulia> o1 = degrevlex(R)\ndegrevlex([x, y, z])\n\njulia> matrix(o1)\n[ 1    1    1]\n[ 0    0   -1]\n[ 0   -1    0]\n[-1    0    0]\n\njulia> o2 = degrevlex([x, y])\ndegrevlex([x, y])\n\njulia> matrix(o2)\n[ 1    1   0]\n[ 0   -1   0]\n[-1    0   0]\n\n\n\n\n\n","category":"method"},{"location":"CommutativeAlgebra/GroebnerBases/orderings/","page":"Monomial Orderings","title":"Monomial Orderings","text":"canonical_matrix(ord::MonomialOrdering)","category":"page"},{"location":"CommutativeAlgebra/GroebnerBases/orderings/#canonical_matrix-Tuple{MonomialOrdering}","page":"Monomial Orderings","title":"canonical_matrix","text":"canonical_matrix(ord::MonomialOrdering)\n\nReturn the canonical matrix defining ord as a matrix ordering.\n\nExamples\n\njulia> R, (x, y, z) = polynomial_ring(QQ, [:x, :y, :z]);\n\njulia> o1 = degrevlex(R)\ndegrevlex([x, y, z])\n\njulia> canonical_matrix(o1)\n[1    1    1]\n[0    0   -1]\n[0   -1    0]\n\njulia> o2 = degrevlex([x, y])\ndegrevlex([x, y])\n\njulia> canonical_matrix(o2)\n[1    1   0]\n[0   -1   0]\n\n\n\n\n\n","category":"method"},{"location":"CommutativeAlgebra/GroebnerBases/orderings/#Predefined-Global-Orderings","page":"Monomial Orderings","title":"Predefined Global Orderings","text":"","category":"section"},{"location":"CommutativeAlgebra/GroebnerBases/orderings/#The-Lexicographical-Ordering","page":"Monomial Orderings","title":"The Lexicographical Ordering","text":"","category":"section"},{"location":"CommutativeAlgebra/GroebnerBases/orderings/","page":"Monomial Orderings","title":"Monomial Orderings","text":"The lexicographical ordering lex is defined by setting","category":"page"},{"location":"CommutativeAlgebra/GroebnerBases/orderings/","page":"Monomial Orderings","title":"Monomial Orderings","text":"x^alpha  x^beta   Leftrightarrow exists  1 leq i leq n alpha_1 = beta_1 dots alpha_i-1 = beta_i-1 alpha_i  beta_i","category":"page"},{"location":"CommutativeAlgebra/GroebnerBases/orderings/","page":"Monomial Orderings","title":"Monomial Orderings","text":"lex(R::MPolyRing)","category":"page"},{"location":"CommutativeAlgebra/GroebnerBases/orderings/#lex-Tuple{MPolyRing}","page":"Monomial Orderings","title":"lex","text":"lex(R::MPolyRing) -> MonomialOrdering\n\nReturn the lexicographical ordering on the set of monomials in the variables of R.\n\nlex(V::AbstractVector{<:MPolyRingElem}) -> MonomialOrdering\n\nGiven a vector V of variables, return the lexicographical ordering on the set of monomials in these variables.\n\nExamples\n\njulia> R, (w, x, y, z) = polynomial_ring(QQ, [:w, :x, :y, :z])\n(Multivariate polynomial ring in 4 variables over QQ, QQMPolyRingElem[w, x, y, z])\n\njulia> o1 = lex(R)\nlex([w, x, y, z])\n\njulia> canonical_matrix(o1)\n[1   0   0   0]\n[0   1   0   0]\n[0   0   1   0]\n[0   0   0   1]\n\njulia> o2 = lex([w, x])\nlex([w, x])\n\njulia> o3 = lex(gens(R)[3:4])\nlex([y, z])\n\n\n\n\n\n","category":"method"},{"location":"CommutativeAlgebra/GroebnerBases/orderings/#The-Degree-Lexicographical-Ordering","page":"Monomial Orderings","title":"The Degree Lexicographical Ordering","text":"","category":"section"},{"location":"CommutativeAlgebra/GroebnerBases/orderings/","page":"Monomial Orderings","title":"Monomial Orderings","text":"The degree lexicographical ordering deglex is defined by setting deg(x^alpha) = alpha_1 + cdots + alpha_n and","category":"page"},{"location":"CommutativeAlgebra/GroebnerBases/orderings/","page":"Monomial Orderings","title":"Monomial Orderings","text":"x^alpha  x^beta   Leftrightarrow   deg(x^alpha)  deg(x^beta)  text or  (deg(x^alpha) = deg(x^beta) text and  exists  1 leq i leq n alpha_1 = beta_1 dots alpha_i-1 = beta_i-1 alpha_i  beta_i)","category":"page"},{"location":"CommutativeAlgebra/GroebnerBases/orderings/","page":"Monomial Orderings","title":"Monomial Orderings","text":"deglex(R::MPolyRing)","category":"page"},{"location":"CommutativeAlgebra/GroebnerBases/orderings/#deglex-Tuple{MPolyRing}","page":"Monomial Orderings","title":"deglex","text":"deglex(R::MPolyRing) -> MonomialOrdering\n\nReturn the degree lexicographical ordering on the set of monomials in the variables of R.\n\ndeglex(V::AbstractVector{<:MPolyRingElem}) -> MonomialOrdering\n\nGiven a vector V of variables, return the degree lexicographical ordering on the set of monomials in these variables.\n\nExamples\n\njulia> R, (w, x, y, z) = polynomial_ring(QQ, [:w, :x, :y, :z])\n(Multivariate polynomial ring in 4 variables over QQ, QQMPolyRingElem[w, x, y, z])\n\njulia> o1 = deglex(R)\ndeglex([w, x, y, z])\n\njulia> canonical_matrix(o1)\n[1    1    1    1]\n[0   -1   -1   -1]\n[0    0   -1   -1]\n[0    0    0   -1]\n\njulia> o2 = deglex([w, x])\ndeglex([w, x])\n\njulia> o3 = deglex(gens(R)[3:4])\ndeglex([y, z])\n\n\n\n\n\n","category":"method"},{"location":"CommutativeAlgebra/GroebnerBases/orderings/#The-Inverse-Lexicographical-Ordering","page":"Monomial Orderings","title":"The Inverse Lexicographical Ordering","text":"","category":"section"},{"location":"CommutativeAlgebra/GroebnerBases/orderings/","page":"Monomial Orderings","title":"Monomial Orderings","text":"The inverse lexicographical ordering invlex is defined by setting","category":"page"},{"location":"CommutativeAlgebra/GroebnerBases/orderings/","page":"Monomial Orderings","title":"Monomial Orderings","text":"x^alpha  x^beta   Leftrightarrow exists  1 leq i leq n alpha_n = beta_n dots alpha_i+1 = beta_i+1 alpha_i   beta_i","category":"page"},{"location":"CommutativeAlgebra/GroebnerBases/orderings/","page":"Monomial Orderings","title":"Monomial Orderings","text":"invlex(R::MPolyRing)","category":"page"},{"location":"CommutativeAlgebra/GroebnerBases/orderings/#invlex-Tuple{MPolyRing}","page":"Monomial Orderings","title":"invlex","text":"invlex(R::MPolyRing) -> MonomialOrdering\n\nReturn the inverse lexicographical ordering on the set of monomials in the variables of R.\n\ninvlex(V::AbstractVector{<:MPolyRingElem}) -> MonomialOrdering\n\nGiven a vector V of variables, return the inverse lexicographical ordering on the set of monomials in these variables.\n\nExamples\n\njulia> R, (w, x, y, z) = polynomial_ring(QQ, [:w, :x, :y, :z])\n(Multivariate polynomial ring in 4 variables over QQ, QQMPolyRingElem[w, x, y, z])\n\njulia> o1 = invlex(R)\ninvlex([w, x, y, z])\n\njulia> canonical_matrix(o1)\n[0   0   0   1]\n[0   0   1   0]\n[0   1   0   0]\n[1   0   0   0]\n\njulia> o2 = invlex([w, x])\ninvlex([w, x])\n\njulia> o3 = invlex(gens(R)[3:4])\ninvlex([y, z])\n\n\n\n\n\n","category":"method"},{"location":"CommutativeAlgebra/GroebnerBases/orderings/#The-Degree-Inverse-Lexicographical-Ordering","page":"Monomial Orderings","title":"The Degree Inverse Lexicographical Ordering","text":"","category":"section"},{"location":"CommutativeAlgebra/GroebnerBases/orderings/","page":"Monomial Orderings","title":"Monomial Orderings","text":"The degree inverse lexicographical ordering deginvlex is defined by setting","category":"page"},{"location":"CommutativeAlgebra/GroebnerBases/orderings/","page":"Monomial Orderings","title":"Monomial Orderings","text":"x^alpha  x^beta   Leftrightarrow deg(x^alpha)  deg(x^beta)  text or (deg(x^alpha) = deg(x^beta) text and  exists  1 leq i leq n alpha_n = beta_n dots alpha_i+1 = beta_i+1 alpha_i   beta_i)","category":"page"},{"location":"CommutativeAlgebra/GroebnerBases/orderings/","page":"Monomial Orderings","title":"Monomial Orderings","text":"deginvlex(R::MPolyRing)","category":"page"},{"location":"CommutativeAlgebra/GroebnerBases/orderings/#deginvlex-Tuple{MPolyRing}","page":"Monomial Orderings","title":"deginvlex","text":"deginvlex(R::MPolyRing) -> MonomialOrdering\n\nReturn the degree inverse lexicographical ordering on the set of monomials in the variables of R.\n\ndeginvlex(V::AbstractVector{<:MPolyRingElem}) -> MonomialOrdering\n\nGiven a vector V of variables, return the degree inverse lexicographical ordering on the set of monomials in these variables.\n\nExamples\n\njulia> R, (w, x, y, z) = polynomial_ring(QQ, [:w, :x, :y, :z])\n(Multivariate polynomial ring in 4 variables over QQ, QQMPolyRingElem[w, x, y, z])\n\njulia> o1 = deginvlex(R)\ndeginvlex([w, x, y, z])\n\njulia> canonical_matrix(o1)\n[1   1   1   1]\n[0   0   0   1]\n[0   0   1   0]\n[0   1   0   0]\n\njulia> o2 = deginvlex([w, x])\ndeginvlex([w, x])\n\njulia> o3 = deginvlex(gens(R)[3:4])\ndeginvlex([y, z])\n\n\n\n\n\n","category":"method"},{"location":"CommutativeAlgebra/GroebnerBases/orderings/#The-Degree-Reverse-Lexicographical-Ordering","page":"Monomial Orderings","title":"The Degree Reverse Lexicographical Ordering","text":"","category":"section"},{"location":"CommutativeAlgebra/GroebnerBases/orderings/","page":"Monomial Orderings","title":"Monomial Orderings","text":"The degree reverse lexicographical ordering degrevlex is defined by setting deg(x^alpha) = alpha_1 + cdots + alpha_n and","category":"page"},{"location":"CommutativeAlgebra/GroebnerBases/orderings/","page":"Monomial Orderings","title":"Monomial Orderings","text":"x^alpha  x^beta   Leftrightarrow  deg(x^alpha)  deg(x^beta)  text or (deg(x^alpha) = deg(x^beta) text and  exists  1 leq i leq n alpha_n = beta_n dots alpha_i+1 = beta_i+1 alpha_i  beta_i)","category":"page"},{"location":"CommutativeAlgebra/GroebnerBases/orderings/","page":"Monomial Orderings","title":"Monomial Orderings","text":"degrevlex(R::MPolyRing)","category":"page"},{"location":"CommutativeAlgebra/GroebnerBases/orderings/#degrevlex-Tuple{MPolyRing}","page":"Monomial Orderings","title":"degrevlex","text":"degrevlex(R::MPolyRing) -> MonomialOrdering\n\nReturn the degree reverse lexicographical ordering on the set of monomials in the variables of R.\n\ndegrevlex(V::AbstractVector{<:MPolyRingElem}) -> MonomialOrdering\n\nGiven a vector V of variables, return the degree reverse lexicographical ordering on the set of monomials in these variables\n\nExamples\n\njulia> R, (w, x, y, z) = polynomial_ring(QQ, [:w, :x, :y, :z])\n(Multivariate polynomial ring in 4 variables over QQ, QQMPolyRingElem[w, x, y, z])\n\njulia> o1 = degrevlex(R)\ndegrevlex([w, x, y, z])\n\njulia> canonical_matrix(o1)\n[1    1    1    1]\n[0    0    0   -1]\n[0    0   -1    0]\n[0   -1    0    0]\n\njulia> o2 = degrevlex([w, x])\ndegrevlex([w, x])\n\njulia> o3 = degrevlex(gens(R)[3:4])\ndegrevlex([y, z])\n\n\n\n\n\n","category":"method"},{"location":"CommutativeAlgebra/GroebnerBases/orderings/#Weighted-Lexicographical-Orderings","page":"Monomial Orderings","title":"Weighted Lexicographical Orderings","text":"","category":"section"},{"location":"CommutativeAlgebra/GroebnerBases/orderings/","page":"Monomial Orderings","title":"Monomial Orderings","text":"If W is a vector of positive integers  w_1 dots w_n, the corresponding weighted lexicographical ordering wdeglex(W)  is defined by setting textwdeg(x^alpha) = w_1alpha_1 + cdots + w_nalpha_n and","category":"page"},{"location":"CommutativeAlgebra/GroebnerBases/orderings/","page":"Monomial Orderings","title":"Monomial Orderings","text":"x^alpha  x^beta   Leftrightarrow   textwdeg(x^alpha)  textwdeg(x^beta)  text or \n(textwdeg(x^alpha) = textwdeg(x^beta)  text and  exists  1 leq i leq n alpha_1 = beta_1 dots alpha_i-1 = beta_i-1 alpha_i  beta_i)","category":"page"},{"location":"CommutativeAlgebra/GroebnerBases/orderings/","page":"Monomial Orderings","title":"Monomial Orderings","text":"wdeglex(R::MPolyRing, W::Vector{Int})","category":"page"},{"location":"CommutativeAlgebra/GroebnerBases/orderings/#wdeglex-Tuple{MPolyRing, Vector{Int64}}","page":"Monomial Orderings","title":"wdeglex","text":"wdeglex(R::MPolyRing, W::Vector{Int}) -> MonomialOrdering\n\nIf W is a vector of positive integers, return the corresponding weighted  lexicographical ordering on the set of monomials in the variables of R.\n\nwdeglex(V::AbstractVector{<:MPolyRingElem}, W::Vector{Int}) -> MonomialOrdering\n\nGiven a vector V of variables and a vector W of positive integers, return the corresponding weighted  lexicographical ordering on the set of monomials in the given variables.\n\nExamples\n\njulia> R, (w, x, y, z) = polynomial_ring(QQ, [:w, :x, :y, :z])\n(Multivariate polynomial ring in 4 variables over QQ, QQMPolyRingElem[w, x, y, z])\n\njulia> o1 = wdeglex(R, [1, 2, 3, 4])\nwdeglex([w, x, y, z], [1, 2, 3, 4])\n\njulia> canonical_matrix(o1)\n[1    2    3    4]\n[0   -2   -3   -4]\n[0    0   -3   -4]\n[0    0    0   -1]\n\njulia> o2 = wdeglex([w, x], [1, 2])\nwdeglex([w, x], [1, 2])\n\njulia> o3 = wdeglex(gens(R)[3:4], [3, 4])\nwdeglex([y, z], [3, 4])\n\n\n\n\n\n","category":"method"},{"location":"CommutativeAlgebra/GroebnerBases/orderings/#Weighted-Reverse-Lexicographical-Orderings","page":"Monomial Orderings","title":"Weighted Reverse Lexicographical Orderings","text":"","category":"section"},{"location":"CommutativeAlgebra/GroebnerBases/orderings/","page":"Monomial Orderings","title":"Monomial Orderings","text":"If W is a vector of positive integers  w_1 dots w_n, the corresponding weighted reverse lexicographical ordering wdegrevlex  is defined by setting textwdeg(x^alpha) = w_1alpha_1 + cdots + w_nalpha_n and","category":"page"},{"location":"CommutativeAlgebra/GroebnerBases/orderings/","page":"Monomial Orderings","title":"Monomial Orderings","text":"x^alpha  x^beta   Leftrightarrow  textwdeg(x^alpha)  textwdeg(x^beta)  text or \n(textwdeg(x^alpha) = textwdeg(x^beta)  text and  exists  1 leq i leq n alpha_n = beta_n dots alpha_i+1 = beta_i+1 alpha_i  beta_i)","category":"page"},{"location":"CommutativeAlgebra/GroebnerBases/orderings/","page":"Monomial Orderings","title":"Monomial Orderings","text":"wdegrevlex(R::MPolyRing, W::Vector{Int})","category":"page"},{"location":"CommutativeAlgebra/GroebnerBases/orderings/#wdegrevlex-Tuple{MPolyRing, Vector{Int64}}","page":"Monomial Orderings","title":"wdegrevlex","text":"wdegrevlex(R::MPolyRing, W::Vector{Int}) -> MonomialOrdering\n\nIf W is a vector of positive integers, return the corresponding weighted reverse  lexicographical ordering on the set of monomials in the variables of R.\n\nwdegrevlex(V::AbstractVector{<:MPolyRingElem}, W::Vector{Int}) -> MonomialOrdering\n\nGiven a vector V of variables and a vector W of positive integers, return the corresponding weighted reverse  lexicographical ordering on the set of monomials in the given variables.\n\nExamples\n\njulia> R, (w, x, y, z) = polynomial_ring(QQ, [:w, :x, :y, :z])\n(Multivariate polynomial ring in 4 variables over QQ, QQMPolyRingElem[w, x, y, z])\n\njulia> o1 = wdegrevlex(R, [1, 2, 3, 4])\nwdegrevlex([w, x, y, z], [1, 2, 3, 4])\n\njulia> canonical_matrix(o1)\n[1    2    3    4]\n[0    0    0   -1]\n[0    0   -1    0]\n[0   -1    0    0]\n\njulia> o2 = wdegrevlex([w, x], [1, 2])\nwdegrevlex([w, x], [1, 2])\n\njulia> o3 = wdegrevlex(gens(R)[3:4], [3, 4])\nwdegrevlex([y, z], [3, 4])\n\n\n\n\n\n","category":"method"},{"location":"CommutativeAlgebra/GroebnerBases/orderings/#Predefined-Local-Orderings","page":"Monomial Orderings","title":"Predefined Local Orderings","text":"","category":"section"},{"location":"CommutativeAlgebra/GroebnerBases/orderings/#The-Negative-Lexicographical-Ordering","page":"Monomial Orderings","title":"The Negative Lexicographical Ordering","text":"","category":"section"},{"location":"CommutativeAlgebra/GroebnerBases/orderings/","page":"Monomial Orderings","title":"Monomial Orderings","text":"The negative lexicographical ordering neglex is defined by setting","category":"page"},{"location":"CommutativeAlgebra/GroebnerBases/orderings/","page":"Monomial Orderings","title":"Monomial Orderings","text":"x^alpha  x^beta   Leftrightarrow exists  1 leq i leq n alpha_1 = beta_1 dots alpha_i-1 = beta_i-1 alpha_i  beta_i","category":"page"},{"location":"CommutativeAlgebra/GroebnerBases/orderings/","page":"Monomial Orderings","title":"Monomial Orderings","text":"neglex(R::MPolyRing)","category":"page"},{"location":"CommutativeAlgebra/GroebnerBases/orderings/#neglex-Tuple{MPolyRing}","page":"Monomial Orderings","title":"neglex","text":"neglex(R::MPolyRing) -> MonomialOrdering\n\nReturn the negative lexicographical ordering on the set of monomials in the variables of R.\n\nneglex(V::AbstractVector{<:MPolyRingElem}) -> MonomialOrdering\n\nGiven a vector V of variables, return the negative lexicographical ordering on the set of monomials in these variables.\n\nExamples\n\njulia> R, (w, x, y, z) = polynomial_ring(QQ, [:w, :x, :y, :z])\n(Multivariate polynomial ring in 4 variables over QQ, QQMPolyRingElem[w, x, y, z])\n\njulia> o1 = neglex(R)\nneglex([w, x, y, z])\n\njulia> canonical_matrix(o1)\n[-1    0    0    0]\n[ 0   -1    0    0]\n[ 0    0   -1    0]\n[ 0    0    0   -1]\n\njulia> o2 = neglex([w, x])\nneglex([w, x])\n\njulia> o3 = neglex(gens(R)[3:4])\nneglex([y, z])\n\n\n\n\n\n","category":"method"},{"location":"CommutativeAlgebra/GroebnerBases/orderings/#The-Negative-Degree-Lexicographical-Ordering","page":"Monomial Orderings","title":"The Negative Degree Lexicographical Ordering","text":"","category":"section"},{"location":"CommutativeAlgebra/GroebnerBases/orderings/","page":"Monomial Orderings","title":"Monomial Orderings","text":"The negative degree lexicographical ordering negdeglex is defined by setting deg(x^alpha) = alpha_1 + cdots + alpha_n and","category":"page"},{"location":"CommutativeAlgebra/GroebnerBases/orderings/","page":"Monomial Orderings","title":"Monomial Orderings","text":"x^alpha  x^beta   Leftrightarrow   deg(x^alpha)  deg(x^beta)  text or  (deg(x^alpha) = deg(x^beta) text and   exists  1 leq i leq n alpha_1 = beta_1 dots alpha_i-1 = beta_i-1 alpha_i  beta_i)","category":"page"},{"location":"CommutativeAlgebra/GroebnerBases/orderings/","page":"Monomial Orderings","title":"Monomial Orderings","text":"negdeglex(R::MPolyRing)","category":"page"},{"location":"CommutativeAlgebra/GroebnerBases/orderings/#negdeglex-Tuple{MPolyRing}","page":"Monomial Orderings","title":"negdeglex","text":"negdeglex(R::MPolyRing) -> MonomialOrdering\n\nReturn the negative degree lexicographical ordering on the set of monomials in the variables of R.\n\nnegdeglex(V::AbstractVector{<:MPolyRingElem}) -> MonomialOrdering\n\nGiven a vector V of variables, return the negative degree lexicographical ordering on the set of monomials in these variables.\n\nExamples\n\njulia> R, (w, x, y, z) = polynomial_ring(QQ, [:w, :x, :y, :z])\n(Multivariate polynomial ring in 4 variables over QQ, QQMPolyRingElem[w, x, y, z])\n\njulia> o1 = negdeglex(R)\nnegdeglex([w, x, y, z])\n\njulia> canonical_matrix(o1)\n[-1   -1   -1   -1]\n[ 0   -1   -1   -1]\n[ 0    0   -1   -1]\n[ 0    0    0   -1]\n\njulia> o2 = negdeglex([w, x])\nnegdeglex([w, x])\n\njulia> o3 = negdeglex(gens(R)[3:4])\nnegdeglex([y, z])\n\n\n\n\n\n","category":"method"},{"location":"CommutativeAlgebra/GroebnerBases/orderings/#The-Negative-Inverse-Lexicographical-Ordering","page":"Monomial Orderings","title":"The Negative Inverse Lexicographical Ordering","text":"","category":"section"},{"location":"CommutativeAlgebra/GroebnerBases/orderings/","page":"Monomial Orderings","title":"Monomial Orderings","text":"The negative inverse lexicographical ordering neginvlex is defined by setting","category":"page"},{"location":"CommutativeAlgebra/GroebnerBases/orderings/","page":"Monomial Orderings","title":"Monomial Orderings","text":"x^alpha  x^beta   Leftrightarrow exists  1 leq i leq n alpha_n = beta_n dots alpha_i+1 = beta_i+1 alpha_i   beta_i","category":"page"},{"location":"CommutativeAlgebra/GroebnerBases/orderings/","page":"Monomial Orderings","title":"Monomial Orderings","text":"neginvlex(R::MPolyRing)","category":"page"},{"location":"CommutativeAlgebra/GroebnerBases/orderings/#neginvlex-Tuple{MPolyRing}","page":"Monomial Orderings","title":"neginvlex","text":"neginvlex(R::MPolyRing) -> MonomialOrdering\n\nReturn the negative inverse lexicographical ordering on the set of monomials in the variables of R.\n\nneginvlex(V::AbstractVector{<:MPolyRingElem}) -> MonomialOrdering\n\nGiven a vector V of variables, return the negative inverse lexicographical ordering on the set of monomials in these variables.\n\nExamples\n\njulia> R, (w, x, y, z) = polynomial_ring(QQ, [:w, :x, :y, :z])\n(Multivariate polynomial ring in 4 variables over QQ, QQMPolyRingElem[w, x, y, z])\n\njulia> o1 = neginvlex(R)\nneginvlex([w, x, y, z])\n\njulia> canonical_matrix(o1)\n[ 0    0    0   -1]\n[ 0    0   -1    0]\n[ 0   -1    0    0]\n[-1    0    0    0]\n\njulia> o2 = neginvlex([w, x])\nneginvlex([w, x])\n\njulia> o3 = neginvlex(gens(R)[3:4])\nneginvlex([y, z])\n\n\n\n\n\n","category":"method"},{"location":"CommutativeAlgebra/GroebnerBases/orderings/#The-Negative-Degree-Reverse-Lexicographical-Ordering","page":"Monomial Orderings","title":"The Negative Degree Reverse Lexicographical Ordering","text":"","category":"section"},{"location":"CommutativeAlgebra/GroebnerBases/orderings/","page":"Monomial Orderings","title":"Monomial Orderings","text":"The negative degree reverse lexicographical ordering negdegrevlex is defined by setting deg(x^alpha) = alpha_1 + cdots + alpha_n and","category":"page"},{"location":"CommutativeAlgebra/GroebnerBases/orderings/","page":"Monomial Orderings","title":"Monomial Orderings","text":"x^alpha  x^beta   Leftrightarrow  deg(x^alpha)  deg(x^beta)  text or (deg(x^alpha) = deg(x^beta) text and  exists  1 leq i leq n alpha_n = beta_n dots alpha_i+1 = beta_i+1 alpha_i  beta_i)","category":"page"},{"location":"CommutativeAlgebra/GroebnerBases/orderings/","page":"Monomial Orderings","title":"Monomial Orderings","text":"negdegrevlex(R::MPolyRing)","category":"page"},{"location":"CommutativeAlgebra/GroebnerBases/orderings/#negdegrevlex-Tuple{MPolyRing}","page":"Monomial Orderings","title":"negdegrevlex","text":"negdegrevlex(R::MPolyRing) -> MonomialOrdering\n\nReturn the negative degree reverse lexicographical ordering on the set of monomials in the variables of R.\n\nnegdegrevlex(V::AbstractVector{<:MPolyRingElem}) -> MonomialOrdering\n\nGiven a vector V of variables, return the negative degree reverse lexicographical ordering on the set of monomials in these variables.\n\nExamples\n\njulia> R, (w, x, y, z) = polynomial_ring(QQ, [:w, :x, :y, :z])\n(Multivariate polynomial ring in 4 variables over QQ, QQMPolyRingElem[w, x, y, z])\n\njulia> o1 = negdegrevlex(R)\nnegdegrevlex([w, x, y, z])\n\njulia> canonical_matrix(o1)\n[-1   -1   -1   -1]\n[ 0    0    0   -1]\n[ 0    0   -1    0]\n[ 0   -1    0    0]\n\njulia> o2 = negdegrevlex([w, x])\nnegdegrevlex([w, x])\n\njulia> o3 = negdegrevlex(gens(R)[3:4])\nnegdegrevlex([y, z])\n\n\n\n\n\n","category":"method"},{"location":"CommutativeAlgebra/GroebnerBases/orderings/#Negative-Weighted-Lexicographical-Orderings","page":"Monomial Orderings","title":"Negative Weighted Lexicographical Orderings","text":"","category":"section"},{"location":"CommutativeAlgebra/GroebnerBases/orderings/","page":"Monomial Orderings","title":"Monomial Orderings","text":"If W is a vector of positive integers  w_1 dots w_n, the corresponding negative weighted lexicographical ordering negwdeglex(W)  is defined by setting textwdeg(x^alpha) = w_1alpha_1 + cdots + w_nalpha_n and","category":"page"},{"location":"CommutativeAlgebra/GroebnerBases/orderings/","page":"Monomial Orderings","title":"Monomial Orderings","text":"x^alpha  x^beta   Leftrightarrow   textwdeg(x^alpha)  textwdeg(x^beta)  text or \n(textwdeg(x^alpha) = textwdeg(x^beta)  text and  exists  1 leq i leq n alpha_1 = beta_1 dots alpha_i-1 = beta_i-1 alpha_i  beta_i)","category":"page"},{"location":"CommutativeAlgebra/GroebnerBases/orderings/","page":"Monomial Orderings","title":"Monomial Orderings","text":"negwdeglex(R::MPolyRing, W::Vector{Int})","category":"page"},{"location":"CommutativeAlgebra/GroebnerBases/orderings/#negwdeglex-Tuple{MPolyRing, Vector{Int64}}","page":"Monomial Orderings","title":"negwdeglex","text":"negwdeglex(R::MPolyRing, W::Vector{Int}) -> MonomialOrdering\n\nIf W is a vector of positive integers, return the corresponding negative weighted  lexicographical ordering on the set of monomials in the variables of R.\n\nnegwdeglex(V::AbstractVector{<:MPolyRingElem}, W::Vector{Int}) -> MonomialOrdering\n\nGiven a vector V of variables and a vector W of positive integers, return the corresponding negative weighted lexicographical ordering on the set of monomials in the given variables.\n\nExamples\n\njulia> R, (w, x, y, z) = polynomial_ring(QQ, [:w, :x, :y, :z])\n(Multivariate polynomial ring in 4 variables over QQ, QQMPolyRingElem[w, x, y, z])\n\njulia> o1 = negwdeglex(R, [1, 2, 3, 4])\nnegwdeglex([w, x, y, z], [1, 2, 3, 4])\n\njulia> canonical_matrix(o1)\n[-1   -2   -3   -4]\n[ 0   -2   -3   -4]\n[ 0    0   -3   -4]\n[ 0    0    0   -1]\n\njulia> o2 = negwdeglex([w, x], [1, 2])\nnegwdeglex([w, x], [1, 2])\n\njulia> o3 = negwdeglex(gens(R)[3:4], [3, 4])\nnegwdeglex([y, z], [3, 4])\n\n\n\n\n\n","category":"method"},{"location":"CommutativeAlgebra/GroebnerBases/orderings/#Negative-Weighted-Reverse-Lexicographical-Orderings","page":"Monomial Orderings","title":"Negative Weighted Reverse Lexicographical Orderings","text":"","category":"section"},{"location":"CommutativeAlgebra/GroebnerBases/orderings/","page":"Monomial Orderings","title":"Monomial Orderings","text":"If W is a vector of positive integers  w_1 dots w_n, the corresponding negative weighted reverse lexicographical ordering negwdegrevlex(W)  is defined by setting textwdeg(x^alpha) = w_1alpha_1 + cdots + w_nalpha_n and","category":"page"},{"location":"CommutativeAlgebra/GroebnerBases/orderings/","page":"Monomial Orderings","title":"Monomial Orderings","text":"x^alpha  x^beta   Leftrightarrow  textwdeg(x^alpha)  textwdeg(x^beta)  text or \n(textwdeg(x^alpha) = textwdeg(x^beta)  text and  exists  1 leq i leq n alpha_n = beta_n dots alpha_i+1 = beta_i+1 alpha_i  beta_i)","category":"page"},{"location":"CommutativeAlgebra/GroebnerBases/orderings/","page":"Monomial Orderings","title":"Monomial Orderings","text":"negwdegrevlex(R::MPolyRing, W::Vector{Int})","category":"page"},{"location":"CommutativeAlgebra/GroebnerBases/orderings/#negwdegrevlex-Tuple{MPolyRing, Vector{Int64}}","page":"Monomial Orderings","title":"negwdegrevlex","text":"negwdegrevlex(R::MPolyRing, W::Vector{Int}) -> MonomialOrdering\n\nIf W is a vector of positive integers, return the corresponding negative weighted reverse lexicographical ordering on the set of monomials in the variables of R.\n\nnegwdegrevlex(V::AbstractVector{<:MPolyRingElem}, W::Vector{Int}) -> MonomialOrdering\n\nGiven a vector V of variables and a vector W of positive integers, return the corresponding negative weighted reverse lexicographical ordering on the set of monomials in the given variables.\n\nExamples\n\njulia> R, (w, x, y, z) = polynomial_ring(QQ, [:w, :x, :y, :z])\n(Multivariate polynomial ring in 4 variables over QQ, QQMPolyRingElem[w, x, y, z])\n\njulia> o1 = negwdegrevlex(R, [1, 2, 3, 4])\nnegwdegrevlex([w, x, y, z], [1, 2, 3, 4])\n\njulia> canonical_matrix(o1)\n[-1   -2   -3   -4]\n[ 0    0    0   -1]\n[ 0    0   -1    0]\n[ 0   -1    0    0]\n\njulia> o2 = negwdegrevlex([w, x], [1, 2])\nnegwdegrevlex([w, x], [1, 2])\n\njulia> o3 = negwdegrevlex(gens(R)[3:4], [3, 4])\nnegwdegrevlex([y, z], [3, 4])\n\n\n\n\n\n","category":"method"},{"location":"CommutativeAlgebra/GroebnerBases/orderings/#Weight-Orderings","page":"Monomial Orderings","title":"Weight Orderings","text":"","category":"section"},{"location":"CommutativeAlgebra/GroebnerBases/orderings/","page":"Monomial Orderings","title":"Monomial Orderings","text":"If W is a vector of integers  w_1 dots w_n, and  is a monomial ordering on textMon_n(x), then the corresponding weight ordering is defined by setting textwdeg(x^alpha) = w_1alpha_1 + cdots + w_nalpha_n and","category":"page"},{"location":"CommutativeAlgebra/GroebnerBases/orderings/","page":"Monomial Orderings","title":"Monomial Orderings","text":"x^alpha _W x^beta   Leftrightarrow  textwdeg(x^alpha)  textwdeg(x^beta)  text or \n(textwdeg(x^alpha) = textwdeg(x^beta)  text and  x^alpha  x^beta)","category":"page"},{"location":"CommutativeAlgebra/GroebnerBases/orderings/","page":"Monomial Orderings","title":"Monomial Orderings","text":"weight_ordering(W::Vector{Int}, ord::MonomialOrdering)","category":"page"},{"location":"CommutativeAlgebra/GroebnerBases/orderings/#weight_ordering-Tuple{Vector{Int64}, MonomialOrdering}","page":"Monomial Orderings","title":"weight_ordering","text":"weight_ordering(W::Vector{<:IntegerUnion}, ord::MonomialOrdering) -> MonomialOrdering\n\nGiven an integer vector W and a monomial ordering ord on a set of monomials in length(W) variables, return the monomial ordering ord_W on this set of monomials which is obtained by first comparing the W-weighted degrees and then using ord  in the case of a tie.\n\nnote: Note\nThe ordering ord_W is   global if all entries of W are positive, or if they are all non-negative and ord is global,\nan elimination ordering for the set of variables which correspond to positive entries of W.   \n\nExamples\n\njulia> R, (x, y, z) = polynomial_ring(QQ, [:x, :y, :z]);\n\njulia> W = [1, 0, -1];\n\njulia> o = lex(R)\nlex([x, y, z])\n\njulia> matrix(o)\n[1   0   0]\n[0   1   0]\n[0   0   1]\n\njulia> oW = weight_ordering(W, o)\nmatrix_ordering([x, y, z], [1 0 -1])*lex([x, y, z])\n\njulia> matrix(oW)\n[1   0   -1]\n[1   0    0]\n[0   1    0]\n[0   0    1]\n\njulia> canonical_matrix(oW)\n[1   0   -1]\n[0   0    1]\n[0   1    0]\n\njulia> o2 = weight_ordering([1, -1], lex([x, z]))\nmatrix_ordering([x, z], [1 -1])*lex([x, z])\n\njulia> canonical_matrix(o2)\n[1   0   -1]\n[0   0    1]\n\n\n\n\n\n","category":"method"},{"location":"CommutativeAlgebra/GroebnerBases/orderings/#Block-Orderings","page":"Monomial Orderings","title":"Block Orderings","text":"","category":"section"},{"location":"CommutativeAlgebra/GroebnerBases/orderings/","page":"Monomial Orderings","title":"Monomial Orderings","text":"The concept of block orderings (product orderings) allows one to construct new monomial orderings from already given ones: If _1 and _2 are monomial orderings on textMon_s(x_1 ldots x_s) and textMon_n-s(x_s+1 ldots x_n), respectively, then the block ordering   =  (_1 _2) on textMon_n(x)=textMon_n(x_1 ldots x_n) is defined by setting","category":"page"},{"location":"CommutativeAlgebra/GroebnerBases/orderings/","page":"Monomial Orderings","title":"Monomial Orderings","text":"x^alphax^beta  Leftrightarrow  x_1^alpha_1cdots x_s^alpha_s _1 x_1^beta_1cdots x_s^beta_s text or \nbigl(x_1^alpha_1cdots x_s^alpha_s = x_1^beta_1cdots x_s^beta_s text and   x_s+1^alpha_s+1cdots x_n^alpha_n _2\nx_s+1^beta_s+1cdots x_n^beta_nbigr)","category":"page"},{"location":"CommutativeAlgebra/GroebnerBases/orderings/","page":"Monomial Orderings","title":"Monomial Orderings","text":"note: Note\nThe ordering  (_1 _2)is global (local) iff both _1 and _2 are global (local). Mixed orderings arise by choosing one of _1 and _2 global and the other one local,\nis an elimination ordering for the first block of variables iff _1 is global.","category":"page"},{"location":"CommutativeAlgebra/GroebnerBases/orderings/","page":"Monomial Orderings","title":"Monomial Orderings","text":"note: Note\nThe definition of a block ordering above subdivides x into a block of initial variables and its complementary block of variables.   Block orderings for a subdivision of x into any block of variables and its complementary block are defined similarly and have similar properties.\nInductively, one obtains block orderings composed of more than two individual orderings.","category":"page"},{"location":"CommutativeAlgebra/GroebnerBases/orderings/","page":"Monomial Orderings","title":"Monomial Orderings","text":"In OSCAR, block orderings are obtained by the concatenation of individual  orderings using the * operator.","category":"page"},{"location":"CommutativeAlgebra/GroebnerBases/orderings/#Examples-2","page":"Monomial Orderings","title":"Examples","text":"","category":"section"},{"location":"CommutativeAlgebra/GroebnerBases/orderings/","page":"Monomial Orderings","title":"Monomial Orderings","text":"julia> R, (w, x, y, z) = polynomial_ring(QQ, [:w, :x, :y, :z])\n(Multivariate polynomial ring in 4 variables over QQ, QQMPolyRingElem[w, x, y, z])\n\njulia> o = degrevlex([w, x])*degrevlex([y, z])\ndegrevlex([w, x])*degrevlex([y, z])\n","category":"page"},{"location":"CommutativeAlgebra/GroebnerBases/orderings/#Elimination-Orderings","page":"Monomial Orderings","title":"Elimination Orderings","text":"","category":"section"},{"location":"CommutativeAlgebra/GroebnerBases/orderings/","page":"Monomial Orderings","title":"Monomial Orderings","text":"Let Cx=Cx_1 ldots x_n be a multivariate polynomial ring with coefficient ring C. Fix a subset sigmasubset 1dots n and write x_sigma  for the set of variables x_i with iinsigma. An elimination ordering for xsmallsetminus x_sigma  is a monomial ordering  on textMon_n(x) which satisfies the following property: If a is a monomial involving one of the variables in xsmallsetminus x_sigma , and b is a monomial depending only on the variables in  x_sigma, then a  b Computing a Gröbner basis of I with respect to such an ordering provides one way of finding the intersection Icap Cx_sigma, that is, of  eliminating the variables in xsmallsetminus x_sigma from I: The Gröbner basis elements which only depend on the variables in x_sigma form a Gröbner basis for Icap Cx_sigma with respect to the restriction of  to the set of monomials in Icap Cx_sigma.","category":"page"},{"location":"CommutativeAlgebra/GroebnerBases/orderings/","page":"Monomial Orderings","title":"Monomial Orderings","text":"note: Note\nThe lexicographical ordering is an elimination ordering for each initial set of variables x_1 dots x_k. If only a fixed subset of variables is considered, suitable weight or block orderings as discussed above are more effective. The documentation of the is_elimination_ordering function below offers examples and non-examples.","category":"page"},{"location":"CommutativeAlgebra/GroebnerBases/orderings/#Tests-on-Monomial-Orderings","page":"Monomial Orderings","title":"Tests on Monomial Orderings","text":"","category":"section"},{"location":"CommutativeAlgebra/GroebnerBases/orderings/","page":"Monomial Orderings","title":"Monomial Orderings","text":"is_elimination_ordering(ord::MonomialOrdering, V::Vector{<:MPolyRingElem})","category":"page"},{"location":"CommutativeAlgebra/GroebnerBases/orderings/#is_elimination_ordering-Tuple{MonomialOrdering, Vector{<:MPolyRingElem}}","page":"Monomial Orderings","title":"is_elimination_ordering","text":"is_elimination_ordering(ord::MonomialOrdering, V::Vector{<:MPolyRingElem})\n\nGiven a vector V of polynomials which are variables, return true if ord is an elimination ordering for the variables in V. Return false, otherwise.\n\nis_elimination_ordering(ord::MonomialOrdering, V:Vector{Int})\n\nGiven a vector V of indices which specify variables, return true if ord is an elimination ordering for the specified variables. Return false, otherwise.\n\nExamples\n\njulia> R, (w, x, y, z) = polynomial_ring(QQ, [:w, :x, :y, :z]);\n\njulia> o1 = lex(R)\nlex([w, x, y, z])\n\njulia> is_elimination_ordering(o1, [w, x])\ntrue\n\njulia> o2 = weight_ordering([1, 1, 0, 0], degrevlex(R))\nmatrix_ordering([w, x, y, z], [1 1 0 0])*degrevlex([w, x, y, z])\n\njulia> is_elimination_ordering(o2, [w, x])\ntrue\n\njulia> o3 = weight_ordering([1, -1, 0, 0], degrevlex(R))\nmatrix_ordering([w, x, y, z], [1 -1 0 0])*degrevlex([w, x, y, z])\n\njulia> is_elimination_ordering(o3, [w, x])\nfalse\n\njulia> o4 = degrevlex([w, x])*degrevlex([y, z])\ndegrevlex([w, x])*degrevlex([y, z])\n\njulia> is_elimination_ordering(o4, [w, x])\ntrue\n\njulia> o5 = degrevlex([w, x])*negdegrevlex([y, z])\ndegrevlex([w, x])*negdegrevlex([y, z])\n\njulia> is_elimination_ordering(o5, [w, x])\ntrue\n\njulia> o6 = negdegrevlex([w, x])*negdegrevlex([y, z])\nnegdegrevlex([w, x])*negdegrevlex([y, z])\n\njulia> is_elimination_ordering(o6, [w, x])\nfalse\n\n\n\n\n\n","category":"method"},{"location":"CommutativeAlgebra/GroebnerBases/orderings/","page":"Monomial Orderings","title":"Monomial Orderings","text":"is_global(ord::MonomialOrdering)","category":"page"},{"location":"CommutativeAlgebra/GroebnerBases/orderings/#is_global-Tuple{MonomialOrdering}","page":"Monomial Orderings","title":"is_global","text":"is_global(ord::MonomialOrdering)\n\nReturn true if ord is global, false otherwise.\n\nExamples\n\njulia> R, (x, y) = polynomial_ring(QQ, [:x, :y]);\n\njulia> o = matrix_ordering(R, [1 1; 0 -1])\nmatrix_ordering([x, y], [1 1; 0 -1])\n\njulia> is_global(o)\ntrue\n\n\n\n\n\n","category":"method"},{"location":"CommutativeAlgebra/GroebnerBases/orderings/","page":"Monomial Orderings","title":"Monomial Orderings","text":"is_local(ord::MonomialOrdering)","category":"page"},{"location":"CommutativeAlgebra/GroebnerBases/orderings/#is_local-Tuple{MonomialOrdering}","page":"Monomial Orderings","title":"is_local","text":"is_local(ord::MonomialOrdering)\n\nReturn true if ord is local, false otherwise.\n\nExamples\n\njulia> R, (x, y) = polynomial_ring(QQ, [:x, :y]);\n\njulia> o = matrix_ordering(R, [-1 -1; 0 -1])\nmatrix_ordering([x, y], [-1 -1; 0 -1])\n\njulia> is_local(o)\ntrue\n\n\n\n\n\n","category":"method"},{"location":"CommutativeAlgebra/GroebnerBases/orderings/","page":"Monomial Orderings","title":"Monomial Orderings","text":"is_mixed(ord::MonomialOrdering)","category":"page"},{"location":"CommutativeAlgebra/GroebnerBases/orderings/#is_mixed-Tuple{MonomialOrdering}","page":"Monomial Orderings","title":"is_mixed","text":"is_mixed(ord::MonomialOrdering)\n\nReturn true if ord is mixed, false otherwise.\n\nExamples\n\njulia> R, (x, y) = polynomial_ring(QQ, [:x, :y]);\n\njulia> o = matrix_ordering(R, [1 -1; 0 -1])\nmatrix_ordering([x, y], [1 -1; 0 -1])\n\njulia> is_mixed(o)\ntrue\n\n\n\n\n\n","category":"method"},{"location":"CommutativeAlgebra/GroebnerBases/orderings/#Transferring-an-ordering-from-another-ring","page":"Monomial Orderings","title":"Transferring an ordering from another ring","text":"","category":"section"},{"location":"CommutativeAlgebra/GroebnerBases/orderings/","page":"Monomial Orderings","title":"Monomial Orderings","text":"induce(vars::AbstractVector{<:MPolyRingElem}, ord::MonomialOrdering)","category":"page"},{"location":"CommutativeAlgebra/GroebnerBases/orderings/#induce-Tuple{AbstractVector{<:MPolyRingElem}, MonomialOrdering}","page":"Monomial Orderings","title":"induce","text":"induce(vars::AbstractVector{<:MPolyRingElem}, ord::MonomialOrdering)\n\nReturn the monomial ordering on the variables vars induced by transferring the ordering ord.\n\nExamples\n\njulia> R, (x, y, z) = polynomial_ring(QQ, [:x, :y, :z]);\n\njulia> S, (a, b, c) = polynomial_ring(GF(5), [:a, :b, :c]);\n\njulia> ord = degrevlex([x, y])*neglex([z]);\n\njulia> induce([a, b, c], ord)\ndegrevlex([a, b])*neglex([c])\n\n\n\n\n\n","category":"method"},{"location":"CommutativeAlgebra/GroebnerBases/orderings/#Module-Orderings","page":"Monomial Orderings","title":"Module Orderings","text":"","category":"section"},{"location":"CommutativeAlgebra/GroebnerBases/orderings/","page":"Monomial Orderings","title":"Monomial Orderings","text":"Let R = Cx=Cx_1 ldots x_n be a multivariate polynomial ring with coefficient ring C. Referring to the section on free modules for details, we recall that by a free R-module we mean a free module of type R^p , where we think of R^p as a free module with a given basis, namely the basis of standard unit vectors. In what follows, F will denote such free R-module, and e_1 dots  e_p will denote the given basis.","category":"page"},{"location":"CommutativeAlgebra/GroebnerBases/orderings/","page":"Monomial Orderings","title":"Monomial Orderings","text":"A monomial in F, involving the basis element e_i, is a monomial in R times e_i.  A term in F is a monomial in F multiplied by a coefficient cin C. Every nonzero element fin F can  be uniquely expressed as the sum of finitely many nonzero terms involving  distinct monomials. These terms (monomials)  are called the terms (monomials} of f.","category":"page"},{"location":"CommutativeAlgebra/GroebnerBases/orderings/","page":"Monomial Orderings","title":"Monomial Orderings","text":"A monomial ordering on F is a total ordering  on the set of monomials in F such that if x^alpha e_i and x^beta e_j are monomials in F, and x^gamma is a monomial in R, then ","category":"page"},{"location":"CommutativeAlgebra/GroebnerBases/orderings/","page":"Monomial Orderings","title":"Monomial Orderings","text":"x^alpha e_i  x^beta e_j Longrightarrow x^gamma x^alpha e_i  x^gamma x^beta e_j","category":"page"},{"location":"CommutativeAlgebra/GroebnerBases/orderings/","page":"Monomial Orderings","title":"Monomial Orderings","text":"In OSCAR, we require in addition that","category":"page"},{"location":"CommutativeAlgebra/GroebnerBases/orderings/","page":"Monomial Orderings","title":"Monomial Orderings","text":"x^alpha e_i  x^beta e_i text iff  x^alpha e_j  x^beta e_j text for all  ij","category":"page"},{"location":"CommutativeAlgebra/GroebnerBases/orderings/","page":"Monomial Orderings","title":"Monomial Orderings","text":"Then  induces a unique monomial ordering on R in the obvious way, and we say that   is global, local, or mixed if the induced ordering on R is global, local, or mixed. ","category":"page"},{"location":"CommutativeAlgebra/GroebnerBases/orderings/","page":"Monomial Orderings","title":"Monomial Orderings","text":"One way of getting a monomial ordering on F is to pick a monomial ordering  on R, and extend it to F. For instance, setting","category":"page"},{"location":"CommutativeAlgebra/GroebnerBases/orderings/","page":"Monomial Orderings","title":"Monomial Orderings","text":"x^alpha e_i   x^beta e_j iff x^alpha  x^beta text or  (x^alpha = x^beta text and  i  j)","category":"page"},{"location":"CommutativeAlgebra/GroebnerBases/orderings/","page":"Monomial Orderings","title":"Monomial Orderings","text":"gives priority to the monomials in R, whereas the ordering defined below gives priority to the components of F:","category":"page"},{"location":"CommutativeAlgebra/GroebnerBases/orderings/","page":"Monomial Orderings","title":"Monomial Orderings","text":"x^alpha e_i   x^beta e_j iff i  j text or  (i = jtext and  x^alpha  x^beta)","category":"page"},{"location":"CommutativeAlgebra/GroebnerBases/orderings/","page":"Monomial Orderings","title":"Monomial Orderings","text":"Alternatively, we may wish to use i  j instead of i  j in this definition.","category":"page"},{"location":"CommutativeAlgebra/GroebnerBases/orderings/","page":"Monomial Orderings","title":"Monomial Orderings","text":"In other words, these orderings are obtained by concatenating a monomial ordering on the monomials of R with a way of ordering the basis vectors of F or vice versa. In OSCAR, we refer to the i  j ordering on the basis vectors as lex, and to the i  j ordering as invlex. And, we use the * operator for concatenation.","category":"page"},{"location":"CommutativeAlgebra/GroebnerBases/orderings/#Examples-3","page":"Monomial Orderings","title":"Examples","text":"","category":"section"},{"location":"CommutativeAlgebra/GroebnerBases/orderings/","page":"Monomial Orderings","title":"Monomial Orderings","text":"julia> R, (w, x, y, z) = polynomial_ring(QQ, [:w, :x, :y, :z]);\n\njulia> F = free_module(R, 3)\nFree module of rank 3 over R\n\njulia> o1 = degrevlex(R)*invlex(gens(F))\ndegrevlex([w, x, y, z])*invlex([gen(1), gen(2), gen(3)])\n\njulia> o2 = invlex(gens(F))*degrevlex(R)\ninvlex([gen(1), gen(2), gen(3)])*degrevlex([w, x, y, z])\n","category":"page"},{"location":"CommutativeAlgebra/GroebnerBases/orderings/","page":"Monomial Orderings","title":"Monomial Orderings","text":"The induced ordering on the given polynomial ring is recovered as follows:","category":"page"},{"location":"CommutativeAlgebra/GroebnerBases/orderings/","page":"Monomial Orderings","title":"Monomial Orderings","text":"induced_ring_ordering(ord::ModuleOrdering)","category":"page"},{"location":"CommutativeAlgebra/GroebnerBases/orderings/#induced_ring_ordering-Tuple{ModuleOrdering}","page":"Monomial Orderings","title":"induced_ring_ordering","text":"induced_ring_ordering(ord::ModuleOrdering)\n\nReturn the ring ordering induced by ord.  \n\nExamples\n\njulia> R, (w, x, y, z) = polynomial_ring(QQ, [:w, :x, :y, :z]);\n\njulia> F = free_module(R, 3)\nFree module of rank 3 over R\n\njulia> o = invlex(gens(F))*degrevlex(R)\ninvlex([gen(1), gen(2), gen(3)])*degrevlex([w, x, y, z])\n\njulia> induced_ring_ordering(o)\ndegrevlex([w, x, y, z])\n\n\n\n\n\n","category":"method"},{"location":"CommutativeAlgebra/GroebnerBases/orderings/","page":"Monomial Orderings","title":"Monomial Orderings","text":"The comparison function cmp as well as the tests is_global, is_local, and is_mixed are also available for module orderings.","category":"page"},{"location":"DeveloperDocumentation/debugging/#Debugging-OSCAR-Code","page":"Debugging OSCAR Code","title":"Debugging OSCAR Code","text":"","category":"section"},{"location":"DeveloperDocumentation/debugging/#Pitfalls:-Mutable-objects-in-OSCAR-code","page":"Debugging OSCAR Code","title":"Pitfalls: Mutable objects in OSCAR code","text":"","category":"section"},{"location":"DeveloperDocumentation/debugging/","page":"Debugging OSCAR Code","title":"Debugging OSCAR Code","text":"Suppose you are having the following difficulties. Your code is exhibiting inexplicable behavior and values that should not be changing are changing in seemingly random locations. To get to the bottom of these kind of issues it is necessary to be familiar with mutable objects in Julia and some of the relevant conventions in place in OSCAR. This section discusses these informal rules as well as some of the exceptions to these rules.","category":"page"},{"location":"DeveloperDocumentation/debugging/","page":"Debugging OSCAR Code","title":"Debugging OSCAR Code","text":"In Julia, objects that can change after construction are declared with the mutable struct keywords and satisfy the ismutable predicate. These objects can be linked together into an arbitrary dependency graph, and a change to one object may therefore have unintended consequences on another object in the system.","category":"page"},{"location":"DeveloperDocumentation/debugging/","page":"Debugging OSCAR Code","title":"Debugging OSCAR Code","text":"The simplest example is the creation of a polynomial ring. If we mutate the array of symbols used for printing, we have effectively changed the ring.","category":"page"},{"location":"DeveloperDocumentation/debugging/","page":"Debugging OSCAR Code","title":"Debugging OSCAR Code","text":"julia> v = [:x, :y, :z]; R = polynomial_ring(QQ, v)[1]\nMultivariate Polynomial Ring in x, y, z over Rational Field\n\njulia> v[3] = :w; R\nMultivariate Polynomial Ring in x, y, w over Rational Field","category":"page"},{"location":"DeveloperDocumentation/debugging/","page":"Debugging OSCAR Code","title":"Debugging OSCAR Code","text":"In this example, the modification of v is unexpected and may in fact corrupt the internal data structures used by the polynomial ring. As such, this modification of v has to be considered illegal. Upon creation of the array called v, we have full rights over the object and can mutate at will. However, after passing it to the function polynomial_ring, we have given up ownership of the array and are no longer free to modify it.","category":"page"},{"location":"DeveloperDocumentation/debugging/","page":"Debugging OSCAR Code","title":"Debugging OSCAR Code","text":"General OSCAR Principle (GOP):","category":"page"},{"location":"DeveloperDocumentation/debugging/","page":"Debugging OSCAR Code","title":"Debugging OSCAR Code","text":"Code should be expected to behave as if all objects are immutable.","category":"page"},{"location":"DeveloperDocumentation/debugging/","page":"Debugging OSCAR Code","title":"Debugging OSCAR Code","text":"Ramifications:","category":"page"},{"location":"DeveloperDocumentation/debugging/","page":"Debugging OSCAR Code","title":"Debugging OSCAR Code","text":"This means that the polynomial ring constructor is allowed to expect that v is never mutated for the remaining duration of its life. In return, the constructor is guaranteed not to modify the array, so that v is still [:x, :y, :z] after polynomial_ring returns.\nIn general this means that all functions should be expected to take ownership of their arguments: the user is safest never modifying an existing object that has been passed to an unknown Julia function. Note that assignments such as a[i] = b or a.foo = b usually mutate the object a. See Ownership of function arguments\nFor reasons of efficiency, it is sometimes desirable to defy this principle and modify an existing object. The fact that a given function may modify a preexisting object is usually communicated via coding conventions on the name - either a ! or a _unsafe in the name of the function. See Unsafe arithmetic with OSCAR objects","category":"page"},{"location":"DeveloperDocumentation/debugging/#Ownership-of-function-arguments","page":"Debugging OSCAR Code","title":"Ownership of function arguments","text":"","category":"section"},{"location":"DeveloperDocumentation/debugging/","page":"Debugging OSCAR Code","title":"Debugging OSCAR Code","text":"In this example we construct the factored element x = 2^3 and then change the 2 to a 1. The GOP says this modification of a on line 3 is illegal.","category":"page"},{"location":"DeveloperDocumentation/debugging/","page":"Debugging OSCAR Code","title":"Debugging OSCAR Code","text":"julia> a = ZZRingElem(2)\n2\n\njulia> x = FacElem([a], [ZZRingElem(3)]); evaluate(x)\n8\n\njulia> a = one!(a)  # illegal in-place assignment of a to 1\n1\n\njulia> evaluate(x)  # x has been changed and possibly corrupted\n1","category":"page"},{"location":"DeveloperDocumentation/debugging/","page":"Debugging OSCAR Code","title":"Debugging OSCAR Code","text":"In the previous example, the link between the object x and the object a can be broken by passing a deepcopy of a to the FacElem function.","category":"page"},{"location":"DeveloperDocumentation/debugging/","page":"Debugging OSCAR Code","title":"Debugging OSCAR Code","text":"julia> a = ZZRingElem(2)\n2\n\njulia> x = FacElem([deepcopy(a)], [ZZRingElem(3)]); evaluate(x)\n8\n\njulia> a = one!(a)  # we still own a, so modification is legal\n1\n\njulia> evaluate(x)  # x is now unchanged\n8","category":"page"},{"location":"DeveloperDocumentation/debugging/","page":"Debugging OSCAR Code","title":"Debugging OSCAR Code","text":"It is of course not true that all Julia functions take ownership of their arguments, but the GOP derives from the fact that this decision is an implementation detail with performance consequences. The behavior of a function may be inconsistent across different types and versions of OSCAR. In the following two snippets, the GOP says both modifications of a are illegal since they have since been passed to a function. If K = QQ, the two mutations turn out to be legal currently, while they are illegal if K = quadratic_field(-1)[1]. Only with special knowledge of the types can the GOP be safely ignored.","category":"page"},{"location":"DeveloperDocumentation/debugging/","page":"Debugging OSCAR Code","title":"Debugging OSCAR Code","text":"R = polynomial_ring(K, [:x, :y])[1]\na = one(K)\np = R([a], [[0,0]])\n@show p\na = add!(a, a, a)       # legal? (does a += a in-place)\n@show p","category":"page"},{"location":"DeveloperDocumentation/debugging/","page":"Debugging OSCAR Code","title":"Debugging OSCAR Code","text":"R = polynomial_ring(K, :x)[1]\na = [one(K), one(K)]\np = R(a)\n@show (p, degree(p))\na[2] = zero(K)          # legal?\n@show (p, degree(p))","category":"page"},{"location":"DeveloperDocumentation/debugging/#Ownership-of-function-return-values","page":"Debugging OSCAR Code","title":"Ownership of function return values","text":"","category":"section"},{"location":"DeveloperDocumentation/debugging/","page":"Debugging OSCAR Code","title":"Debugging OSCAR Code","text":"The nuances of who is allowed to modify an object returned by a function is best left to the next section Unsafe arithmetic with OSCAR objects. The GOP says of course you should not do it, but there are cases where it can be more efficient. However, there is another completely different issue of return values that can arise in certain interfaces.","category":"page"},{"location":"DeveloperDocumentation/debugging/","page":"Debugging OSCAR Code","title":"Debugging OSCAR Code","text":"First, we create the Gaussian rationals and the two primes above 5.","category":"page"},{"location":"DeveloperDocumentation/debugging/","page":"Debugging OSCAR Code","title":"Debugging OSCAR Code","text":"julia> K, i = quadratic_field(-1)\n(Imaginary quadratic field defined by x^2 + 1, sqrt(-1))\n\njulia> m = Hecke.modular_init(K, 5)\nmodular environment for p=5, using 2 ideals","category":"page"},{"location":"DeveloperDocumentation/debugging/","page":"Debugging OSCAR Code","title":"Debugging OSCAR Code","text":"The function modular_project returns the projection of an element of K into each of the residue fields.","category":"page"},{"location":"DeveloperDocumentation/debugging/","page":"Debugging OSCAR Code","title":"Debugging OSCAR Code","text":"julia> a = Hecke.modular_proj(1+2*i, m)\n2-element Vector{fqPolyRepFieldElem}:\n 2\n 0","category":"page"},{"location":"DeveloperDocumentation/debugging/","page":"Debugging OSCAR Code","title":"Debugging OSCAR Code","text":"While the function has produced the correct answer, if we run it again on a different input, we will find that a has changed.","category":"page"},{"location":"DeveloperDocumentation/debugging/","page":"Debugging OSCAR Code","title":"Debugging OSCAR Code","text":"julia> b = Hecke.modular_proj(2+3*i, m)\n2-element Vector{fqPolyRepFieldElem}:\n 1\n 3\n\njulia> a\n2-element Vector{fqPolyRepFieldElem}:\n 1\n 3","category":"page"},{"location":"DeveloperDocumentation/debugging/","page":"Debugging OSCAR Code","title":"Debugging OSCAR Code","text":"The preceding behavior of the function modular_proj is an artifact of internal efficiency and may be desirable in certain circumstances. In other circumstances, the following deepcopys may be necessary for your code to function correctly.","category":"page"},{"location":"DeveloperDocumentation/debugging/","page":"Debugging OSCAR Code","title":"Debugging OSCAR Code","text":"julia> a = deepcopy(Hecke.modular_proj(1+2*i, m));\njulia> b = deepcopy(Hecke.modular_proj(2+3*i, m));\njulia> (a, b)\n(fqPolyRepFieldElem[2, 0], fqPolyRepFieldElem[1, 3])","category":"page"},{"location":"DeveloperDocumentation/debugging/#Unsafe-arithmetic-with-OSCAR-objects","page":"Debugging OSCAR Code","title":"Unsafe arithmetic with OSCAR objects","text":"","category":"section"},{"location":"DeveloperDocumentation/debugging/","page":"Debugging OSCAR Code","title":"Debugging OSCAR Code","text":"Particularly with integers (BigInt and ZZRingElem) - but also to a lesser extent with polynomials - the cost of basic arithmetic operations can easily be dominated by the cost of allocating space for the answer. For this reason, OSCAR offers an interface for in-place arithmetic operations.","category":"page"},{"location":"DeveloperDocumentation/debugging/","page":"Debugging OSCAR Code","title":"Debugging OSCAR Code","text":"Instead of writing x = a + b to compute a sum, one writes x = add!(x, a, b) with the idea that the object to which x is pointing is modified instead of having x point to a newly allocated object. In order for this to work, x must point to a fully independent object, that is, an object whose modification through the interface Unsafe operators will not change the values of other existing objects. The actual definition of \"fully independent\" is left to the implementation of the ring element type. For example, there is no distinction for immutables.","category":"page"},{"location":"DeveloperDocumentation/debugging/","page":"Debugging OSCAR Code","title":"Debugging OSCAR Code","text":"It is generally not safe to mutate the return of a function. However, the basic arithmetic operations +, -, *, and ^ are guaranteed to return a fully independent object regardless of the status of their inputs. As such, the following implementation of ^ is illegal by this guarantee.","category":"page"},{"location":"DeveloperDocumentation/debugging/","page":"Debugging OSCAR Code","title":"Debugging OSCAR Code","text":"function ^(a::RingElem, n::Int)\n  if n == 1\n    return a    # must be return deepcopy(a)\n  else\n    ...\n  end\nend","category":"page"},{"location":"DeveloperDocumentation/debugging/","page":"Debugging OSCAR Code","title":"Debugging OSCAR Code","text":"In general, if you are not sure if your object is fully independent, a deepcopy should always do the job.","category":"page"},{"location":"AlgebraicGeometry/Curves/ProjectiveCurves/","page":"Projective Curves","title":"Projective Curves","text":"CurrentModule = Oscar","category":"page"},{"location":"AlgebraicGeometry/Curves/ProjectiveCurves/#Projective-Curves","page":"Projective Curves","title":"Projective Curves","text":"","category":"section"},{"location":"AlgebraicGeometry/Curves/ProjectiveCurves/","page":"Projective Curves","title":"Projective Curves","text":"ProjectiveCurve\ninvert_birational_map\ngeometric_genus","category":"page"},{"location":"AlgebraicGeometry/Curves/ProjectiveCurves/#ProjectiveCurve","page":"Projective Curves","title":"ProjectiveCurve","text":"ProjectiveCurve\n\nA reduced projective curve, defined as the vanishing locus of a homogeneous (but not necessarily radical) ideal.\n\nExamples\n\njulia> R, (w, x, y, z) = graded_polynomial_ring(QQ, [:w, :x, :y, :z]);\n\njulia> M = matrix(R, 2, 3, [w x y; x y z])\n[w   x   y]\n[x   y   z]\n\njulia> V = minors(M, 2)\n3-element Vector{MPolyDecRingElem{QQFieldElem, QQMPolyRingElem}}:\n w*y - x^2\n w*z - x*y\n x*z - y^2\n\njulia> I = ideal(R, V);\n\njulia> TC = projective_curve(I)\nProjective curve\n  in projective 3-space over QQ with coordinates [w, x, y, z]\ndefined by ideal (w*y - x^2, w*z - x*y, x*z - y^2)\n\n\n\n\n\n\n","category":"type"},{"location":"AlgebraicGeometry/Curves/ProjectiveCurves/#invert_birational_map","page":"Projective Curves","title":"invert_birational_map","text":"invert_birational_map(phi::Vector{T}, C::ProjectiveCurve) where {T <: MPolyRingElem}\n\nReturn a dictionary where image represents the image of the birational map given by phi, and inverse represents its inverse, where phi is a birational map of the projective curve C to its image in the projective space of dimension size(phi) - 1. Note that the entries of inverse should be considered as representatives of elements in R/image, where R is the basering.\n\n\n\n\n\ninvert_birational_map(phi::Vector{T}, C::ProjectivePlaneCurve) where {T <: MPolyRingElem}\n\nReturn a dictionary where image represents the image of the birational map given by phi, and inverse represents its inverse, where phi is a birational map of the projective plane curve C to its image in the projective space of dimension size(phi) - 1. Note that the entries of inverse should be considered as representatives of elements in R/image, where R is the basering.\n\n\n\n\n\n","category":"function"},{"location":"AlgebraicGeometry/Curves/ProjectiveCurves/#geometric_genus","page":"Projective Curves","title":"geometric_genus","text":"geometric_genus(X::AbsProjectiveScheme{<:Field}; algorithm::Symbol=:default) -> Int\n\nGiven a projective curve X return the genus of X, i.e. the  integer p_g = p_a - delta where p_a is the arithmetic genus and \\delta the delta-invariant of the curve.\n\nThe algorithm keyword can be specified to \n\n:normalization to compute delta a normalization\n:primary_decomposition to proceed with a primary decomposition\n\nNormalization is usually slower, but not always.\n\nExamples\n\njulia> R, (x,y,z) = graded_polynomial_ring(QQ, [:x, :y, :z]);\n\njulia> C = plane_curve(z*x^2-y^3)\nProjective plane curve\n  defined by 0 = x^2*z - y^3\n\njulia> geometric_genus(C)\n0\n\n\n\n\n\n\n","category":"function"},{"location":"Combinatorics/EnumerativeCombinatorics/partitions/","page":"Partitions","title":"Partitions","text":"CurrentModule = Oscar\nDocTestSetup = Oscar.doctestsetup()","category":"page"},{"location":"Combinatorics/EnumerativeCombinatorics/partitions/#Partitions","page":"Partitions","title":"Partitions","text":"","category":"section"},{"location":"Combinatorics/EnumerativeCombinatorics/partitions/","page":"Partitions","title":"Partitions","text":"A partition of a non-negative integer n is a decreasing sequence lambda_1 geq lambda_2geq dots geq lambda_r of positive integers lambda_i such that n = lambda_1 + dots + lambda_r. The lambda_i are called the parts of the partition and r is called the length. General references on partitions are [Ful97] and [Knu11], Section 7.2.1.4.","category":"page"},{"location":"Combinatorics/EnumerativeCombinatorics/partitions/","page":"Partitions","title":"Partitions","text":"A partition can be encoded as an array with elements lambda_i. In OSCAR, the parametric type Partition{T} is provided which is a subtype of AbstractVector{T}. Here, T can be any subtype of IntegerUnion. There is no performance impact by using an own type for partitions rather than simply using arrays. The parametric type allows to increase performance by using smaller integer types.","category":"page"},{"location":"Combinatorics/EnumerativeCombinatorics/partitions/","page":"Partitions","title":"Partitions","text":"partition","category":"page"},{"location":"Combinatorics/EnumerativeCombinatorics/partitions/#partition","page":"Partitions","title":"partition","text":"partition([T::Type{<:IntegerUnion}], parts::IntegerUnion...; check::Bool = true)\npartition(parts::Vector{T}; check::Bool = true) where T <: IntegerUnion\n\nReturn the partition given by the integer sequence parts as an object of type Partition{T}.\n\nThe element type T may be optionally specified, see also the examples below.\n\nIf check is true (default), it is checked whether the given sequence defines a partition.\n\nExamples\n\njulia> P = partition([6, 4, 4, 2]) # the partition 6 + 4 + 4 + 2 of 16\n[6, 4, 4, 2]\n\njulia> P = partition(6, 4, 4, 2) # the same partition\n[6, 4, 4, 2]\n\njulia> P = partition(Int8, 6, 4, 4, 2) # save the elements in 8-bit integers\nInt8[6, 4, 4, 2]\n\n\n\n\n\n","category":"function"},{"location":"Combinatorics/EnumerativeCombinatorics/partitions/","page":"Partitions","title":"Partitions","text":"Because Partition is a subtype of AbstractVector, all functions that can be used for vectors (1-dimensional arrays) can be used for partitions as well.","category":"page"},{"location":"Combinatorics/EnumerativeCombinatorics/partitions/","page":"Partitions","title":"Partitions","text":"julia> P = partition(6, 4, 4, 2)\n[6, 4, 4, 2]\n\njulia> length(P)\n4\n\njulia> P[1]\n6","category":"page"},{"location":"Combinatorics/EnumerativeCombinatorics/partitions/","page":"Partitions","title":"Partitions","text":"However, usually, lambda = n is called the size of lambda. In Julia, the function size for arrays already exists and returns the dimension of an array. Instead, one can use the Julia function sum to get the sum of the parts.","category":"page"},{"location":"Combinatorics/EnumerativeCombinatorics/partitions/","page":"Partitions","title":"Partitions","text":"julia> P = partition(6, 4, 4, 2)\n[6, 4, 4, 2]\n\njulia> sum(P)\n16","category":"page"},{"location":"Combinatorics/EnumerativeCombinatorics/partitions/","page":"Partitions","title":"Partitions","text":"In algorithms involving partitions it is sometimes convenient to be able to access parts beyond the length of the partition and then one wants to get the value zero instead of an error. For this, OSCAR provides the function getindex_safe:","category":"page"},{"location":"Combinatorics/EnumerativeCombinatorics/partitions/","page":"Partitions","title":"Partitions","text":"getindex_safe","category":"page"},{"location":"Combinatorics/EnumerativeCombinatorics/partitions/#getindex_safe","page":"Partitions","title":"getindex_safe","text":"getindex_safe(P::Partition, i::IntegerUnion)\n\nReturn P[i] if i < length(P) and 0 otherwise. It is assumed that i is positive.\n\nExamples\n\njulia> P = partition([3, 2, 1])\n[3, 2, 1]\n\njulia> getindex_safe(P, 3)\n1\n\njulia> getindex_safe(P, 4)\n0\n\n\n\n\n\n","category":"function"},{"location":"Combinatorics/EnumerativeCombinatorics/partitions/","page":"Partitions","title":"Partitions","text":"If you are sure that P[i] exists, use getindex because this will be faster.","category":"page"},{"location":"Combinatorics/EnumerativeCombinatorics/partitions/#Generating-and-counting","page":"Partitions","title":"Generating and counting","text":"","category":"section"},{"location":"Combinatorics/EnumerativeCombinatorics/partitions/","page":"Partitions","title":"Partitions","text":"partitions(::Oscar.IntegerUnion)\nnumber_of_partitions(::Oscar.IntegerUnion)","category":"page"},{"location":"Combinatorics/EnumerativeCombinatorics/partitions/#partitions-Tuple{Union{Integer, ZZRingElem}}","page":"Partitions","title":"partitions","text":"partitions(n::IntegerUnion)\n\nReturn an iterator over all partitions of a non-negative integer n, produced in lexicographically descending order. Using a smaller integer type for n (e.g. Int8) may increase performance.\n\nThe algorithm used is \"Algorithm ZS1\" by [ZS98]. This algorithm is also discussed in [Knu11], Algorithm P (page 392).\n\nExamples\n\njulia> p = partitions(4);\n\njulia> first(p)\n[4]\n\njulia> collect(p)\n5-element Vector{Partition{Int64}}:\n [4]\n [3, 1]\n [2, 2]\n [2, 1, 1]\n [1, 1, 1, 1]\n\njulia> collect(partitions(Int8(4))) # using less memory\n5-element Vector{Partition{Int8}}:\n Int8[4]\n Int8[3, 1]\n Int8[2, 2]\n Int8[2, 1, 1]\n Int8[1, 1, 1, 1]\n\n\n\n\n\n","category":"method"},{"location":"Combinatorics/EnumerativeCombinatorics/partitions/#number_of_partitions-Tuple{Union{Integer, ZZRingElem}}","page":"Partitions","title":"number_of_partitions","text":"number_of_partitions(n::IntegerUnion)\n\nReturn the number of integer partitions of n. For n < 0, return 0.\n\nExamples\n\njulia> number_of_partitions(1000)\n24061467864032622473692149727991\n\n\n\n\n\n","category":"method"},{"location":"Combinatorics/EnumerativeCombinatorics/partitions/","page":"Partitions","title":"Partitions","text":"For counting partitions, the Hardy-Ramanujan-Rademachen formula is used, see [Joh12] for details. See also [Knu11], Section 7.2.1.4 and [OEIS], A000041.","category":"page"},{"location":"Combinatorics/EnumerativeCombinatorics/partitions/#Partitions-with-restrictions","page":"Partitions","title":"Partitions with restrictions","text":"","category":"section"},{"location":"Combinatorics/EnumerativeCombinatorics/partitions/","page":"Partitions","title":"Partitions","text":"How many ways are there to pay one euro, using coins worth 1, 2, 5, 10, 20, 50, and/or 100 cents? What if you are allowed to use at most two of each coin?","category":"page"},{"location":"Combinatorics/EnumerativeCombinatorics/partitions/","page":"Partitions","title":"Partitions","text":"This is Exercise 11 in [Knu11], Section 7.2.1.4. It goes back to the famous \"Ways to change one dollar\" problem, see [Pol56]. Generally, the problem is to generate and/or count partitions satisfying some restrictions. Of course, one could generate the list of all partitions of 100 (there are about 190 million) and then filter the result by the restrictions. But for certain types of restrictions there are much more efficient algorithms. The functions in this section implement some of these. In combination with Julia's filter function one can also handle more general types of restrictions.","category":"page"},{"location":"Combinatorics/EnumerativeCombinatorics/partitions/","page":"Partitions","title":"Partitions","text":"For example, there are precisely six ways for the second question in the exercise quoted above:","category":"page"},{"location":"Combinatorics/EnumerativeCombinatorics/partitions/","page":"Partitions","title":"Partitions","text":"julia> collect(partitions(100, [1, 2, 5, 10, 20, 50], [2, 2, 2, 2, 2, 2]))\n6-element Vector{Partition{Int64}}:\n [50, 50]\n [50, 20, 20, 10]\n [50, 20, 20, 5, 5]\n [50, 20, 10, 10, 5, 5]\n [50, 20, 20, 5, 2, 2, 1]\n [50, 20, 10, 10, 5, 2, 2, 1]","category":"page"},{"location":"Combinatorics/EnumerativeCombinatorics/partitions/","page":"Partitions","title":"Partitions","text":"and there are 4562 ways for the first question in the exercise:","category":"page"},{"location":"Combinatorics/EnumerativeCombinatorics/partitions/","page":"Partitions","title":"Partitions","text":"julia> length(collect(partitions(100, [1, 2, 5, 10, 20, 50])))\n4562","category":"page"},{"location":"Combinatorics/EnumerativeCombinatorics/partitions/","page":"Partitions","title":"Partitions","text":"The original \"Ways to change one dollar\" problem has 292 solutions:","category":"page"},{"location":"Combinatorics/EnumerativeCombinatorics/partitions/","page":"Partitions","title":"Partitions","text":"julia> length(collect(partitions(100, [1, 5, 10, 25, 50])))\n292","category":"page"},{"location":"Combinatorics/EnumerativeCombinatorics/partitions/","page":"Partitions","title":"Partitions","text":"number_of_partitions(::Oscar.IntegerUnion, ::Oscar.IntegerUnion)","category":"page"},{"location":"Combinatorics/EnumerativeCombinatorics/partitions/#number_of_partitions-Tuple{Union{Integer, ZZRingElem}, Union{Integer, ZZRingElem}}","page":"Partitions","title":"number_of_partitions","text":"number_of_partitions(n::IntegerUnion, k::IntegerUnion)\n\nReturn the number of integer partitions of the non-negative integer n into k >= 0 parts. If n < 0 or k < 0, return 0.\n\n\n\n\n\n","category":"method"},{"location":"Combinatorics/EnumerativeCombinatorics/partitions/","page":"Partitions","title":"Partitions","text":"For counting the partitions the recurrence relation p_k(n) = p_k - 1(n - 1) + p_k(n - k) is used, where p_k(n) denotes the number of partitions of n into k parts; see [Knu11], Section 7.2.1.4, Equation (39), and also [OEIS], A008284.","category":"page"},{"location":"Combinatorics/EnumerativeCombinatorics/partitions/","page":"Partitions","title":"Partitions","text":"partitions(::Oscar.IntegerUnion, ::Oscar.IntegerUnion, ::Oscar.IntegerUnion, ::Oscar.IntegerUnion)\npartitions(::T, ::Vector{T}) where T <: Oscar.IntegerUnion","category":"page"},{"location":"Combinatorics/EnumerativeCombinatorics/partitions/#partitions-NTuple{4, Union{Integer, ZZRingElem}}","page":"Partitions","title":"partitions","text":"partitions(n::IntegerUnion, k::IntegerUnion; only_distinct_parts::Bool = false)\npartitions(n::IntegerUnion, k::IntegerUnion, lb::IntegerUnion, ub::IntegerUnion; only_distinct_parts::Bool = false)\n\nReturn an iterator over all partitions of a non-negative integer n into k >= 0 parts. Optionally, a lower bound lb >= 0 and an upper bound ub for the parts can be supplied. In this case, the partitions are produced in decreasing order.\n\nThere are two choices for the parameter only_distinct_parts:\n\nfalse: no further restriction (default);\ntrue: only distinct parts.\n\nThe implemented algorithm is \"parta\" in [RJ76].\n\nExamples\n\nAll partitions of 7 into 3 parts:\n\njulia> collect(partitions(7, 3))\n4-element Vector{Partition{Int64}}:\n [5, 1, 1]\n [4, 2, 1]\n [3, 3, 1]\n [3, 2, 2]\n\nAll partitions of 7 into 3 parts where all parts are between 1 and 4:\n\njulia> collect(partitions(7, 3, 1, 4))\n3-element Vector{Partition{Int64}}:\n [4, 2, 1]\n [3, 3, 1]\n [3, 2, 2]\n\nSame as above but requiring all parts to be distinct:\n\njulia> collect(partitions(7, 3, 1, 4; only_distinct_parts = true))\n1-element Vector{Partition{Int64}}:\n [4, 2, 1]\n\n\n\n\n\n","category":"method"},{"location":"Combinatorics/EnumerativeCombinatorics/partitions/#partitions-Union{Tuple{T}, Tuple{T, Vector{T}}} where T<:Union{Integer, ZZRingElem}","page":"Partitions","title":"partitions","text":"partitions(n::T, v::Vector{T}) where T <: IntegerUnion\npartitions(n::T, v::Vector{T}, mu::Vector{<:IntegerUnion}) where T <: IntegerUnion\npartitions(n::T, k::IntegerUnion, v::Vector{T}, mu::Vector{<:IntegerUnion}) where T <: IntegerUnion\n\nReturn an iterator over all partitions of a non-negative integer n where each part is an element in the vector v of positive integers. It is assumed that the entries in v are strictly increasing.\n\nIf the optional vector mu is supplied, then each v[i] occurs a maximum of mu[i] > 0 times per partition.\n\nIf the optional integer k >= 0 is supplied, the partitions will be into k parts. In this case, the partitions are produced in lexicographically decreasing order.\n\nThe implemented algorithm is \"partb\" in [RJ76].\n\nExamples\n\nThe number of partitions of 100 where the parts are from {1, 2, 5, 10, 20, 50}:\n\njulia> length(collect(partitions(100, [1, 2, 5, 10, 20, 50])))\n4562\n\nAll partitions of 100 where the parts are from {1, 2, 5, 10, 20, 50} and each part is allowed to occur at most twice:\n\njulia> collect(partitions(100, [1, 2, 5, 10, 20, 50], [2, 2, 2, 2, 2, 2]))\n6-element Vector{Partition{Int64}}:\n [50, 50]\n [50, 20, 20, 10]\n [50, 20, 20, 5, 5]\n [50, 20, 10, 10, 5, 5]\n [50, 20, 20, 5, 2, 2, 1]\n [50, 20, 10, 10, 5, 2, 2, 1]\n\nThe partitions of 100 into seven parts, where the parts are required to be elements from {1, 2, 5, 10, 20, 50} and each part is allowed to occur at most twice.\n\njulia> collect(partitions(100, 7, [1, 2, 5, 10, 20, 50], [2, 2, 2, 2, 2, 2]))\n1-element Vector{Partition{Int64}}:\n [50, 20, 20, 5, 2, 2, 1]\n\n\n\n\n\n","category":"method"},{"location":"Combinatorics/EnumerativeCombinatorics/partitions/#Operations","page":"Partitions","title":"Operations","text":"","category":"section"},{"location":"Combinatorics/EnumerativeCombinatorics/partitions/","page":"Partitions","title":"Partitions","text":"The conjugate of a partition lambda is obtained by considering its Young diagram (see Tableaux) and then flipping it along its main diagonal, see [Ful97], page 2, and [Knu11], Section 7.2.1.4.","category":"page"},{"location":"Combinatorics/EnumerativeCombinatorics/partitions/","page":"Partitions","title":"Partitions","text":"conjugate","category":"page"},{"location":"Combinatorics/EnumerativeCombinatorics/partitions/#conjugate","page":"Partitions","title":"conjugate","text":"conjugate(lambda::Partition)\n\nReturn the conjugate of the partition lambda.\n\nExamples\n\njulia> conjugate(partition(8, 8, 8, 7, 2, 1, 1))\n[7, 5, 4, 4, 4, 4, 4, 3]\n\n\n\n\n\n","category":"function"},{"location":"Combinatorics/EnumerativeCombinatorics/partitions/#Relations","page":"Partitions","title":"Relations","text":"","category":"section"},{"location":"Combinatorics/EnumerativeCombinatorics/partitions/","page":"Partitions","title":"Partitions","text":"The dominance order on partitions is the partial order trianglerighteq defined by lambda trianglerighteqmu if and only if lambda_1 + dots + lambda_i geq mu_1 + dots + mu_i for all i. If lambdatrianglerighteqmu one says that lambda dominates mu. See [Ful97], page 26, and [Knu11], Section 7.2.1.4, Exercise 54.","category":"page"},{"location":"Combinatorics/EnumerativeCombinatorics/partitions/","page":"Partitions","title":"Partitions","text":"Note that whereas the lexicographic ordering is a total ordering, the dominance ordering is not. Further, [Knu11] says majorizes instead of dominates and uses the symbol succeq instead of trianglerighteq.","category":"page"},{"location":"Combinatorics/EnumerativeCombinatorics/partitions/","page":"Partitions","title":"Partitions","text":"dominates","category":"page"},{"location":"Combinatorics/EnumerativeCombinatorics/partitions/#dominates","page":"Partitions","title":"dominates","text":"dominates(lambda::Partition, mu::Partition)\n\nReturn true if lambda dominates mu, false otherwise.\n\nExamples\n\njulia> dominates(partition(3, 1), partition(2, 2))\ntrue\n\njulia> dominates(partition(4, 1), partition(3, 3))\nfalse\n\n\n\n\n\n","category":"function"},{"location":"Fields/algebraic_closure_fp/","page":"Algebraic closure of finite prime fields","title":"Algebraic closure of finite prime fields","text":"CurrentModule = Oscar\nDocTestSetup = Oscar.doctestsetup()","category":"page"},{"location":"Fields/algebraic_closure_fp/#Algebraic-closure-of-finite-prime-fields","page":"Algebraic closure of finite prime fields","title":"Algebraic closure of finite prime fields","text":"","category":"section"},{"location":"Fields/algebraic_closure_fp/","page":"Algebraic closure of finite prime fields","title":"Algebraic closure of finite prime fields","text":"It is sometimes useful to consider various finite fields in a fixed characteristic at the same time, together with natural embeddings between these fields. The fields returned by abelian_closure are intended for that purpose.","category":"page"},{"location":"Fields/algebraic_closure_fp/","page":"Algebraic closure of finite prime fields","title":"Algebraic closure of finite prime fields","text":"algebraic_closure(F::T) where T <: FinField\next_of_degree","category":"page"},{"location":"Fields/algebraic_closure_fp/#algebraic_closure-Tuple{T} where T<:FinField","page":"Algebraic closure of finite prime fields","title":"algebraic_closure","text":"algebraic_closure(F::FinField)\n\nLet F be a prime field of order p. Return a field K that is the union of finite fields of order p^d, for all positive integers d. The degree d extension of F can be obtained as ext_of_degree(K, d).\n\nK is cached in F, and the fields returned by ext_of_degree are cached in K.\n\nExamples\n\njulia> K = algebraic_closure(GF(3, 1));\n\njulia> F2 = ext_of_degree(K, 2);\n\njulia> F3 = ext_of_degree(K, 3);\n\njulia> x = K(gen(F2)) + K(gen(F3));\n\njulia> degree(x)\n6\n\n\n\n\n\n","category":"method"},{"location":"Fields/algebraic_closure_fp/#ext_of_degree","page":"Algebraic closure of finite prime fields","title":"ext_of_degree","text":"ext_of_degree(A::AlgClosure, d::Int)\n\nReturn a finite field F of order p^d where p is the characteristic of K. This field is compatible with A in the sense that A(x) returns the element of A that corresponds to the element x of F.\n\n\n\n\n\n","category":"function"},{"location":"Groups/autgroup/","page":"Groups of automorphisms","title":"Groups of automorphisms","text":"CurrentModule = Oscar\nDocTestSetup = Oscar.doctestsetup()","category":"page"},{"location":"Groups/autgroup/#Groups-of-automorphisms","page":"Groups of automorphisms","title":"Groups of automorphisms","text":"","category":"section"},{"location":"Groups/autgroup/","page":"Groups of automorphisms","title":"Groups of automorphisms","text":"automorphism_group(G::GAPGroup)","category":"page"},{"location":"Groups/autgroup/#automorphism_group-Tuple{Oscar.GAPGroup}","page":"Groups of automorphisms","title":"automorphism_group","text":"automorphism_group(G::Group) -> A::AutomorphismGroup{T}\n\nReturn the full automorphism group of G. If f is an object of type GAPGroupHomomorphism and it is bijective from G to itself, then A(f) return the embedding of f in A.\n\nGroups of automorphisms over a group G have parametric type AutomorphismGroup{T}, where T is the type of G. \n\nExamples\n\njulia> S = symmetric_group(3)\nSym(3)\n\njulia> typeof(S)\nPermGroup\n\njulia> A = automorphism_group(S)\nAut( Sym( [ 1 .. 3 ] ) )\n\njulia> typeof(A)\nAutomorphismGroup{PermGroup}\n\nThe evaluation of the automorphism f in the element x is analogous to the homomorphism evaluation:  it can be obtained by typing either f(x) or x^f.\n\njulia> S = symmetric_group(4)\nSym(4)\n\njulia> A = automorphism_group(S)\nAut( Sym( [ 1 .. 4 ] ) )\n\njulia> x = perm(S,[2,1,4,3])\n(1,2)(3,4)\n\njulia> f = A[2]\nPcgs([ (3,4), (2,4,3), (1,4)(2,3), (1,3)(2,4) ]) -> [ (2,3), (2,4,3), (1,3)(2,4), (1,2)(3,4) ]\n\njulia> f(x)\n(1,4)(2,3)\n\njulia> x^f\n(1,4)(2,3)\n\nIt is possible to turn an automorphism f into a homomorphism by typing hom(f).\n\njulia> S = symmetric_group(4)\nSym(4)\n\njulia> A = automorphism_group(S)\nAut( Sym( [ 1 .. 4 ] ) )\n\njulia> f = A[2]\nPcgs([ (3,4), (2,4,3), (1,4)(2,3), (1,3)(2,4) ]) -> [ (2,3), (2,4,3), (1,3)(2,4), (1,2)(3,4) ]\n\njulia> typeof(f)\nAutomorphismGroupElem{PermGroup} (alias for Oscar.BasicGAPGroupElem{AutomorphismGroup{PermGroup}})\n\njulia> typeof(hom(f))\nGAPGroupHomomorphism{PermGroup, PermGroup}\n\nThe converse is also possible: if g is a bijective homomorphism from the group G to itself and A  is the automorphism group of G, then the instruction A(g) returns g as automorphism of G.  This is the standard way to explicitly build an automorphism (another way, available for inner  automorphisms, is shown in Section Inner_automorphisms).\n\nExamples\n\njulia> S = symmetric_group(4)\nSym(4)\n\njulia> a = perm(S,[2,1,4,3])\n(1,2)(3,4)\n\njulia> f = hom(S,S,x ->x^a)\nGroup homomorphism\n  from Sym(4)\n  to Sym(4)\n\njulia> A = automorphism_group(S)\nAut( Sym( [ 1 .. 4 ] ) )\n\njulia> A(f)\nMappingByFunction( Sym( [ 1 .. 4 ] ), Sym( [ 1 .. 4 ] ), <Julia: gap_fun> )\n\nElements of A can be multiplied with other elements of A or by elements of type GAPGroupHomomorphism; in this last case, the result has type GAPGroupHomomorphism.\n\nExamples\n\njulia> S = symmetric_group(4);\n\njulia> A = automorphism_group(S);\n\njulia> g = hom(S,S,x->x^S[1]);\n\njulia> g in A\nfalse\n\njulia> au = A(g);\n\njulia> au in A\ntrue\n\njulia> g == hom(au)\ntrue\n\njulia> x = cperm(S,[1,2,3]);\n\njulia> au(x)\n(2,3,4)\n\njulia> g(x) == au(x)\ntrue\n\nIn Oscar it is possible to multiply homomorphisms and automorphisms (whenever it makes sense); in such cases, the output is always a variable of type GAPGroupHomomorphism{S,T}.\n\njulia> S = symmetric_group(4)\nSym(4)\n\njulia> A = automorphism_group(S)\nAut( Sym( [ 1 .. 4 ] ) )\n\njulia> g = hom(S,S,x->x^S[1])\nGroup homomorphism\n  from Sym(4)\n  to Sym(4)\n\njulia> f = A(g)\nMappingByFunction( Sym( [ 1 .. 4 ] ), Sym( [ 1 .. 4 ] ), <Julia: gap_fun> )\n\njulia> typeof(g*f)\nGAPGroupHomomorphism{PermGroup, PermGroup}\n\n\n\n\n\n","category":"method"},{"location":"Groups/autgroup/","page":"Groups of automorphisms","title":"Groups of automorphisms","text":"The following functions are available for automorphisms, some of them similar to the corresponding functions for homomorphisms of groups.","category":"page"},{"location":"Groups/autgroup/","page":"Groups of automorphisms","title":"Groups of automorphisms","text":"is_invariant(f::GAPGroupElem{AutomorphismGroup{T}}, H::GAPGroup) where T <: GAPGroup\nrestrict_automorphism(f::GAPGroupElem{AutomorphismGroup{T}}, H::GAPGroup, A=automorphism_group(H)) where T <: GAPGroup\ninduced_automorphism(f::GAPGroupHomomorphism, mH::GAPGroupHomomorphism)\nhom(x::GAPGroupElem{AutomorphismGroup{T}}) where T <: GAPGroup","category":"page"},{"location":"Groups/autgroup/#is_invariant-Union{Tuple{T}, Tuple{GAPGroupElem{AutomorphismGroup{T}}, Oscar.GAPGroup}} where T<:Oscar.GAPGroup","page":"Groups of automorphisms","title":"is_invariant","text":"is_invariant(f::GAPGroupElem{AutomorphismGroup{T}}, H::GAPGroup) where T <: GAPGroup\n\nReturn whether f(H) == H.\n\n\n\n\n\n","category":"method"},{"location":"Groups/autgroup/#restrict_automorphism-Union{Tuple{T}, Tuple{GAPGroupElem{AutomorphismGroup{T}}, Oscar.GAPGroup}, Tuple{GAPGroupElem{AutomorphismGroup{T}}, Oscar.GAPGroup, Any}} where T<:Oscar.GAPGroup","page":"Groups of automorphisms","title":"restrict_automorphism","text":"restrict_automorphism(f::GAPGroupElem{AutomorphismGroup{T}}, H::GAPGroup) where T <: GAPGroup\n\nReturn the restriction of f to H as an automorphism of H. An exception is thrown if H is not invariant under f.\n\n\n\n\n\n","category":"method"},{"location":"Groups/autgroup/#induced_automorphism-Tuple{GAPGroupHomomorphism, GAPGroupHomomorphism}","page":"Groups of automorphisms","title":"induced_automorphism","text":"induced_automorphism(f::GAPGroupHomomorphism, g::GAPGroupHomomorphism)\ninduced_automorphism(f::GAPGroupHomomorphism, g::GAPGroupElem{AutomorphismGroup{T}})\n\nReturn the automorphism h of the image of f such that h(f) == f(g), where g is an automorphism of a group G and f is a group homomorphism defined over G such that the kernel of f is invariant under g\n\n\n\n\n\n","category":"method"},{"location":"Groups/autgroup/#hom-Union{Tuple{GAPGroupElem{AutomorphismGroup{T}}}, Tuple{T}} where T<:Oscar.GAPGroup","page":"Groups of automorphisms","title":"hom","text":"hom(f::GAPGroupElem{AutomorphismGroup{T}}) where T\n\nReturn the element f of type GAPGroupHomomorphism{T,T}.\n\n\n\n\n\n","category":"method"},{"location":"Groups/autgroup/#inner_automorphisms","page":"Groups of automorphisms","title":"Inner automorphisms","text":"","category":"section"},{"location":"Groups/autgroup/","page":"Groups of automorphisms","title":"Groups of automorphisms","text":"OSCAR provides the following functions to handle inner automorphisms of a group.","category":"page"},{"location":"Groups/autgroup/","page":"Groups of automorphisms","title":"Groups of automorphisms","text":"inner_automorphism(g::GAPGroupElem)\nis_inner_automorphism(f::GAPGroupHomomorphism)\ninner_automorphism_group(A::AutomorphismGroup{T}) where T <: GAPGroup","category":"page"},{"location":"Groups/autgroup/#inner_automorphism-Tuple{GAPGroupElem}","page":"Groups of automorphisms","title":"inner_automorphism","text":"inner_automorphism(g::GAPGroupElem)\n\nReturn the inner automorphism in automorphism_group(parent(g)) defined by x -> x^g.\n\n\n\n\n\n","category":"method"},{"location":"Groups/autgroup/#is_inner_automorphism-Tuple{GAPGroupHomomorphism}","page":"Groups of automorphisms","title":"is_inner_automorphism","text":"is_inner_automorphism(f::GAPGroupHomomorphism)\nis_inner_automorphism(f::GAPGroupElem{AutomorphismGroup{T}})\n\nReturn whether f is an inner automorphism.\n\n\n\n\n\n","category":"method"},{"location":"Groups/autgroup/#inner_automorphism_group-Union{Tuple{AutomorphismGroup{T}}, Tuple{T}} where T<:Oscar.GAPGroup","page":"Groups of automorphisms","title":"inner_automorphism_group","text":"inner_automorphism_group(A::AutomorphismGroup{T})\n\nReturn the subgroup of A of the inner automorphisms.\n\n\n\n\n\n","category":"method"},{"location":"AbstractAlgebra/puiseux/","page":"Generic Puiseux series","title":"Generic Puiseux series","text":"CurrentModule = AbstractAlgebra\nDocTestSetup = AbstractAlgebra.doctestsetup()","category":"page"},{"location":"AbstractAlgebra/puiseux/#Generic-Puiseux-series","page":"Generic Puiseux series","title":"Generic Puiseux series","text":"","category":"section"},{"location":"AbstractAlgebra/puiseux/","page":"Generic Puiseux series","title":"Generic Puiseux series","text":"AbstractAlgebra.jl allows the creation of Puiseux series over any computable commutative ring R.","category":"page"},{"location":"AbstractAlgebra/puiseux/","page":"Generic Puiseux series","title":"Generic Puiseux series","text":"Puiseux series are power series of the form a_jx^jm + a_j+1x^(j+1)m + cdots + a_k-1x^(k-1)m + O(x^km) for some integer m  0 where i geq 0, a_i in R and the relative precision k - j is at most equal to some specified precision n.","category":"page"},{"location":"AbstractAlgebra/puiseux/","page":"Generic Puiseux series","title":"Generic Puiseux series","text":"The generic Puiseux series module is implemented in src/generic/PuiseuxSeries.jl.","category":"page"},{"location":"AbstractAlgebra/puiseux/","page":"Generic Puiseux series","title":"Generic Puiseux series","text":"As well as implementing the Series Ring interface, the Puiseux series module in AbstractAlgebra.jl implements the generic algorithms described below.","category":"page"},{"location":"AbstractAlgebra/puiseux/","page":"Generic Puiseux series","title":"Generic Puiseux series","text":"All of the generic functionality is part of the Generic submodule of AbstractAlgebra.jl. This is exported by default so that it is not necessary to qualify function names.","category":"page"},{"location":"AbstractAlgebra/puiseux/#Types-and-parent-objects","page":"Generic Puiseux series","title":"Types and parent objects","text":"","category":"section"},{"location":"AbstractAlgebra/puiseux/","page":"Generic Puiseux series","title":"Generic Puiseux series","text":"The types of generic Puiseux series implemented by AbstractAlgebra.jl are Generic.PuiseuxSeriesRingElem{T} and Generic.PuiseuxSeriesFieldElem{T}.","category":"page"},{"location":"AbstractAlgebra/puiseux/","page":"Generic Puiseux series","title":"Generic Puiseux series","text":"Both series element types belong to the union type Generic.PuiseuxSeriesElem.","category":"page"},{"location":"AbstractAlgebra/puiseux/","page":"Generic Puiseux series","title":"Generic Puiseux series","text":"Puiseux series elements belong directly to either RingElem or FieldElem since it is more useful to be able to distinguish whether they belong to a ring or field than it is to distinguish that they are Puiseux series.","category":"page"},{"location":"AbstractAlgebra/puiseux/","page":"Generic Puiseux series","title":"Generic Puiseux series","text":"The parent types for Puiseux series, Generic.PuiseuxSeriesRing{T} and Generic.PuiseuxSeriesField{T} respectively, belong to Ring and Field respectively.","category":"page"},{"location":"AbstractAlgebra/puiseux/","page":"Generic Puiseux series","title":"Generic Puiseux series","text":"The default precision, string representation of the variable and base ring R of a generic Puiseux series are stored in its parent object.","category":"page"},{"location":"AbstractAlgebra/puiseux/#Puiseux-series-ring-constructors","page":"Generic Puiseux series","title":"Puiseux series ring constructors","text":"","category":"section"},{"location":"AbstractAlgebra/puiseux/","page":"Generic Puiseux series","title":"Generic Puiseux series","text":"In order to construct Puiseux series in AbstractAlgebra.jl, one must first construct the ring itself. This is accomplished with any of the following constructors.","category":"page"},{"location":"AbstractAlgebra/puiseux/","page":"Generic Puiseux series","title":"Generic Puiseux series","text":"puiseux_series_ring(R::Ring, prec_max::Int, s::VarName; cached::Bool = true)","category":"page"},{"location":"AbstractAlgebra/puiseux/","page":"Generic Puiseux series","title":"Generic Puiseux series","text":"puiseux_series_ring(R::Field, prec_max::Int, s::VarName; cached::Bool = true)","category":"page"},{"location":"AbstractAlgebra/puiseux/","page":"Generic Puiseux series","title":"Generic Puiseux series","text":"puiseux_series_field(R::Field, prec_max::Int, s::VarName; cached::Bool = true)","category":"page"},{"location":"AbstractAlgebra/puiseux/","page":"Generic Puiseux series","title":"Generic Puiseux series","text":"Given a base ring R, a maximum relative precision and a string s specifying how the generator (variable) should be printed, return a tuple S, x representing the Puiseux series ring and its generator.","category":"page"},{"location":"AbstractAlgebra/puiseux/","page":"Generic Puiseux series","title":"Generic Puiseux series","text":"By default, S will depend only on S, x and the maximum precision and will be cached. Setting the optional argument cached to false will prevent this.","category":"page"},{"location":"AbstractAlgebra/puiseux/","page":"Generic Puiseux series","title":"Generic Puiseux series","text":"Here are some examples of constructing various kinds of Puiseux series rings and coercing various elements into those rings.","category":"page"},{"location":"AbstractAlgebra/puiseux/","page":"Generic Puiseux series","title":"Generic Puiseux series","text":"Examples","category":"page"},{"location":"AbstractAlgebra/puiseux/","page":"Generic Puiseux series","title":"Generic Puiseux series","text":"julia> R, x = puiseux_series_ring(ZZ, 10, :x)\n(Puiseux series ring in x over integers, x + O(x^11))\n\njulia> S, y = puiseux_series_field(QQ, 10, :y)\n(Puiseux series field in y over rationals, y + O(y^11))\n\njulia> f = R()\nO(x^10)\n\njulia> g = S(123)\n123 + O(y^10)\n\njulia> h = R(BigInt(1234))\n1234 + O(x^10)\n\njulia> k = S(y + 1)\n1 + y + O(y^10)\n","category":"page"},{"location":"AbstractAlgebra/puiseux/#Big-oh-notation","page":"Generic Puiseux series","title":"Big-oh notation","text":"","category":"section"},{"location":"AbstractAlgebra/puiseux/","page":"Generic Puiseux series","title":"Generic Puiseux series","text":"Series elements can be given a precision using the big-oh notation. This is provided by a function of the following form, (or something equivalent for Laurent series):","category":"page"},{"location":"AbstractAlgebra/puiseux/","page":"Generic Puiseux series","title":"Generic Puiseux series","text":"O(x::SeriesElem)","category":"page"},{"location":"AbstractAlgebra/puiseux/","page":"Generic Puiseux series","title":"Generic Puiseux series","text":"Examples","category":"page"},{"location":"AbstractAlgebra/puiseux/","page":"Generic Puiseux series","title":"Generic Puiseux series","text":"julia> R, x = puiseux_series_ring(ZZ, 10, :x)\n(Puiseux series ring in x over integers, x + O(x^11))\n\njulia> f = 1 + 2x + O(x^5)\n1 + 2*x + O(x^5)\n\njulia> g = 2x^(1//3) + 7x^(2//3) + O(x^(7//3))\n2*x^(1//3) + 7*x^(2//3) + O(x^(7//3))","category":"page"},{"location":"AbstractAlgebra/puiseux/","page":"Generic Puiseux series","title":"Generic Puiseux series","text":"What is happening here in practice is that O(x^n) is creating the series 0 + O(x^n) and the rules for addition of series dictate that if this is added to a series of greater precision, then the lower of the two precisions must be used.","category":"page"},{"location":"AbstractAlgebra/puiseux/","page":"Generic Puiseux series","title":"Generic Puiseux series","text":"Of course it may be that the precision of the series that O(x^n) is added to is already lower than n, in which case adding O(x^n) has no effect. This is the case if the default precision is too low, since x on its own has the default precision.","category":"page"},{"location":"AbstractAlgebra/puiseux/#Puiseux-series-implementation","page":"Generic Puiseux series","title":"Puiseux series implementation","text":"","category":"section"},{"location":"AbstractAlgebra/puiseux/","page":"Generic Puiseux series","title":"Generic Puiseux series","text":"Puiseux series have their maximum relative precision capped at some value prec_max. This refers to the internal Laurent series used to store the Puiseux series, i.e. the series without denominators in the exponents.","category":"page"},{"location":"AbstractAlgebra/puiseux/","page":"Generic Puiseux series","title":"Generic Puiseux series","text":"The Puiseux series type stores such a Laurent series and a scale or denominator for the exponents. For example, f(x) = 1 + x^13 + 2x^23 + O(x^73) would be stored as a Laurent series 1 + x + 2x^2 + O(x^7) and a scale of 3..","category":"page"},{"location":"AbstractAlgebra/puiseux/","page":"Generic Puiseux series","title":"Generic Puiseux series","text":"The maximum precision is also used as a default (Laurent) precision in the case of coercing coefficients into the ring and for any computation where the result could mathematically be given to infinite precision.","category":"page"},{"location":"AbstractAlgebra/puiseux/","page":"Generic Puiseux series","title":"Generic Puiseux series","text":"In all models we say that two Puiseux series are equal if they agree up to the minimum absolute precision of the two power series.","category":"page"},{"location":"AbstractAlgebra/puiseux/","page":"Generic Puiseux series","title":"Generic Puiseux series","text":"Thus, for example, x^5 + O(x^10) == 0 + O(x^5), since the minimum absolute precision is 5.","category":"page"},{"location":"AbstractAlgebra/puiseux/","page":"Generic Puiseux series","title":"Generic Puiseux series","text":"Sometimes it is necessary to compare Puiseux series not just for arithmetic equality, as above, but to see if they have precisely the same precision and terms. For this purpose we introduce the isequal function.","category":"page"},{"location":"AbstractAlgebra/puiseux/","page":"Generic Puiseux series","title":"Generic Puiseux series","text":"For example, if f = x^2 + O(x^7) and g = x^2 + O(x^8) and h = 0 + O(x^2) then f == g, f == h and g == h, but isequal(f, g), isequal(f, h) and isequal(g, h) would all return false. However, if k = x^2 + O(x^7) then isequal(f, k) would return true.","category":"page"},{"location":"AbstractAlgebra/puiseux/","page":"Generic Puiseux series","title":"Generic Puiseux series","text":"There are a number of technicalities that must be observed when working with Puiseux series. As these are the same as for the other series rings in AbstractAlgebra.jl, we refer the reader to the documentation of series rings for information about these issues.","category":"page"},{"location":"AbstractAlgebra/puiseux/#Basic-ring-functionality","page":"Generic Puiseux series","title":"Basic ring functionality","text":"","category":"section"},{"location":"AbstractAlgebra/puiseux/","page":"Generic Puiseux series","title":"Generic Puiseux series","text":"All Puiseux series provide the functionality described in the Ring and Series Ring interfaces with the exception of the pol_length and polcoeff functions. Naturally the set_precision!, set_valuation! and coeff functions can take a rational exponent.","category":"page"},{"location":"AbstractAlgebra/puiseux/","page":"Generic Puiseux series","title":"Generic Puiseux series","text":"Examples","category":"page"},{"location":"AbstractAlgebra/puiseux/","page":"Generic Puiseux series","title":"Generic Puiseux series","text":"julia> S, x = puiseux_series_ring(ZZ, 10, :x)\n(Puiseux series ring in x over integers, x + O(x^11))\n\njulia> f = 1 + 3x + x^3 + O(x^10)\n1 + 3*x + x^3 + O(x^10)\n\njulia> g = 1 + 2x^(1//3) + x^(2//3) + O(x^(7//3))\n1 + 2*x^(1//3) + x^(2//3) + O(x^(7//3))\n\njulia> h = zero(S)\nO(x^10)\n\njulia> k = one(S)\n1 + O(x^10)\n\njulia> isone(k)\ntrue\n\njulia> iszero(f)\nfalse\n\njulia> coeff(g, 1//3)\n2\n\njulia> U = base_ring(S)\nIntegers\n\njulia> v = var(S)\n:x\n\njulia> T = parent(x + 1)\nPuiseux series ring in x over integers\n\njulia> g == deepcopy(g)\ntrue\n\njulia> t = divexact(2g, 2)\n1 + 2*x^(1//3) + x^(2//3) + O(x^(7//3))\n\njulia> p = precision(f)\n10//1\n","category":"page"},{"location":"AbstractAlgebra/puiseux/#Puiseux-series-functionality-provided-by-AbstractAlgebra.jl","page":"Generic Puiseux series","title":"Puiseux series functionality provided by AbstractAlgebra.jl","text":"","category":"section"},{"location":"AbstractAlgebra/puiseux/","page":"Generic Puiseux series","title":"Generic Puiseux series","text":"The functionality below is automatically provided by AbstractAlgebra.jl for any Puiseux series.","category":"page"},{"location":"AbstractAlgebra/puiseux/","page":"Generic Puiseux series","title":"Generic Puiseux series","text":"Of course, modules are encouraged to provide specific implementations of the functions described here, that override the generic implementation.","category":"page"},{"location":"AbstractAlgebra/puiseux/#Basic-functionality","page":"Generic Puiseux series","title":"Basic functionality","text":"","category":"section"},{"location":"AbstractAlgebra/puiseux/","page":"Generic Puiseux series","title":"Generic Puiseux series","text":"coeff(a::Generic.PuiseuxSeriesElem, n::Int)","category":"page"},{"location":"AbstractAlgebra/puiseux/","page":"Generic Puiseux series","title":"Generic Puiseux series","text":"coeff(a::Generic.PuiseuxSeriesElem, n::Rational{Int})","category":"page"},{"location":"AbstractAlgebra/puiseux/","page":"Generic Puiseux series","title":"Generic Puiseux series","text":"Return the coefficient of the term of exponent n of the given power series. If n exceeds the current precision of the power series or does not correspond to a nonzero term of the Puiseux series, the function returns a zero coefficient.","category":"page"},{"location":"AbstractAlgebra/puiseux/","page":"Generic Puiseux series","title":"Generic Puiseux series","text":"modulus{T <: ResElem}(::Generic.PuiseuxSeriesElem{T})","category":"page"},{"location":"AbstractAlgebra/puiseux/#modulus-Union{Tuple{Union{AbstractAlgebra.Generic.PuiseuxSeriesFieldElem{T}, AbstractAlgebra.Generic.PuiseuxSeriesRingElem{T}}}, Tuple{T}} where T<:ResElem","page":"Generic Puiseux series","title":"modulus","text":"modulus(a::Generic.PuiseuxSeriesElem{T}) where {T <: ResElem}\n\nReturn the modulus of the coefficients of the given Puiseux series.\n\n\n\n\n\n","category":"method"},{"location":"AbstractAlgebra/puiseux/","page":"Generic Puiseux series","title":"Generic Puiseux series","text":"is_gen(::Generic.PuiseuxSeriesElem)","category":"page"},{"location":"AbstractAlgebra/puiseux/#is_gen-Tuple{Union{AbstractAlgebra.Generic.PuiseuxSeriesFieldElem{T}, AbstractAlgebra.Generic.PuiseuxSeriesRingElem{T}} where T<:RingElement}","page":"Generic Puiseux series","title":"is_gen","text":"is_gen(a::Generic.PuiseuxSeriesElem)\n\nReturn true if the given Puiseux series is arithmetically equal to the generator of its Puiseux series ring to its current precision, otherwise return false.\n\n\n\n\n\n","category":"method"},{"location":"AbstractAlgebra/puiseux/","page":"Generic Puiseux series","title":"Generic Puiseux series","text":"Examples","category":"page"},{"location":"AbstractAlgebra/puiseux/","page":"Generic Puiseux series","title":"Generic Puiseux series","text":"julia> R, t = puiseux_series_ring(QQ, 10, :t)\n(Puiseux series field in t over rationals, t + O(t^11))\n\njulia> S, x = puiseux_series_ring(R, 30, :x)\n(Puiseux series field in x over R, x + O(x^31))\n\njulia> a = O(x^4)\nO(x^4)\n\njulia> b = (t + 3)*x + (t^2 + 1)*x^2 + O(x^4)\n(3 + t + O(t^10))*x + (1 + t^2 + O(t^10))*x^2 + O(x^4)\n\njulia> k = is_gen(gen(R))\ntrue\n\njulia> m = is_unit(-1 + x^(1//3) + 2x^2)\ntrue\n\njulia> n = valuation(a)\n4//1\n\njulia> p = valuation(b)\n1//1\n\njulia> c = coeff(b, 2)\n1 + t^2 + O(t^10)\n","category":"page"},{"location":"AbstractAlgebra/puiseux/#Division","page":"Generic Puiseux series","title":"Division","text":"","category":"section"},{"location":"AbstractAlgebra/puiseux/","page":"Generic Puiseux series","title":"Generic Puiseux series","text":"Base.inv(::Generic.PuiseuxSeriesElem)","category":"page"},{"location":"AbstractAlgebra/puiseux/#inv-Tuple{Union{AbstractAlgebra.Generic.PuiseuxSeriesFieldElem{T}, AbstractAlgebra.Generic.PuiseuxSeriesRingElem{T}} where T<:RingElement}","page":"Generic Puiseux series","title":"inv","text":"inv(M::MatrixElem{T}) where {T <: RingElement}\n\nGiven a non-singular ntimes n matrix over a ring, return an ntimes n matrix X such that MX = I_n, where I_n is the ntimes n identity matrix. If M is not invertible over the base ring an exception is raised.\n\n\n\n\n\ninv(f::EllCrvIso) -> EllCrvIso\n\nReturn the inverse of the isomorphism f.\n\n\n\n\n\nBase.inv(a::PuiseuxSeriesElem{T}) where T <: RingElement\n\nReturn the inverse of the power series a, i.e. 1a, if it exists. Otherwise an exception is raised.\n\n\n\n\n\n inv(a::LocalizedEuclideanRingElem{T}, checked::Bool = true)  where {T <: RingElem}\n\nReturns the inverse element of a if a is a unit. If 'checked = false' the invertibility of a is not checked and the corresponding inverse element of the Fraction Field is returned.\n\n\n\n\n\n","category":"method"},{"location":"AbstractAlgebra/puiseux/","page":"Generic Puiseux series","title":"Generic Puiseux series","text":"Examples","category":"page"},{"location":"AbstractAlgebra/puiseux/","page":"Generic Puiseux series","title":"Generic Puiseux series","text":"julia> R, x = puiseux_series_ring(QQ, 30, :x)\n(Puiseux series field in x over rationals, x + O(x^31))\n\njulia> a = 1 + x + 2x^2 + O(x^5)\n1 + x + 2*x^2 + O(x^5)\n\njulia> b = R(-1)\n-1 + O(x^30)\n\njulia> c = inv(a)\n1 - x - x^2 + 3*x^3 - x^4 + O(x^5)\n\njulia> d = inv(b)\n-1 + O(x^30)\n","category":"page"},{"location":"AbstractAlgebra/puiseux/#Derivative-and-integral","page":"Generic Puiseux series","title":"Derivative and integral","text":"","category":"section"},{"location":"AbstractAlgebra/puiseux/","page":"Generic Puiseux series","title":"Generic Puiseux series","text":"derivative(a::Generic.PuiseuxSeriesElem)\nintegral(a::Generic.PuiseuxSeriesElem)","category":"page"},{"location":"AbstractAlgebra/puiseux/#derivative-Tuple{Union{AbstractAlgebra.Generic.PuiseuxSeriesFieldElem{T}, AbstractAlgebra.Generic.PuiseuxSeriesRingElem{T}} where T<:RingElement}","page":"Generic Puiseux series","title":"derivative","text":"derivative(f::AbsPowerSeriesRingElem{T})\n\nReturn the derivative of the power series f.\n\n\n\n\n\nderivative(f::RelPowerSeriesRingElem{T})\n\nReturn the derivative of the power series f.\n\njulia> R, x = power_series_ring(QQ, 10, :x)\n(Univariate power series ring in x over Rationals, x + O(x^11))\n\njulia> f = 2 + x + 3x^3\n2 + x + 3*x^3 + O(x^10)\n\njulia> derivative(f)\n1 + 9*x^2 + O(x^9)\n\n\n\n\n\nderivative(f::MPolyRingElem{T}, j::Int) where {T <: RingElement}\n\nReturn the partial derivative of f with respect to j-th variable of the polynomial ring.\n\n\n\n\n\nderivative(f::MPolyRingElem{T}, x::MPolyRingElem{T}) where T <: RingElement\n\nReturn the partial derivative of f with respect to x. The value x must be a generator of the polynomial ring of f.\n\n\n\n\n\nderivative(x::spoly{T}, n::Int) where T <: Nemo.RingElem\n\nReturn the derivative of x with respect to the variable of index n.\n\n\n\n\n\nderivative(x::spoly{T}, v::spoly{T}) where T <: Nemo.RingElem\n\nReturn the derivative of x with respect to the variable v.\n\n\n\n\n\nderivative(a::Generic.PuiseuxSeriesElem{T}) where T <: RingElement\n\nReturn the derivative of the given Puiseux series a.\n\n\n\n\n\n","category":"method"},{"location":"AbstractAlgebra/puiseux/#integral-Tuple{Union{AbstractAlgebra.Generic.PuiseuxSeriesFieldElem{T}, AbstractAlgebra.Generic.PuiseuxSeriesRingElem{T}} where T<:RingElement}","page":"Generic Puiseux series","title":"integral","text":"integral(f::AbsPowerSeriesRingElem{T})\n\nReturn the integral of the power series f.\n\n\n\n\n\nintegral(f::RelPowerSeriesRingElem{T})\n\nReturn the integral of the power series f.\n\njulia> R, x = power_series_ring(QQ, 10, :x)\n(Univariate power series ring in x over Rationals, x + O(x^11))\n\njulia> f = 2 + x + 3x^3\n2 + x + 3*x^3 + O(x^10)\n\njulia> integral(f)\n2*x + 1//2*x^2 + 3//4*x^4 + O(x^11)\n\n\n\n\n\nintegral(f::RelPowerSeriesRingElem{T}) -> RelPowerSeriesRingElem\n\nReturn the integral of the power series f.\n\n\n\n\n\nintegral(a::Generic.PuiseuxSeriesElem{T}) where T <: RingElement\n\nReturn the integral of the given Puiseux series a.\n\n\n\n\n\n","category":"method"},{"location":"AbstractAlgebra/puiseux/","page":"Generic Puiseux series","title":"Generic Puiseux series","text":"Examples","category":"page"},{"location":"AbstractAlgebra/puiseux/","page":"Generic Puiseux series","title":"Generic Puiseux series","text":"julia> R, x = puiseux_series_ring(QQ, 10, :x)\n(Puiseux series field in x over rationals, x + O(x^11))\n\njulia> f = x^(5//3) + x^(7//3) + x^(11//3)\nx^(5//3) + x^(7//3) + x^(11//3) + O(x^5)\n\njulia> derivative(f)\n5//3*x^(2//3) + 7//3*x^(4//3) + 11//3*x^(8//3) + O(x^4)\n\njulia> derivative(integral(f)) == f\ntrue","category":"page"},{"location":"AbstractAlgebra/puiseux/#Special-functions","page":"Generic Puiseux series","title":"Special functions","text":"","category":"section"},{"location":"AbstractAlgebra/puiseux/","page":"Generic Puiseux series","title":"Generic Puiseux series","text":"Base.log(a::Generic.PuiseuxSeriesElem)\nBase.exp(a::Generic.PuiseuxSeriesElem)","category":"page"},{"location":"AbstractAlgebra/puiseux/#log-Tuple{Union{AbstractAlgebra.Generic.PuiseuxSeriesFieldElem{T}, AbstractAlgebra.Generic.PuiseuxSeriesRingElem{T}} where T<:RingElement}","page":"Generic Puiseux series","title":"log","text":"log(a::Generic.PuiseuxSeriesElem{T}) where T <: RingElement\n\nReturn the logarithm of the given Puiseux series a.\n\n\n\n\n\n","category":"method"},{"location":"AbstractAlgebra/puiseux/#exp-Tuple{Union{AbstractAlgebra.Generic.PuiseuxSeriesFieldElem{T}, AbstractAlgebra.Generic.PuiseuxSeriesRingElem{T}} where T<:RingElement}","page":"Generic Puiseux series","title":"exp","text":"exp(a::AbsPowerSeriesRingElem)\n\nReturn the exponential of the power series a.\n\n\n\n\n\nexp(a::RelPowerSeriesRingElem)\n\nReturn the exponential of the power series a.\n\n\n\n\n\nexp(a::Generic.LaurentSeriesElem)\n\nReturn the exponential of the power series a.\n\n\n\n\n\nexp(a::Generic.PuiseuxSeriesElem{T}) where T <: RingElement\n\nReturn the exponential of the given Puiseux series a.\n\n\n\n\n\n","category":"method"},{"location":"AbstractAlgebra/puiseux/","page":"Generic Puiseux series","title":"Generic Puiseux series","text":"Base.sqrt(a::Generic.PuiseuxSeriesElem)","category":"page"},{"location":"AbstractAlgebra/puiseux/#sqrt-Tuple{Union{AbstractAlgebra.Generic.PuiseuxSeriesFieldElem{T}, AbstractAlgebra.Generic.PuiseuxSeriesRingElem{T}} where T<:RingElement}","page":"Generic Puiseux series","title":"sqrt","text":"Base.sqrt(f::PolyRingElem{T}; check::Bool=true) where T <: RingElement\n\nReturn the square root of f. By default the function checks the input is square and raises an exception if not. If check=false this check is omitted.\n\n\n\n\n\nBase.sqrt(a::FracElem{T}; check::Bool=true) where T <: RingElem\n\nReturn the square root of a. By default the function will throw an exception if the input is not square. If check=false this test is omitted.\n\n\n\n\n\nsqrt(a::Generic.PuiseuxSeriesElem{T}; check::Bool=true) where T <: RingElement\n\nReturn the square root of the given Puiseux series a. By default the function will throw an exception if the input is not square. If check=false this test is omitted.\n\n\n\n\n\n","category":"method"},{"location":"AbstractAlgebra/puiseux/","page":"Generic Puiseux series","title":"Generic Puiseux series","text":"Examples","category":"page"},{"location":"AbstractAlgebra/puiseux/","page":"Generic Puiseux series","title":"Generic Puiseux series","text":"julia> R, t = polynomial_ring(QQ, :t)\n(Univariate polynomial ring in t over rationals, t)\n\njulia> S, x = puiseux_series_ring(R, 30, :x)\n(Puiseux series ring in x over R, x + O(x^31))\n\njulia> T, z = puiseux_series_ring(QQ, 30, :z)\n(Puiseux series field in z over rationals, z + O(z^31))\n\njulia> a = 1 + z + 3z^2 + O(z^5)\n1 + z + 3*z^2 + O(z^5)\n\njulia> b = z + 2z^2 + 5z^3 + O(z^5)\nz + 2*z^2 + 5*z^3 + O(z^5)\n\njulia> c = exp(x + O(x^40))\n1 + x + 1//2*x^2 + 1//6*x^3 + 1//24*x^4 + 1//120*x^5 + 1//720*x^6 + 1//5040*x^7 + 1//40320*x^8 + 1//362880*x^9 + 1//3628800*x^10 + 1//39916800*x^11 + 1//479001600*x^12 + 1//6227020800*x^13 + 1//87178291200*x^14 + 1//1307674368000*x^15 + 1//20922789888000*x^16 + 1//355687428096000*x^17 + 1//6402373705728000*x^18 + 1//121645100408832000*x^19 + 1//2432902008176640000*x^20 + 1//51090942171709440000*x^21 + 1//1124000727777607680000*x^22 + 1//25852016738884976640000*x^23 + 1//620448401733239439360000*x^24 + 1//15511210043330985984000000*x^25 + 1//403291461126605635584000000*x^26 + 1//10888869450418352160768000000*x^27 + 1//304888344611713860501504000000*x^28 + 1//8841761993739701954543616000000*x^29 + 1//265252859812191058636308480000000*x^30 + O(x^31)\n\njulia> d = divexact(x, exp(x + O(x^40)) - 1)\n1 - 1//2*x + 1//12*x^2 - 1//720*x^4 + 1//30240*x^6 - 1//1209600*x^8 + 1//47900160*x^10 - 691//1307674368000*x^12 + 1//74724249600*x^14 - 3617//10670622842880000*x^16 + 43867//5109094217170944000*x^18 - 174611//802857662698291200000*x^20 + 77683//14101100039391805440000*x^22 - 236364091//1693824136731743669452800000*x^24 + 657931//186134520519971831808000000*x^26 - 3392780147//37893265687455865519472640000000*x^28 + O(x^29)\n\njulia> f = exp(b)\n1 + z + 5//2*z^2 + 43//6*z^3 + 193//24*z^4 + O(z^5)\n\njulia> h = sqrt(a)\n1 + 1//2*z + 11//8*z^2 - 11//16*z^3 - 77//128*z^4 + O(z^5)\n","category":"page"},{"location":"DeveloperDocumentation/documentation/#Documenting-OSCAR-code","page":"Documenting OSCAR code","title":"Documenting OSCAR code","text":"","category":"section"},{"location":"DeveloperDocumentation/documentation/","page":"Documenting OSCAR code","title":"Documenting OSCAR code","text":"The general philosophy of the OSCAR documentation is to put as much of the information as possible into the docstrings and only use the doc pages for collecting this information and provide some additional general context. Exceptions to this philosophy are the developer and general pages.","category":"page"},{"location":"DeveloperDocumentation/documentation/#Docstrings-of-exported-functions","page":"Documenting OSCAR code","title":"Docstrings of exported functions","text":"","category":"section"},{"location":"DeveloperDocumentation/documentation/","page":"Documenting OSCAR code","title":"Documenting OSCAR code","text":"Exported function should have docstrings, which look like","category":"page"},{"location":"DeveloperDocumentation/documentation/","page":"Documenting OSCAR code","title":"Documenting OSCAR code","text":"@doc raw\"\"\"\n    functionname(x::ArgumentType, b::OtherArgument; c::Keyword = default) -> Int, Int\n\nA short description of the function. It is allowed to use $\\LaTeX$.\n\"\"\"\nfunctionname(x...,b...; c = ...)","category":"page"},{"location":"DeveloperDocumentation/documentation/","page":"Documenting OSCAR code","title":"Documenting OSCAR code","text":"If the signature is too long, use linebreaks to fit 80 characters.","category":"page"},{"location":"DeveloperDocumentation/documentation/","page":"Documenting OSCAR code","title":"Documenting OSCAR code","text":"Please also do provide an example within the docstring if possible, preferably as a jldoctest, i.e.","category":"page"},{"location":"DeveloperDocumentation/documentation/","page":"Documenting OSCAR code","title":"Documenting OSCAR code","text":"@doc raw\"\"\"\n    functionname(x::ArgumentType, b::OtherArgument; c::Keyword = default) -> Int, Int\n\nA short description of the function. It is allowed to use $\\LaTeX$.\n\n# Examples\nThis shows that `functionname` does the right thing for input `input`\n```jldoctest\njulia> input = ...\n\njulia> functionname(input)\noutput\n```\n\"\"\"\nfunctionname(x...,b...; c = ...)","category":"page"},{"location":"DeveloperDocumentation/documentation/","page":"Documenting OSCAR code","title":"Documenting OSCAR code","text":"This allows the user to immediately see how the function can be used, gives them some code that they can copy-paste and manipulate, and, as a bonus, provides a testcase as well.","category":"page"},{"location":"DeveloperDocumentation/documentation/#The-folder-docs","page":"Documenting OSCAR code","title":"The folder docs","text":"","category":"section"},{"location":"DeveloperDocumentation/documentation/","page":"Documenting OSCAR code","title":"Documenting OSCAR code","text":"The folder docs/src contains the OSCAR documentation website. Most of the pages are relatively sparse and consist of","category":"page"},{"location":"DeveloperDocumentation/documentation/","page":"Documenting OSCAR code","title":"Documenting OSCAR code","text":"```@docs\nsome_function\nsome_other_function\n[...]\n```","category":"page"},{"location":"DeveloperDocumentation/documentation/","page":"Documenting OSCAR code","title":"Documenting OSCAR code","text":"blocks that simply pull in the docstring from the corresponding source file. If you add a new page in docs/src, you will have to modify docs/doc.main to include your new page in the appropriate place.","category":"page"},{"location":"DeveloperDocumentation/documentation/#Building-the-OSCAR-documentation-with-Oscar.build_doc","page":"Documenting OSCAR code","title":"Building the OSCAR documentation with Oscar.build_doc","text":"","category":"section"},{"location":"DeveloperDocumentation/documentation/","page":"Documenting OSCAR code","title":"Documenting OSCAR code","text":"note: Previewing the documentation\nOnce you have created a pull request it is possible to preview the documentation on github using the link https://docs.oscar-system.org/previews/PR<prnumber>/ where you insert the number of your PR for prnumber. Alternatively you can look at the github actions tab of your PR and click the details link next to the documenter/deploy action. There are a few conditions for this  to work:No conflicts with the master branch.\nDocumentation action is successful, i.e. no doctest errors.\nThe branch for the PR is in the main oscar-system/Oscar.jl repository.You can still build the documentation locally with the commands described below.","category":"page"},{"location":"DeveloperDocumentation/documentation/","page":"Documenting OSCAR code","title":"Documenting OSCAR code","text":"build_doc","category":"page"},{"location":"DeveloperDocumentation/documentation/#build_doc","page":"Documenting OSCAR code","title":"build_doc","text":"build_doc(; doctest=false, warnonly=true, open_browser=true, start_server=false)\n\nBuild the manual of Oscar.jl locally and open the front page in a browser.\n\nThe optional parameter doctest can take three values:\n\nfalse: Do not run the doctests (default).\ntrue: Run the doctests and report errors.\n:fix: Run the doctests and replace the output in the manual with the output produced by Oscar. Please use this option carefully.\n\nIn GitHub Actions the Julia version used for building the manual is 1.10 and doctests are run with >= 1.7. Using a different Julia version may produce errors in some parts of Oscar, so please be careful, especially when setting doctest=:fix.\n\nThe optional parameter warnonly is passed on to makedocs of Documenter.jl and if set to false then according to the manual of Documenter.jl \"a doctesting error will always make makedocs throw an error in this mode\". Alternatively, one can pass a list of symbols to warnonly to suppress errors for the given error types.\n\nTo prevent the opening of the browser at the end, set the optional parameter open_browser to false.\n\nAlternatively, one can use the optional parameter start_server to start a web server in the build directory which is accessible via 127.0.0.1:8000. If both start_server and open_browser are true, the browser will show this page. The server keeps running in the background until the julia session is terminated, so the proposed usage for this option is to run build_doc(start_server = true) for the first build and build_doc(open_browser = false) for following builds and only refresh the browser tab.\n\nWhen working on the manual the Revise package can significantly speed up running build_doc. First, install Revise in the following way:\n\nusing Pkg ; Pkg.add(\"Revise\")\n\nSecond, restart Julia and load Revise before Oscar:\n\nusing Revise, Oscar;\n\nThe first run of build_doc will take the usual few minutes, subsequent runs will be significantly faster.\n\n\n\n\n\n","category":"function"},{"location":"DeveloperDocumentation/documentation/","page":"Documenting OSCAR code","title":"Documenting OSCAR code","text":"Please also read the section below on repairing the jldoctests using build_doc.","category":"page"},{"location":"DeveloperDocumentation/documentation/","page":"Documenting OSCAR code","title":"Documenting OSCAR code","text":"note: Browser reports denied access\nDepending on your system, it might happen that the browser opens after a successful build, but only informs you that the access to the file was denied. This happens, for example, on Ubuntu which comes with a sandboxed Firefox. In this case, using build_doc with start_server = true should circumvent this problem.","category":"page"},{"location":"DeveloperDocumentation/documentation/#Automatically-repairing-jldoctests","page":"Documenting OSCAR code","title":"Automatically repairing jldoctests","text":"","category":"section"},{"location":"DeveloperDocumentation/documentation/","page":"Documenting OSCAR code","title":"Documenting OSCAR code","text":"It is possible to have julia fix the output of all jldoctests when your changes to the code entail changes to the output. Just run the following command:","category":"page"},{"location":"DeveloperDocumentation/documentation/","page":"Documenting OSCAR code","title":"Documenting OSCAR code","text":"build_doc(doctest = :fix)","category":"page"},{"location":"DeveloperDocumentation/documentation/","page":"Documenting OSCAR code","title":"Documenting OSCAR code","text":"If you just want to fix some of the jldoctests, and do not want to build the documentation, you can also use Oscar.doctest_fix:","category":"page"},{"location":"DeveloperDocumentation/documentation/","page":"Documenting OSCAR code","title":"Documenting OSCAR code","text":"Oscar.doctest_fix","category":"page"},{"location":"DeveloperDocumentation/documentation/#doctest_fix","page":"Documenting OSCAR code","title":"doctest_fix","text":"doctest_fix(f::Function; set_meta::Bool = false)\n\nFixes all doctests for the given function f.\n\nExamples\n\nThe following call fixes all doctests for the function symmetric_group:\n\njulia> Oscar.doctest_fix(symmetric_group)\n\n\n\n\n\ndoctest_fix(path::String; set_meta::Bool = false)\n\nFixes all doctests for all files in Oscar where path occurs in the full pathname.\n\nExamples\n\nThe following call fixes all doctests in files that live in a directory called Rings (or a subdirectory thereof), so e.g. everything in src/Rings/:\n\njulia> Oscar.doctest_fix(\"/Rings/\")\n\n\n\n\n\n","category":"function"},{"location":"DeveloperDocumentation/documentation/","page":"Documenting OSCAR code","title":"Documenting OSCAR code","text":"danger: Danger\nPlease use these commands carefully:Make sure to only commit the changes to the doctests originating from your changes to the code.\nThe doctests also serve as actual tests, so make absolutely sure that the output is still mathematically correct.","category":"page"},{"location":"DeveloperDocumentation/documentation/","page":"Documenting OSCAR code","title":"Documenting OSCAR code","text":"tip: Tip\nIf these commands fail with an error message indicating lacking permissions to change AbstractAlgebra.jl related docs, it may help to run the following command:]dev AbstractAlgebra","category":"page"},{"location":"DeveloperDocumentation/documentation/#Updating-the-bibliography","page":"Documenting OSCAR code","title":"Updating the bibliography","text":"","category":"section"},{"location":"DeveloperDocumentation/documentation/","page":"Documenting OSCAR code","title":"Documenting OSCAR code","text":"When editing docs/oscar_references.bib please follow the style of the existing entries. An easy way to do that is to add your new BibTeX entry, then run bibtool by invoking it as follows from the root directory of the Oscar.jl repository:","category":"page"},{"location":"DeveloperDocumentation/documentation/","page":"Documenting OSCAR code","title":"Documenting OSCAR code","text":"bibtool docs/oscar_references.bib -o docs/oscar_references.bib","category":"page"},{"location":"DeveloperDocumentation/documentation/","page":"Documenting OSCAR code","title":"Documenting OSCAR code","text":"For every pull request on github, the CI checks if running bibtool leads to changes in the bibliography. If so, this test fails and indicates that the (recently) added bibliography entries are not standardized. For a merge, it is not required that this test is passed. Still, please feel encouraged to fix this failure by running bibtool locally as explained above.","category":"page"},{"location":"DeveloperDocumentation/documentation/","page":"Documenting OSCAR code","title":"Documenting OSCAR code","text":"note: bibtool produces changes in unrelated parts of oscar_references.bib\nSometimes bibtool will produce many changes when run locally. This can be caused by a version difference. The version used in our github actions is 2.68. Check your version by running bibtool -V. When running this command, please also pay attention whether any \"Special configuration options\" are set.","category":"page"},{"location":"DeveloperDocumentation/documentation/","page":"Documenting OSCAR code","title":"Documenting OSCAR code","text":"Please follow the additional guidelines below, that are not checked by bibtool:","category":"page"},{"location":"DeveloperDocumentation/documentation/","page":"Documenting OSCAR code","title":"Documenting OSCAR code","text":"Do not escape special characters like umlauts or accented characters. Instead, use the unicode character directly.\nYou do not need to use braces to preserve capitalization as DocumenterCitations.jl keeps entries as is (in contrast to bibtex). In some cases, braces can even be harmful, i.e., show up in the output.\nIf a DOI is available for your reference, please add it as a doi field to the BibTeX entry. In this case, please refrain from adding an additional url field.\nIf your reference has no DOI or the paper is not open-access, but is available as an arXiv preprint, you can add the arXiv link as a eprint field (even additionally to a doi field). For other preprint servers (e.g. HAL), please refer to the DocumenterCitations.jl docs.\nDocuments available only as an arXiv preprint should be added as @Misc entries with the arXiv-ID in the eprint field, e.g., archiveprefix = {arXiv} and eprint = {2008.12651}.","category":"page"},{"location":"General/architecture/","page":"Architecture","title":"Architecture","text":"CurrentModule = Oscar\nDocTestSetup = Oscar.doctestsetup()","category":"page"},{"location":"General/architecture/","page":"Architecture","title":"Architecture","text":"using Oscar","category":"page"},{"location":"General/architecture/#Architecture","page":"Architecture","title":"Architecture","text":"","category":"section"},{"location":"General/architecture/","page":"Architecture","title":"Architecture","text":"This page aims to give a short technical overview of the architecture of OSCAR. A more in-depth overview of the various components of OSCAR is given on the OSCAR homepage.","category":"page"},{"location":"General/architecture/#Julia-packages","page":"Architecture","title":"Julia packages","text":"","category":"section"},{"location":"General/architecture/","page":"Architecture","title":"Architecture","text":"OSCAR is developed as a pure julia package Oscar.jl and builds on the features and interfaces provided by the julia packages for the cornerstones:","category":"page"},{"location":"General/architecture/","page":"Architecture","title":"Architecture","text":"ANTIC: AbstractAlgebra.jl,        Hecke.jl,        Nemo.jl\nGAP.jl\nPolymake.jl\nSingular.jl","category":"page"},{"location":"General/architecture/","page":"Architecture","title":"Architecture","text":"The packages are integrated into the julia package manager and will be installed automatically as dependencies of OSCAR. They can be accessed directly by their names once OSCAR is loaded.","category":"page"},{"location":"General/architecture/","page":"Architecture","title":"Architecture","text":"The current versions of these packages can be inspected with the Oscar.versioninfo command:","category":"page"},{"location":"General/architecture/","page":"Architecture","title":"Architecture","text":"Oscar.versioninfo()","category":"page"},{"location":"General/architecture/#Binary-packages-for-non-julia-libraries","page":"Architecture","title":"Binary packages for non-julia libraries","text":"","category":"section"},{"location":"General/architecture/","page":"Architecture","title":"Architecture","text":"In addition to the pure julia packages, OSCAR builds on many non-julia libraries for the cornerstones (FLINT, GAP, polymake, Singular) and their dependencies.","category":"page"},{"location":"General/architecture/","page":"Architecture","title":"Architecture","text":"Both Polymake.jl and Singular.jl use CxxWrap.jl together with the corresponding libcxxwrap-julia library as an intermediate layer between the julia packages and the C / C++ libraries.","category":"page"},{"location":"General/architecture/","page":"Architecture","title":"Architecture","text":"All dependencies have been integrated into the BinaryBuilder ecosystem which provides precompiled binaries for all supported architectures. The build-recipes are maintained in julia's Yggdrasil repository. These are used to automatically build binary artifacts together with the corresponding jll packages which allow automatic installation of all required binaries as dependencies for OSCAR.","category":"page"},{"location":"General/architecture/","page":"Architecture","title":"Architecture","text":"The binary packages can be found under the JuliaBinaryWrappers organization. Each repository has an autogenerated Readme file which gives some details on the original sources, supported platforms, and dependencies.","category":"page"},{"location":"General/architecture/","page":"Architecture","title":"Architecture","text":"The Oscar.versioninfo function can also include the versions of all binary packages that are maintained by the OSCAR developers:","category":"page"},{"location":"General/architecture/","page":"Architecture","title":"Architecture","text":"Oscar.versioninfo(jll=true)","category":"page"},{"location":"General/architecture/","page":"Architecture","title":"Architecture","text":"For a full list of all dependencies of the current project please use using Pkg; Pkg.status(mode=PKGMODE_MANIFEST) or the Pkg REPL command ]st -m.","category":"page"},{"location":"General/architecture/","page":"Architecture","title":"Architecture","text":"versioninfo","category":"page"},{"location":"General/architecture/#versioninfo","page":"Architecture","title":"versioninfo","text":"Oscar.versioninfo(io::IO=stdout; branch=false, jll=false, julia=false, commit=false, full=false)\n\nPrint the versions of all Oscar-related dependencies.\n\nArguments\n\nbranch::Bool=false: include git branch name in the output\ncommit::Bool=false: include git commit hash and date where applicable\njll::Bool=false   : include binary packages (jll) in the output\njulia::Bool=false : include julia versioninfo output\nfull::Bool=false  : include all of the above\n\n\n\n\n\n","category":"function"},{"location":"AlgebraicGeometry/Schemes/RationalPointsAffine/","page":"Rational Points on Affine Schemes","title":"Rational Points on Affine Schemes","text":"CurrentModule = Oscar\nDocTestSetup = Oscar.doctestsetup()","category":"page"},{"location":"AlgebraicGeometry/Schemes/RationalPointsAffine/#Rational-Points-on-Affine-Schemes","page":"Rational Points on Affine Schemes","title":"Rational Points on Affine Schemes","text":"","category":"section"},{"location":"AlgebraicGeometry/Schemes/RationalPointsAffine/","page":"Rational Points on Affine Schemes","title":"Rational Points on Affine Schemes","text":"AbsAffineRationalPoint\nAffineRationalPoint\ncoordinates(p::AffineRationalPoint)\nideal(P::AbsAffineRationalPoint)\nscheme(P::AbsAffineRationalPoint)\nclosed_embedding(P::AbsAffineRationalPoint)\nis_smooth(P::AbsAffineRationalPoint)\ntangent_space(P::AbsAffineRationalPoint{<:FieldElem})","category":"page"},{"location":"AlgebraicGeometry/Schemes/RationalPointsAffine/#AbsAffineRationalPoint","page":"Rational Points on Affine Schemes","title":"AbsAffineRationalPoint","text":"AbsAffineRationalPoint{CoefficientType, ParentType}\n\nA rational point P of an affine scheme X. We refer to X as the parent of P.\n\nLet X subseteq mathbbA^n_k be an algebraic set or more generally a subscheme defined by the ideal I = (f_1 dots f_r) subseteq kx_1dots x_n. A rational point p of X is a tuple p = (p_1 dots  p_n) in k^n such that f_1(p) = dots = f_n(p) = 0.\n\n\n\n\n\n","category":"type"},{"location":"AlgebraicGeometry/Schemes/RationalPointsAffine/#AffineRationalPoint","page":"Rational Points on Affine Schemes","title":"AffineRationalPoint","text":"AffineRationalPoint{CoeffType<:RingElem, ParentType<:RationalPointSet}\n\nA rational point represented in terms of a vector of coordinates.\n\nExamples\n\njulia> A2 = affine_space(GF(2), [:x, :y]);\n\njulia> (x, y) = coordinates(A2);\n\njulia> X = algebraic_set(x*y);\n\njulia> X([1, 0])\nRational point\n  of V(x*y)\nwith coordinates (1, 0)\n\n\n\n\n\n\n","category":"type"},{"location":"AlgebraicGeometry/Schemes/RationalPointsAffine/#coordinates-Tuple{Oscar.AffineRationalPoint}","page":"Rational Points on Affine Schemes","title":"coordinates","text":"coordinates(p::AffineRationalPoint{S,T}) -> Vector{S}\n\nReturn the coordinates of the rational point p.\n\nThe coordinates are with respect to the ambient space of its ambient scheme.\n\n\n\n\n\n","category":"method"},{"location":"AlgebraicGeometry/Schemes/RationalPointsAffine/#ideal-Tuple{AbsAffineRationalPoint}","page":"Rational Points on Affine Schemes","title":"ideal","text":"ideal(P::AbsAffineRationalPoint)\n\nReturn the maximal ideal associated to P in the coordinate ring of its ambient space.\n\n\n\n\n\n","category":"method"},{"location":"AlgebraicGeometry/Schemes/RationalPointsAffine/#scheme-Tuple{AbsAffineRationalPoint}","page":"Rational Points on Affine Schemes","title":"scheme","text":"scheme(P::AbsAffineRationalPoint) -> AbsAffineScheme\n\nReturn the rational point P viewed as a reduced, affine subscheme of its ambient affine space.\n\n\n\n\n\n","category":"method"},{"location":"AlgebraicGeometry/Schemes/RationalPointsAffine/#closed_embedding-Tuple{AbsAffineRationalPoint}","page":"Rational Points on Affine Schemes","title":"closed_embedding","text":"closed_embedding(P::AbsAffineRationalPoint) -> ClosedEmbedding\n\nReturn the closed embedding of P into its ambient scheme X.\n\n\n\n\n\n","category":"method"},{"location":"AlgebraicGeometry/Schemes/RationalPointsAffine/#is_smooth-Tuple{AbsAffineRationalPoint}","page":"Rational Points on Affine Schemes","title":"is_smooth","text":"is_smooth(P::AbsAffineRationalPoint)\n\nReturn whether P is a smooth point of its ambient scheme X.\n\n\n\n\n\n","category":"method"},{"location":"AlgebraicGeometry/Schemes/RationalPointsAffine/#tangent_space-Tuple{AbsAffineRationalPoint{<:FieldElem}}","page":"Rational Points on Affine Schemes","title":"tangent_space","text":"tangent_space(P::AbsAffineRationalPoint{<:FieldElem}) -> AlgebraicSet\n\nReturn the Zariski tangent space of the ambient scheme of P at its point P.\n\nSee also tangent_space(X::AbsAffineScheme{<:Field}, P::AbsAffineRationalPoint)\n\n\n\n\n\n","category":"method"},{"location":"AlgebraicGeometry/Schemes/RationalPointsAffine/","page":"Rational Points on Affine Schemes","title":"Rational Points on Affine Schemes","text":"Some experimental methods are available too. Note that their interface is likely to change in the future.","category":"page"},{"location":"AlgebraicGeometry/Schemes/RationalPointsAffine/","page":"Rational Points on Affine Schemes","title":"Rational Points on Affine Schemes","text":"is_du_val_singularity(P::AbsAffineRationalPoint{<:FieldElem})\ndecide_du_val_singularity(P::AbsAffineRationalPoint{<:FieldElem,<:Any})","category":"page"},{"location":"AlgebraicGeometry/Schemes/RationalPointsAffine/#is_du_val_singularity-Tuple{AbsAffineRationalPoint{<:FieldElem}}","page":"Rational Points on Affine Schemes","title":"is_du_val_singularity","text":"is_du_val_singularity(P::AbsAffineRationalPoint{<:Field})\n\nReturn whether the ambient scheme of P has at most a Du Val singularity at P.\n\nNote that this includes the case that P is a smooth point.\n\n\n\n\n\n","category":"method"},{"location":"AlgebraicGeometry/Schemes/RationalPointsAffine/#decide_du_val_singularity-Tuple{AbsAffineRationalPoint{<:FieldElem}}","page":"Rational Points on Affine Schemes","title":"decide_du_val_singularity","text":"decide_du_val_singularity(P::AbsAffineRationalPoint{<:Field})\n\nReturn whether the ambient scheme of P has a Du Val singularity at P.\n\nExamples\n\njulia> A3 = affine_space(QQ, [:x, :y, :z]);\n\njulia> (x, y, z) = ambient_coordinates(A3);\n\njulia> X = subscheme(A3, ideal([x^2+y^2-z^2]));\n\njulia> Oscar.decide_du_val_singularity(X([0,0,0]))\n(true, (:A, 1))\n\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/elliptic_curves/intro/#Introduction","page":"Introduction","title":"Introduction","text":"","category":"section"},{"location":"Hecke/manual/elliptic_curves/intro/","page":"Introduction","title":"Introduction","text":"CurrentModule = Hecke\nDocTestSetup = quote\n    using Hecke\nend\n","category":"page"},{"location":"Hecke/manual/elliptic_curves/intro/","page":"Introduction","title":"Introduction","text":"This chapter deals with functionality for elliptic curves, which is available over arbitrary fields, with specific features available for curvers over the rationals and number fields, and finite fields.","category":"page"},{"location":"Hecke/manual/elliptic_curves/intro/","page":"Introduction","title":"Introduction","text":"An elliptic curve E is the projective closure of the curve given by the Weierstrass equation","category":"page"},{"location":"Hecke/manual/elliptic_curves/intro/","page":"Introduction","title":"Introduction","text":"y^2 + a_1 x y + a_3 y = x^3 + a_2 x^2 + a_4 x + a_6","category":"page"},{"location":"Hecke/manual/elliptic_curves/intro/","page":"Introduction","title":"Introduction","text":"specified by the list of coefficients [a1, a2, a3, a4, a6]. If a_1 = a_2 = a_3 = 0, this simplifies to","category":"page"},{"location":"Hecke/manual/elliptic_curves/intro/","page":"Introduction","title":"Introduction","text":"y^2 = x^3 + a_4 x + a_6","category":"page"},{"location":"Hecke/manual/elliptic_curves/intro/","page":"Introduction","title":"Introduction","text":"which we refer to as a short Weierstrass equation and which is specified by the two element list [a4, a6].","category":"page"},{"location":"Combinatorics/matroids/","page":"Matroids","title":"Matroids","text":"CurrentModule = Oscar","category":"page"},{"location":"Combinatorics/matroids/#Matroids","page":"Matroids","title":"Matroids","text":"","category":"section"},{"location":"Combinatorics/matroids/#Introduction","page":"Matroids","title":"Introduction","text":"","category":"section"},{"location":"Combinatorics/matroids/","page":"Matroids","title":"Matroids","text":"Matroids are a fundamental combinatorial object with connections to various fields of mathematics. It is an abstraction of linear independence in vector spaces and forests in graphs. One way to define a matroid is via the following two sets of data:","category":"page"},{"location":"Combinatorics/matroids/","page":"Matroids","title":"Matroids","text":"a finite ground set E = 1ldotsn and\na nonempty finite set mathcalB subseteq mathcalP(E) of bases satisfying an exchange property.","category":"page"},{"location":"Combinatorics/matroids/","page":"Matroids","title":"Matroids","text":"There are however many equivalent ways to define a matroid. One can also define a matroid via its circuits, hyperplanes, a graph, or a matrix. For a detailed introduction of matroids we refer to the textbook [Oxl11].","category":"page"},{"location":"Combinatorics/matroids/#Construction","page":"Matroids","title":"Construction","text":"","category":"section"},{"location":"Combinatorics/matroids/","page":"Matroids","title":"Matroids","text":"matroid_from_bases(bases::AbstractVector{T}, nelements::IntegerUnion; check::Bool=true) where T<:GroundsetType\nmatroid_from_nonbases(nonbases::AbstractVector{T}, nelements::IntegerUnion; check::Bool=true) where T<:GroundsetType\nmatroid_from_circuits(circuits::AbstractVector{T}, nelements::IntegerUnion) where T<:GroundsetType\nmatroid_from_hyperplanes(hyperplanes::AbstractVector{T}, nelements::IntegerUnion) where T<:GroundsetType\nmatroid_from_matrix_columns(A::MatrixElem; check::Bool=true)\nmatroid_from_matrix_rows(A::MatrixElem, ; check::Bool=true)\ncycle_matroid\nbond_matroid(g::Graph)\ncocycle_matroid(g::Graph)\nMatroid(pm_matroid::Polymake.BigObjectAllocated, E::GroundsetType=Vector{Integer}(1:pm_matroid.N_ELEMENTS))\nmatroid_from_revlex_basis_encoding(rvlx::String, r::IntegerUnion, n::IntegerUnion)\nmatroid_from_matroid_hex(str::AbstractString)","category":"page"},{"location":"Combinatorics/matroids/#matroid_from_bases-Union{Tuple{T}, Tuple{AbstractVector{T}, Union{Integer, ZZRingElem}}} where T<:Union{AbstractSet, AbstractVector}","page":"Matroids","title":"matroid_from_bases","text":"matroid_from_bases(B, [n, E])\n\nArguments\n\nB::AbstractVector: The set of bases of the matroid.\nn::InterUnion: The size of the ground set. The ground set will be {1,..n} in this case.\nE::AbstractVector: An explicit ground set passed as vector.\n\nConstruct a matroid with bases B on the ground set E (which can be the empty set). The set B is a non-empty collection of subsets of the ground set E satisfying an exchange property, and the default value for E is the set {1,..n} for a non-negative value n.\n\nSee Section 1.2 of [Oxl11].\n\nExamples\n\nTo construct a rank two matroid with five bases on four elements you can write:\n\njulia> B = [[1,2],[1,3],[1,4],[2,3],[2,4]];\n\njulia> M = matroid_from_bases(B,4)\nMatroid of rank 2 on 4 elements\n\nTo construct the same matroid on the four elements 1,2,i,j you may write:\n\njulia> M = matroid_from_bases([[1,2],[1,'i'],[1,'j'],[2,'i'],[2,'j']],[1,2,'i','j'])\nMatroid of rank 2 on 4 elements\n\n\n\n\n\n","category":"method"},{"location":"Combinatorics/matroids/#matroid_from_nonbases-Union{Tuple{T}, Tuple{AbstractVector{T}, Union{Integer, ZZRingElem}}} where T<:Union{AbstractSet, AbstractVector}","page":"Matroids","title":"matroid_from_nonbases","text":"matroid_from_nonbases(N, [n, E])\n\nArguments\n\nN::AbstractVector: The set of nonbases of the matroid.\nn::InterUnion: The size of the ground set. The ground set will be {1,..n} in this case.\nE::AbstractVector: An explicit ground set passed as vector.\n\nConstruct a matroid with nonbases N on the ground set E (which can be the empty set). That means that the matroid has as bases all subsets of the size |N[1]| of the ground set that are not in N. The set N can't be empty in this function. The described complement of N needs to be a non-empty collection of subsets of the ground set E satisfying an exchange property, and the default value for E is the set {1,..n} for a non-negative value n.\n\nSee Section 1.2 of [Oxl11].\n\nExamples\n\nTo construct the Fano matroid you may write:\n\njulia> H = [[1,2,4],[2,3,5],[1,3,6],[3,4,7],[1,5,7],[2,6,7],[4,5,6]];\n\njulia> M = matroid_from_nonbases(H,7)\nMatroid of rank 3 on 7 elements\n\n\n\n\n\n\n","category":"method"},{"location":"Combinatorics/matroids/#matroid_from_circuits-Union{Tuple{T}, Tuple{AbstractVector{T}, Union{Integer, ZZRingElem}}} where T<:Union{AbstractSet, AbstractVector}","page":"Matroids","title":"matroid_from_circuits","text":"matroid_from_circuits(C, [n, E])\n\nArguments\n\nC::AbstractVector: The set of circuits of the matroid.\nn::InterUnion: The size of the ground set. The ground set will be {1,..n} in this case.\nE::AbstractVector: An explicit ground set passed as vector.\n\nA matroid with circuits C on the ground set E (which can be the empty set). The set C is a collection of subsets of the ground set E satisfying an exchange property, and the default value for E is the set {1,..n} for a non-negative value n. \n\nSee Section 1.1 of [Oxl11].\n\nExamples\n\nTo construct a rank two matroid with five bases on four elements by its circuits you may write:\n\njulia> C = [[1,2,3],[1,2,4],[3,4]];\n\njulia> M = matroid_from_circuits(C,4)\nMatroid of rank 2 on 4 elements\n\nTo construct the same matroid on the ground set {1,2,i,j} you may write:\n\njulia> C = [[1,2,'j'],[1,2,'i'],['i','j']];\n\njulia> M = matroid_from_circuits(C,[1,2,'i','j'])\nMatroid of rank 2 on 4 elements\n\n\n\n\n\n","category":"method"},{"location":"Combinatorics/matroids/#matroid_from_hyperplanes-Union{Tuple{T}, Tuple{AbstractVector{T}, Union{Integer, ZZRingElem}}} where T<:Union{AbstractSet, AbstractVector}","page":"Matroids","title":"matroid_from_hyperplanes","text":"matroid_from_hyperplanes(H, [n, E])\n\nArguments\n\nH::AbstractVector: The set of hyperplanes of the matroid.\nn::InterUnion: The size of the ground set. The ground set will be {1,..n} in this case.\nE::AbstractVector: An explicit ground set passed as vector.\n\nA matroid with hyperplanes H on the ground set E (which can be the empty set). A hyperplane is a flat of rank r-1. The set H is a collection of subsets of the ground set E satisfying an exchange property, and the default value for E is the set {1,..n} for a non-negative value n. \n\nSee Section 1.4 of [Oxl11].\n\nExamples\n\nTo construct the Fano matroid you may write:\n\njulia> H = [[1,2,4],[2,3,5],[1,3,6],[3,4,7],[1,5,7],[2,6,7],[4,5,6]];\n\njulia> M = matroid_from_hyperplanes(H,7)\nMatroid of rank 3 on 7 elements\n\n\n\n\n\n\n","category":"method"},{"location":"Combinatorics/matroids/#matroid_from_matrix_columns-Tuple{MatrixElem}","page":"Matroids","title":"matroid_from_matrix_columns","text":"matroid_from_matrix_columns(A::MatrixElem; check::Bool=true)\n\nA matroid represented by the column vectors of a matrix A. The value of check is currently ignored.\n\nSee Section 1.1 of [Oxl11].\n\nExamples\n\nTo construct the vector matroid (a.k.a linear matroid) of the matrix A over the field with two elements write:\n\njulia> A = matrix(GF(2),[[1,0,1,1],[0,1,1,1]]);\n\njulia> M = matroid_from_matrix_columns(A)\nMatroid of rank 2 on 4 elements\n\n\n\n\n\n","category":"method"},{"location":"Combinatorics/matroids/#matroid_from_matrix_rows-Tuple{MatrixElem}","page":"Matroids","title":"matroid_from_matrix_rows","text":"matroid_from_matrix_rows(A::MatrixElem, check::Bool=true)\n\nA matroid represented by the row vectors of a matrix. The value of check is currently ignored.\n\nSee Section 1.1 of [Oxl11].\n\nExamples\n\nTo construct the linear matroid of the rows of the matrix A over the field with two elements write:\n\njulia> A = matrix(GF(2),[[1,0],[0,1],[1,1],[1,1]]);\n\njulia> M = matroid_from_matrix_rows(A)\nMatroid of rank 2 on 4 elements\n\n\n\n\n\n","category":"method"},{"location":"Combinatorics/matroids/#cycle_matroid","page":"Matroids","title":"cycle_matroid","text":"cycle_matroid(g::Graph{Undirected})\n\nThe cycle matroid of a graph g.\n\nSee Section 1.1 of [Oxl11].\n\nExamples\n\nTo construct the cycle matroid of the complete graph of 4 vertices write:\n\njulia> g = complete_graph(4);\n\njulia> M = cycle_matroid(g)\nMatroid of rank 3 on 6 elements\n\n\n\n\n\n","category":"function"},{"location":"Combinatorics/matroids/#bond_matroid-Tuple{Graph}","page":"Matroids","title":"bond_matroid","text":"bond_matroid(g::Graph)\n\nThe \"bond matroid\" or \"cocycle matroid\" of a graph which is the dual of a cycle matroid, i.e., cographic.\n\nSee Section 2.3 of [Oxl11].\n\nExamples\n\nTo construct the bond or cocycle matroid of the complete graph of 4 vertices write:\n\njulia> g = complete_graph(4);\n\njulia> M = bond_matroid(g)\nMatroid of rank 3 on 6 elements\n\nor equivalently\n\njulia> g = complete_graph(4);\n\njulia> M = cocycle_matroid(g)\nMatroid of rank 3 on 6 elements\n\n\n\n\n\n","category":"method"},{"location":"Combinatorics/matroids/#cocycle_matroid-Tuple{Graph}","page":"Matroids","title":"cocycle_matroid","text":"See bond_matroid.\n\n\n\n\n\n","category":"method"},{"location":"Combinatorics/matroids/#Matroid","page":"Matroids","title":"Matroid","text":"Matroid(pm_matroid::Polymake.BigObjectAllocated, [E::GroundsetType])\n\nConstruct a matroid from a polymake matroid M on the default ground set {1,...,n}.\n\n\n\n\n\n","category":"type"},{"location":"Combinatorics/matroids/#matroid_from_revlex_basis_encoding-Tuple{String, Union{Integer, ZZRingElem}, Union{Integer, ZZRingElem}}","page":"Matroids","title":"matroid_from_revlex_basis_encoding","text":"matroid_from_revlex_basis_encoding(rvlx::String, r::IntegerUnion, n::IntegerUnion)\n\nConstruct a matroid from a revlex-basis-encoding-string rvlx of rank r and size n.\n\nExamples\n\njulia> matroid_from_revlex_basis_encoding(\"0******0******0***0******0*0**0****\", 3, 7)\nMatroid of rank 3 on 7 elements\n\n\n\n\n\n","category":"method"},{"location":"Combinatorics/matroids/#matroid_from_matroid_hex-Tuple{AbstractString}","page":"Matroids","title":"matroid_from_matroid_hex","text":"matroid_from_matroid_hex(str::AbstractString)\n\nReturns a matroid from a string of hex characters.\n\nExamples\n\nTo retrieve the fano matroid from its hex encoding write:\n\njulia> matroid_from_matroid_hex(\"r3n7_3f7eefd6f\")\nMatroid of rank 3 on 7 elements\n\n\n\n\n\n\n","category":"method"},{"location":"Combinatorics/matroids/#Examples","page":"Matroids","title":"Examples","text":"","category":"section"},{"location":"Combinatorics/matroids/","page":"Matroids","title":"Matroids","text":"uniform_matroid(r::IntegerUnion,n::IntegerUnion)\nfano_matroid()\nmoebius_kantor_matroid()\nnon_fano_matroid()\nnon_pappus_matroid()\npappus_matroid()\nperles_matroid()\nR10_matroid()\nvamos_matroid()\nall_subsets_matroid(r::Int)\nprojective_plane(q::Int)\nprojective_geometry(r::Int, q::Int; check::Bool=false)\naffine_geometry(r::Int, q::Int; check::Bool=false)","category":"page"},{"location":"Combinatorics/matroids/#uniform_matroid-Tuple{Union{Integer, ZZRingElem}, Union{Integer, ZZRingElem}}","page":"Matroids","title":"uniform_matroid","text":"uniform_matroid(r,n)\n\nConstruct the uniform matroid of rank r on the n elements {1,...,n}.\n\n\n\n\n\n","category":"method"},{"location":"Combinatorics/matroids/#fano_matroid-Tuple{}","page":"Matroids","title":"fano_matroid","text":"fano_matroid()\n\nConstruct the Fano matroid.\n\n\n\n\n\n","category":"method"},{"location":"Combinatorics/matroids/#moebius_kantor_matroid-Tuple{}","page":"Matroids","title":"moebius_kantor_matroid","text":"moebius_kantor_matroid()\n\nConstruct the Möbius-Kantor matroid.\n\n\n\n\n\n","category":"method"},{"location":"Combinatorics/matroids/#non_fano_matroid-Tuple{}","page":"Matroids","title":"non_fano_matroid","text":"non_fano_matroid()\n\nConstruct the non-Fano matroid.\n\n\n\n\n\n","category":"method"},{"location":"Combinatorics/matroids/#non_pappus_matroid-Tuple{}","page":"Matroids","title":"non_pappus_matroid","text":"non_pappus_matroid()\n\nConstruct the non-Pappus matroid.\n\n\n\n\n\n","category":"method"},{"location":"Combinatorics/matroids/#pappus_matroid-Tuple{}","page":"Matroids","title":"pappus_matroid","text":"pappus_matroid()\n\nConstruct the Pappus matroid.\n\n\n\n\n\n","category":"method"},{"location":"Combinatorics/matroids/#perles_matroid-Tuple{}","page":"Matroids","title":"perles_matroid","text":"perles_matroid()\n\nConstruct the Perles matroid.\n\n\n\n\n\n","category":"method"},{"location":"Combinatorics/matroids/#R10_matroid-Tuple{}","page":"Matroids","title":"R10_matroid","text":"R10_matroid()\n\nConstruct the R10 matroid.\n\n\n\n\n\n","category":"method"},{"location":"Combinatorics/matroids/#vamos_matroid-Tuple{}","page":"Matroids","title":"vamos_matroid","text":"vamos_matroid()\n\nConstruct the Vamos matroid.\n\n\n\n\n\n","category":"method"},{"location":"Combinatorics/matroids/#all_subsets_matroid-Tuple{Int64}","page":"Matroids","title":"all_subsets_matroid","text":"all_subsets_matroid(r)\n\nConstruct the all-subsets-matroid of rank r, a.k.a. the matroid underlying the resonance arrangement or rank r.\n\n\n\n\n\n","category":"method"},{"location":"Combinatorics/matroids/#projective_plane-Tuple{Int64}","page":"Matroids","title":"projective_plane","text":"projective_plane(q::Int)\n\nThe projective plane of order q. Note that this only works for prime numbers q for now.\n\nSee Section 6.1 of [Oxl11].\n\nExamples\n\njulia> M = projective_plane(3)\nMatroid of rank 3 on 13 elements\n\n\n\n\n\n\n","category":"method"},{"location":"Combinatorics/matroids/#projective_geometry-Tuple{Int64, Int64}","page":"Matroids","title":"projective_geometry","text":"projective_geometry(r::Int, q::Int)\n\nThe projective geometry of order q and rank r+1. Note that this only works for prime numbers q for now.\n\nSee Section 6.1 of [Oxl11]. Warning: Following the book of Oxley, the rank of the resulting matroid is r+1.\n\nExamples\n\njulia> M = projective_geometry(2, 3)\nMatroid of rank 3 on 13 elements\n\n\n\n\n\n\n","category":"method"},{"location":"Combinatorics/matroids/#affine_geometry-Tuple{Int64, Int64}","page":"Matroids","title":"affine_geometry","text":"affine_geometry(r::Int, q::Int)\n\nThe affine geometry of order q and rank r+1. Note that this only works for prime numbers q for now.\n\nSee Section 6.1 of [Oxl11]. Warning: Following the book of Oxley, the rank of the resulting matroid is r+1.\n\nExamples\n\njulia> M = affine_geometry(2, 3)\nMatroid of rank 3 on 9 elements\n\n\n\n\n\n","category":"method"},{"location":"Combinatorics/matroids/#Modifying-matroids","page":"Matroids","title":"Modifying matroids","text":"","category":"section"},{"location":"Combinatorics/matroids/","page":"Matroids","title":"Matroids","text":"dual_matroid(M::Matroid)\ndirect_sum(M::Matroid, N::Matroid)\ndeletion(M::Matroid,set::GroundsetType)\nrestriction(M::Matroid, set::GroundsetType)\ncontraction(M::Matroid,set::GroundsetType)\nminor(M::Matroid, set_del::GroundsetType, set_cont::GroundsetType)\nprincipal_extension(M::Matroid, set::GroundsetType, elem::ElementType)\nfree_extension(M::Matroid, elem::ElementType)\nseries_extension(M::Matroid, old::ElementType, new::ElementType)\nparallel_extension(M::Matroid, old::ElementType, new::ElementType)","category":"page"},{"location":"Combinatorics/matroids/#dual_matroid-Tuple{Matroid}","page":"Matroids","title":"dual_matroid","text":"dual_matroid(M::Matroid)\n\nThe dual matroid of a given matroid M.\n\nSee page 65 and Sectrion 2 in [Oxl11].\n\nExamples\n\nTo construct the dual of the Fano matroid write:\n\njulia> M = dual_matroid(fano_matroid())\nMatroid of rank 4 on 7 elements\n\n\n\n\n\n","category":"method"},{"location":"Combinatorics/matroids/#direct_sum-Tuple{Matroid, Matroid}","page":"Matroids","title":"direct_sum","text":"direct_sum(M::Matroid, N::Matroid)\n\nThe direct sum of the matroids M and N. Optionally one can also pass a vector of matroids.\n\nSee Section 4.2 of [Oxl11].\n\nTo obtain the direct sum of the Fano and a uniform matroid type:\n\nExamples\n\njulia> direct_sum(fano_matroid(), uniform_matroid(2,4))\nMatroid of rank 5 on 11 elements\n\nTo take the sum of three uniform matroids use:\n\nExamples\n\njulia> matroids = Vector([uniform_matroid(2,4), uniform_matroid(1,3), uniform_matroid(3,4)]);\n\njulia> M = direct_sum(matroids)\nMatroid of rank 6 on 11 elements\n\n\n\n\n\n","category":"method"},{"location":"Combinatorics/matroids/#deletion-Tuple{Matroid, Union{AbstractSet, AbstractVector}}","page":"Matroids","title":"deletion","text":"deletion(M, [S, e])\n\nArguments\n\nM::Matroid: A matroid M.\nS::GroundsetType: A subset S of the ground set of M.\ne::ElementType: An element e of the ground set of M.\n\nThe deletion M\\S of an element e or a subset S of the ground set E of the matroid M.\n\nSee Section 3 of [Oxl11].\n\nExamples\n\njulia> M = matroid_from_bases([[1,2],[1,'i'],[1,'j'],[2,'i'],[2,'j']],[1,2,'i','j']);\n\njulia> N = deletion(M,'i')\nMatroid of rank 2 on 3 elements\n\nExamples\n\njulia> M = matroid_from_bases([[1,2],[1,'i'],[1,'j'],[2,'i'],[2,'j']],[1,2,'i','j']);\n\njulia> N = deletion(M,['i','j'])\nMatroid of rank 2 on 2 elements\n\njulia> matroid_groundset(N)\n2-element Vector{Any}:\n 1\n 2\n\n\n\n\n\n","category":"method"},{"location":"Combinatorics/matroids/#restriction-Tuple{Matroid, Union{AbstractSet, AbstractVector}}","page":"Matroids","title":"restriction","text":"restriction(M, S)\n\nArguments\n\nM::Matroid: A matroid M.\nS::GroundSetType: A subset S of the ground set of M.\n\nThe restriction M|S on a subset S of the ground set E of the matroid M.\n\nSee Section 3 of [Oxl11].\n\nExamples\n\njulia> M = matroid_from_bases([[1,2],[1,'i'],[1,'j'],[2,'i'],[2,'j']],[1,2,'i','j']);\n\njulia> N = restriction(M,[1,2])\nMatroid of rank 2 on 2 elements\n\njulia> matroid_groundset(N)\n2-element Vector{Any}:\n 1\n 2\n\n\n\n\n\n","category":"method"},{"location":"Combinatorics/matroids/#contraction-Tuple{Matroid, Union{AbstractSet, AbstractVector}}","page":"Matroids","title":"contraction","text":"contraction(M, [S, e])\n\nArguments\n\nM::Matroid: A matroid M.\nS::GroundSetType: A subset S of the ground set of M.\ne::ElementType: An element e of the ground set of M.\n\nThe contraction M/S of an element or a subset S of the ground set E of the matroid M.\n\nSee Section 3 of [Oxl11].\n\nExamples\n\njulia> M = matroid_from_bases([[1,2],[1,'i'],[1,'j'],[2,'i'],[2,'j']],[1,2,'i','j']);\n\njulia> N = contraction(M,'i')\nMatroid of rank 1 on 3 elements\n\nExamples\n\njulia> M = matroid_from_bases([[1,2],[1,'i'],[1,'j'],[2,'i'],[2,'j']],[1,2,'i','j']);\n\njulia> N = contraction(M,['i','j'])\nMatroid of rank 1 on 2 elements\n\njulia> matroid_groundset(N)\n2-element Vector{Any}:\n 1\n 2\n\n\n\n\n\n","category":"method"},{"location":"Combinatorics/matroids/#minor-Tuple{Matroid, Union{AbstractSet, AbstractVector}, Union{AbstractSet, AbstractVector}}","page":"Matroids","title":"minor","text":"minor(M::Matroid, set_del::GroundsetType, set_cont::GroundsetType)\n\nThe minor M\\S/T of disjoint subsets  S and T of the ground set E of the matroid M.\n\nSee also contraction and deletion. You can find more in Section 3 of [Oxl11].\n\nExamples\n\njulia> M = fano_matroid();\n\njulia> S = [1,2,3];\n\njulia> T = [4];\n\njulia>  N = minor(M,S,T) \nMatroid of rank 2 on 3 elements\n\n\n\n\n\n","category":"method"},{"location":"Combinatorics/matroids/#principal_extension-Tuple{Matroid, Union{AbstractSet, AbstractVector}, Union{Char, Edge, Integer, String, ZZRingElem}}","page":"Matroids","title":"principal_extension","text":"principal_extension(M::Matroid, F::GroundsetType, e::ElementType)\n\nThe principal extension M +_F e of a matroid M where the element e is freely added to the flat F.\n\nSee Section 7.2 of [Oxl11].\n\nExamples\n\nTo add 5 freely to the flat {1,2} of the uniform matroid U_{3,4} do\n\njulia> M = uniform_matroid(3,4);\n\njulia> N = principal_extension(M,[1,2],5)\nMatroid of rank 3 on 5 elements\n\n\n\n\n\n","category":"method"},{"location":"Combinatorics/matroids/#free_extension-Tuple{Matroid, Union{Char, Edge, Integer, String, ZZRingElem}}","page":"Matroids","title":"free_extension","text":"free_extension(M::Matroid, e::ElementType)\n\nThe free extension M +_E e of a matroid M where the element e.\n\nSee principal_extension and Section 7.2 of [Oxl11].\n\nExamples\n\nTo add 5 freely to the uniform matroid U_{3,4} do\n\njulia> M = uniform_matroid(3,4);\n\njulia>  N = free_extension(M,5)\nMatroid of rank 3 on 5 elements\n\n\n\n\n\n","category":"method"},{"location":"Combinatorics/matroids/#series_extension-Tuple{Matroid, Union{Char, Edge, Integer, String, ZZRingElem}, Union{Char, Edge, Integer, String, ZZRingElem}}","page":"Matroids","title":"series_extension","text":"series_extension(M::Matroid, f::ElementType, e::ElementType)\n\nThe series extension of a matroid M where the element e is added in series to f.\n\nThis is actually a coextension see also Section 7.2 of [Oxl11].\n\nExamples\n\nTo add e in series to 1 in the uniform matroid U_{3,4} do\n\njulia> M = uniform_matroid(1,4);\n\njulia> N = series_extension(M,1,'e')\nMatroid of rank 2 on 5 elements\n\njulia> cocircuits(N)[1]\n2-element Vector{Any}:\n 1\n  'e': ASCII/Unicode U+0065 (category Ll: Letter, lowercase)\n\n\n\n\n\n","category":"method"},{"location":"Combinatorics/matroids/#parallel_extension-Tuple{Matroid, Union{Char, Edge, Integer, String, ZZRingElem}, Union{Char, Edge, Integer, String, ZZRingElem}}","page":"Matroids","title":"parallel_extension","text":"parallel_extension(M::Matroid, f::ElementType, e::ElementType)\n\nThe parallel extension M +_{cl(f)} e of a matroid M where the element e is added parallel to (the closure of) f.\n\nSee Section 7.2 of [Oxl11].\n\nExamples\n\nTo add e parallel to 1 in the uniform matroid U_{3,4} do\n\njulia> M = uniform_matroid(3,4);\n\njulia> N = parallel_extension(M,1,'e')\nMatroid of rank 3 on 5 elements\n\njulia> circuits(N)[1]\n2-element Vector{Any}:\n 1\n  'e': ASCII/Unicode U+0065 (category Ll: Letter, lowercase)\n\n\n\n\n\n","category":"method"},{"location":"Combinatorics/matroids/#Properties","page":"Matroids","title":"Properties","text":"","category":"section"},{"location":"Combinatorics/matroids/","page":"Matroids","title":"Matroids","text":"matroid_groundset(M::Matroid)\nlength(M::Matroid)\nrank(M::Matroid)\nrank(M::Matroid, set::GroundsetType)\nbases(M::Matroid)\nnonbases(M::Matroid)\ncircuits(M::Matroid)\nhyperplanes(M::Matroid)\nflats(M::Matroid, r::Union{Int,Nothing}=nothing)\ncyclic_flats(M::Matroid, r::Union{Int,Nothing}=nothing)\nclosure(M::Matroid, set::GroundsetType)\nnullity(M::Matroid, set::GroundsetType)\nfundamental_circuit(M::Matroid, basis::GroundsetType, elem::ElementType)\nfundamental_cocircuit(M::Matroid, basis::GroundsetType, elem::ElementType)\nindependent_sets(M::Matroid)\nspanning_sets(M::Matroid)\ncobases(M::Matroid)\ncocircuits(M::Matroid)\ncohyperplanes(M::Matroid)\ncorank(M::Matroid, set::GroundsetType)\nis_clutter(sets::AbstractVector{T}) where T <: GroundsetType\nis_regular(M::Matroid)\nis_binary(M::Matroid)\nis_ternary(M::Matroid)\nn_connected_components(M::Matroid)\nconnected_components(M::Matroid)\nis_connected(M::Matroid)\nloops(M::Matroid)\ncoloops(M::Matroid)\nis_loopless(M::Matroid)\nis_coloopless(M::Matroid)\nis_simple(M::Matroid)\ndirect_sum_components(M::Matroid)\nconnectivity_function(M::Matroid, set::GroundsetType)\nis_vertical_k_separation(M::Matroid,k::IntegerUnion, set::GroundsetType) \nis_k_separation(M::Matroid,k::IntegerUnion, set::GroundsetType)\nvertical_connectivity(M::Matroid)\ngirth(M::Matroid, set::GroundsetType=M.groundset)\ntutte_connectivity(M::Matroid)\ntutte_polynomial(M::Matroid)\ncharacteristic_polynomial(M::Matroid)\nreduced_characteristic_polynomial(M::Matroid)\nrevlex_basis_encoding(M::Matroid)\nis_isomorphic(M1::Matroid, M2::Matroid)\nis_minor(M::Matroid, N::Matroid)\nmatroid_hex(M::Matroid)\nautomorphism_group(M::Matroid)\nmatroid_base_polytope(M::Matroid)","category":"page"},{"location":"Combinatorics/matroids/#matroid_groundset-Tuple{Matroid}","page":"Matroids","title":"matroid_groundset","text":"matroid_groundset(M::Matroid)\n\nThe ground set E of a matroid M.\n\nTo obtain the ground set of the Fano matroid write:\n\nExamples\n\njulia> matroid_groundset(fano_matroid())\n7-element Vector{Int64}:\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n\n\n\n\n\n","category":"method"},{"location":"Combinatorics/matroids/#length-Tuple{Matroid}","page":"Matroids","title":"length","text":"length(M::Matroid)\n\nReturn the size of the ground set of the matroid M.\n\nExamples\n\njulia> length(fano_matroid())\n7\n\n\n\n\n\n","category":"method"},{"location":"Combinatorics/matroids/#rank-Tuple{Matroid}","page":"Matroids","title":"rank","text":"rank(M::Matroid)\n\nReturn the rank of the matroid M.\n\nExamples\n\njulia> rank(fano_matroid())\n3\n\n\n\n\n\n","category":"method"},{"location":"Combinatorics/matroids/#rank-Tuple{Matroid, Union{AbstractSet, AbstractVector}}","page":"Matroids","title":"rank","text":"rank(M::Matroid, set::GroundsetType)\n\nReturn the rank of set in the matroid M.\n\nExamples\n\njulia> M = fano_matroid();\n\njulia> rank(M, [1,2,3])\n2\n\n\n\n\n\n","category":"method"},{"location":"Combinatorics/matroids/#bases-Tuple{Matroid}","page":"Matroids","title":"bases","text":"bases([::Type{Int},] M::Matroid)\n\nReturn the list of bases of the matroid M. If Int is passed as a first argument then the bases will be returned as indices instead of ground set elements.\n\nExamples\n\njulia> bases(uniform_matroid(2, 3))\n3-element Vector{Vector{Int64}}:\n [1, 2]\n [1, 3]\n [2, 3]\n\n\n\n\n\n","category":"method"},{"location":"Combinatorics/matroids/#nonbases-Tuple{Matroid}","page":"Matroids","title":"nonbases","text":"nonbases(M::Matroid)\n\nReturn the list of nonbases of the matroid M.\n\nExamples\n\njulia> nonbases(fano_matroid())\n7-element Vector{Vector{Int64}}:\n [1, 2, 3]\n [1, 4, 5]\n [1, 6, 7]\n [2, 4, 6]\n [2, 5, 7]\n [3, 4, 7]\n [3, 5, 6]\n\n\n\n\n\n","category":"method"},{"location":"Combinatorics/matroids/#circuits-Tuple{Matroid}","page":"Matroids","title":"circuits","text":"circuits(M::Matroid)\n\nReturn the list of circuits of the matroid M.\n\nExamples\n\njulia> circuits(uniform_matroid(2, 4))\n4-element Vector{Vector{Int64}}:\n [1, 2, 3]\n [1, 2, 4]\n [1, 3, 4]\n [2, 3, 4]\n\n\n\n\n\n","category":"method"},{"location":"Combinatorics/matroids/#hyperplanes-Tuple{Matroid}","page":"Matroids","title":"hyperplanes","text":"hyperplanes(M::Matroid)\n\nReturn the list of hyperplanes of the matroid M.\n\nExamples\n\njulia> hyperplanes(fano_matroid())\n7-element Vector{Vector{Int64}}:\n [3, 5, 6]\n [3, 4, 7]\n [2, 5, 7]\n [2, 4, 6]\n [1, 6, 7]\n [1, 4, 5]\n [1, 2, 3]\n\n\n\n\n\n","category":"method"},{"location":"Combinatorics/matroids/#flats","page":"Matroids","title":"flats","text":"flats(M::Matroid, [r::Int])\n\nReturn the list of flats of the matroid M. By default all flats are returned. One may specify a rank r as the second parameter in which case only the flats of rank r are returned.\n\nExamples\n\njulia> M = fano_matroid()\nMatroid of rank 3 on 7 elements\n\njulia> flats(M)\n16-element Vector{Vector{Int64}}:\n []\n [1]\n [2]\n [3]\n [4]\n [5]\n [6]\n [7]\n [1, 2, 3]\n [1, 4, 5]\n [1, 6, 7]\n [2, 4, 6]\n [2, 5, 7]\n [3, 5, 6]\n [3, 4, 7]\n [1, 2, 3, 4, 5, 6, 7]\n\njulia> flats(M, 2)\n7-element Vector{Vector{Int64}}:\n [1, 2, 3]\n [1, 4, 5]\n [1, 6, 7]\n [2, 4, 6]\n [2, 5, 7]\n [3, 5, 6]\n [3, 4, 7]\n\n\n\n\n\n","category":"function"},{"location":"Combinatorics/matroids/#cyclic_flats","page":"Matroids","title":"cyclic_flats","text":"cyclic_flats(M::Matroid, [r::Int])\n\nReturn the list of cyclic flats of the matroid M. These are the flats that are the union of cycles. See Section 2.1 in [Oxl11].\n\nBy default all cyclic flats are returned. One may specify a rank r as the second parameter. In this case only the cyclic flats of this rank are returned.\n\nExamples\n\njulia> M = fano_matroid()\nMatroid of rank 3 on 7 elements\n\njulia> cyclic_flats(M)\n9-element Vector{Vector{Int64}}:\n []\n [1, 2, 3]\n [1, 4, 5]\n [1, 6, 7]\n [2, 4, 6]\n [2, 5, 7]\n [3, 5, 6]\n [3, 4, 7]\n [1, 2, 3, 4, 5, 6, 7]\n\njulia> cyclic_flats(M, 2)\n7-element Vector{Vector{Int64}}:\n [1, 2, 3]\n [1, 4, 5]\n [1, 6, 7]\n [2, 4, 6]\n [2, 5, 7]\n [3, 5, 6]\n [3, 4, 7]\n\n\n\n\n\n","category":"function"},{"location":"Combinatorics/matroids/#closure-Tuple{Matroid, Union{AbstractSet, AbstractVector}}","page":"Matroids","title":"closure","text":"closure(M::Matroid, set::GroundsetType)\n\nReturn the closure of set in the matroid M.\n\nExamples\n\njulia> closure(fano_matroid(), [1,2])\n3-element Vector{Int64}:\n 1\n 2\n 3\n\n\n\n\n\n","category":"method"},{"location":"Combinatorics/matroids/#nullity-Tuple{Matroid, Union{AbstractSet, AbstractVector}}","page":"Matroids","title":"nullity","text":"nullity(M::Matroid, set::GroundsetType)\n\nReturn the nullity of set in the matroid M. This is defined to be |set| - rk(set).\n\nExamples\n\njulia> M = fano_matroid();\n\njulia> nullity(M, [1,2,3])\n1\n\n\n\n\n\n","category":"method"},{"location":"Combinatorics/matroids/#fundamental_circuit-Tuple{Matroid, Union{AbstractSet, AbstractVector}, Union{Char, Edge, Integer, String, ZZRingElem}}","page":"Matroids","title":"fundamental_circuit","text":"fundamental_circuit(M::Matroid, basis::GroundsetType, elem::ElementType)\n\nReturn the unique circuit contained in the union of basis and elem of the matroid M. See Section 1.2 of [Oxl11]. Note that elem needs to be in the complement of the basis in this case.\n\nExamples\n\njulia> M = fano_matroid();\n\njulia> fundamental_circuit(M, [1,2,4], 7)\n4-element Vector{Int64}:\n 1\n 2\n 4\n 7\n\njulia> fundamental_circuit(M, [1,2,4], 3)\n3-element Vector{Int64}:\n 1\n 2\n 3\n\n\n\n\n\n","category":"method"},{"location":"Combinatorics/matroids/#fundamental_cocircuit-Tuple{Matroid, Union{AbstractSet, AbstractVector}, Union{Char, Edge, Integer, String, ZZRingElem}}","page":"Matroids","title":"fundamental_cocircuit","text":"fundamental_cocircuit(M::Matroid, cobasis::GroundsetType, elem::ElementType)\n\nReturn the unique circuit of the dual matroid of M in the union of the complement of basis and elem. See Section 2.1 of [Oxl11]. Note that elem needs to be an element of the basis in this case.\n\nExamples\n\njulia> fundamental_cocircuit(fano_matroid(), [1,2,4], 4)\n4-element Vector{Int64}:\n 4\n 5\n 6\n 7\n\n\n\n\n\n","category":"method"},{"location":"Combinatorics/matroids/#independent_sets-Tuple{Matroid}","page":"Matroids","title":"independent_sets","text":"independent_sets(M::Matroid)\n\nReturn the list of independent sets of the matroid M. These are all subsets of the bases.\n\nExamples\n\njulia> independent_sets(uniform_matroid(2, 3))\n7-element Vector{Vector{Int64}}:\n []\n [1]\n [2]\n [3]\n [1, 3]\n [2, 3]\n [1, 2]\n\n\n\n\n\n","category":"method"},{"location":"Combinatorics/matroids/#spanning_sets-Tuple{Matroid}","page":"Matroids","title":"spanning_sets","text":"spanning_sets(M::Matroid)\n\nReturn the list of spanning sets of the matroid M. These are all sets containing a basis.\n\nExamples\n\njulia> spanning_sets(uniform_matroid(2, 3))\n4-element Vector{Vector{Int64}}:\n [1, 2]\n [1, 3]\n [2, 3]\n [1, 2, 3]\n\n\n\n\n\n","category":"method"},{"location":"Combinatorics/matroids/#cobases-Tuple{Matroid}","page":"Matroids","title":"cobases","text":"cobases(M::Matroid)\n\nReturn the bases of the dual matroid of M. See Section 2 in [Oxl11].\n\nExamples\n\njulia> cobases(uniform_matroid(2, 3))\n3-element Vector{Vector{Int64}}:\n [3]\n [2]\n [1]\n\n\n\n\n\n","category":"method"},{"location":"Combinatorics/matroids/#cocircuits-Tuple{Matroid}","page":"Matroids","title":"cocircuits","text":"cocircuits(M::Matroid)\n\nReturn the circuits of the dual matroid of M. See Section 2 in [Oxl11].\n\nExamples\n\njulia> cocircuits(uniform_matroid(2, 5))\n5-element Vector{Vector{Int64}}:\n [1, 2, 3, 4]\n [1, 2, 3, 5]\n [1, 2, 4, 5]\n [1, 3, 4, 5]\n [2, 3, 4, 5]\n\n\n\n\n\n","category":"method"},{"location":"Combinatorics/matroids/#cohyperplanes-Tuple{Matroid}","page":"Matroids","title":"cohyperplanes","text":"cohyperplanes(M::Matroid)\n\nReturn the hyperplanes of the dual matroid of M. See Section 2 in [Oxl11].\n\nExamples\n\njulia> cohyperplanes(fano_matroid())\n14-element Vector{Vector{Int64}}:\n [4, 5, 6, 7]\n [2, 3, 6, 7]\n [2, 3, 4, 5]\n [1, 3, 5, 7]\n [1, 3, 4, 6]\n [1, 2, 5, 6]\n [1, 2, 4, 7]\n [3, 5, 6]\n [3, 4, 7]\n [2, 5, 7]\n [2, 4, 6]\n [1, 6, 7]\n [1, 4, 5]\n [1, 2, 3]\n\n\n\n\n\n","category":"method"},{"location":"Combinatorics/matroids/#corank-Tuple{Matroid, Union{AbstractSet, AbstractVector}}","page":"Matroids","title":"corank","text":"corank(M::Matroid, set::GroundsetType)\n\nReturn the rank of set in the dual matroid of M.\n\nExamples\n\njulia> corank(fano_matroid(), [1,2,3])\n3\n\n\n\n\n\n","category":"method"},{"location":"Combinatorics/matroids/#is_clutter-Union{Tuple{AbstractVector{T}}, Tuple{T}} where T<:Union{AbstractSet, AbstractVector}","page":"Matroids","title":"is_clutter","text":"is_clutter(sets::AbstractVector{T}) where T <: GroundsetType\n\nChecks if the collection of subsets sets is a clutter. A collection of subsets is a clutter if none of the sets is a proper subset of another. See Section 2.1 in [Oxl11].\n\nExamples\n\njulia> is_clutter([[1,2], [1,2,3]])\nfalse\n\njulia> is_clutter(circuits(fano_matroid()))\ntrue\n\n\n\n\n\n","category":"method"},{"location":"Combinatorics/matroids/#is_regular-Tuple{Matroid}","page":"Matroids","title":"is_regular","text":"is_regular(M::Matroid)\n\nChecks if the matroid M is regular, that is representable over every field. See Section 6.6 in [Oxl11].\n\nExamples\n\njulia> is_regular(uniform_matroid(2, 3))\ntrue\n\njulia> is_regular(fano_matroid())\nfalse\n\n\n\n\n\n","category":"method"},{"location":"Combinatorics/matroids/#is_binary-Tuple{Matroid}","page":"Matroids","title":"is_binary","text":"is_binary(M::Matroid)\n\nChecks if the matroid M is binary, that is representable over the finite field F_2. See Section 6.5 in [Oxl11].\n\nExamples\n\njulia> is_binary(uniform_matroid(2, 4))\nfalse\n\njulia> is_binary(fano_matroid())\ntrue\n\n\n\n\n\n","category":"method"},{"location":"Combinatorics/matroids/#is_ternary-Tuple{Matroid}","page":"Matroids","title":"is_ternary","text":"is_ternary(M::Matroid)\n\nChecks if the matroid M is ternary, that is representable over the finite field F_3. See Section 4.1 in [Oxl11].\n\nExamples\n\njulia> is_ternary(uniform_matroid(2, 4))\ntrue\n\njulia> is_ternary(fano_matroid())\nfalse\n\n\n\n\n\n","category":"method"},{"location":"Combinatorics/matroids/#n_connected_components-Tuple{Matroid}","page":"Matroids","title":"n_connected_components","text":"n_connected_components(M::Matroid)\n\nReturn the number of connected components of M. See Section 4.1 in [Oxl11].\n\nExamples\n\njulia> n_connected_components(fano_matroid())\n1\n\njulia> n_connected_components(uniform_matroid(3, 3))\n3\n\n\n\n\n\n","category":"method"},{"location":"Combinatorics/matroids/#connected_components-Tuple{Matroid}","page":"Matroids","title":"connected_components","text":"connected_components(M::Matroid)\n\nReturn the connected components of M. The function returns a partition of the ground set where each part corresponds to one connected component.  See Section 4.1 in [Oxl11].\n\nExamples\n\njulia> connected_components(fano_matroid())\n1-element Vector{Vector{Int64}}:\n [1, 2, 3, 4, 5, 6, 7]\n\njulia> connected_components(uniform_matroid(3, 3))\n3-element Vector{Vector{Int64}}:\n [1]\n [2]\n [3]\n\n\n\n\n\n","category":"method"},{"location":"Combinatorics/matroids/#is_connected-Tuple{Matroid}","page":"Matroids","title":"is_connected","text":"is_connected(M::Matroid)\n\nCheck if the matroid M is connected, that is has one connected component See Section 4.1 in [Oxl11].\n\nExamples\n\njulia> is_connected(fano_matroid())\ntrue\n\njulia> is_connected(uniform_matroid(3, 3))\nfalse\n\n\n\n\n\n","category":"method"},{"location":"Combinatorics/matroids/#loops-Tuple{Matroid}","page":"Matroids","title":"loops","text":"loops(M::Matroid)\n\nReturn the loops of M. A loop is an element of the ground set that is not contained in any basis.\n\nExamples\n\njulia> loops(matroid_from_bases([[1,2]], 4))\n2-element Vector{Int64}:\n 3\n 4\n\njulia> loops(fano_matroid())\nInt64[]\n\n\n\n\n\n","category":"method"},{"location":"Combinatorics/matroids/#coloops-Tuple{Matroid}","page":"Matroids","title":"coloops","text":"coloops(M::Matroid)\n\nReturn the coloops of M. A coloop is an element of the ground set that is contained in every basis.\n\nExamples\n\njulia> coloops(matroid_from_bases([[1,2]], 4))\n2-element Vector{Int64}:\n 1\n 2\n\njulia> coloops(fano_matroid())\nInt64[]\n\n\n\n\n\n","category":"method"},{"location":"Combinatorics/matroids/#is_loopless-Tuple{Matroid}","page":"Matroids","title":"is_loopless","text":"is_loopless(M::Matroid)\n\nCheck if M has a loop. Return true if M does not have a loop. See also loops.\n\nExamples\n\njulia> is_loopless(matroid_from_bases([[1,2]], 4))\nfalse\n\njulia> is_loopless(fano_matroid())\ntrue\n\n\n\n\n\n","category":"method"},{"location":"Combinatorics/matroids/#is_coloopless-Tuple{Matroid}","page":"Matroids","title":"is_coloopless","text":"is_coloopless(M::Matroid)\n\nCheck if M has a coloop. Return true if M does not have a coloop. See also coloops.\n\nExamples\n\njulia> is_coloopless(matroid_from_bases([[1,2]], 4))\nfalse\n\njulia> is_coloopless(fano_matroid())\ntrue\n\n\n\n\n\n","category":"method"},{"location":"Combinatorics/matroids/#is_simple-Tuple{Matroid}","page":"Matroids","title":"is_simple","text":"is_simple(M::Matroid)\n\nCheck if M has is simple. A matroid is simple if it doesn't have loops and doesn't have parallel elements. Return true if M is simple. See also loops.\n\nExamples\n\njulia> is_simple(matroid_from_bases([[1,2]], 4))\nfalse\n\njulia> is_simple(fano_matroid())\ntrue\n\n\n\n\n\n","category":"method"},{"location":"Combinatorics/matroids/#direct_sum_components-Tuple{Matroid}","page":"Matroids","title":"direct_sum_components","text":"direct_sum_components(M::Matroid)\n\nReturn the connected components of M as a list of matroids. See Section 4.1 in [Oxl11].\n\nExamples\n\njulia> direct_sum_components(fano_matroid())\n1-element Vector{Matroid}:\n Matroid of rank 3 on 7 elements\n\njulia> direct_sum_components(uniform_matroid(3, 3))\n3-element Vector{Matroid}:\n Matroid of rank 1 on 1 elements\n Matroid of rank 1 on 1 elements\n Matroid of rank 1 on 1 elements\n\n\n\n\n\n","category":"method"},{"location":"Combinatorics/matroids/#connectivity_function-Tuple{Matroid, Union{AbstractSet, AbstractVector}}","page":"Matroids","title":"connectivity_function","text":"connectivity_function(M::Matroid, set::GroundsetType)\n\nReturn the value of the connectivity function of set in the matroid M. See Section 8.1 in [Oxl11].\n\nExamples\n\njulia> connectivity_function(fano_matroid(), [1,2,4])\n3\n\n\n\n\n\n\n","category":"method"},{"location":"Combinatorics/matroids/#is_vertical_k_separation-Tuple{Matroid, Union{Integer, ZZRingElem}, Union{AbstractSet, AbstractVector}}","page":"Matroids","title":"is_vertical_k_separation","text":"is_vertical_k_separation(M::Matroid, k::IntegerUnion, set::GroundsetType)\n\nCheck if set together with its complement defines a k separation in M See Section 8.6 in [Oxl11].\n\nExamples\n\njulia> is_vertical_k_separation(fano_matroid(), 2, [1,2,4])\nfalse\n\n\n\n\n\n\n","category":"method"},{"location":"Combinatorics/matroids/#is_k_separation-Tuple{Matroid, Union{Integer, ZZRingElem}, Union{AbstractSet, AbstractVector}}","page":"Matroids","title":"is_k_separation","text":"is_k_separation(M::Matroid, k::IntegerUnion, set::GroundsetType)\n\nCheck if set together with its complement defines a k separation in M See Section 8.1 in [Oxl11].\n\nExamples\n\njulia> is_k_separation(fano_matroid(), 2, [1,2,4])\nfalse\n\n\n\n\n\n\n","category":"method"},{"location":"Combinatorics/matroids/#vertical_connectivity-Tuple{Matroid}","page":"Matroids","title":"vertical_connectivity","text":"vertical_connectivity(M::Matroid)\n\nIf 'M' has two disjoint cocircuits, its vertical connectivity is defined to be least positive integer k such that M has a vertical k separation. Otherwise its vertical connectivity is defined to be the rank of M. See Section 8.6 in [Oxl11].\n\nExamples\n\njulia> vertical_connectivity(fano_matroid())\n3\n\n\n\n\n\n\n","category":"method"},{"location":"Combinatorics/matroids/#girth","page":"Matroids","title":"girth","text":"girth(M::Matroid, set::GroundsetType)\n\nReturn the girth of set in the matroid M. This is the size of the smallest circuit contained in set and infinite otherwise. See Section 8.6 in [Oxl11].\n\nExamples\n\njulia> girth(fano_matroid(), [1,2,3,4])\n3\n\n\n\n\n\n\n","category":"function"},{"location":"Combinatorics/matroids/#tutte_connectivity-Tuple{Matroid}","page":"Matroids","title":"tutte_connectivity","text":"tutte_connectivity(M::Matroid)\n\nThe Tutte connectivity of M is the least integer k such that M has a k separation. It can be infinite if no k separation exists. See Section 8.6 in [Oxl11].\n\nExamples\n\njulia> tutte_connectivity(fano_matroid())\n3\n\njulia> tutte_connectivity(uniform_matroid(2,4))\ninfinity\n\n\n\n\n\n\n","category":"method"},{"location":"Combinatorics/matroids/#tutte_polynomial-Tuple{Matroid}","page":"Matroids","title":"tutte_polynomial","text":"tutte_polynomial(M::Matroid)\ntutte_polynomial(M::Matroid; parent::ZZMPolyRing)\ntutte_polynomial(parent::ZZMPolyRing, M::Matroid)\n\nReturn the Tutte polynomial of M. This is polynomial in the variables x and y with integral coefficients. See Section 15.3 in [Oxl11].\n\nExamples\n\njulia> tutte_polynomial(fano_matroid())\nx^3 + 4*x^2 + 7*x*y + 3*x + y^4 + 3*y^3 + 6*y^2 + 3*y\n\n\n\n\n\n\n","category":"method"},{"location":"Combinatorics/matroids/#characteristic_polynomial-Tuple{Matroid}","page":"Matroids","title":"characteristic_polynomial","text":"characteristic_polynomial(M::Matroid)\ncharacteristic_polynomial(M::Matroid; parent::ZZPolyRing)\ncharacteristic_polynomial(parent::ZZPolyRing, M::Matroid)\n\nReturn the characteristic polynomial of M. This is polynomial in the variable q with integral coefficients. It is computed as an evaluation of the Tutte polynmomial. See Section 15.2 in [Oxl11].\n\nExamples\n\njulia> characteristic_polynomial(fano_matroid())\nq^3 - 7*q^2 + 14*q - 8\n\n\n\n\n\n\n","category":"method"},{"location":"Combinatorics/matroids/#reduced_characteristic_polynomial-Tuple{Matroid}","page":"Matroids","title":"reduced_characteristic_polynomial","text":"reduced_characteristic_polynomial(M::Matroid)\nreduced_characteristic_polynomial(M::Matroid; parent::ZZPolyRing)\nreduced_characteristic_polynomial(parent::ZZPolyRing, M::Matroid)\n\nReturn the reduced characteristic polynomial of M. This is the quotient of the characteristic polynomial by (q-1). See Section 15.2 in [Oxl11].\n\nExamples\n\njulia> reduced_characteristic_polynomial(fano_matroid())\nq^2 - 6*q + 8\n\n\n\n\n\n\n","category":"method"},{"location":"Combinatorics/matroids/#revlex_basis_encoding-Tuple{Matroid}","page":"Matroids","title":"revlex_basis_encoding","text":"revlex_basis_encoding(M::Matroid)\n\nComputes the revlex basis encoding of the matroid M.\n\nExamples\n\nTo get the revlex basis encoding of the fano matroid and to produce a matrod form the encoding write:\n\njulia> str = revlex_basis_encoding(fano_matroid())\n\"0******0******0***0******0*0**0****\"\n\njulia> matroid_from_revlex_basis_encoding(str, 3, 7)\nMatroid of rank 3 on 7 elements\n\n\n\n\n\n\n","category":"method"},{"location":"Combinatorics/matroids/#is_isomorphic-Tuple{Matroid, Matroid}","page":"Matroids","title":"is_isomorphic","text":"is_isomorphic(M1::Matroid, M2::Matroid)\n\nChecks if the matroid M1 is isomorphic to the matroid M2 under the action of the symmetric group that acts on their groundsets.\n\nExamples\n\nTo compare two matrods write:\n\njulia> H = [[1,2,4],[2,3,5],[1,3,6],[3,4,7],[1,5,7],[2,6,7],[4,5,6]];\n\njulia> M = matroid_from_hyperplanes(H,7);\n\njulia> is_isomorphic(M,fano_matroid())\ntrue\n\n\n\n\n\n\n","category":"method"},{"location":"Combinatorics/matroids/#is_minor-Tuple{Matroid, Matroid}","page":"Matroids","title":"is_minor","text":"is_minor(M::Matroid, N::Matroid)\n\nChecks if the matroid M is isomorphic to a minor of the matroid N.\n\nExamples\n\njulia> is_minor(direct_sum(uniform_matroid(0,1), uniform_matroid(2,2)), fano_matroid())\nfalse\n\njulia> is_minor(direct_sum(uniform_matroid(0,1), uniform_matroid(2,2)), parallel_extension(uniform_matroid(3,4), 1, 5))\ntrue\n\n\n\n\n\n","category":"method"},{"location":"Combinatorics/matroids/#matroid_hex-Tuple{Matroid}","page":"Matroids","title":"matroid_hex","text":"matroid_hex(M::Matroid)\n\nStores a matroid as a string of hex characters. The first part of the string is \"r\" followed by the rank of the matroid. This is followed by \"n\" and the number of elements. The rest of the string is the revlex basis encoding. The encoding is done by converting the basis encoding to a vector of bits and then to a string of characters. The bits are padded to a multiple of 4 and then converted to hex characters.\n\nExamples\n\nTo get the hex encoding of the fano matroid write:\n\njulia> matroid_hex(fano_matroid())\n\"r3n7_3f7eefd6f\"\n\n\n\n\n\n\n","category":"method"},{"location":"Combinatorics/matroids/#automorphism_group-Tuple{Matroid}","page":"Matroids","title":"automorphism_group","text":"automorphism_group(M::Matroid)\n\nGiven a matroid M return its automorphism group as a PermGroup. The group acts on the elements of M.\n\nExamples\n\njulia> M = uniform_matroid(2, 4)\nMatroid of rank 2 on 4 elements\n\njulia> automorphism_group(M)\nPermutation group of degree 4\n\n\n\n\n\n","category":"method"},{"location":"Combinatorics/matroids/#matroid_base_polytope-Tuple{Matroid}","page":"Matroids","title":"matroid_base_polytope","text":"matroid_base_polytope(M::Matroid)\n\nThe base polytope of the matroid M.  \n\nExamples\n\njulia> D = matroid_base_polytope(uniform_matroid(2,4));\n\njulia> vertices(D)\n6-element SubObjectIterator{PointVector{QQFieldElem}}:\n [1, 1, 0, 0]\n [1, 0, 1, 0]\n [1, 0, 0, 1]\n [0, 1, 1, 0]\n [0, 1, 0, 1]\n [0, 0, 1, 1]\n\n\n\n\n\n","category":"method"},{"location":"Combinatorics/matroids/#Chow-Rings","page":"Matroids","title":"Chow Rings","text":"","category":"section"},{"location":"Combinatorics/matroids/","page":"Matroids","title":"Matroids","text":"chow_ring(M::Matroid; ring::Union{MPolyRing,Nothing}=nothing, extended::Bool=false)\naugmented_chow_ring(M::Matroid)","category":"page"},{"location":"Combinatorics/matroids/#chow_ring-Tuple{Matroid}","page":"Matroids","title":"chow_ring","text":"chow_ring(M::Matroid; ring::MPolyRing=nothing, extended::Bool=false)\n\nReturn the Chow ring of a matroid, optionally also with the simplicial generators and the polynomial ring.\n\nSee [AHK18] and [BES23].\n\nExamples\n\nThe following computes the Chow ring of the Fano matroid.\n\njulia> M = fano_matroid();\n\njulia> R = chow_ring(M);\n\njulia> R[1]*R[8]\n-x_{3,4,7}^2\n\nThe following computes the Chow ring of the Fano matroid including variables for the simplicial generators.\n\njulia> M = fano_matroid();\n\njulia> R = chow_ring(M, extended=true);\n\njulia> f = R[22] + R[8] - R[29]\nx_{1,2,3} + h_{1,2,3} - h_{1,2,3,4,5,6,7}\n\njulia> f==0\ntrue\n\nThe following computes the Chow ring of the free matroid on three elements in a given graded polynomial ring.\n\njulia> M = uniform_matroid(3,3);\n\njulia> GR, _ = graded_polynomial_ring(QQ,[:a,:b,:c,:d,:e,:f]);\n\njulia> R = chow_ring(M, ring=GR);\n\njulia> hilbert_series_reduced(R)\n(t^2 + 4*t + 1, 1) \n\n\n\n\n\n\n","category":"method"},{"location":"Combinatorics/matroids/#augmented_chow_ring-Tuple{Matroid}","page":"Matroids","title":"augmented_chow_ring","text":"augmented_chow_ring(M::Matroid)\n\nReturn an augmented Chow ring of a matroid. As described in [BHMPW22].\n\nExamples\n\njulia> M = fano_matroid();\n\njulia> R = augmented_chow_ring(M);\n\n\n\n\n\n","category":"method"},{"location":"Combinatorics/matroids/#Quantum-Automorphisms","page":"Matroids","title":"Quantum Automorphisms","text":"","category":"section"},{"location":"Combinatorics/matroids/","page":"Matroids","title":"Matroids","text":"quantum_symmetric_group(n::Int)\nquantum_automorphism_group(M::Matroid, structure::Symbol)","category":"page"},{"location":"Combinatorics/matroids/#quantum_symmetric_group-Tuple{Int64}","page":"Matroids","title":"quantum_symmetric_group","text":"quantum_symmetric_group(n::Int)\n\nReturn the ideal that defines the quantum symmetric group on n elements. It is comprised of 2*n + n^2 + 2*n*n*(n-1) many generators.\n\nThe relations are:\n\nrow and column sum relations: 2*n relations\nidempotent relations: n^2 relations\nrelations of type u[i,j]*u[i,k] and u[j,i]*u[k,i] for k != j: 2*n*n*(n-1) relations\n\nExamples\n\njulia> S4 = quantum_symmetric_group(4);\n\njulia> length(gens(S4))\n120\n\n\n\n\n\n","category":"method"},{"location":"Combinatorics/matroids/#quantum_automorphism_group-Tuple{Matroid, Symbol}","page":"Matroids","title":"quantum_automorphism_group","text":"quantum_automorphism_group(M::Matroid, structure::Symbol=:bases)\n\nReturn the ideal that defines the quantum automorphism group of a matroid for a given structure.\n\nExamples\n\njulia> G = complete_graph(4)\nUndirected graph with 4 nodes and the following edges:\n(2, 1)(3, 1)(3, 2)(4, 1)(4, 2)(4, 3)\n\njulia> M = cycle_matroid(G);\n\njulia> qAut = quantum_automorphism_group(M,:bases);\n\njulia> length(gens(qAut))\n23448\n\n\n\n\n\n","category":"method"},{"location":"AbstractAlgebra/free_module/","page":"Free Modules and Vector Spaces","title":"Free Modules and Vector Spaces","text":"CurrentModule = AbstractAlgebra\nDocTestSetup = AbstractAlgebra.doctestsetup()","category":"page"},{"location":"AbstractAlgebra/free_module/#Free-Modules-and-Vector-Spaces","page":"Free Modules and Vector Spaces","title":"Free Modules and Vector Spaces","text":"","category":"section"},{"location":"AbstractAlgebra/free_module/","page":"Free Modules and Vector Spaces","title":"Free Modules and Vector Spaces","text":"AbstractAlgebra allows the construction of free modules of any rank over any Euclidean ring and the vector space of any dimension over a field. By default the system considers the free module of a given rank over a given ring or vector space of given dimension over a field to be unique.","category":"page"},{"location":"AbstractAlgebra/free_module/#Generic-free-module-and-vector-space-types","page":"Free Modules and Vector Spaces","title":"Generic free module and vector space types","text":"","category":"section"},{"location":"AbstractAlgebra/free_module/","page":"Free Modules and Vector Spaces","title":"Free Modules and Vector Spaces","text":"AbstractAlgebra provides generic types for free modules and vector spaces, via the type FreeModule{T} for free modules, where T is the type of the elements of the ring R over which the module is built.","category":"page"},{"location":"AbstractAlgebra/free_module/","page":"Free Modules and Vector Spaces","title":"Free Modules and Vector Spaces","text":"Elements of a free module have type FreeModuleElem{T}.","category":"page"},{"location":"AbstractAlgebra/free_module/","page":"Free Modules and Vector Spaces","title":"Free Modules and Vector Spaces","text":"Vector spaces are simply free modules over a field.","category":"page"},{"location":"AbstractAlgebra/free_module/","page":"Free Modules and Vector Spaces","title":"Free Modules and Vector Spaces","text":"The implementation of generic free modules can be found in src/generic/FreeModule.jl.","category":"page"},{"location":"AbstractAlgebra/free_module/","page":"Free Modules and Vector Spaces","title":"Free Modules and Vector Spaces","text":"The free module of a given rank over a given ring is made unique on the system by caching them (unless an optional cache parameter is set to false).","category":"page"},{"location":"AbstractAlgebra/free_module/","page":"Free Modules and Vector Spaces","title":"Free Modules and Vector Spaces","text":"See src/generic/GenericTypes.jl for an example of how to implement such a cache (which usually makes use of a dictionary).","category":"page"},{"location":"AbstractAlgebra/free_module/#Abstract-types","page":"Free Modules and Vector Spaces","title":"Abstract types","text":"","category":"section"},{"location":"AbstractAlgebra/free_module/","page":"Free Modules and Vector Spaces","title":"Free Modules and Vector Spaces","text":"The type FreeModule{T} belongs to FPModule{T} and FreeModuleElem{T} to FPModuleElem{T}. Here the FP prefix stands for finitely presented.","category":"page"},{"location":"AbstractAlgebra/free_module/#Functionality-for-free-modules","page":"Free Modules and Vector Spaces","title":"Functionality for free modules","text":"","category":"section"},{"location":"AbstractAlgebra/free_module/","page":"Free Modules and Vector Spaces","title":"Free Modules and Vector Spaces","text":"As well as implementing the entire module interface, free modules provide the following functionality.","category":"page"},{"location":"AbstractAlgebra/free_module/#Constructors","page":"Free Modules and Vector Spaces","title":"Constructors","text":"","category":"section"},{"location":"AbstractAlgebra/free_module/","page":"Free Modules and Vector Spaces","title":"Free Modules and Vector Spaces","text":"free_module(R::Ring, rank::Int)\nvector_space(F::Field, dim::Int)","category":"page"},{"location":"AbstractAlgebra/free_module/#free_module-Tuple{Ring, Int64}","page":"Free Modules and Vector Spaces","title":"free_module","text":"free_module(R::NCRing, rank::Int; cached::Bool = true)\n\nReturn the free module over the ring R with the given rank.\n\n\n\n\n\n","category":"method"},{"location":"AbstractAlgebra/free_module/#vector_space-Tuple{Field, Int64}","page":"Free Modules and Vector Spaces","title":"vector_space","text":"vector_space(R::Field, dim::Int; cached::Bool = true)\n\nReturn the vector space over the field R with the given dimension.\n\n\n\n\n\n","category":"method"},{"location":"AbstractAlgebra/free_module/","page":"Free Modules and Vector Spaces","title":"Free Modules and Vector Spaces","text":"Construct the free module/vector space of given rank/dimension.","category":"page"},{"location":"AbstractAlgebra/free_module/","page":"Free Modules and Vector Spaces","title":"Free Modules and Vector Spaces","text":"Examples","category":"page"},{"location":"AbstractAlgebra/free_module/","page":"Free Modules and Vector Spaces","title":"Free Modules and Vector Spaces","text":"julia> M = free_module(ZZ, 3)\nFree module of rank 3 over integers\n\njulia> V = vector_space(QQ, 2)\nVector space of dimension 2 over rationals\n","category":"page"},{"location":"AbstractAlgebra/free_module/#Basic-manipulation","page":"Free Modules and Vector Spaces","title":"Basic manipulation","text":"","category":"section"},{"location":"AbstractAlgebra/free_module/","page":"Free Modules and Vector Spaces","title":"Free Modules and Vector Spaces","text":"rank(M::Generic.FreeModule{T}) where T <: RingElem\ndim(V::Generic.FreeModule{T}) where T <: FieldElem\nbasis(V::Generic.FreeModule{T}) where T <: FieldElem","category":"page"},{"location":"AbstractAlgebra/free_module/","page":"Free Modules and Vector Spaces","title":"Free Modules and Vector Spaces","text":"Examples","category":"page"},{"location":"AbstractAlgebra/free_module/","page":"Free Modules and Vector Spaces","title":"Free Modules and Vector Spaces","text":"julia> M = free_module(ZZ, 3)\nFree module of rank 3 over integers\n\njulia> V = vector_space(QQ, 2)\nVector space of dimension 2 over rationals\n\njulia> rank(M)\n3\n\njulia> dim(V)\n2\n\njulia> basis(V)\n2-element Vector{AbstractAlgebra.Generic.FreeModuleElem{Rational{BigInt}}}:\n (1//1, 0//1)\n (0//1, 1//1)","category":"page"},{"location":"CommutativeAlgebra/GroebnerBases/groebner_bases/","page":"Gröbner/Standard Bases Over Fields","title":"Gröbner/Standard Bases Over Fields","text":"CurrentModule = Oscar\nDocTestSetup = Oscar.doctestsetup()","category":"page"},{"location":"CommutativeAlgebra/GroebnerBases/groebner_bases/#gb_fields","page":"Gröbner/Standard Bases Over Fields","title":"Gröbner/Standard Bases Over Fields","text":"","category":"section"},{"location":"CommutativeAlgebra/GroebnerBases/groebner_bases/","page":"Gröbner/Standard Bases Over Fields","title":"Gröbner/Standard Bases Over Fields","text":"We fix our notation in the context of standard (Gröbner) bases and present relevant OSCAR functions.","category":"page"},{"location":"CommutativeAlgebra/GroebnerBases/groebner_bases/","page":"Gröbner/Standard Bases Over Fields","title":"Gröbner/Standard Bases Over Fields","text":"Let Kx = Kx_1 dots x_n be a polynomial ring over a field K, and let  be a monomial ordering on textMon_n(x).","category":"page"},{"location":"CommutativeAlgebra/GroebnerBases/groebner_bases/","page":"Gröbner/Standard Bases Over Fields","title":"Gröbner/Standard Bases Over Fields","text":"Given a polynomial fin Kxsetminus 0, write f as the sum of its nonzero terms as follows:","category":"page"},{"location":"CommutativeAlgebra/GroebnerBases/groebner_bases/","page":"Gröbner/Standard Bases Over Fields","title":"Gröbner/Standard Bases Over Fields","text":"f = a_alpha x^alpha + a_beta_1 x^beta_1 + dots + a_beta_s x^beta_squad x^alpha  x^beta_1  dots  x^beta_s ","category":"page"},{"location":"CommutativeAlgebra/GroebnerBases/groebner_bases/","page":"Gröbner/Standard Bases Over Fields","title":"Gröbner/Standard Bases Over Fields","text":"Then, with respect to , we refer to textLT_(f) = a_alpha x^alpha, textLM_(f) = x^alpha, textLE_(f) = alpha, textLC_(f) = a_alpha, and texttail_(f) = f - textLT_(f) as the  leading term, the leading monomial, the leading exponent, the leading coefficient, and the tail of f, respectively.","category":"page"},{"location":"CommutativeAlgebra/GroebnerBases/groebner_bases/","page":"Gröbner/Standard Bases Over Fields","title":"Gröbner/Standard Bases Over Fields","text":"Next note that the set","category":"page"},{"location":"CommutativeAlgebra/GroebnerBases/groebner_bases/","page":"Gröbner/Standard Bases Over Fields","title":"Gröbner/Standard Bases Over Fields","text":"U_= uin Kxsetminus 0 mid textLM_(u)=1 ","category":"page"},{"location":"CommutativeAlgebra/GroebnerBases/groebner_bases/","page":"Gröbner/Standard Bases Over Fields","title":"Gröbner/Standard Bases Over Fields","text":"is a multiplicatively closed subset of Kx. Consider the localization","category":"page"},{"location":"CommutativeAlgebra/GroebnerBases/groebner_bases/","page":"Gröbner/Standard Bases Over Fields","title":"Gröbner/Standard Bases Over Fields","text":"Kx_= KxU^-1 = left fracfu bigg f in Kx  uin U_right","category":"page"},{"location":"CommutativeAlgebra/GroebnerBases/groebner_bases/","page":"Gröbner/Standard Bases Over Fields","title":"Gröbner/Standard Bases Over Fields","text":"Then Kxsubseteq Kx_subseteq Kx_langle x rangle where Kx_langle x rangle is the localization of Kx  at the maximal ideal langle x rangle  Moreover,","category":"page"},{"location":"CommutativeAlgebra/GroebnerBases/groebner_bases/","page":"Gröbner/Standard Bases Over Fields","title":"Gröbner/Standard Bases Over Fields","text":"Kx = Kx_ iff  is global, and\nKx_ = Kx_langle x rangle iff  is local.","category":"page"},{"location":"CommutativeAlgebra/GroebnerBases/groebner_bases/","page":"Gröbner/Standard Bases Over Fields","title":"Gröbner/Standard Bases Over Fields","text":"Extending the notation introduced for polynomials, let now fin Kx_setminus 0. Choose uin U_ such that ufin Kx. Then, with respect to , the  leading term  of f is defined to be textLT_(f) = textLT_(uf) (this definition is independent of the choice of u). The leading monomial textLM_(f), the leading exponent textLE_(f), the leading coefficient textLC_(f), and the tail texttail_(f) of f are defined similarly.","category":"page"},{"location":"CommutativeAlgebra/GroebnerBases/groebner_bases/","page":"Gröbner/Standard Bases Over Fields","title":"Gröbner/Standard Bases Over Fields","text":"note: Note\nGiven a monomial ordering  on a free Kx-module F = Kx^p with basis e_1 dots e_p, the above notation extends naturally to elements of  Kx^p and Kx_^p, respectively. There is one particularity: Given an element f = Kx^psetminus 0 with leading term textLT(f) = x^alpha e_i, we write textLE_(f) = (alpha i).","category":"page"},{"location":"CommutativeAlgebra/GroebnerBases/groebner_bases/#Default-Orderings","page":"Gröbner/Standard Bases Over Fields","title":"Default Orderings","text":"","category":"section"},{"location":"CommutativeAlgebra/GroebnerBases/groebner_bases/","page":"Gröbner/Standard Bases Over Fields","title":"Gröbner/Standard Bases Over Fields","text":"note: Note\nThe OSCAR functions discussed in this section depend on a monomial ordering which is entered as a keyword argument. Given a polynomial ring R, the default_ordering for this is degrevlex except if R is mathbb Z-graded with positive weights. Then the corresponding wdegrevlex ordering is used. Given a free R-module F, the default_ordering is default_ordering(R)*lex(gens(F)).","category":"page"},{"location":"CommutativeAlgebra/GroebnerBases/groebner_bases/","page":"Gröbner/Standard Bases Over Fields","title":"Gröbner/Standard Bases Over Fields","text":"default_ordering(::MPolyRing)","category":"page"},{"location":"CommutativeAlgebra/GroebnerBases/groebner_bases/#default_ordering-Tuple{MPolyRing}","page":"Gröbner/Standard Bases Over Fields","title":"default_ordering","text":"default_ordering(R::MPolyRing)\n\nReturn the monomial ordering that is used for computations with ideals in R if no other ordering is specified – either directly by the user or by requirements of a specific algorithm.\n\n\n\n\n\n","category":"method"},{"location":"CommutativeAlgebra/GroebnerBases/groebner_bases/","page":"Gröbner/Standard Bases Over Fields","title":"Gröbner/Standard Bases Over Fields","text":"Here are some illustrating OSCAR examples:","category":"page"},{"location":"CommutativeAlgebra/GroebnerBases/groebner_bases/#Examples","page":"Gröbner/Standard Bases Over Fields","title":"Examples","text":"","category":"section"},{"location":"CommutativeAlgebra/GroebnerBases/groebner_bases/","page":"Gröbner/Standard Bases Over Fields","title":"Gröbner/Standard Bases Over Fields","text":"julia> R, (x, y, z) = polynomial_ring(QQ, [:x, :y, :z])\n(Multivariate polynomial ring in 3 variables over QQ, QQMPolyRingElem[x, y, z])\n\njulia> default_ordering(R)\ndegrevlex([x, y, z])\n\njulia> F = free_module(R, 2)\nFree module of rank 2 over R\n\njulia> default_ordering(F)\ndegrevlex([x, y, z])*lex([gen(1), gen(2)])\n\njulia> S, _ = grade(R, [1, 2, 3])\n(Graded multivariate polynomial ring in 3 variables over QQ, MPolyDecRingElem{QQFieldElem, QQMPolyRingElem}[x, y, z])\n\njulia> default_ordering(S)\nwdegrevlex([x, y, z], [1, 2, 3])","category":"page"},{"location":"CommutativeAlgebra/GroebnerBases/groebner_bases/","page":"Gröbner/Standard Bases Over Fields","title":"Gröbner/Standard Bases Over Fields","text":"Expert users may temporarily choose a different default ordering for a given ring.","category":"page"},{"location":"CommutativeAlgebra/GroebnerBases/groebner_bases/","page":"Gröbner/Standard Bases Over Fields","title":"Gröbner/Standard Bases Over Fields","text":"with_ordering","category":"page"},{"location":"CommutativeAlgebra/GroebnerBases/groebner_bases/#with_ordering","page":"Gröbner/Standard Bases Over Fields","title":"with_ordering","text":"with_ordering(f, R::MPolyRing, o::MonomialOrdering)\n\nUse the monomial ordering o for computations in R during the execution of f. This may be used with do block syntax, see the example.\n\nThis functionality is meant for advanced users. In general it should not be necessary to explicitly set a monomial ordering. Further, there is no guarantee that o is actually used. For example, if an algorithm requires an elimination ordering, o might be ignored.\n\nExample\n\njulia> R, (x, y, z) = QQ[:x, :y, :z];\n\njulia> f = x + y^2;\n\njulia> I = ideal(R, [y^2 - z, x - z^2]);\n\njulia> normal_form(f, I) # this uses degrevlex\nx + z\n\njulia> with_ordering(R, lex(R)) do\n           # this uses lex\n           normal_form(f, I)\n       end\nz^2 + z\n\nNotice that in this small example we could have achieved the same by using the keyword argument ordering:\n\njulia> normal_form(f, I, ordering = lex(R))\nz^2 + z\n\n\n\n\n\n","category":"function"},{"location":"CommutativeAlgebra/GroebnerBases/groebner_bases/#monomials_terms_more","page":"Gröbner/Standard Bases Over Fields","title":"Monomials, Terms, and More","text":"","category":"section"},{"location":"CommutativeAlgebra/GroebnerBases/groebner_bases/","page":"Gröbner/Standard Bases Over Fields","title":"Gröbner/Standard Bases Over Fields","text":"Here are examples which indicate how to recover monomials, terms, and more from a given polynomial.","category":"page"},{"location":"CommutativeAlgebra/GroebnerBases/groebner_bases/","page":"Gröbner/Standard Bases Over Fields","title":"Gröbner/Standard Bases Over Fields","text":"julia> R, (x, y, z) = polynomial_ring(QQ, [:x, :y, :z])\n(Multivariate polynomial ring in 3 variables over QQ, QQMPolyRingElem[x, y, z])\n\njulia> f = 3*z^3+2*x*y+1\n2*x*y + 3*z^3 + 1\n\njulia> terms(f)\nterms iterator of 3*z^3 + 2*x*y + 1\n\njulia> collect(ans)\n3-element Vector{QQMPolyRingElem}:\n 3*z^3\n 2*x*y\n 1\n\njulia> monomials(f, ordering = lex(R))\nmonomials iterator of 2*x*y + 3*z^3 + 1\n\njulia> coefficients(f)\ncoefficients iterator of 3*z^3 + 2*x*y + 1\n\njulia> exponents(f, ordering = neglex(R))\nexponents iterator of 1 + 3*z^3 + 2*x*y\n\njulia> coefficients_and_exponents(f)\ncoefficients and exponents iterator of 3*z^3 + 2*x*y + 1\n\njulia> collect(ans)\n3-element Vector{Tuple{QQFieldElem, Vector{Int64}}}:\n (3, [0, 0, 3])\n (2, [1, 1, 0])\n (1, [0, 0, 0])\n\njulia> leading_term(f)\n3*z^3\n\njulia> leading_monomial(f, ordering = lex(R))\nx*y\n\njulia> leading_exponent(f, ordering = neglex(R))\n3-element Vector{Int64}:\n 0\n 0\n 0\n\njulia> leading_coefficient(f)\n3\n\njulia> tail(f)\n2*x*y + 1","category":"page"},{"location":"CommutativeAlgebra/GroebnerBases/groebner_bases/","page":"Gröbner/Standard Bases Over Fields","title":"Gröbner/Standard Bases Over Fields","text":"julia> R, (x, y) = polynomial_ring(QQ, [:x, :y])\n(Multivariate polynomial ring in 2 variables over QQ, QQMPolyRingElem[x, y])\n\njulia> F = free_module(R, 3)\nFree module of rank 3 over R\n\njulia> f = (5*x*y^2-y^10+3)*F[1]+(4*x^3+2*y) *F[2]+16*x*F[3]\n(5*x*y^2 - y^10 + 3)*e[1] + (4*x^3 + 2*y)*e[2] + 16*x*e[3]\n\njulia> default_ordering(F)\ndegrevlex([x, y])*lex([gen(1), gen(2), gen(3)])\n\njulia> collect(terms(f))\n6-element Vector{FreeModElem{QQMPolyRingElem}}:\n -y^10*e[1]\n 4*x^3*e[2]\n 5*x*y^2*e[1]\n 16*x*e[3]\n 2*y*e[2]\n 3*e[1]\n\njulia> collect(terms(f, ordering = invlex(F)*lex(R)))\n6-element Vector{FreeModElem{QQMPolyRingElem}}:\n 5*x*y^2*e[1]\n -y^10*e[1]\n 3*e[1]\n 4*x^3*e[2]\n 2*y*e[2]\n 16*x*e[3]\n\njulia> tail(f)\n(5*x*y^2 + 3)*e[1] + (4*x^3 + 2*y)*e[2] + 16*x*e[3]\n\njulia> leading_exponent(f)\n([0, 10], 1)\n\njulia> leading_exponent(f, ordering = invlex(F)*lex(R))\n([1, 2], 1)","category":"page"},{"location":"CommutativeAlgebra/GroebnerBases/groebner_bases/#Division-With-Remainder","page":"Gröbner/Standard Bases Over Fields","title":"Division With Remainder","text":"","category":"section"},{"location":"CommutativeAlgebra/GroebnerBases/groebner_bases/","page":"Gröbner/Standard Bases Over Fields","title":"Gröbner/Standard Bases Over Fields","text":"The computation of Gröbner (standard) bases relies on multivariate division with remainder which is interesting in its own right. If a monomial ordering  is given, the basic idea is to mimic Euclidean division with remainder, allowing more than one divisor: At each step of the resulting process, this amounts to removing the leading term of the intermediate dividend, using the leading term of some divisor by which it is divisible. In its basic form, the process works well if  is global, but may not terminate for local and mixed orderings. In the latter case, Mora's division algorithm, which relies on a more restricted selection strategy for the divisors to be used, comes to our rescue.","category":"page"},{"location":"CommutativeAlgebra/GroebnerBases/groebner_bases/","page":"Gröbner/Standard Bases Over Fields","title":"Gröbner/Standard Bases Over Fields","text":"We discuss this in more detail:","category":"page"},{"location":"CommutativeAlgebra/GroebnerBases/groebner_bases/","page":"Gröbner/Standard Bases Over Fields","title":"Gröbner/Standard Bases Over Fields","text":"First suppose that  is global and let polynomials gin Kx and f_1 dots f_rin Kxsetminus 0 be given. In this situation, multivariate division with remainder allows us to compute expressions","category":"page"},{"location":"CommutativeAlgebra/GroebnerBases/groebner_bases/","page":"Gröbner/Standard Bases Over Fields","title":"Gröbner/Standard Bases Over Fields","text":"g = q_1f_1+dots q_rf_r + h  hin Kx text all  q_i in Kx","category":"page"},{"location":"CommutativeAlgebra/GroebnerBases/groebner_bases/","page":"Gröbner/Standard Bases Over Fields","title":"Gröbner/Standard Bases Over Fields","text":"such that:","category":"page"},{"location":"CommutativeAlgebra/GroebnerBases/groebner_bases/","page":"Gröbner/Standard Bases Over Fields","title":"Gröbner/Standard Bases Over Fields","text":"textLM_(g) ge textLM_(q_if_i) whenever both sides are nonzero.\nIf h is nonzero, then textLM_(h) is not divisible by any textLM_(f_i).","category":"page"},{"location":"CommutativeAlgebra/GroebnerBases/groebner_bases/","page":"Gröbner/Standard Bases Over Fields","title":"Gröbner/Standard Bases Over Fields","text":"Each such expression is called a standard representation for g with quotients q_i and remainder h (on division by the f_i, with respect to ). If, at each step of the division process, we allow to remove some term of the current dividend instead of just focusing on its leading term, then the algorithm will return a standard expression in which the remainder is fully reduced. That is, h satisfies the stronger condition below:","category":"page"},{"location":"CommutativeAlgebra/GroebnerBases/groebner_bases/","page":"Gröbner/Standard Bases Over Fields","title":"Gröbner/Standard Bases Over Fields","text":"If h is nonzero, then no term of h is divisible by any textLM_(f_i).","category":"page"},{"location":"CommutativeAlgebra/GroebnerBases/groebner_bases/","page":"Gröbner/Standard Bases Over Fields","title":"Gröbner/Standard Bases Over Fields","text":"Without restrictions on  , let elements gin Kx_ and f_1 dots f_rin Kxsetminus 0 be given. In this situation, Mora division with remainder allows us to compute expressions","category":"page"},{"location":"CommutativeAlgebra/GroebnerBases/groebner_bases/","page":"Gröbner/Standard Bases Over Fields","title":"Gröbner/Standard Bases Over Fields","text":"ug = q_1f_1+dots q_rf_r + h  hin Kx_ text all  q_i in Kx_","category":"page"},{"location":"CommutativeAlgebra/GroebnerBases/groebner_bases/","page":"Gröbner/Standard Bases Over Fields","title":"Gröbner/Standard Bases Over Fields","text":"such that:","category":"page"},{"location":"CommutativeAlgebra/GroebnerBases/groebner_bases/","page":"Gröbner/Standard Bases Over Fields","title":"Gröbner/Standard Bases Over Fields","text":"u is a unit of Kx_, that is, textLM_(u)=1.\ntextLM_(g) ge textLM_(q_if_i) whenever both sides are nonzero.\nIf h is nonzero, then textLM_(h) is not divisible by any textLM_(f_i).","category":"page"},{"location":"CommutativeAlgebra/GroebnerBases/groebner_bases/","page":"Gröbner/Standard Bases Over Fields","title":"Gröbner/Standard Bases Over Fields","text":"Each such expression is called a weak standard representation for g with quotients q_i and remainder h (on division by the f_i, with respect to ). If gin Kx, we speak of a polynomial weak standard representation if u and the q_i are elements of Kx Using power series expansions, it makes still sense to speak of fully reduced remainders. However, even if we start from polynomial data, such remainders may not be computable (in finitely many steps).","category":"page"},{"location":"CommutativeAlgebra/GroebnerBases/groebner_bases/","page":"Gröbner/Standard Bases Over Fields","title":"Gröbner/Standard Bases Over Fields","text":"note: Note\nGiven a monomial ordering  on a free Kx-module F = Kx^p with basis e_1 dots e_p, the above notation and the division algorithms extend naturally to Kx^p and Kx_^p, respectively.","category":"page"},{"location":"CommutativeAlgebra/GroebnerBases/groebner_bases/","page":"Gröbner/Standard Bases Over Fields","title":"Gröbner/Standard Bases Over Fields","text":"The OSCAR functions discussed below compute standard representations and polynomial weak standard representations, respectively.","category":"page"},{"location":"CommutativeAlgebra/GroebnerBases/groebner_bases/","page":"Gröbner/Standard Bases Over Fields","title":"Gröbner/Standard Bases Over Fields","text":"reduce(g::T, F::Vector{T}; \n    ordering::MonomialOrdering = default_ordering(parent(F[1]))) where T <: MPolyRingElem","category":"page"},{"location":"CommutativeAlgebra/GroebnerBases/groebner_bases/#reduce-Union{Tuple{T}, Tuple{T, Vector{T}}} where T<:MPolyRingElem","page":"Gröbner/Standard Bases Over Fields","title":"reduce","text":"reduce(g::T, F::Union{Vector{T}, IdealGens{T}};\n       ordering::MonomialOrdering = default_ordering(g)), complete_reduction::Bool = false) where T <: MPolyRingElem\n\nIf ordering is global, return the remainder in a standard representation for g on division by the polynomials in F with respect to ordering. Otherwise, return the remainder in a weak standard representation for g on division by the polynomials in F with respect to ordering.\n\nreduce(G::Vector{T}, F::Union{Vector{T}, IdealGens{T}};\n       ordering::MonomialOrdering = default_ordering(parent(G[1])), complete_reduction::Bool = false) where T <: MPolyRingElem\n\nReturn a Vector which contains, for each element g of G, a remainder as above.\n\nnote: Note\nThe returned remainders are fully reduced if complete_reduction is set to true and ordering is global.\n\nnote: Note\nThe reduction strategy behind the reduce function and the reduction strategy behind the functions  reduce_with_quotients and reduce_with_quotients_and_unit differ. As a consequence, the computed remainders may differ.\n\nExamples\n\njulia> R, (z, y, x) = polynomial_ring(QQ, [:z, :y, :x]);\n\njulia> f1 = y-x^2; f2 = z-x^3;\n\njulia> g = x^3*y-3*y^2*z^2+x*y*z;\n\njulia> reduce(g, [f1, f2], ordering = lex(R))\n-3*x^10 + x^6 + x^5\n\njulia> R, (x, y, z) = polynomial_ring(QQ, [:x, :y, :z]);\n\njulia> f1 = x^2+x^2*y; f2 = y^3+x*y*z; f3 = x^3*y^2+z^4;\n\njulia> g = x^3*y+x^5+x^2*y^2*z^2+z^6;\n\njulia> reduce(g, [f1, f2, f3], ordering = lex(R))\nx^5 + x^3*y + x^2*y^2*z^2 + z^6\n\njulia> reduce(g, [f1,f2, f3], ordering = lex(R), complete_reduction = true)\nx^5 - x^3 + y^6 + z^6\n\n\n\n\n\n","category":"method"},{"location":"CommutativeAlgebra/GroebnerBases/groebner_bases/","page":"Gröbner/Standard Bases Over Fields","title":"Gröbner/Standard Bases Over Fields","text":"reduce_with_quotients(g::T, F::Vector{T}; \n    ordering::MonomialOrdering = default_ordering(parent(F[1]))) where T <: MPolyRingElem","category":"page"},{"location":"CommutativeAlgebra/GroebnerBases/groebner_bases/#reduce_with_quotients-Union{Tuple{T}, Tuple{T, Vector{T}}} where T<:MPolyRingElem","page":"Gröbner/Standard Bases Over Fields","title":"reduce_with_quotients","text":"reduce_with_quotients(g::T, F::Union{Vector{T}, IdealGens{T}};\n       ordering::MonomialOrdering = default_ordering(parent(g)), complete_reduction::Bool = false) where T <: MPolyRingElem\n\nIf ordering is global, return the quotients and the remainder in a standard representation for g on division by the polynomials in F with respect to ordering. Otherwise, return the quotients and the remainder in a weak standard representation for g on division by the polynomials in F with respect to ordering.\n\nreduce_with_quotients(G::Vector{T}, F::Union{Vector{T}, IdealGens{T}};\n       ordering::MonomialOrdering = default_ordering(parent(G[1])), complete_reduction::Bool = false) where T <: MPolyRingElem\n\nReturn a Vector which contains, for each element g of G, quotients and a remainder as above.\n\nnote: Note\nThe returned remainders are fully reduced if complete_reduction is set to true and ordering is global.\n\nExamples\n\njulia> R, (x, y, z) = polynomial_ring(QQ, [:x, :y, :z]);\n\njulia> f1 = x^2+x^2*y; f2 = y^3+x*y*z; f3 = x^3*y^2+z^4;\n\njulia> g = x^3*y+x^5+x^2*y^2*z^2+z^6;\n\njulia> Q, h = reduce_with_quotients(g, [f1,f2, f3], ordering = lex(R));\n\njulia> h\nx^5 - x^3 + y^6 + z^6\n\njulia> g == Q[1]*f1+Q[2]*f2+Q[3]*f3+h\ntrue\n\n\n\n\n\n","category":"method"},{"location":"CommutativeAlgebra/GroebnerBases/groebner_bases/","page":"Gröbner/Standard Bases Over Fields","title":"Gröbner/Standard Bases Over Fields","text":"reduce_with_quotients_and_unit(g::T, F::Vector{T}; \n    ordering::MonomialOrdering = default_ordering(parent(F[1]))) where T <: MPolyRingElem","category":"page"},{"location":"CommutativeAlgebra/GroebnerBases/groebner_bases/#reduce_with_quotients_and_unit-Union{Tuple{T}, Tuple{T, Vector{T}}} where T<:MPolyRingElem","page":"Gröbner/Standard Bases Over Fields","title":"reduce_with_quotients_and_unit","text":"reduce_with_quotients_and_unit(g::T, F::Union{Vector{T}, IdealGens{T}};\n       ordering::MonomialOrdering = default_ordering(parent(g)), complete_reduction::Bool = false) where T <: MPolyRingElem\n\nReturn the unit, the quotients and the remainder in a weak standard representation for g on division by the polynomials in F with respect to ordering.\n\nreduce_with_quotients_and_unit(G::Vector{T}, F::Union{Vector{T}, IdealGens{T}};\n       ordering::MonomialOrdering = default_ordering(parent(G[1])), complete_reduction::Bool = false) where T <: MPolyRingElem\n\nReturn a Vector which contains, for each element g of G, a unit, quotients, and a remainder as above.\n\nnote: Note\nThe returned remainders are fully reduced if complete_reduction is set to true and ordering is global.\n\nnote: Note\nThe reduction strategy behind the reduce function and the reduction strategy behind the functions  reduce_with_quotients and reduce_with_quotients_and_unit differ. As a consequence, the computed remainders may differ.\n\nExamples\n\njulia> R, (x, y, z) = polynomial_ring(QQ, [:x, :y, :z]);\n\njulia> f1 = x^2+x^2*y; f2 = y^3+x*y*z; f3 = x^3*y^2+z^4;\n\njulia> g = x^3*y+x^5+x^2*y^2*z^2+z^6;\n\njulia> u, Q, h =reduce_with_quotients_and_unit(g, [f1,f2, f3], ordering = lex(R));\n\njulia> u\n[1]\n\njulia> G = [g, x*y^3-3*x^2*y^2*z^2];\n\njulia> U, Q, H = reduce_with_quotients_and_unit(G, [f1, f2, f3], ordering = negdegrevlex(R));\n\njulia> U\n[y + 1       0]\n[    0   y + 1]\n\njulia> Q\n[  x^3 - x*y^2*z^2 + x*y + y^2*z^2                            0   y*z^2 + z^2]\n[x*y*z^2 + y^3*z - 3*y^2*z^2 - y*z   -x^2*y*z - x^2*z + x*y + x             0]\n\njulia> H\n2-element Vector{QQMPolyRingElem}:\n 0\n 0\n\njulia> U*G == Q*[f1, f2, f3]+H\ntrue\n\n\n\n\n\n","category":"method"},{"location":"CommutativeAlgebra/GroebnerBases/groebner_bases/#Computing-Gröbner/Standard-Bases","page":"Gröbner/Standard Bases Over Fields","title":"Computing Gröbner/Standard Bases","text":"","category":"section"},{"location":"CommutativeAlgebra/GroebnerBases/groebner_bases/","page":"Gröbner/Standard Bases Over Fields","title":"Gröbner/Standard Bases Over Fields","text":"Still keeping the notation introduced at the beginning of this section, let G be a subset of Kx_. Then the leading ideal of G is the ideal of Kx defined by","category":"page"},{"location":"CommutativeAlgebra/GroebnerBases/groebner_bases/","page":"Gröbner/Standard Bases Over Fields","title":"Gröbner/Standard Bases Over Fields","text":"textL_(G)=langle textLT_(g) mid gin Gsetminus0ranglesubset Kx","category":"page"},{"location":"CommutativeAlgebra/GroebnerBases/groebner_bases/","page":"Gröbner/Standard Bases Over Fields","title":"Gröbner/Standard Bases Over Fields","text":"A finite subset G of an ideal Isubset Kx_ is called a standard basis of I (with respect to ) if textL_(G) = textL_(I).  A finite subset of Kx_ is a standard basis if it is a standard basis of the ideal it generates. A standard basis with respect to a global monomial ordering is also called a Gröbner basis.","category":"page"},{"location":"CommutativeAlgebra/GroebnerBases/groebner_bases/","page":"Gröbner/Standard Bases Over Fields","title":"Gröbner/Standard Bases Over Fields","text":"note: Note\nEvery standard basis of I generates I.","category":"page"},{"location":"CommutativeAlgebra/GroebnerBases/groebner_bases/","page":"Gröbner/Standard Bases Over Fields","title":"Gröbner/Standard Bases Over Fields","text":"note: Note\nGröbner bases (standard bases) can be computed using Buchberger's algorithm (Buchberger's algorithm as enhanced by Mora).","category":"page"},{"location":"CommutativeAlgebra/GroebnerBases/groebner_bases/","page":"Gröbner/Standard Bases Over Fields","title":"Gröbner/Standard Bases Over Fields","text":"We call a standard basis G = g_1dots g_rsubset Kx_setminus 0 minimal  if textLM_(g_i)neq textLM_(g_j) for ineq j.","category":"page"},{"location":"CommutativeAlgebra/GroebnerBases/groebner_bases/","page":"Gröbner/Standard Bases Over Fields","title":"Gröbner/Standard Bases Over Fields","text":"note: Note\nThe definition of minimal above deviates from the definition in most textbooks as we do not ask that the leading coefficients of the standard basis elements are 1.","category":"page"},{"location":"CommutativeAlgebra/GroebnerBases/groebner_bases/","page":"Gröbner/Standard Bases Over Fields","title":"Gröbner/Standard Bases Over Fields","text":"note: Note\nThe standard bases returned by OSCAR are always minimal in the sense above.","category":"page"},{"location":"CommutativeAlgebra/GroebnerBases/groebner_bases/","page":"Gröbner/Standard Bases Over Fields","title":"Gröbner/Standard Bases Over Fields","text":"We call a standard basis G = g_1dots g_r with respect to a global monomial ordering reduced if it is minimal and no term of g_i is divisible by textLM_(g_j), for ineq j. Using power series expansions, we may extend this notion to local and mixed orderings. However, while reduced standard bases can be computed in the global case, they may not be computable (in finitely many steps) in the other cases.","category":"page"},{"location":"CommutativeAlgebra/GroebnerBases/groebner_bases/","page":"Gröbner/Standard Bases Over Fields","title":"Gröbner/Standard Bases Over Fields","text":"note: Note\nGiven a monomial ordering  on a free Kx-module F = Kx^p with basis e_1 dots e_p, the above notation and results extend naturally to submodules of Kx_^p.","category":"page"},{"location":"CommutativeAlgebra/GroebnerBases/groebner_bases/","page":"Gröbner/Standard Bases Over Fields","title":"Gröbner/Standard Bases Over Fields","text":"Here are the relevant OSCAR functions for computing Gröbner and standard bases. The elements of a computed basis can be retrieved by using the elements function or its alias gens.","category":"page"},{"location":"CommutativeAlgebra/GroebnerBases/groebner_bases/","page":"Gröbner/Standard Bases Over Fields","title":"Gröbner/Standard Bases Over Fields","text":"groebner_basis(I::MPolyIdeal;\n    ord::MonomialOrdering = default_ordering(base_ring(I)),\n    complete_reduction::Bool = false, algorithm::Symbol = :buchberger)","category":"page"},{"location":"CommutativeAlgebra/GroebnerBases/groebner_bases/#groebner_basis-Tuple{MPolyIdeal}","page":"Gröbner/Standard Bases Over Fields","title":"groebner_basis","text":"groebner_basis(I::MPolyIdeal;\n  ordering::MonomialOrdering = default_ordering(base_ring(I)),\n  complete_reduction::Bool = false, algorithm::Symbol = :buchberger)\n\nIf ordering is global, return a Gröbner basis of I with respect to ordering.\n\nThe keyword algorithm can be set to\n\n:buchberger (implementation of Buchberger's algorithm in Singular),\n:modular (implementation of multi-modular approach, if applicable),\n:hilbert (implementation of a Hilbert driven Gröbner basis computation in Singular),\n:fglm (implementation of the FGLM algorithm in Singular), and\n:f4 (implementation of Faugère's F4 algorithm in the msolve package).\n\nnote: Note\nSee the description of the functions groebner_basis_hilbert_driven, fglm,  and f4 in the OSCAR documentation for some more details and for restrictions     on the input data when using these versions of the standard basis algorithm.\n\nnote: Note\nThe returned Gröbner basis is reduced if complete_reduction = true.\n\nExamples\n\njulia> R, (x, y, z) = polynomial_ring(QQ, [:x, :y, :z]);\n\njulia> I = ideal(R, [y-x^2, z-x^3]);\n\njulia> G = groebner_basis(I)\nGröbner basis with elements\n  1: y^2 - x*z\n  2: x*y - z\n  3: x^2 - y\nwith respect to the ordering\n  degrevlex([x, y, z])\n\njulia> elements(G)\n3-element Vector{QQMPolyRingElem}:\n -x*z + y^2\n x*y - z\n x^2 - y\n\njulia> elements(G) == gens(G)\ntrue\n\njulia> groebner_basis(I, ordering = lex(R))\nGröbner basis with elements\n  1: y^3 - z^2\n  2: x*z - y^2\n  3: x*y - z\n  4: x^2 - y\nwith respect to the ordering\n  lex([x, y, z])\n\njulia> R, (x, y) = graded_polynomial_ring(QQ, [:x, :y], [1, 3]);\n\njulia> I = ideal(R, [x*y-3*x^4,y^3-2*x^6*y]);\n\njulia> groebner_basis(I)\nGröbner basis with elements\n  1: 3*x^4 - x*y\n  2: 2*x^3*y^2 - 3*y^3\n  3: x*y^3\n  4: y^4\nwith respect to the ordering\n  wdegrevlex([x, y], [1, 3])\n\njulia> R, (x, y, z) = polynomial_ring(QQ, [:x, :y, :z]);\n\njulia> V = [3*x^3*y+x^3+x*y^3+y^2*z^2, 2*x^3*z-x*y-x*z^3-y^4-z^2,\n               2*x^2*y*z-2*x*y^2+x*z^2-y^4];\n\njulia> I = ideal(R, V);\n\njulia> G = groebner_basis(I, ordering = lex(R), algorithm = :fglm);\n\njulia> length(G)\n8\n\njulia> total_degree(G[8])\n34\n\njulia> leading_coefficient(G[8])\n-91230304237130414552564280286681870842473427917231798336639893796481988733936505735341479640589040146625319419037353645834346047404145021391726185993823650399589880820226804328750\n\n\n\n\n\n","category":"method"},{"location":"CommutativeAlgebra/GroebnerBases/groebner_bases/","page":"Gröbner/Standard Bases Over Fields","title":"Gröbner/Standard Bases Over Fields","text":"standard_basis(I::MPolyIdeal;\n    ord::MonomialOrdering = default_ordering(base_ring(I)),\n    complete_reduction::Bool = false, algorithm::Symbol = :buchberger)","category":"page"},{"location":"CommutativeAlgebra/GroebnerBases/groebner_bases/#standard_basis-Tuple{MPolyIdeal}","page":"Gröbner/Standard Bases Over Fields","title":"standard_basis","text":"standard_basis(I::MPolyIdeal; ordering::MonomialOrdering = default_ordering(base_ring(I)),\n               complete_reduction::Bool = false, algorithm::Symbol = :buchberger)\n\nReturn a standard basis of I with respect to ordering.\n\nThe keyword algorithm can be set to\n\n:buchberger (implementation of Buchberger's algorithm in Singular),\n:modular (implementation of multi-modular approach, if applicable),\n:f4 (implementation of Faugère's F4 algorithm in the msolve package),\n:fglm (implementation of the FGLM algorithm in Singular),\n:hc (implementation of Buchberger's algorithm in Singular trying to first compute the highest corner modulo some prime), and\n:hilbert (implementation of a Hilbert driven Gröbner basis computation in Singular).\n\nnote: Note\nSee the description of the functions groebner_basis_hilbert_driven, fglm,  and f4 in the OSCAR documentation for some more details and for restrictions     on the input data when using these versions of the standard basis algorithm.\n\nnote: Note\nThe returned standard basis is reduced if ordering is global and complete_reduction = true.\n\nExamples\n\njulia> R,(x,y) = polynomial_ring(QQ, [:x,:y]);\n\njulia> I = ideal([x*(x+1), x^2-y^2+(x-2)*y]);\n\njulia> standard_basis(I, ordering = negdegrevlex(R))\nStandard basis with elements\n  1: x\n  2: y\nwith respect to the ordering\n  negdegrevlex([x, y])\n\n\n\n\n\n","category":"method"},{"location":"CommutativeAlgebra/GroebnerBases/groebner_bases/#Gröbner-Bases-with-transformation-matrix","page":"Gröbner/Standard Bases Over Fields","title":"Gröbner Bases with transformation matrix","text":"","category":"section"},{"location":"CommutativeAlgebra/GroebnerBases/groebner_bases/","page":"Gröbner/Standard Bases Over Fields","title":"Gröbner/Standard Bases Over Fields","text":"groebner_basis_with_transformation_matrix(I::MPolyIdeal;\n    ordering::MonomialOrdering = default_ordering(base_ring(I)),\n    complete_reduction::Bool=false)","category":"page"},{"location":"CommutativeAlgebra/GroebnerBases/groebner_bases/#groebner_basis_with_transformation_matrix-Tuple{MPolyIdeal}","page":"Gröbner/Standard Bases Over Fields","title":"groebner_basis_with_transformation_matrix","text":"groebner_basis_with_transformation_matrix(I::MPolyIdeal;\n  ordering::MonomialOrdering = default_ordering(base_ring(I)),\n  complete_reduction::Bool=false)\n\nReturn a pair G, T, say, where G is a Gröbner basis of I with respect to ordering, and T  is a transformation matrix from gens(I) to G. That is, gens(I)*T == G.\n\nnote: Note\nThe returned Gröbner basis is reduced if complete_reduction = true.\n\nExamples\n\njulia> R,(x,y) = polynomial_ring(QQ,[:x,:y]);\n\njulia> I = ideal([x*y^2-1,x^3+y^2+x*y]);\n\njulia> G, T = groebner_basis_with_transformation_matrix(I)\n(Gröbner basis with 3 elements w.r.t. degrevlex([x, y]), [1 0 -x^2-y; 0 1 y^2])\n\njulia> gens(I)*T == gens(G)\ntrue\n\n\n\n\n\n","category":"method"},{"location":"CommutativeAlgebra/GroebnerBases/groebner_bases/","page":"Gröbner/Standard Bases Over Fields","title":"Gröbner/Standard Bases Over Fields","text":"standard_basis_with_transformation_matrix(I::MPolyIdeal;\n    ordering::MonomialOrdering = default_ordering(base_ring(I)),\n    complete_reduction::Bool=false)","category":"page"},{"location":"CommutativeAlgebra/GroebnerBases/groebner_bases/#standard_basis_with_transformation_matrix-Tuple{MPolyIdeal}","page":"Gröbner/Standard Bases Over Fields","title":"standard_basis_with_transformation_matrix","text":"standard_basis_with_transformation_matrix(I::MPolyIdeal;\n  ordering::MonomialOrdering = default_ordering(base_ring(I)),\n  complete_reduction::Bool=false)\n\nReturn a pair G, T, say, where G is a standard basis of I with respect to ordering, and T  is a transformation matrix from gens(I) to G. That is, gens(I)*T == G.\n\nnote: Note\nThe returned Gröbner basis is reduced if ordering is a global monomial ordering and complete_reduction = true.\n\nExamples\n\njulia> R,(x,y) = polynomial_ring(QQ,[:x,:y]);\n\njulia> I = ideal([x*y^2-1,x^3+y^2+x*y]);\n\njulia> G, T = standard_basis_with_transformation_matrix(I, ordering=neglex(R))\n(Standard basis with 1 element w.r.t. neglex([x, y]), [-1; 0])\n\njulia> gens(I)*T == gens(G)\ntrue\n\n\n\n\n\n","category":"method"},{"location":"CommutativeAlgebra/GroebnerBases/groebner_bases/#Gröbner-Basis-Conversion-Algorithms","page":"Gröbner/Standard Bases Over Fields","title":"Gröbner Basis Conversion Algorithms","text":"","category":"section"},{"location":"CommutativeAlgebra/GroebnerBases/groebner_bases/","page":"Gröbner/Standard Bases Over Fields","title":"Gröbner/Standard Bases Over Fields","text":"The performance of Buchberger's Gröbner basis algorithm is sensitive to the choice of monomial ordering. A Gröbner basis computation with respect to a less favorable ordering such as lex may easily run out of time or memory even in cases where a Gröbner basis computation with respect to a more efficient  ordering such as degrevlex is very well feasible. Gröbner basis conversion algorithms and the Hilbert driven Buchberger algorithm  discussed subsequently take their cue from this observation.","category":"page"},{"location":"CommutativeAlgebra/GroebnerBases/groebner_bases/","page":"Gröbner/Standard Bases Over Fields","title":"Gröbner/Standard Bases Over Fields","text":"Gröbner basis conversion algorithms proceed along the following lines:","category":"page"},{"location":"CommutativeAlgebra/GroebnerBases/groebner_bases/","page":"Gröbner/Standard Bases Over Fields","title":"Gröbner/Standard Bases Over Fields","text":"Given an ideal I of a multivariate polynomial ring over a field and a slow destination_ordering, compute a Gröbner basis for I with respect to an appropriately chosen fast start_ordering.\nConvert the result to a Gröbner basis with respect to the given slow destination_ordering.","category":"page"},{"location":"CommutativeAlgebra/GroebnerBases/groebner_bases/","page":"Gröbner/Standard Bases Over Fields","title":"Gröbner/Standard Bases Over Fields","text":"The algorithms differ in how they perform the conversion.","category":"page"},{"location":"CommutativeAlgebra/GroebnerBases/groebner_bases/#The-FGLM-Algorithm","page":"Gröbner/Standard Bases Over Fields","title":"The FGLM Algorithm","text":"","category":"section"},{"location":"CommutativeAlgebra/GroebnerBases/groebner_bases/","page":"Gröbner/Standard Bases Over Fields","title":"Gröbner/Standard Bases Over Fields","text":"fglm(I::MPolyIdeal; start_ordering::MonomialOrdering = default_ordering(base_ring(I)),\n    destination_ordering::MonomialOrdering)","category":"page"},{"location":"CommutativeAlgebra/GroebnerBases/groebner_bases/#fglm-Tuple{MPolyIdeal}","page":"Gröbner/Standard Bases Over Fields","title":"fglm","text":"fglm(I::MPolyIdeal; start_ordering::MonomialOrdering = default_ordering(base_ring(I)),\n                    destination_ordering::MonomialOrdering)\n\nGiven a zero-dimensional ideal I, return the reduced Gröbner basis of I with respect to destination_ordering.\n\nnote: Note\nBoth start_ordering and destination_ordering must be global and the base ring of I must be a polynomial ring over a field.\n\nnote: Note\nThe function implements the Gröbner basis conversion algorithm by Faugère, Gianni, Lazard, and Mora. See [FGLM93] for more information.\n\nExamples\n\njulia> R, (a, b, c, d, e) = polynomial_ring(QQ, [:a, :b, :c, :d, :e]);\n\njulia> f1 = a+b+c+d+e;\n\njulia> f2 = a*b+b*c+c*d+a*e+d*e;\n\njulia> f3 = a*b*c+b*c*d+a*b*e+a*d*e+c*d*e;\n\njulia> f4 = b*c*d+a*b*c*e+a*b*d*e+a*c*d*e+b*c*d*e;\n\njulia> f5 = a*b*c*d*e-1;\n\njulia> I = ideal(R, [f1, f2, f3, f4, f5]);\n\njulia> G = fglm(I, destination_ordering = lex(R));\n\njulia> length(G)\n8\n\njulia> total_degree(G[8])\n60\n\njulia> leading_coefficient(G[8])\n83369589588385815165248207597941242098312973356252482872580035860533111990678631297423089011608753348453253671406641805924218003925165995322989635503951507226650115539638517111445927746874479234\n\n\n\n\n\n","category":"method"},{"location":"CommutativeAlgebra/GroebnerBases/groebner_bases/#Gröbner-Walk-Algorithms","page":"Gröbner/Standard Bases Over Fields","title":"Gröbner Walk Algorithms","text":"","category":"section"},{"location":"CommutativeAlgebra/GroebnerBases/groebner_bases/#The-Hilbert-driven-Buchberger-Algorithm","page":"Gröbner/Standard Bases Over Fields","title":"The Hilbert driven Buchberger Algorithm","text":"","category":"section"},{"location":"CommutativeAlgebra/GroebnerBases/groebner_bases/","page":"Gröbner/Standard Bases Over Fields","title":"Gröbner/Standard Bases Over Fields","text":"Calling the functions standard_basis and groebner_basis with algorithm = :hilbert in OSCAR triggers a version of the Hilbert driven Gröbner basis algorithm which proceeds along the following lines.","category":"page"},{"location":"CommutativeAlgebra/GroebnerBases/groebner_bases/","page":"Gröbner/Standard Bases Over Fields","title":"Gröbner/Standard Bases Over Fields","text":"Given an ideal I of a multivariate polynomial ring R over a field K and a slow destination_ordering, check whether I is homogeneous with respect to the standard mathbb Z-grading on R. If so, set start_ordering to degrevlex and go to step 3.\nCheck whether there exists a mathbb Z-grading on R with positive weights such that I is homogeneous with respect to this grading. If so, let start_ordering be the corresponding weight ordering. If not, go to step 5.\nCompute a Gröbner basis of I with respect to start_ordering and use this Gröbner basis to compute the Hilbert function of RI.\nCompute a Gröbner basis with respect to destination_ordering,  proceeding by increasing (weighted) degree, and skipping all further Buchberger tests in a given (weighted) degree as soon as the leading terms found so far account for the Hilbert function in that (weighted) degree. Return the computed Gröbner basis.\nExtend R to a polynomial ring S by appending an extra variable, equip S with the standard mathbb Z-grading, and let I^hsubset S be the homogenization of I with respect to the extra variable. Compute a Gröbner basis of I with respect to degrevlex on R, and homogenize its elements to obtain a Gröbner basis of I^h with respect to degrevlex on S. Use the latter basis to compute the Hilbert function of SI^h. Extend destination_ordering to a block ordering on S. Following the recipe in step 4, compute a Gröbner basis of SI^h with respect to the extended ordering. Return the dehomogenization of this basis with respect to the extra variable.","category":"page"},{"location":"CommutativeAlgebra/GroebnerBases/groebner_bases/","page":"Gröbner/Standard Bases Over Fields","title":"Gröbner/Standard Bases Over Fields","text":"If the characteristic of K is zero,  by semi-continuity of the Hilbert function, it is sufficient to perform step 3 for the reduction of I modulo a conveniently chosen prime number rather than for I itself.","category":"page"},{"location":"CommutativeAlgebra/GroebnerBases/groebner_bases/","page":"Gröbner/Standard Bases Over Fields","title":"Gröbner/Standard Bases Over Fields","text":"note: Note\nIf appropriate weights and/or the Hilbert function with respect to appropriate weights are already known to the user, this information can be entered when calling the Hilbert driven Gröbner basis algorithm as follows:","category":"page"},{"location":"CommutativeAlgebra/GroebnerBases/groebner_bases/","page":"Gröbner/Standard Bases Over Fields","title":"Gröbner/Standard Bases Over Fields","text":"groebner_basis_hilbert_driven(I::MPolyIdeal{P};\n    destination_ordering::MonomialOrdering,\n    complete_reduction::Bool = false,\n    weights::Vector{Int} = ones(Int, number_of_generators(base_ring(I))),\n    hilbert_numerator::Union{Nothing, ZZPolyRingElem} = nothing) where {P <: MPolyRingElem}","category":"page"},{"location":"CommutativeAlgebra/GroebnerBases/groebner_bases/#groebner_basis_hilbert_driven-Union{Tuple{MPolyIdeal{P}}, Tuple{P}} where P<:MPolyRingElem","page":"Gröbner/Standard Bases Over Fields","title":"groebner_basis_hilbert_driven","text":"groebner_basis_hilbert_driven(I::MPolyIdeal{P}; destination_ordering::MonomialOrdering,\n                complete_reduction::Bool = false,\n                weights::Vector{Int} = ones(Int, ngens(base_ring(I))),\n                hilbert_numerator::Union{Nothing, ZZPolyRingElem} = nothing) \n                where {P <: MPolyRingElem}\n\nReturn a Gröbner basis of I with respect to destination_ordering.\n\nnote: Note\nThe function implements a version of the Hilbert driven Gröbner basis algorithm. See the corresponding section of the OSCAR documentation for some details.\n\nnote: Note\nAll weights must be positive. If no weight vector is entered by the user, all weights  are set to 1. An error is thrown if the generators of I are not homogeneous with  respect to the corresponding (weighted) degree.  \n\nnote: Note\nIf R denotes the parent ring of I, and p qinmathbb Zt are polynomials such that pq represents the Hilbert series of RI as a rational function with  denominator q = (1-t^w_1)cdots (1-t^w_n) where n is the number of variables  of R, and w_1 dots w_n are the assigned weights, then hilbert_numerator is  meant to be p. If this numerator is not entered by the user, it will be computed  internally.\n\nExamples\n\njulia> R, (a, b, c, d, e, f, g) = polynomial_ring(QQ, [:a, :b, :c, :d, :e, :f, :g]);\n\njulia> V = [-3*a^2+2*f*b+3*f*d, (3*g*b+3*g*e)*a-3*f*c*b,\n                      -3*g^2*a^2-c*b^2*a-g^2*f*e-g^4, e*a-f*b-d*c];\n\njulia> I = ideal(R, V);\n\njulia> o = degrevlex([a, b, c])*degrevlex([d, e, f, g]);\n\njulia> G = groebner_basis_hilbert_driven(I, destination_ordering = o);\n\njulia> length(G)\n296\n\njulia> total_degree(G[49])\n30\n\njulia> R, (x, y, z) = polynomial_ring(GF(32003), [:x, :y, :z]);\n\njulia> f1 = x^2*y+169*y^21+151*x*y*z^10;\n\njulia> f2 = 6*x^2*y^4+x*z^14+3*z^24;\n\njulia> f3 = 11*x^3+5*x*y^10*z^10+2*y^20*z^10+y^10*z^20;\n\njulia> I = ideal(R, [f1, f2,f3]);\n\njulia> W = [10, 1, 1];\n\njulia> GB = groebner_basis_hilbert_driven(I, destination_ordering = lex(R), weights = W);\n\njulia> length(GB)\n40\n\njulia> R, (x, y, z) = polynomial_ring(GF(32003), [:x, :y, :z]);\n\njulia> f1 = x^2*y+169*y^21+151*x*y*z^10;\n\njulia> f2 = 6*x^2*y^4+x*z^14+3*z^24;\n\njulia> f3 = 11*x^3+5*x*y^10*z^10+2*y^20*z^10+y^10*z^20;\n\njulia> I = ideal(R, [f1, f2,f3]);\n\njulia> W = [10, 1, 1];\n\njulia> S, t = polynomial_ring(ZZ, :t)\n(Univariate polynomial ring in t over ZZ, t)\n\njulia> hn = -t^75 + t^54 + t^51 + t^45 - t^30 - t^24 - t^21 + 1\n-t^75 + t^54 + t^51 + t^45 - t^30 - t^24 - t^21 + 1\n\njulia> GB = groebner_basis_hilbert_driven(I, destination_ordering = lex(R), weights = W, hilbert_numerator = hn);\n\njulia> length(GB)\n40\n\n\n\n\n\n","category":"method"},{"location":"CommutativeAlgebra/GroebnerBases/groebner_bases/#Faugère's-F4-Algorithm","page":"Gröbner/Standard Bases Over Fields","title":"Faugère's F4 Algorithm","text":"","category":"section"},{"location":"CommutativeAlgebra/GroebnerBases/groebner_bases/","page":"Gröbner/Standard Bases Over Fields","title":"Gröbner/Standard Bases Over Fields","text":"warning: Expert function for computing Gröbner bases\nWith many adjustable keyword arguments, the following function provides low-level implementations of various versions of the Gröbner basis algorithm. Use these functions only if you know what you are doing.","category":"page"},{"location":"CommutativeAlgebra/GroebnerBases/groebner_bases/","page":"Gröbner/Standard Bases Over Fields","title":"Gröbner/Standard Bases Over Fields","text":"groebner_basis_f4( I::MPolyIdeal; initial_hts::Int=17, nr_thrds::Int=1, max_nr_pairs::Int=0, la_option::Int=2, reduce_gb::Int=1, info_level::Int=0)","category":"page"},{"location":"CommutativeAlgebra/GroebnerBases/groebner_bases/#groebner_basis_f4-Tuple{MPolyIdeal}","page":"Gröbner/Standard Bases Over Fields","title":"groebner_basis_f4","text":"groebner_basis_f4(I::MPolyIdeal, <keyword arguments>)\n\nCompute a Gröbner basis of I with respect to degrevlex using Faugère's F4 algorithm. See [Fau99] for more information.\n\nnote: Note\nAt current state only prime fields of characteristic 0 < p < 2^{31} and the rationals are supported.\n\nPossible keyword arguments\n\ninitial_hts::Int=17: initial hash table size log_2.\nnr_thrds::Int=1: number of threads for parallel linear algebra.\nmax_nr_pairs::Int=0: maximal number of pairs per matrix, only bounded by minimal degree if 0.\nla_option::Int=2: linear algebra option: exact sparse-dense (1), exact sparse (2, default), probabilistic sparse-dense (42), probabilistic sparse(44).\neliminate::Int=0: size of first block of variables to be eliminated.\ncomplete_reduction::Bool=true: compute a reduced Gröbner basis for I\nnormalize::Bool=true: normalizes elements in computed Gröbner basis for I\ntruncate_lifting::Int=0: degree up to which the elements of the Gröbner basis are lifted to QQ, 0 for complete lifting\ninfo_level::Int=0: info level printout: off (0, default), summary (1), detailed (2).\n\nExamples\n\njulia> R,(x,y,z) = polynomial_ring(GF(101), [:x,:y,:z])\n(Multivariate polynomial ring in 3 variables over GF(101), FqMPolyRingElem[x, y, z])\n\njulia> I = ideal(R, [x+2*y+2*z-1, x^2+2*y^2+2*z^2-x, 2*x*y+2*y*z-y])\nIdeal generated by\n  x + 2*y + 2*z + 100\n  x^2 + 100*x + 2*y^2 + 2*z^2\n  2*x*y + 2*y*z + 100*y\n\njulia> groebner_basis_f4(I)\nGröbner basis with elements\n  1: x + 2*y + 2*z + 100\n  2: y*z + 82*z^2 + 10*y + 40*z\n  3: y^2 + 60*z^2 + 20*y + 81*z\n  4: z^3 + 28*z^2 + 64*y + 13*z\nwith respect to the ordering\n  degrevlex([x, y, z])\n\n\n\n\n\n","category":"method"},{"location":"CommutativeAlgebra/GroebnerBases/groebner_bases/#Leading-Ideals","page":"Gröbner/Standard Bases Over Fields","title":"Leading Ideals","text":"","category":"section"},{"location":"CommutativeAlgebra/GroebnerBases/groebner_bases/","page":"Gröbner/Standard Bases Over Fields","title":"Gröbner/Standard Bases Over Fields","text":"leading_ideal(G::Vector{T}; ordering::MonomialOrdering = default_ordering(parent(G[1])))  where T <: MPolyRingElem\nleading_ideal(I::MPolyIdeal; ordering::MonomialOrdering = default_ordering(base_ring(I)))","category":"page"},{"location":"CommutativeAlgebra/GroebnerBases/groebner_bases/#leading_ideal-Union{Tuple{Vector{T}}, Tuple{T}} where T<:MPolyRingElem","page":"Gröbner/Standard Bases Over Fields","title":"leading_ideal","text":"leading_ideal(G::Vector{T}; ordering::MonomialOrdering = default_ordering(parent(G[1]))) \n                            where T <: MPolyRingElem\n\nReturn the leading ideal of G with respect to ordering.\n\nExamples\n\njulia> R, (x, y) = polynomial_ring(QQ, [:x, :y])\n(Multivariate polynomial ring in 2 variables over QQ, QQMPolyRingElem[x, y])\n\njulia> L = leading_ideal([x*y^2-3*x, x^3-14*y^5], ordering=degrevlex(R))\nIdeal generated by\n  x*y^2\n  y^5\n\njulia> L = leading_ideal([x*y^2-3*x, x^3-14*y^5], ordering=lex(R))\nIdeal generated by\n  x*y^2\n  x^3\n\n\n\n\n\n","category":"method"},{"location":"CommutativeAlgebra/GroebnerBases/groebner_bases/#leading_ideal-Tuple{MPolyIdeal}","page":"Gröbner/Standard Bases Over Fields","title":"leading_ideal","text":"leading_ideal(I::MPolyIdeal; ordering::MonomialOrdering = default_ordering(base_ring(I)))\n\nReturn the leading ideal of I with respect to ordering.\n\nExamples\n\njulia> R, (x, y) = polynomial_ring(QQ, [:x, :y])\n(Multivariate polynomial ring in 2 variables over QQ, QQMPolyRingElem[x, y])\n\njulia> I = ideal(R,[x*y^2-3*x, x^3-14*y^5])\nIdeal generated by\n  x*y^2 - 3*x\n  x^3 - 14*y^5\n\njulia> L = leading_ideal(I, ordering=degrevlex(R))\nIdeal generated by\n  x*y^2\n  x^4\n  y^5\n\njulia> L = leading_ideal(I, ordering=lex(R))\nIdeal generated by\n  y^7\n  x*y^2\n  x^3\n\n\n\n\n\n","category":"method"},{"location":"CommutativeAlgebra/GroebnerBases/groebner_bases/#Normal-Forms","page":"Gröbner/Standard Bases Over Fields","title":"Normal Forms","text":"","category":"section"},{"location":"CommutativeAlgebra/GroebnerBases/groebner_bases/","page":"Gröbner/Standard Bases Over Fields","title":"Gröbner/Standard Bases Over Fields","text":"Given a polynomial gin Kx, an ideal Isubset Kx, and a global monomial ordering  on the monomials in x, the fully reduced remainder h in a standard expression on division by the elements of a Gröbner basis of I with respect to  is uniquely determined by g, I, and  (and does not depend on the choice of Gröbner basis). We refer to such a remainder as the normal form  of g mod I, with respect to .","category":"page"},{"location":"CommutativeAlgebra/GroebnerBases/groebner_bases/","page":"Gröbner/Standard Bases Over Fields","title":"Gröbner/Standard Bases Over Fields","text":"normal_form(g::T, I::MPolyIdeal; ordering::MonomialOrdering = default_ordering(base_ring(I))) where T <: MPolyRingElem","category":"page"},{"location":"CommutativeAlgebra/GroebnerBases/groebner_bases/#normal_form-Union{Tuple{T}, Tuple{T, MPolyIdeal}} where T<:MPolyRingElem","page":"Gröbner/Standard Bases Over Fields","title":"normal_form","text":"normal_form(g::T, I::MPolyIdeal; \n  ordering::MonomialOrdering = default_ordering(base_ring(I))) where T <: MPolyRingElem\n\nCompute the normal form of g mod I with respect to ordering.\n\nnormal_form(G::Vector{T}, I::MPolyIdeal; \n  ordering::MonomialOrdering = default_ordering(base_ring(I))) where T <: MPolyRingElem\n\nReturn a Vector which contains for each element g of G a normal form as above.\n\nExamples\n\njulia> R,(a,b,c) = polynomial_ring(QQ,[:a,:b,:c])\n(Multivariate polynomial ring in 3 variables over QQ, QQMPolyRingElem[a, b, c])\n\njulia> J = ideal(R,[-1+c+b,-1+b+c*a+2*a*b])\nIdeal generated by\n  b + c - 1\n  2*a*b + a*c + b - 1\n\njulia> gens(groebner_basis(J))\n2-element Vector{QQMPolyRingElem}:\n b + c - 1\n a*c - 2*a + c\n\njulia> normal_form(-1+c+b+a^3, J)\na^3\n\njulia> R,(a,b,c) = polynomial_ring(QQ,[:a,:b,:c])\n(Multivariate polynomial ring in 3 variables over QQ, QQMPolyRingElem[a, b, c])\n\njulia> A = [-1+c+b+a^3,-1+b+c*a+2*a^3,5+c*b+c^2*a]\n3-element Vector{QQMPolyRingElem}:\n a^3 + b + c - 1\n 2*a^3 + a*c + b - 1\n a*c^2 + b*c + 5\n\njulia> J = ideal(R,[-1+c+b,-1+b+c*a+2*a*b])\nIdeal generated by\n  b + c - 1\n  2*a*b + a*c + b - 1\n\njulia> gens(groebner_basis(J))\n2-element Vector{QQMPolyRingElem}:\n b + c - 1\n a*c - 2*a + c\n\njulia> normal_form(A, J)\n3-element Vector{QQMPolyRingElem}:\n a^3\n 2*a^3 + 2*a - 2*c\n 4*a - 2*c^2 - c + 5\n\n\n\n\n\n","category":"method"},{"location":"CommutativeAlgebra/GroebnerBases/groebner_bases/#Syzygies","page":"Gröbner/Standard Bases Over Fields","title":"Syzygies","text":"","category":"section"},{"location":"CommutativeAlgebra/GroebnerBases/groebner_bases/","page":"Gröbner/Standard Bases Over Fields","title":"Gröbner/Standard Bases Over Fields","text":"We refer to the section on modules for more on syzygies.","category":"page"},{"location":"CommutativeAlgebra/GroebnerBases/groebner_bases/","page":"Gröbner/Standard Bases Over Fields","title":"Gröbner/Standard Bases Over Fields","text":"syzygy_generators(G::Vector{<:MPolyRingElem})","category":"page"},{"location":"CommutativeAlgebra/GroebnerBases/groebner_bases/#syzygy_generators-Tuple{Vector{<:MPolyRingElem}}","page":"Gröbner/Standard Bases Over Fields","title":"syzygy_generators","text":"syzygy_generators(\n    a::Vector{T};\n    parent::Union{FreeMod{T}, Nothing} = nothing\n  ) where {T<:RingElem}\n\nReturn generators for the syzygies on the polynomials given as elements of a. The optional keyword argument can be used to specify the parent of the output.\n\nExamples\n\njulia> R, (x, y) = polynomial_ring(QQ, [:x, :y])\n(Multivariate polynomial ring in 2 variables over QQ, QQMPolyRingElem[x, y])\n\njulia> S = syzygy_generators([x^3+y+2,x*y^2-13*x^2,y-14])\n3-element Vector{FreeModElem{QQMPolyRingElem}}:\n (-y + 14)*e[2] + (-13*x^2 + x*y^2)*e[3]\n (-169*y + 2366)*e[1] + (-13*x*y + 182*x - 196*y + 2744)*e[2] + (13*x^2*y^2 - 2548*x^2 + 196*x*y^2 + 169*y + 338)*e[3]\n (-13*x^2 + 196*x)*e[1] + (-x^3 - 16)*e[2] + (x^4*y + 14*x^4 + 13*x^2 + 16*x*y + 28*x)*e[3]\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/abelian/structural/","page":"Structural Computations","title":"Structural Computations","text":"CurrentModule = Hecke\nDocTestSetup = quote\n    using Hecke\nend","category":"page"},{"location":"Hecke/manual/abelian/structural/#Structural-Computations","page":"Structural Computations","title":"Structural Computations","text":"","category":"section"},{"location":"Hecke/manual/abelian/structural/","page":"Structural Computations","title":"Structural Computations","text":"Abelian groups support a wide range of structural operations such as","category":"page"},{"location":"Hecke/manual/abelian/structural/","page":"Structural Computations","title":"Structural Computations","text":"enumeration of subgroups\n(outer) direct products\ntensor and hom constructions\nfree resolutions and general complexes\n(co)-homology and tensor and hom-functors","category":"page"},{"location":"Hecke/manual/abelian/structural/","page":"Structural Computations","title":"Structural Computations","text":"snf(A::FinGenAbGroup)\nHecke.find_isomorphism(G, op, A::Hecke.GrpAb)","category":"page"},{"location":"Hecke/manual/abelian/structural/#snf-Tuple{FinGenAbGroup}","page":"Structural Computations","title":"snf","text":"snf(A::FinGenAbGroup) -> FinGenAbGroup, FinGenAbGroupHom\n\nReturn a pair (G f), where G is an abelian group in canonical Smith normal form isomorphic to A and an isomorphism f  G to A.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/abelian/structural/#find_isomorphism-Tuple{Any, Any, Hecke.GrpAb}","page":"Structural Computations","title":"find_isomorphism","text":"find_isomorphism(G, op, A::GrpAb) -> Dict, Dict\n\nGiven an abelian group A and a collection G which is an abelian group with the operation op, this functions returns isomorphisms G to A and A to G encoded as dictionaries.\n\nIt is assumed that G and A are isomorphic.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/abelian/structural/#Subgroups-and-Quotients","page":"Structural Computations","title":"Subgroups and Quotients","text":"","category":"section"},{"location":"Hecke/manual/abelian/structural/","page":"Structural Computations","title":"Structural Computations","text":"torsion_subgroup(G::FinGenAbGroup)\nsub(G::FinGenAbGroup, s::Vector{FinGenAbGroupElem})\nsub(s::Vector{FinGenAbGroupElem})\nsub(G::FinGenAbGroup, M::ZZMatrix)\nsub(G::FinGenAbGroup, n::ZZRingElem)\nsub(G::FinGenAbGroup, n::Integer)\nsylow_subgroup(G::FinGenAbGroup, p::Union{ZZRingElem, Integer})\nHecke.has_quotient(G::FinGenAbGroup, invariant::Vector{Int})\nHecke.has_complement(f::FinGenAbGroupHom)\nis_pure(U::FinGenAbGroup, G::FinGenAbGroup)\nis_neat(U::FinGenAbGroup, G::FinGenAbGroup)\nsaturate(U::FinGenAbGroup, G::FinGenAbGroup)","category":"page"},{"location":"Hecke/manual/abelian/structural/#torsion_subgroup-Tuple{FinGenAbGroup}","page":"Structural Computations","title":"torsion_subgroup","text":"torsion_subgroup(G::FinGenAbGroup) -> FinGenAbGroup, Map\n\nReturn the torsion subgroup of G.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/abelian/structural/#sub-Tuple{FinGenAbGroup, Vector{FinGenAbGroupElem}}","page":"Structural Computations","title":"sub","text":"sub(G::FinGenAbGroup, s::Vector{FinGenAbGroupElem}) -> FinGenAbGroup, FinGenAbGroupHom\n\nCreate the subgroup H of G generated by the elements in s together with the injection iota  H to G.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/abelian/structural/#sub-Tuple{Vector{FinGenAbGroupElem}}","page":"Structural Computations","title":"sub","text":"sub(A::SMat, r::AbstractUnitRange, c::AbstractUnitRange) -> SMat\n\nReturn the submatrix of A, where the rows correspond to r and the columns correspond to c.\n\n\n\n\n\nsub(s::Vector{FinGenAbGroupElem}) -> FinGenAbGroup, FinGenAbGroupHom\n\nAssuming that the non-empty array s contains elements of an abelian group G, this functions returns the subgroup H of G generated by the elements in s together with the injection iota  H to G.\n\n\n\n\n\nsub(F::FreeMod{T}, V::Vector{<:FreeModElem{T}}; cache_morphism::Bool=false) where {T}\n\nGiven a vector V of (homogeneous) elements of F, return a pair (I, inc) consisting of the (graded) submodule I of F generated by these elements and its inclusion map inc : I ↪ F.\n\nWhen cache_morphism is set to true, then inc will be cached and available for transport and friends.\n\nIf only the submodule itself is desired, use sub_object instead.\n\n\n\n\n\nsub(F::FreeMod{T}, A::MatElem{T}; cache_morphism::Bool=false) where {T}\n\nGiven a (homogeneous) matrix A interpret the rows of A as elements of the free module F and return a pair (I, inc) consisting of the (graded) submodule I of F generated by these row vectors, together with its inclusion map inc : I ↪ F.\n\nWhen cache_morphism is set to true, then inc will be cached and available for transport and friends.\n\nIf only the submodule itself is desired, use sub_object instead.\n\n\n\n\n\nsub(F::FreeMod{T}, O::Vector{<:SubquoModuleElem{T}}; cache_morphism::Bool=false) where T\n\nSuppose the ambient_free_module of the parent M of the elements v_i in O is F and M is a submodule (i.e. no relations are present). Then this returns a pair (I, inc) consisting of the submodule I generated by the elements in O in F, together with its inclusion morphism inc : I ↪ F.\n\nWhen cache_morphism is set to true, then inc will be cached and available for transport and friends.\n\nIf only the submodule itself is desired, use sub_object instead.\n\n\n\n\n\nsub(F::FreeMod{T}, M::SubquoModule{T}; cache_morphism::Bool=false) where T\n\nReturn M as a submodule of F, together with its inclusion morphism inc : M ↪ F.\n\nWhen cache_morphism is set to true, then inc will be cached and available for transport and friends.\n\nThe ambient_free_module of M needs to be F and M has to have no relations.\n\nIf only the submodule itself is desired, use sub_object instead.\n\n\n\n\n\nsub(M::SubquoModule{T}, V::Vector{<:SubquoModuleElem{T}}; cache_morphism::Bool=false) where T\n\nGiven a vector V of (homogeneous) elements of M, return the (graded) submodule I of M generated by these elements together with its inclusion map `inc : I ↪ M.\n\nWhen cache_morphism is set to true, then inc will be cached and available for transport and friends.\n\nIf only the submodule itself is desired, use sub_object instead.\n\n\n\n\n\nsub(M::ModuleFP{T}, V::Vector{<:ModuleFPElem{T}}; cache_morphism::Bool=false) where T\n\nGiven a vector V of (homogeneous) elements of M, return the (graded) submodule I of M generated by these elements together with its inclusion map `inc : I ↪ M.\n\nWhen cache_morphism is set to true, then inc will be cached and available for transport and friends.\n\nIf only the submodule itself is desired, use sub_object instead.\n\nExamples\n\njulia> R, (x, y, z) = polynomial_ring(QQ, [:x, :y, :z]);\n\njulia> F = free_module(R, 1);\n\njulia> V = [x^2*F[1]; y^3*F[1]; z^4*F[1]];\n\njulia> N, incl = sub(F, V);\n\njulia> N\nSubmodule with 3 generators\n  1: x^2*e[1]\n  2: y^3*e[1]\n  3: z^4*e[1]\nrepresented as subquotient with no relations\n\njulia> incl\nModule homomorphism\n  from N\n  to F\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/abelian/structural/#sub-Tuple{FinGenAbGroup, ZZMatrix}","page":"Structural Computations","title":"sub","text":"sub(G::FinGenAbGroup, M::ZZMatrix) -> FinGenAbGroup, FinGenAbGroupHom\n\nCreate the subgroup H of G generated by the elements corresponding to the rows of M together with the injection iota  H to G.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/abelian/structural/#sub-Tuple{FinGenAbGroup, ZZRingElem}","page":"Structural Computations","title":"sub","text":"sub(G::FinGenAbGroup, n::ZZRingElem) -> FinGenAbGroup, FinGenAbGroupHom\n\nCreate the subgroup n cdot G of G together with the injection iota  ncdot G to G.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/abelian/structural/#sub-Tuple{FinGenAbGroup, Integer}","page":"Structural Computations","title":"sub","text":"sub(G::FinGenAbGroup, n::Integer) -> FinGenAbGroup, Map\n\nCreate the subgroup n cdot G of G together with the injection iota  n cdot G to G.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/abelian/structural/#sylow_subgroup-Tuple{FinGenAbGroup, Union{Integer, ZZRingElem}}","page":"Structural Computations","title":"sylow_subgroup","text":"sylow_subgroup(G::FinGenAbGroup, p::IntegerUnion) -> FinGenAbGroup, FinGenAbGroupHom\n\nReturn the Sylow p-subgroup of the finitely generated abelian group G, for a prime p. This is the subgroup of p-power order in G whose index in G is coprime to p.\n\nExamples\n\njulia> A = abelian_group(ZZRingElem[2, 6, 30])\nZ/2 x Z/6 x Z/30\n\njulia> H, j = sylow_subgroup(A, 2);\n\njulia> H\n(Z/2)^3\n\njulia> divexact(order(A), order(H))\n45\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/abelian/structural/#has_quotient-Tuple{FinGenAbGroup, Vector{Int64}}","page":"Structural Computations","title":"has_quotient","text":"has_quotient(G::FinGenAbGroup, invariant::Vector{Int}) -> Bool\n\nGiven an abelian group G, return true if it has a quotient with given elementary divisors and false otherwise.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/abelian/structural/#has_complement-Tuple{FinGenAbGroupHom}","page":"Structural Computations","title":"has_complement","text":"has_complement(f::FinGenAbGroupHom) -> Bool, FinGenAbGroupHom\nhas_complement(U::FinGenAbGroup, G::FinGenAbGroup) -> Bool, FinGenAbGroupHom\n\nGiven a map representing a subgroup of a group G, or a subgroup U of a group G, return either true and an injection of a complement in G, or false.\n\nSee also: is_pure\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/abelian/structural/#is_pure-Tuple{FinGenAbGroup, FinGenAbGroup}","page":"Structural Computations","title":"is_pure","text":"is_pure(U::FinGenAbGroup, G::FinGenAbGroup) -> Bool\n\nA subgroup U of G is called pure if for all n an element in U that is in the image of the multiplication by n map of G is also a multiple of an element in U.\n\nFor finite abelian groups this is equivalent to U having a complement in G. They are also know as isolated subgroups and serving subgroups.\n\nSee also: is_neat, has_complement\n\nEXAMPLES\n\njulia> G = abelian_group([2, 8]);\n\njulia> U, _ = sub(G, [G[1]+2*G[2]]);\n\njulia> is_pure(U, G)\nfalse\n\njulia> U, _ = sub(G, [G[1]+4*G[2]]);\n\njulia> is_pure(U)\ntrue\n\njulia> has_complement(U, G)[1]\ntrue\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/abelian/structural/#is_neat-Tuple{FinGenAbGroup, FinGenAbGroup}","page":"Structural Computations","title":"is_neat","text":"is_neat(U::FinGenAbGroup, G::FinGenAbGroup) -> Bool\n\nA subgroup U of G is called neat if for all primes p an element in U that is in the image of the multiplication by p map of G is also a multiple of an element in U.\n\nSee also: is_pure\n\nEXAMPLES\n\njulia> G = abelian_group([2, 8]);\n\njulia> U, _ = sub(G, [G[1] + 2*G[2]]);\n\njulia> is_neat(U, G)\ntrue\n\njulia> is_pure(U, G)\nfalse\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/abelian/structural/#saturate-Tuple{FinGenAbGroup, FinGenAbGroup}","page":"Structural Computations","title":"saturate","text":"saturate(U::FinGenAbGroup, G::FinGenAbGroup) -> FinGenAbGroup\n\nFor a subgroup U of G find a minimal overgroup that is pure, and thus has a complement.\n\nSee also: is_pure, has_complement\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/abelian/structural/","page":"Structural Computations","title":"Structural Computations","text":"A sophisticated algorithm for the enumeration of all (or selected) subgroups of a finite abelian group is available.","category":"page"},{"location":"Hecke/manual/abelian/structural/","page":"Structural Computations","title":"Structural Computations","text":"psubgroups(g::FinGenAbGroup, p::Integer)","category":"page"},{"location":"Hecke/manual/abelian/structural/#psubgroups-Tuple{FinGenAbGroup, Integer}","page":"Structural Computations","title":"psubgroups","text":"psubgroups(g::FinGenAbGroup, p::Integer;\n           subtype = :all,\n           quotype = :all,\n           index = -1,\n           order = -1)\n\nReturn an iterator for the subgroups of G of the specific form. Note that subtype (and quotype) is the type of the subgroup as an abelian p-group.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/abelian/structural/","page":"Structural Computations","title":"Structural Computations","text":"using Hecke # hide\nG = abelian_group([6, 12])\nshapes = MSet{Vector{ZZRingElem}}()\nfor U = psubgroups(G, 2)\n  push!(shapes, elementary_divisors(U[1]))\nend\nshapes","category":"page"},{"location":"Hecke/manual/abelian/structural/","page":"Structural Computations","title":"Structural Computations","text":"So there are 2 subgroups isomorphic to C_4 (ZZRingElem[4] : 2), 1 isomorphic to C_2times C_4, 1 trivial and 3 C_2 subgroups.","category":"page"},{"location":"Hecke/manual/abelian/structural/","page":"Structural Computations","title":"Structural Computations","text":"subgroups(g::FinGenAbGroup)","category":"page"},{"location":"Hecke/manual/abelian/structural/#subgroups-Tuple{FinGenAbGroup}","page":"Structural Computations","title":"subgroups","text":"subgroups(g::FinGenAbGroup;\n          subtype = :all ,\n          quotype = :all,\n          index = -1,\n          order = -1)\n\nReturn an iterator for the subgroups of G of the specific form.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/abelian/structural/","page":"Structural Computations","title":"Structural Computations","text":"for U = subgroups(G, subtype = [2])\n  @show U[1], map(U[2], gens(U[1]))\nend\nfor U = subgroups(G, quotype = [2])\n  @show U[1], map(U[2], gens(U[1]))\nend","category":"page"},{"location":"Hecke/manual/abelian/structural/","page":"Structural Computations","title":"Structural Computations","text":"quo(G::FinGenAbGroup, s::Vector{FinGenAbGroupElem})\nquo(G::FinGenAbGroup, M::ZZMatrix)\nquo(G::FinGenAbGroup, n::Integer)\nquo(G::FinGenAbGroup, n::ZZRingElem)\nquo(G::FinGenAbGroup, U::FinGenAbGroup)","category":"page"},{"location":"Hecke/manual/abelian/structural/#quo-Tuple{FinGenAbGroup, Vector{FinGenAbGroupElem}}","page":"Structural Computations","title":"quo","text":"quo(G::FinGenAbGroup, s::Vector{FinGenAbGroupElem}) -> FinGenAbGroup, GrpAbfinGemMap\n\nCreate the quotient H of G by the subgroup generated by the elements in s, together with the projection p  G to H.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/abelian/structural/#quo-Tuple{FinGenAbGroup, ZZMatrix}","page":"Structural Computations","title":"quo","text":"quo(G::FinGenAbGroup, M::ZZMatrix) -> FinGenAbGroup, FinGenAbGroupHom\n\nCreate the quotient H of G by the subgroup generated by the elements corresponding to the rows of M, together with the projection p  G to H.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/abelian/structural/#quo-Tuple{FinGenAbGroup, Integer}","page":"Structural Computations","title":"quo","text":"quo(G::FinGenAbGroup, n::Integer}) -> FinGenAbGroup, Map\nquo(G::FinGenAbGroup, n::ZZRingElem}) -> FinGenAbGroup, Map\n\nReturns the quotient H = GnG together with the projection p  G to H.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/abelian/structural/#quo-Tuple{FinGenAbGroup, ZZRingElem}","page":"Structural Computations","title":"quo","text":"quo(G::FinGenAbGroup, n::Integer}) -> FinGenAbGroup, Map\nquo(G::FinGenAbGroup, n::ZZRingElem}) -> FinGenAbGroup, Map\n\nReturns the quotient H = GnG together with the projection p  G to H.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/abelian/structural/#quo-Tuple{FinGenAbGroup, FinGenAbGroup}","page":"Structural Computations","title":"quo","text":"quo(G::FinGenAbGroup, U::FinGenAbGroup) -> FinGenAbGroup, Map\n\nCreate the quotient H of G by U, together with the projection p  G to H.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/abelian/structural/","page":"Structural Computations","title":"Structural Computations","text":"For 2 subgroups U and V of the same group G, U+V returns the smallest subgroup of G containing both. Similarly, Ucap V computes the intersection and U subset V tests for inclusion. The difference between issubset = subset and is_subgroup is that the inclusion map is also returned in the 2nd call.","category":"page"},{"location":"Hecke/manual/abelian/structural/","page":"Structural Computations","title":"Structural Computations","text":"intersect(mG::FinGenAbGroupHom, mH::FinGenAbGroupHom)","category":"page"},{"location":"Hecke/manual/abelian/structural/#intersect-Tuple{FinGenAbGroupHom, FinGenAbGroupHom}","page":"Structural Computations","title":"intersect","text":"intersect(mG::FinGenAbGroupHom, mH::FinGenAbGroupHom) -> FinGenAbGroup, Map\n\nGiven two injective maps of abelian groups with the same codomain G, return the intersection of the images as a subgroup of G.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/abelian/structural/#Direct-Products","page":"Structural Computations","title":"Direct Products","text":"","category":"section"},{"location":"Hecke/manual/abelian/structural/","page":"Structural Computations","title":"Structural Computations","text":"direct_product(G::FinGenAbGroup...)\ncanonical_injection(G::FinGenAbGroup, i::Int)\ncanonical_projection(G::FinGenAbGroup, i::Int)\nflat(G::FinGenAbGroup)","category":"page"},{"location":"Hecke/manual/abelian/structural/#direct_product-Tuple{Vararg{FinGenAbGroup}}","page":"Structural Computations","title":"direct_product","text":"direct_product(G::FinGenAbGroup...) -> FinGenAbGroup, Vector{FinGenAbGroupHom}\n\nReturn the direct product D of the (finitely many) abelian groups G_i, together with the projections D to G_i.\n\nFor finite abelian groups, finite direct sums and finite direct products agree and they are therefore called biproducts. If one wants to obtain D as a direct sum together with the injections D to G_i, one should call direct_sum(G...). If one wants to obtain D as a biproduct together with the projections and the injections, one should call biproduct(G...).\n\nOtherwise, one could also call canonical_injections(D) or canonical_projections(D) later on.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/abelian/structural/#canonical_injection-Tuple{FinGenAbGroup, Int64}","page":"Structural Computations","title":"canonical_injection","text":"canonical_injection(G::FinGenAbGroup, i::Int) -> FinGenAbGroupHom\n\nGiven a group G that was created as a direct product, return the injection from the ith component.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/abelian/structural/#canonical_projection-Tuple{FinGenAbGroup, Int64}","page":"Structural Computations","title":"canonical_projection","text":"canonical_projection(G::FinGenAbGroup, i::Int) -> FinGenAbGroupHom\n\nGiven a group G that was created as a direct product, return the projection onto the ith component.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/abelian/structural/#flat-Tuple{FinGenAbGroup}","page":"Structural Computations","title":"flat","text":"flat(G::FinGenAbGroup) -> FinGenAbGroupHom\n\nGiven a group G that is created using (iterated) direct products, or (iterated) tensor products, return a group isomorphism into a flat product: for G = (A oplus B) oplus C, it returns the isomorphism G to A oplus B oplus C (resp. otimes).\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/abelian/structural/#Tensor-Producs","page":"Structural Computations","title":"Tensor Producs","text":"","category":"section"},{"location":"Hecke/manual/abelian/structural/","page":"Structural Computations","title":"Structural Computations","text":"tensor_product(G::FinGenAbGroup...)\nhom_tensor(G::FinGenAbGroup, H::FinGenAbGroup, A::Vector{ <: Map{FinGenAbGroup, FinGenAbGroup}})","category":"page"},{"location":"Hecke/manual/abelian/structural/#tensor_product-Tuple{Vararg{FinGenAbGroup}}","page":"Structural Computations","title":"tensor_product","text":"tensor_product(G::FinGenAbGroup...; task::Symbol = :map) -> FinGenAbGroup, Map\n\nGiven groups G_i, compute the tensor product G_1otimes cdots otimes G_n. If task is set to \":map\", a map phi is returned that maps tuples in G_1 times cdots times G_n to pure tensors g_1 otimes cdots otimes g_n. The map admits a preimage as well.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/abelian/structural/#hom_tensor-Tuple{FinGenAbGroup, FinGenAbGroup, Vector{<:Map{FinGenAbGroup, FinGenAbGroup}}}","page":"Structural Computations","title":"hom_tensor","text":"hom_tensor(G::FinGenAbGroup, H::FinGenAbGroup, A::Vector{ <: Map{FinGenAbGroup, FinGenAbGroup}}) -> Map\n\nGiven groups G = G_1 otimes cdots otimes G_n and H = H_1 otimes cdot otimes H_n as well as maps phi_i G_ito H_i, compute the tensor product of the maps.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/abelian/structural/#Hom-Group","page":"Structural Computations","title":"Hom-Group","text":"","category":"section"},{"location":"Hecke/manual/abelian/structural/","page":"Structural Computations","title":"Structural Computations","text":"hom(::FinGenAbGroup, ::FinGenAbGroup)","category":"page"},{"location":"Hecke/manual/abelian/structural/#hom-Tuple{FinGenAbGroup, FinGenAbGroup}","page":"Structural Computations","title":"hom","text":"hom(G::FinGenAbGroup, H::FinGenAbGroup; task::Symbol = :map) -> FinGenAbGroup, Map\n\nComputes the group of all homomorpisms from G to H as an abstract group. If task is \":map\", then a map phi is computed that can be used to obtain actual homomorphisms. This map also allows preimages. Set task to \":none\" to not compute the map.\n\n\n\n\n\n","category":"method"},{"location":"TropicalGeometry/linear_space/#Tropical-linear-spaces","page":"Tropical linear spaces","title":"Tropical linear spaces","text":"","category":"section"},{"location":"TropicalGeometry/linear_space/#Introduction","page":"Tropical linear spaces","title":"Introduction","text":"","category":"section"},{"location":"TropicalGeometry/linear_space/","page":"Tropical linear spaces","title":"Tropical linear spaces","text":"A tropical linear space is a balanced polyhedral complex supported on a finite intersection of linear tropical hypersurfaces with all multiplicities one.  It is dual to a matroid subdivision of a hypersimplex, and may arise as tropicalizations of linear ideals. For more on tropical linear spaces, see","category":"page"},{"location":"TropicalGeometry/linear_space/","page":"Tropical linear spaces","title":"Tropical linear spaces","text":"Chapter 4.4 in [MS15]\nChapter 10 in [Jos21]","category":"page"},{"location":"TropicalGeometry/linear_space/#Note:","page":"Tropical linear spaces","title":"Note:","text":"","category":"section"},{"location":"TropicalGeometry/linear_space/","page":"Tropical linear spaces","title":"Tropical linear spaces","text":"Objects of type TropicalLinearSpace need to be embedded, abstract tropical linear spaces are currently not supported.\nThe type TropicalLinearSpace can be thought of as subtype of TropicalVariety in the sense that it should have all properties and features of the latter.","category":"page"},{"location":"TropicalGeometry/linear_space/#Constructors","page":"Tropical linear spaces","title":"Constructors","text":"","category":"section"},{"location":"TropicalGeometry/linear_space/","page":"Tropical linear spaces","title":"Tropical linear spaces","text":"In addition to converting from TropicalVariety, objects of type TropicalLinearSpace can be constructed from:","category":"page"},{"location":"TropicalGeometry/linear_space/","page":"Tropical linear spaces","title":"Tropical linear spaces","text":"Pluecker vectors over a tropical semiring: uses a low-level implementation in polymake\nPluecker vectors over a field and a tropical semiring map: computes coordinatewise valuation and uses constructor (1.)\nmatrices over a tropical semiring: computes tropical minors and uses constructor (1.)\nmatrices over a field and a tropical semiring map.\nif matrix over QQ and tropical semiring map is trivial, uses an implementation of Rincon's algorithm [Rin13] in polymake\nfor general input, computes minors and uses constructor (2.)","category":"page"},{"location":"TropicalGeometry/linear_space/","page":"Tropical linear spaces","title":"Tropical linear spaces","text":"tropical_linear_space","category":"page"},{"location":"TropicalGeometry/linear_space/#tropical_linear_space","page":"Tropical linear spaces","title":"tropical_linear_space","text":"tropical_linear_space(Lambda::Vector{Vector{Int}}, p::Vector{<:TropicalSemiringElem}; weighted_polyhedral_complex_only::Bool=false)\n\nReturn a tropical linear space from a tropical Pluecker vector with indices Lambda and values p.  If weighted_polyhedral_complex==true, will not cache any extra information.\n\nExamples\n\njulia> T = tropical_semiring();\n\njulia> plueckerIndices = [[1,2],[1,3],[1,4],[2,3],[2,4],[3,4]];\n\njulia> plueckerVector = T.([0,0,0,0,0,0]);\n\njulia> tropical_linear_space(plueckerIndices,plueckerVector)\nMin tropical linear space\n\n\n\n\n\n\ntropical_linear_space(k::Int, n::Int, p::Vector{<:TropicalSemiringElem}; weighted_polyhedral_complex_only::Bool=false)\n\nReturn a tropical linear space from a tropical Pluecker vector with indices AbstractAlgebra.combinations(1:n,k) and values p.  If weighted_polyhedral_complex==true, will not cache any extra information.\n\nExamples\n\njulia> T = tropical_semiring();\n\njulia> plueckerVector = T.([0,0,0,0,0,0]);\n\njulia> tropical_linear_space(2,4,plueckerVector)\nMin tropical linear space\n\n\n\n\n\n\ntropical_linear_space(Lambda::Vector{Vector{Int}}, p::Vector, nu::TropicalSemiringMap; weighted_polyhedral_complex_only::Bool=false)\n\nReturn a tropical linear space from a tropical Pluecker vector with indices Lambda and values nu(p).  If weighted_polyhedral_complex==true, will not cache any extra information.\n\nExamples\n\njulia> nu = tropical_semiring_map(QQ,2)\nMap into Min tropical semiring encoding the 2-adic valuation on Rational field\n\njulia> plueckerIndices = [[1,2],[1,3],[1,4],[2,3],[2,4],[3,4]];\n\njulia> plueckerVector = QQ.([1,3,5,5,3,1]);\n\njulia> tropical_linear_space(plueckerIndices,plueckerVector,nu)\nMin tropical linear space\n\n\n\n\n\n\ntropical_linear_space(k::Int, n::Int, p::Vector, nu::TropicalSemiringMap; weighted_polyhedral_complex_only::Bool=false)\n\nReturn a tropical linear space from a tropical Pluecker vector with indices AbstractAlgebra.combinations(1:n,k) and values nu(p).  If weighted_polyhedral_complex==true, will not cache any extra information.\n\nExamples\n\njulia> nu = tropical_semiring_map(QQ);\n\njulia> plueckerVector = QQ.([1,3,5,5,3,1]);\n\njulia> tropical_linear_space(2,4,plueckerVector,nu)\nMin tropical linear space\n\n\n\n\n\n\ntropical_linear_space(A::MatElem{<:TropicalSemiringElem}; weighted_polyhedral_complex_only::Bool=false)\n\nReturn a tropical linear space whose Pluecker vector are the tropical minors of A.  Assumes that ncols(A)>=nrows(A).  If weighted_polyhedral_complex==true, will not cache any extra information.\n\nExamples\n\njulia> A = matrix(tropical_semiring(),[[1,2,4,8],[8,4,2,1]])\n[(1)   (2)   (4)   (8)]\n[(8)   (4)   (2)   (1)]\n\njulia> tropical_linear_space(A)\nMin tropical linear space\n\n\n\n\n\n\ntropical_linear_space(A::MatElem,nu::TropicalSemiringMap; weighted_polyhedral_complex_only::Bool=false)\n\nReturn a tropical linear space whose Pluecker vector is nu applied to the minors of A.  If weighted_polyhedral_complex==true, will not cache any extra information.\n\nExamples\n\njulia> nu = tropical_semiring_map(QQ,2)\nMap into Min tropical semiring encoding the 2-adic valuation on Rational field\n\njulia> A = matrix(QQ,[[1,2,4,8],[8,4,2,1]])\n[1   2   4   8]\n[8   4   2   1]\n\njulia> tropical_linear_space(A, nu)\nMin tropical linear space\n\n\n\n\n\n\ntropical_linear_space(I::MPolyIdeal, nu::TropicalSemiringMap; weighted_polyhedral_complex_only::Bool=false)\n\nReturn the tropicalization of the vanishing set of I with respect to the tropical semiring map nu.  Requires the generators of I to be linear and homogeneous.  If weighted_polyhedral_complex==true, will not cache any extra information.\n\nExamples\n\njulia> R,(x1,x2,x3,x4) = polynomial_ring(QQ,4);\n\njulia> I = ideal(R,[-x1+x3,-x2+x4])\nIdeal generated by\n  -x1 + x3\n  -x2 + x4\n\njulia> nu = tropical_semiring_map(QQ)\nMap into Min tropical semiring encoding the trivial valuation on Rational field\n\njulia> tropical_linear_space(I, nu)\nMin tropical linear space\n\n\n\n\n\n\n","category":"function"},{"location":"TropicalGeometry/linear_space/#Properties","page":"Tropical linear spaces","title":"Properties","text":"","category":"section"},{"location":"TropicalGeometry/linear_space/","page":"Tropical linear spaces","title":"Tropical linear spaces","text":"In addition to the properties inherited from TropicalVariety, objects of type TropicalLinearSpace have the following exclusive properties:","category":"page"},{"location":"TropicalGeometry/linear_space/","page":"Tropical linear spaces","title":"Tropical linear spaces","text":"pluecker_indices(TropL::TropicalLinearSpace)\ntropical_pluecker_vector(TropL::TropicalLinearSpace)\nalgebraic_pluecker_vector(TropL::TropicalLinearSpace)\ntropical_semiring_map(TropL::TropicalLinearSpace)\ntropical_matrix(TropL::TropicalLinearSpace)\nalgebraic_matrix(TropL::TropicalLinearSpace)\nalgebraic_ideal(TropL::TropicalLinearSpace)","category":"page"},{"location":"TropicalGeometry/linear_space/#pluecker_indices-Tuple{TropicalLinearSpace}","page":"Tropical linear spaces","title":"pluecker_indices","text":"pluecker_indices(TropL::TropicalLinearSpace)\n\nReturn the Pluecker indices used to construct TropL.\n\n\n\n\n\n","category":"method"},{"location":"TropicalGeometry/linear_space/#tropical_pluecker_vector-Tuple{TropicalLinearSpace}","page":"Tropical linear spaces","title":"tropical_pluecker_vector","text":"tropical_pluecker_vector(TropL::TropicalLinearSpace)\n\nReturn the tropical Pluecker vector of TropL.\n\n\n\n\n\n","category":"method"},{"location":"TropicalGeometry/linear_space/#algebraic_pluecker_vector-Tuple{TropicalLinearSpace}","page":"Tropical linear spaces","title":"algebraic_pluecker_vector","text":"algebraic_pluecker_vector(TropL::TropicalLinearSpace)\n\nReturn the Pluecker vector over a valued field used to construct TropL.\n\n\n\n\n\n","category":"method"},{"location":"TropicalGeometry/linear_space/#tropical_semiring_map-Tuple{TropicalLinearSpace}","page":"Tropical linear spaces","title":"tropical_semiring_map","text":"tropical_semiring_map(TropL::TropicalLinearSpace)\n\nReturn the tropical semiring map used to construct TropL.  Raises an error, if it is not cached.\n\n\n\n\n\n","category":"method"},{"location":"TropicalGeometry/linear_space/#tropical_matrix-Tuple{TropicalLinearSpace}","page":"Tropical linear spaces","title":"tropical_matrix","text":"tropical_matrix(TropL::TropicalLinearSpace)\n\nReturn the tropical matrix used to construct TropL.  Raises an error, if it is not cached.\n\n\n\n\n\n","category":"method"},{"location":"TropicalGeometry/linear_space/#algebraic_matrix-Tuple{TropicalLinearSpace}","page":"Tropical linear spaces","title":"algebraic_matrix","text":"algebraic_matrix(TropL::TropicalLinearSpace)\n\nReturn the matrix over a valued field used to construct TropL.\n\n\n\n\n\n","category":"method"},{"location":"TropicalGeometry/linear_space/#algebraic_ideal-Tuple{TropicalLinearSpace}","page":"Tropical linear spaces","title":"algebraic_ideal","text":"algebraic_ideal(TropL::TropicalLinearSpace)\n\nReturn the polynomial ideal over a valued field used to construct TropL. Raises an error, if it is not cached.\n\n\n\n\n\n","category":"method"},{"location":"AlgebraicGeometry/ToricVarieties/CyclicQuotientSingularities/","page":"Cyclic Quotient Singularities","title":"Cyclic Quotient Singularities","text":"CurrentModule = Oscar","category":"page"},{"location":"AlgebraicGeometry/ToricVarieties/CyclicQuotientSingularities/#Cyclic-Quotient-Singularities","page":"Cyclic Quotient Singularities","title":"Cyclic Quotient Singularities","text":"","category":"section"},{"location":"AlgebraicGeometry/ToricVarieties/CyclicQuotientSingularities/#Introduction","page":"Cyclic Quotient Singularities","title":"Introduction","text":"","category":"section"},{"location":"AlgebraicGeometry/ToricVarieties/CyclicQuotientSingularities/","page":"Cyclic Quotient Singularities","title":"Cyclic Quotient Singularities","text":"Cyclic quotient singularities are quotients of mathbbC^2 by the action of mathbbZnmathbbZ acting via  left(beginarrayccxi  00  xi^qendarrayright), where xi is a n-th root of unity, and q and n are integers, such that q is coprime with n, and 0qn.","category":"page"},{"location":"AlgebraicGeometry/ToricVarieties/CyclicQuotientSingularities/","page":"Cyclic Quotient Singularities","title":"Cyclic Quotient Singularities","text":"For the notation we rely on [Chr91] and [Ste91].","category":"page"},{"location":"AlgebraicGeometry/ToricVarieties/CyclicQuotientSingularities/","page":"Cyclic Quotient Singularities","title":"Cyclic Quotient Singularities","text":"warning: Warning\nNote that [Chr91] and [Ste91] use Hirzebruch-Jung continued fraction, which differ from the commonly known continued fraction from literature and used in the rest of OSCAR.","category":"page"},{"location":"AlgebraicGeometry/ToricVarieties/CyclicQuotientSingularities/#Constructors","page":"Cyclic Quotient Singularities","title":"Constructors","text":"","category":"section"},{"location":"AlgebraicGeometry/ToricVarieties/CyclicQuotientSingularities/","page":"Cyclic Quotient Singularities","title":"Cyclic Quotient Singularities","text":"cyclic_quotient_singularity(n::T, q::T) where {T <: IntegerUnion}","category":"page"},{"location":"AlgebraicGeometry/ToricVarieties/CyclicQuotientSingularities/#cyclic_quotient_singularity-Union{Tuple{T}, Tuple{T, T}} where T<:Union{Integer, ZZRingElem}","page":"Cyclic Quotient Singularities","title":"cyclic_quotient_singularity","text":"cyclic_quotient_singularity(n::ZZRingElem, q::ZZRingElem)\n\nReturn the cyclic quotient singularity for the parameters n and q, with 0qn and q n coprime.\n\nExamples\n\njulia> cqs = cyclic_quotient_singularity(7, 5)\nCyclic quotient singularity Y(7, 5)\n\njulia> is_affine(cqs)\ntrue\n\njulia> is_smooth(cqs)\nfalse\n\n\n\n\n\n","category":"method"},{"location":"AlgebraicGeometry/ToricVarieties/CyclicQuotientSingularities/#Attributes","page":"Cyclic Quotient Singularities","title":"Attributes","text":"","category":"section"},{"location":"AlgebraicGeometry/ToricVarieties/CyclicQuotientSingularities/","page":"Cyclic Quotient Singularities","title":"Cyclic Quotient Singularities","text":"continued_fraction_hirzebruch_jung(cqs::CyclicQuotientSingularity)\ndual_continued_fraction_hirzebruch_jung(cqs::CyclicQuotientSingularity)","category":"page"},{"location":"AlgebraicGeometry/ToricVarieties/CyclicQuotientSingularities/#continued_fraction_hirzebruch_jung-Tuple{CyclicQuotientSingularity}","page":"Cyclic Quotient Singularities","title":"continued_fraction_hirzebruch_jung","text":"continued_fraction_hirzebruch_jung(cqs::CyclicQuotientSingularity)\n\nReturn the Hirzebruch-Jung continued fraction associated with the cyclic quotient singularity, i.e. the Hirzebruch-Jung continued fraction corresponding to nq.\n\nThe rational number corresponding to a Hirzebruch-Jung continued fraction c_1 c_2ldots c_n is r(c_1 c_2ldots c_n) =\nc_1-frac1r(c_2ldots c_n) where r(c_n) = c_n.  Note that this is differs in sign from what is commonly known as continued fraction.\n\nExamples\n\njulia> cqs = cyclic_quotient_singularity(7, 5)\nCyclic quotient singularity Y(7, 5)\n\njulia> cf = continued_fraction_hirzebruch_jung(cqs)\n3-element Vector{ZZRingElem}:\n 2\n 2\n 3\n\njulia> ecf = cf[1]-1//(cf[2]-QQFieldElem(1, cf[3]))\n7//5\n\n\n\n\n\n","category":"method"},{"location":"AlgebraicGeometry/ToricVarieties/CyclicQuotientSingularities/#dual_continued_fraction_hirzebruch_jung-Tuple{CyclicQuotientSingularity}","page":"Cyclic Quotient Singularities","title":"dual_continued_fraction_hirzebruch_jung","text":"dual_continued_fraction_hirzebruch_jung(cqs::CyclicQuotientSingularity)\n\nReturn the dual Hirzebruch-Jung continued fraction associated with the cyclic quotient singularity, i.e. the Hirzebruch-Jung continued fraction corresponding to q(n-q).\n\nThe rational number corresponding to a Hirzebruch-Jung continued fraction c_1 c_2ldots c_n is r(c_1 c_2ldots c_n) =\nc_1-frac1r(c_2ldots c_n) where r(c_n) = c_n.  Note that this is differs in sign from what is commonly known as continued fraction.\n\nExamples\n\njulia> cqs = cyclic_quotient_singularity(7, 5)\nCyclic quotient singularity Y(7, 5)\n\njulia> dcf = dual_continued_fraction_hirzebruch_jung(cqs)\n2-element Vector{ZZRingElem}:\n 4\n 2\n\njulia> edcf = dcf[1] - QQFieldElem(1, dcf[2])\n7//2\n\n\n\n\n\n","category":"method"},{"location":"AlgebraicGeometry/ToricVarieties/CyclicQuotientSingularities/#Auxiliary-Methods","page":"Cyclic Quotient Singularities","title":"Auxiliary Methods","text":"","category":"section"},{"location":"AlgebraicGeometry/ToricVarieties/CyclicQuotientSingularities/","page":"Cyclic Quotient Singularities","title":"Cyclic Quotient Singularities","text":"continued_fraction_hirzebruch_jung_to_rational(v::Vector{ZZRingElem})\nrational_to_continued_fraction_hirzebruch_jung(r::QQFieldElem)","category":"page"},{"location":"AlgebraicGeometry/ToricVarieties/CyclicQuotientSingularities/#continued_fraction_hirzebruch_jung_to_rational-Tuple{Vector{ZZRingElem}}","page":"Cyclic Quotient Singularities","title":"continued_fraction_hirzebruch_jung_to_rational","text":"continued_fraction_hirzebruch_jung_to_rational(v::Vector{ZZRingElem})\n\nReturn the rational number corresponding to a Hirzebruch-Jung continued fraction given as a vector of (positive) integers.\n\nThe rational number corresponding to a Hirzebruch-Jung continued fraction c_1 c_2ldots c_n is r(c_1 c_2ldots c_n) =\nc_1-frac1r(c_2ldots c_n) where r(c_n) = c_n.  Note that this is differs in sign from what is commonly known as continued fraction.\n\nExamples\n\njulia> cqs = cyclic_quotient_singularity(7, 5)\nCyclic quotient singularity Y(7, 5)\n\njulia> v = continued_fraction_hirzebruch_jung(cqs)\n3-element Vector{ZZRingElem}:\n 2\n 2\n 3\n\njulia> continued_fraction_hirzebruch_jung_to_rational(v)\n7//5\n\n\n\n\n\n","category":"method"},{"location":"AlgebraicGeometry/ToricVarieties/CyclicQuotientSingularities/#rational_to_continued_fraction_hirzebruch_jung-Tuple{QQFieldElem}","page":"Cyclic Quotient Singularities","title":"rational_to_continued_fraction_hirzebruch_jung","text":"rational_to_continued_fraction_hirzebruch_jung(r::QQFieldElem)\n\nEncode a (positive) rational number as a Hirzebruch-Jung continued fraction, i.e. find the Hirzebruch-Jung continued fraction corresponding to the given rational number.\n\nThe rational number corresponding to a Hirzebruch-Jung continued fraction c_1 c_2ldots c_n is r(c_1 c_2ldots c_n) =\nc_1-frac1r(c_2ldots c_n) where r(c_n) = c_n.  Note that this is differs in sign from what is commonly known as continued fraction.\n\nExamples\n\njulia> r = QQFieldElem(2464144958, 145732115)\n2464144958//145732115\n\njulia> cf = rational_to_continued_fraction_hirzebruch_jung(r)\n7-element Vector{ZZRingElem}:\n 17\n 11\n 23\n 46\n 18\n 19\n 37\n\njulia> continued_fraction_hirzebruch_jung_to_rational(cf)\n2464144958//145732115\n\njulia> r == continued_fraction_hirzebruch_jung_to_rational(cf)\ntrue\n\n\n\n\n\n","category":"method"},{"location":"AlgebraicGeometry/ToricVarieties/cohomCalg/","page":"Line bundle cohomology with cohomCalg","title":"Line bundle cohomology with cohomCalg","text":"CurrentModule = Oscar","category":"page"},{"location":"AlgebraicGeometry/ToricVarieties/cohomCalg/#Line-bundle-cohomology-with-cohomCalg","page":"Line bundle cohomology with cohomCalg","title":"Line bundle cohomology with cohomCalg","text":"","category":"section"},{"location":"AlgebraicGeometry/ToricVarieties/cohomCalg/","page":"Line bundle cohomology with cohomCalg","title":"Line bundle cohomology with cohomCalg","text":"We employ the cohomCalg algorithm [BJRR10*1] to compute the dimension of line bundle cohomologies as well as vanishing sets.","category":"page"},{"location":"AlgebraicGeometry/ToricVarieties/cohomCalg/#Dimensions-of-line-bundle-cohomology","page":"Line bundle cohomology with cohomCalg","title":"Dimensions of line bundle cohomology","text":"","category":"section"},{"location":"AlgebraicGeometry/ToricVarieties/cohomCalg/","page":"Line bundle cohomology with cohomCalg","title":"Line bundle cohomology with cohomCalg","text":"all_cohomologies(l::ToricLineBundle)\ncohomology(l::ToricLineBundle, i::Int)","category":"page"},{"location":"AlgebraicGeometry/ToricVarieties/cohomCalg/#all_cohomologies-Tuple{ToricLineBundle}","page":"Line bundle cohomology with cohomCalg","title":"all_cohomologies","text":"all_cohomologies(l::ToricLineBundle)\n\nComputes the dimension of all sheaf cohomologies of the  toric line bundle l by use of the cohomCalg algorithm  [BJRR10], [BJRR10*1] (see also [RR10], [Jow11] and [BJRR12]).\n\nExamples\n\njulia> dP3 = del_pezzo_surface(NormalToricVariety, 3)\nNormal toric variety\n\njulia> all_cohomologies(toric_line_bundle(dP3, [1, 2, 3, 4]))\n3-element Vector{ZZRingElem}:\n 0\n 16\n 0\n\n\n\n\n\n","category":"method"},{"location":"AlgebraicGeometry/ToricVarieties/cohomCalg/#cohomology-Tuple{ToricLineBundle, Int64}","page":"Line bundle cohomology with cohomCalg","title":"cohomology","text":"cohomology(l::ToricLineBundle, i::Int)\n\nComputes the dimension of the i-th sheaf cohomology of the toric line bundle l by use of the cohomCalg algorithm [BJRR10], [BJRR10*1] (see also [RR10], [Jow11] and [BJRR12]).\n\nExamples\n\njulia> dP3 = del_pezzo_surface(NormalToricVariety, 3)\nNormal toric variety\n\njulia> cohomology(toric_line_bundle(dP3, [4, 1, 1, 1]), 0)\n12\n\n\n\n\n\n","category":"method"},{"location":"AlgebraicGeometry/ToricVarieties/cohomCalg/#Toric-vanishing-sets","page":"Line bundle cohomology with cohomCalg","title":"Toric vanishing sets","text":"","category":"section"},{"location":"AlgebraicGeometry/ToricVarieties/cohomCalg/","page":"Line bundle cohomology with cohomCalg","title":"Line bundle cohomology with cohomCalg","text":"Vanishing sets describe subsets of the Picard group of toric varieties. Their computations is based on [BJRR10*1], i.e. this functionality is only available if the toric variety in question is either smooth and complete or alternatively, simplicial and projective. This approach to identify vanishing sets on toric varieties was originally introduced in [Bie18]. As described there, on a technical level, a vanishing set is the complement of a finite family of polyhedra.","category":"page"},{"location":"AlgebraicGeometry/ToricVarieties/cohomCalg/","page":"Line bundle cohomology with cohomCalg","title":"Line bundle cohomology with cohomCalg","text":"For a toric variety, all vanishing sets are computed as follows:","category":"page"},{"location":"AlgebraicGeometry/ToricVarieties/cohomCalg/","page":"Line bundle cohomology with cohomCalg","title":"Line bundle cohomology with cohomCalg","text":"vanishing_sets(variety::NormalToricVarietyType)","category":"page"},{"location":"AlgebraicGeometry/ToricVarieties/cohomCalg/#vanishing_sets-Tuple{Union{AffineNormalToricVariety, CyclicQuotientSingularity, NormalToricVariety}}","page":"Line bundle cohomology with cohomCalg","title":"vanishing_sets","text":"vanishing_sets(variety::NormalToricVarietyType)\n\nCompute the vanishing sets of an abstract toric variety v by use of the cohomCalg algorithm.\n\n\n\n\n\n","category":"method"},{"location":"AlgebraicGeometry/ToricVarieties/cohomCalg/","page":"Line bundle cohomology with cohomCalg","title":"Line bundle cohomology with cohomCalg","text":"The return value is a vector of vanishing sets. This vector has length one larger than the dimension of the variety in question. The first vanishing set in this vector describes all line bundles for which the zero-th sheaf cohomology vanishes. More generally, if a line bundle is contained in the n-th vanishing set, then its n-1-th sheaf cohomology vanishes. The following method checks if a line bundle is contained in a vanishing set:","category":"page"},{"location":"AlgebraicGeometry/ToricVarieties/cohomCalg/","page":"Line bundle cohomology with cohomCalg","title":"Line bundle cohomology with cohomCalg","text":"contains(tvs::ToricVanishingSet, l::ToricLineBundle)","category":"page"},{"location":"AlgebraicGeometry/ToricVarieties/cohomCalg/#contains-Tuple{ToricVanishingSet, ToricLineBundle}","page":"Line bundle cohomology with cohomCalg","title":"contains","text":"contains(tvs::ToricVanishingSet, l::ToricLineBundle)\n\nChecks if the toric line bundle l is contained in the toric vanishing set tvs.\n\nExamples\n\njulia> dP1 = del_pezzo_surface(NormalToricVariety, 1)\nNormal toric variety\n\njulia> l = toric_line_bundle(dP1, [3, 2])\nToric line bundle on a normal toric variety\n\njulia> all_cohomologies(l)\n3-element Vector{ZZRingElem}:\n 7\n 0\n 0\n\njulia> vs = vanishing_sets(dP1)\n3-element Vector{ToricVanishingSet}:\n Toric vanishing set for cohomology indices [0]\n Toric vanishing set for cohomology indices [1]\n Toric vanishing set for cohomology indices [2]\n\njulia> contains(vs[1], l)\nfalse\n\njulia> contains(vs[2], l)\ntrue\n\njulia> contains(vs[3], l)\ntrue\n\n\n\n\n\n","category":"method"},{"location":"AlgebraicGeometry/ToricVarieties/cohomCalg/","page":"Line bundle cohomology with cohomCalg","title":"Line bundle cohomology with cohomCalg","text":"A vanishing set can in principle cover the entire Picard group. This can be checked with isfull. This methods returns true if the vanishing set is the entire Picard group and false otherwise. Beyond this, we support the following attributes for vanishing sets:","category":"page"},{"location":"AlgebraicGeometry/ToricVarieties/cohomCalg/","page":"Line bundle cohomology with cohomCalg","title":"Line bundle cohomology with cohomCalg","text":"toric_variety(tvs::ToricVanishingSet)\npolyhedra(tvs::ToricVanishingSet)\ncohomology_indices(tvs::ToricVanishingSet)","category":"page"},{"location":"AlgebraicGeometry/ToricVarieties/cohomCalg/#toric_variety-Tuple{ToricVanishingSet}","page":"Line bundle cohomology with cohomCalg","title":"toric_variety","text":"toric_variety(tvs::ToricVanishingSet)\n\nReturn the toric variety of the vanishing set tvs.\n\nExamples\n\njulia> dP1 = del_pezzo_surface(NormalToricVariety, 1)\nNormal toric variety\n\njulia> vs = vanishing_sets(dP1)\n3-element Vector{ToricVanishingSet}:\n Toric vanishing set for cohomology indices [0]\n Toric vanishing set for cohomology indices [1]\n Toric vanishing set for cohomology indices [2]\n\njulia> toric_variety(vs[3])\nNormal, 2-dimensional toric variety without torusfactor\n\n\n\n\n\n","category":"method"},{"location":"AlgebraicGeometry/ToricVarieties/cohomCalg/#polyhedra-Tuple{ToricVanishingSet}","page":"Line bundle cohomology with cohomCalg","title":"polyhedra","text":"polyhedra(tvs::ToricVanishingSet)\n\nReturn the vector of the polyhedra whose complement defines the vanishing set tvs.\n\nExamples\n\njulia> dP1 = del_pezzo_surface(NormalToricVariety, 1)\nNormal toric variety\n\njulia> vs = vanishing_sets(dP1)\n3-element Vector{ToricVanishingSet}:\n Toric vanishing set for cohomology indices [0]\n Toric vanishing set for cohomology indices [1]\n Toric vanishing set for cohomology indices [2]\n\njulia> polyhedra(vs[3])\n1-element Vector{Polyhedron{QQFieldElem}}:\n Polyhedron in ambient dimension 2\n\n\n\n\n\n","category":"method"},{"location":"AlgebraicGeometry/ToricVarieties/cohomCalg/#cohomology_indices-Tuple{ToricVanishingSet}","page":"Line bundle cohomology with cohomCalg","title":"cohomology_indices","text":"cohomology_indices(tvs::ToricVanishingSet)\n\nReturn the cohomology indices of the toric vanishing set tvs.\n\nExamples\n\njulia> dP1 = del_pezzo_surface(NormalToricVariety, 1)\nNormal toric variety\n\njulia> vs = vanishing_sets(dP1)\n3-element Vector{ToricVanishingSet}:\n Toric vanishing set for cohomology indices [0]\n Toric vanishing set for cohomology indices [1]\n Toric vanishing set for cohomology indices [2]\n\njulia> cohomology_indices(vs[3])\n1-element Vector{Int64}:\n 2\n\n\n\n\n\n","category":"method"},{"location":"AlgebraicGeometry/ToricVarieties/cohomCalg/","page":"Line bundle cohomology with cohomCalg","title":"Line bundle cohomology with cohomCalg","text":"Certainly, this also allows to compute the immaculate line bundles:","category":"page"},{"location":"AlgebraicGeometry/ToricVarieties/cohomCalg/","page":"Line bundle cohomology with cohomCalg","title":"Line bundle cohomology with cohomCalg","text":"immaculate_line_bundles(variety::NormalToricVarietyType)","category":"page"},{"location":"AlgebraicGeometry/ToricVarieties/cohomCalg/#immaculate_line_bundles-Tuple{Union{AffineNormalToricVariety, CyclicQuotientSingularity, NormalToricVariety}}","page":"Line bundle cohomology with cohomCalg","title":"immaculate_line_bundles","text":"immaculate_line_bundles(variety::NormalToricVarietyType)\n\nComputes all immaculate line bundles as a toric vanishing set by intersecting the vanishing sets for all cohomology indices.\n\nExamples\n\njulia> dP1 = del_pezzo_surface(NormalToricVariety, 1)\nNormal toric variety\n\njulia> ilb = immaculate_line_bundles(dP1)\nToric vanishing set for cohomology indices [0, 1, 2]\n\njulia> polyhedra(ilb)\n4-element Vector{Polyhedron{QQFieldElem}}:\n Polyhedron in ambient dimension 2\n Polyhedron in ambient dimension 2\n Polyhedron in ambient dimension 2\n Polyhedron in ambient dimension 2\n\njulia> print_constraints(polyhedra(ilb)[1])\n-x_1 <= 0\n-x_1 + x_2 <= 0\n\njulia> print_constraints(polyhedra(ilb)[2])\n-x_1 + x_2 <= 0\nx_2 <= -2\n\njulia> print_constraints(polyhedra(ilb)[3])\n-x_2 <= -1\nx_1 - x_2 <= -2\n\njulia> print_constraints(polyhedra(ilb)[4])\nx_1 - x_2 <= -2\nx_1 <= -3\n\n\n\n\n\n","category":"method"},{"location":"CommutativeAlgebra/localizations/","page":"Localized Rings and Their Ideals","title":"Localized Rings and Their Ideals","text":"CurrentModule = Oscar\nDocTestSetup = Oscar.doctestsetup()","category":"page"},{"location":"CommutativeAlgebra/localizations/#Localized-Rings-and-Their-Ideals","page":"Localized Rings and Their Ideals","title":"Localized Rings and Their Ideals","text":"","category":"section"},{"location":"CommutativeAlgebra/localizations/","page":"Localized Rings and Their Ideals","title":"Localized Rings and Their Ideals","text":"We recall the definition of localization. All rings considered are commutative,  with multiplicative identity 1. Let R be a ring, and let U subset R be a multiplicatively closed subset. That is,","category":"page"},{"location":"CommutativeAlgebra/localizations/","page":"Localized Rings and Their Ideals","title":"Localized Rings and Their Ideals","text":"1 in U  text and   u v in U Rightarrow  ucdot v in U","category":"page"},{"location":"CommutativeAlgebra/localizations/","page":"Localized Rings and Their Ideals","title":"Localized Rings and Their Ideals","text":"Consider the equivalence relation on Rtimes U defined by setting","category":"page"},{"location":"CommutativeAlgebra/localizations/","page":"Localized Rings and Their Ideals","title":"Localized Rings and Their Ideals","text":"(ru)sim (r u) text iff  v(r u-u r)=0 text for some  vin U","category":"page"},{"location":"CommutativeAlgebra/localizations/","page":"Localized Rings and Their Ideals","title":"Localized Rings and Their Ideals","text":"Write fracru for the equivalence class of (r u) and RU^-1 for the set of all equivalence classes. Mimicking the standard arithmetic for fractions, RU^-1 can be made into a ring. This ring is called the localization of R at U. It comes equipped with  the natural ring homomorphism","category":"page"},{"location":"CommutativeAlgebra/localizations/","page":"Localized Rings and Their Ideals","title":"Localized Rings and Their Ideals","text":"iota  Rto RU^-1 r mapsto fracr1","category":"page"},{"location":"CommutativeAlgebra/localizations/","page":"Localized Rings and Their Ideals","title":"Localized Rings and Their Ideals","text":"Given an R-module M, the analogous construction yields an RU^-1-module MU^-1 which is called the localization  of M at U. See the section on modules.","category":"page"},{"location":"CommutativeAlgebra/localizations/","page":"Localized Rings and Their Ideals","title":"Localized Rings and Their Ideals","text":"Our focus in this section is on localizing multivariate polynomial rings and their quotients. The starting point for this is to provide functionality for handling (several types of) multiplicatively closed subsets of multivariate polynomial rings. Given such a polynomial ring R and a multiplicatively closed subset U of R whose type is supported by OSCAR, entering localization(R, U) creates the localization of R at U. Given a quotient RQ of R, with projection map p : R to RQ, and given a multiplicatively closed subset U of R, entering localization(RQ, U) creates the localization of RQ at p(U): Since every multiplicatively closed subset of RQ is of type p(U) for some U, there is no need to support an extra type for multiplicatively closed subsets of quotients.","category":"page"},{"location":"CommutativeAlgebra/localizations/","page":"Localized Rings and Their Ideals","title":"Localized Rings and Their Ideals","text":"note: Note\nMost functions described here rely on the computation of standard bases. Recall that OSCAR supports standard bases for multivariate polynomial rings over fields (exact fields supported by OSCAR) and for multivariate polynomial rings over the integers.","category":"page"},{"location":"CommutativeAlgebra/localizations/#Types","page":"Localized Rings and Their Ideals","title":"Types","text":"","category":"section"},{"location":"CommutativeAlgebra/localizations/","page":"Localized Rings and Their Ideals","title":"Localized Rings and Their Ideals","text":"The OSCAR types discussed in this section are all parametrized. To simplify the presentation, details on the parameters are omitted.","category":"page"},{"location":"CommutativeAlgebra/localizations/","page":"Localized Rings and Their Ideals","title":"Localized Rings and Their Ideals","text":"All types for multiplicatively closed subsets of rings belong to the abstract type AbsMultSet. For multiplicatively closed subsets of multivariate polynomial rings, there are the abstract subtype AbsPolyMultSet and its concrete descendants MPolyComplementOfKPointIdeal, MPolyComplementOfPrimeIdeal, and MPolyPowersOfElement.","category":"page"},{"location":"CommutativeAlgebra/localizations/","page":"Localized Rings and Their Ideals","title":"Localized Rings and Their Ideals","text":"The general abstract type for localizations of rings is AbsLocalizedRing. For localizations of multivariate polynomial rings, there is the concrete subtype MPolyLocRing. For localizations of quotients of multivariate polynomial rings, there is the concrete subtype MPolyQuoLocRing.","category":"page"},{"location":"CommutativeAlgebra/localizations/#Constructors","page":"Localized Rings and Their Ideals","title":"Constructors","text":"","category":"section"},{"location":"CommutativeAlgebra/localizations/#Multiplicatively-Closed-Subsets","page":"Localized Rings and Their Ideals","title":"Multiplicatively Closed Subsets","text":"","category":"section"},{"location":"CommutativeAlgebra/localizations/","page":"Localized Rings and Their Ideals","title":"Localized Rings and Their Ideals","text":"In accordance with the above mentioned types, we have the following constructors for multiplicatively closed subsets of multivariate polynomial rings.","category":"page"},{"location":"CommutativeAlgebra/localizations/","page":"Localized Rings and Their Ideals","title":"Localized Rings and Their Ideals","text":"complement_of_point_ideal(R::MPolyRing, a::Vector)\ncomplement_of_prime_ideal(P::MPolyIdeal; check::Bool=false)\npowers_of_element(f::MPolyRingElem)","category":"page"},{"location":"CommutativeAlgebra/localizations/#complement_of_point_ideal-Tuple{MPolyRing, Vector}","page":"Localized Rings and Their Ideals","title":"complement_of_point_ideal","text":"complement_of_point_ideal(R::MPolyRing, a::Vector)\n\nGiven a polynomial ring R, say R = Kx_1dots x_n, and given a vector  a = (a_1 dots a_n) of n elements of K, return the multiplicatively  closed subset Rsetminus m, where m is the maximal ideal \n\nm = langle x_1-a_1dots x_n-a_nrangle subset R\n\nExamples\n\njulia> R, (x, y, z) = polynomial_ring(QQ, [:x, :y, :z]);\n\njulia> U = complement_of_point_ideal(R, [0, 0 ,0])\nComplement\n  of maximal ideal corresponding to rational point with coordinates (0, 0, 0)\n  in multivariate polynomial ring in 3 variables over QQ\n\n\n\n\n\n\n","category":"method"},{"location":"CommutativeAlgebra/localizations/#complement_of_prime_ideal-Tuple{MPolyIdeal}","page":"Localized Rings and Their Ideals","title":"complement_of_prime_ideal","text":"complement_of_prime_ideal(P::MPolyIdeal; check::Bool=true)\n\nGiven a prime ideal P of a polynomial ring R, say, return the multiplicatively closed subset Rsetminus P\n\nnote: Note\nSince  check is set to true, the function checks whether P is indeed a prime ideal. This may take some time.\n\nExamples\n\njulia> R, (x, y, z) = polynomial_ring(QQ, [:x, :y, :z]);\n\njulia> P = ideal(R, [x])\nIdeal generated by\n  x\n\njulia> U = complement_of_prime_ideal(P)\nComplement\n  of prime ideal (x)\n  in multivariate polynomial ring in 3 variables over QQ\n\n\n\n\n\n","category":"method"},{"location":"CommutativeAlgebra/localizations/#powers_of_element-Tuple{MPolyRingElem}","page":"Localized Rings and Their Ideals","title":"powers_of_element","text":"powers_of_element(f::MPolyRingElem)\n\nGiven an element f of a polynomial ring, return the multiplicatively  closed subset of the polynomial ring which is formed by the powers of f.\n\nExamples\n\njulia> R, (x, y, z) = polynomial_ring(QQ, [:x, :y, :z]);\n\njulia> f = x\nx\n\njulia> U = powers_of_element(f)\nMultiplicative subset\n  of multivariate polynomial ring in 3 variables over QQ\n  given by the products of [x]\n\n\n\n\n\n","category":"method"},{"location":"CommutativeAlgebra/localizations/","page":"Localized Rings and Their Ideals","title":"Localized Rings and Their Ideals","text":"It is also possible to build products of multiplicatively closed sets already given:","category":"page"},{"location":"CommutativeAlgebra/localizations/","page":"Localized Rings and Their Ideals","title":"Localized Rings and Their Ideals","text":"product(T::AbsMPolyMultSet, U::AbsMPolyMultSet)","category":"page"},{"location":"CommutativeAlgebra/localizations/#product-Tuple{Oscar.AbsMPolyMultSet, Oscar.AbsMPolyMultSet}","page":"Localized Rings and Their Ideals","title":"product","text":"product(T::AbsMPolyMultSet, U::AbsMPolyMultSet)\n\nReturn the product of the multiplicative subsets T and U. \n\nAlternatively, write T*U.\n\nExamples\n\njulia> R, (x, y, z) = polynomial_ring(QQ, [:x, :y, :z]);\n\njulia> T = complement_of_point_ideal(R, [0, 0 ,0])\nComplement\n  of maximal ideal corresponding to rational point with coordinates (0, 0, 0)\n  in multivariate polynomial ring in 3 variables over QQ\n\njulia> f = x\nx\n\njulia> U = powers_of_element(f)\nMultiplicative subset\n  of multivariate polynomial ring in 3 variables over QQ\n  given by the products of [x]\n\njulia> S = product(T, U)\nProduct of the multiplicative sets\n  complement of maximal ideal of point (0, 0, 0)\n  products of (x)\n\n\n\n\n\n","category":"method"},{"location":"CommutativeAlgebra/localizations/","page":"Localized Rings and Their Ideals","title":"Localized Rings and Their Ideals","text":"Containment in multiplicatively closed subsets can be checked via the in function:","category":"page"},{"location":"CommutativeAlgebra/localizations/","page":"Localized Rings and Their Ideals","title":"Localized Rings and Their Ideals","text":"in(f::MPolyRingElem, U::AbsMPolyMultSet)","category":"page"},{"location":"CommutativeAlgebra/localizations/#in-Tuple{MPolyRingElem, Oscar.AbsMPolyMultSet}","page":"Localized Rings and Their Ideals","title":"in","text":"in(f::MPolyRingElem, U::AbsMPolyMultSet)\n\nReturn true if f is contained in U, false otherwise.\n\nExamples\n\njulia> R, (x, y, z) = polynomial_ring(QQ, [:x, :y, :z]);\n\njulia> S = complement_of_point_ideal(R, [0, 0 ,0])\nComplement\n  of maximal ideal corresponding to rational point with coordinates (0, 0, 0)\n  in multivariate polynomial ring in 3 variables over QQ\n\njulia> y in S\nfalse\n\njulia> P = ideal(R, [x])\nIdeal generated by\n  x\n\njulia> T = complement_of_prime_ideal(P)\nComplement\n  of prime ideal (x)\n  in multivariate polynomial ring in 3 variables over QQ\n\njulia> y in T\ntrue\n\njulia> U = powers_of_element(x)\nMultiplicative subset\n  of multivariate polynomial ring in 3 variables over QQ\n  given by the products of [x]\n\njulia> x^3 in U\ntrue\n\njulia> (1+y)*x^2 in product(S, U)\ntrue\n\n\n\n\n\n","category":"method"},{"location":"CommutativeAlgebra/localizations/#Localized-Rings","page":"Localized Rings and Their Ideals","title":"Localized Rings","text":"","category":"section"},{"location":"CommutativeAlgebra/localizations/","page":"Localized Rings and Their Ideals","title":"Localized Rings and Their Ideals","text":"localization(R::MPolyRing, U::AbsMPolyMultSet)","category":"page"},{"location":"CommutativeAlgebra/localizations/#localization-Tuple{MPolyRing, Oscar.AbsMPolyMultSet}","page":"Localized Rings and Their Ideals","title":"localization","text":"localization(R::MPolyRing, U::AbsMPolyMultSet)\n\nReturn the localization of R at U, together with the localization map.\n\nExamples\n\njulia> R, (x, y, z) = polynomial_ring(QQ, [:x, :y, :z]);\n\njulia> P = ideal(R, [x])\nIdeal generated by\n  x\n\njulia> U = complement_of_prime_ideal(P)\nComplement\n  of prime ideal (x)\n  in multivariate polynomial ring in 3 variables over QQ\n\njulia> Rloc, iota = localization(R, U);\n\njulia> Rloc\nLocalization\n  of multivariate polynomial ring in 3 variables x, y, z\n    over rational field\n  at complement of prime ideal (x)\n\njulia> iota\nRing homomorphism\n  from multivariate polynomial ring in 3 variables over QQ\n  to localization of multivariate polynomial ring in 3 variables over QQ at complement of prime ideal (x)\ndefined by\n  x -> x\n  y -> y\n  z -> z\n\n\n\n\n\n","category":"method"},{"location":"CommutativeAlgebra/localizations/","page":"Localized Rings and Their Ideals","title":"Localized Rings and Their Ideals","text":"localization(RQ::MPolyQuoRing, U::AbsMPolyMultSet)","category":"page"},{"location":"CommutativeAlgebra/localizations/#localization-Tuple{MPolyQuoRing, Oscar.AbsMPolyMultSet}","page":"Localized Rings and Their Ideals","title":"localization","text":"localization(RQ::MPolyQuoRing, U::AbsMPolyMultSet)\n\nGiven a quotient RQ of a multivariate polynomial ring R with projection map p : R -> RQ, say, and given a multiplicatively closed subset U of R, return the  localization of RQ at p(U), together with the localization map.\n\nExamples\n\njulia> T, t = polynomial_ring(QQ, :t);\n\njulia> K, a =  number_field(2*t^2-1, \"a\");\n\njulia> R, (x, y) = polynomial_ring(K, [:x, :y]);\n\njulia> I = ideal(R, [2*x^2-y^3, 2*x^2-y^5])\nIdeal generated by\n  2*x^2 - y^3\n  2*x^2 - y^5\n\njulia> P = ideal(R, [y-1, x-a])\nIdeal generated by\n  y - 1\n  x - a\n\njulia> U = complement_of_prime_ideal(P)\nComplement\n  of prime ideal (y - 1, x - a)\n  in multivariate polynomial ring in 2 variables over K\n\njulia> RQ, _ = quo(R, I);\n\njulia> RQL, iota = localization(RQ, U);\n\njulia> RQL\nLocalization\n  of quotient\n    of multivariate polynomial ring in 2 variables x, y\n      over number field of degree 2 over QQ\n    by ideal (2*x^2 - y^3, 2*x^2 - y^5)\n  at complement of prime ideal (y - 1, x - a)\n\njulia> iota\nMap defined by a julia-function\n  from quotient of multivariate polynomial ring by ideal (2*x^2 - y^3, 2*x^2 - y^5)\n  to localization of RQ at complement of prime ideal\n\n\n\n\n\n","category":"method"},{"location":"CommutativeAlgebra/localizations/#Data-associated-to-Localized-Rings","page":"Localized Rings and Their Ideals","title":"Data associated to Localized Rings","text":"","category":"section"},{"location":"CommutativeAlgebra/localizations/","page":"Localized Rings and Their Ideals","title":"Localized Rings and Their Ideals","text":"If Rloc is the localization of a multivariate polynomial ring R  at a multiplicatively closed subset U of R, then","category":"page"},{"location":"CommutativeAlgebra/localizations/","page":"Localized Rings and Their Ideals","title":"Localized Rings and Their Ideals","text":"base_ring(Rloc) refers to R, and\ninverted_set(Rloc) to U.","category":"page"},{"location":"CommutativeAlgebra/localizations/","page":"Localized Rings and Their Ideals","title":"Localized Rings and Their Ideals","text":"If RQ is a quotient of a multivariate polynomial ring R, p : R to RQ is the projection map, U  is a multiplicatively closed subset of R, and RQL is the localization of RQ at p(U), then","category":"page"},{"location":"CommutativeAlgebra/localizations/","page":"Localized Rings and Their Ideals","title":"Localized Rings and Their Ideals","text":"base_ring(RQL) refers to R, and\ninverted_set(RQL) to U.","category":"page"},{"location":"CommutativeAlgebra/localizations/","page":"Localized Rings and Their Ideals","title":"Localized Rings and Their Ideals","text":"This reflects the way of creating localizations of quotients of multivariate polynomial rings in OSCAR.","category":"page"},{"location":"CommutativeAlgebra/localizations/#Examples","page":"Localized Rings and Their Ideals","title":"Examples","text":"","category":"section"},{"location":"CommutativeAlgebra/localizations/","page":"Localized Rings and Their Ideals","title":"Localized Rings and Their Ideals","text":"julia> R, (x, y, z) = polynomial_ring(QQ, [:x, :y, :z]);\n\njulia> P = ideal(R, [x])\nIdeal generated by\n  x\n\njulia> U = complement_of_prime_ideal(P)\nComplement\n  of prime ideal (x)\n  in multivariate polynomial ring in 3 variables over QQ\n\njulia> Rloc, _ = localization(U);\n\njulia> R === base_ring(Rloc)\ntrue\n\njulia> U === inverted_set(Rloc)\ntrue","category":"page"},{"location":"CommutativeAlgebra/localizations/","page":"Localized Rings and Their Ideals","title":"Localized Rings and Their Ideals","text":"julia> T, t = polynomial_ring(QQ, :t);\n\njulia> K, a =  number_field(2*t^2-1, \"a\");\n\njulia> R, (x, y) = polynomial_ring(K, [:x, :y]);\n\njulia> I = ideal(R, [2*x^2-y^3, 2*x^2-y^5])\nIdeal generated by\n  2*x^2 - y^3\n  2*x^2 - y^5\n\njulia> P = ideal(R, [y-1, x-a])\nIdeal generated by\n  y - 1\n  x - a\n\njulia> U = complement_of_prime_ideal(P)\nComplement\n  of prime ideal (y - 1, x - a)\n  in multivariate polynomial ring in 2 variables over K\n\njulia> RQ, _ = quo(R, I);\n\njulia> RQL, _ = localization(RQ, U);\n\njulia> R == base_ring(RQL)\ntrue\n\njulia> U == inverted_set(RQL)\ntrue","category":"page"},{"location":"CommutativeAlgebra/localizations/#Elements-of-Localized-Rings","page":"Localized Rings and Their Ideals","title":"Elements of Localized Rings","text":"","category":"section"},{"location":"CommutativeAlgebra/localizations/#Types-2","page":"Localized Rings and Their Ideals","title":"Types","text":"","category":"section"},{"location":"CommutativeAlgebra/localizations/","page":"Localized Rings and Their Ideals","title":"Localized Rings and Their Ideals","text":"The general abstract type for elements of localizations of rings is AbsLocalizedRingElem. For elements of localizations of multivariate polynomial rings, there is the concrete subtype MPolyLocRingElem. For elements of localizations of quotients of multivariate polynomial rings, there is the concrete subtype MPolyQuoLocRingElem.","category":"page"},{"location":"CommutativeAlgebra/localizations/#Creating-Elements-of-Localized-Rings","page":"Localized Rings and Their Ideals","title":"Creating Elements of Localized Rings","text":"","category":"section"},{"location":"CommutativeAlgebra/localizations/","page":"Localized Rings and Their Ideals","title":"Localized Rings and Their Ideals","text":"If Rloc is the localization of a multivariate polynomial ring R  at a multiplicatively closed subset U of R, then elements of Rloc are created as (fractions of) images of elements of R under the localization map or by coercing (pairs of) elements of R into fractions.","category":"page"},{"location":"CommutativeAlgebra/localizations/","page":"Localized Rings and Their Ideals","title":"Localized Rings and Their Ideals","text":"If RQ is a quotient of a multivariate polynomial ring R, p : R to RQ is the projection map, U  is a multiplicatively closed subset of R, and RQL is the localization of RQ at p(U), then elements of RQL are created similarly, starting from elements of R.","category":"page"},{"location":"CommutativeAlgebra/localizations/#Examples-2","page":"Localized Rings and Their Ideals","title":"Examples","text":"","category":"section"},{"location":"CommutativeAlgebra/localizations/","page":"Localized Rings and Their Ideals","title":"Localized Rings and Their Ideals","text":"julia> R, (x, y, z) = polynomial_ring(QQ, [:x, :y, :z])\n(Multivariate polynomial ring in 3 variables over QQ, QQMPolyRingElem[x, y, z])\n\njulia> P = ideal(R, [x])\nIdeal generated by\n  x\n\njulia> U = complement_of_prime_ideal(P)\nComplement\n  of prime ideal (x)\n  in multivariate polynomial ring in 3 variables over QQ\n\njulia> Rloc, iota = localization(U);\n\njulia> iota(x)\nx\n\njulia> Rloc(x)\nx\n\njulia> f = iota(y)/iota(z)\ny/z\n\njulia> g = Rloc(y, z)\ny/z\n\njulia> X, Y, Z = Rloc.(gens(R));\n\njulia> h = Y/Z\ny/z\n\njulia> f == g == h\ntrue\n\njulia> f+g\n2*y/z\n\njulia> f*g\ny^2/z^2","category":"page"},{"location":"CommutativeAlgebra/localizations/","page":"Localized Rings and Their Ideals","title":"Localized Rings and Their Ideals","text":"julia> T, t = polynomial_ring(QQ, :t);\n\njulia> K, a =  number_field(2*t^2-1, \"a\");\n\njulia> R, (x, y) = polynomial_ring(K, [:x, :y]);\n\njulia> I = ideal(R, [2*x^2-y^3, 2*x^2-y^5])\nIdeal generated by\n  2*x^2 - y^3\n  2*x^2 - y^5\n\njulia> P = ideal(R, [y-1, x-a])\nIdeal generated by\n  y - 1\n  x - a\n\njulia> U = complement_of_prime_ideal(P)\nComplement\n  of prime ideal (y - 1, x - a)\n  in multivariate polynomial ring in 2 variables over K\n\njulia> RQ, p = quo(R, I);\n\njulia> RQL, iota = localization(RQ, U);\n\njulia> phi = compose(p, iota);\n\njulia> phi(x)\nx\n\njulia> RQL(x)\nx\n\njulia> f = phi(x)/phi(y)\nx/y\n\njulia> g = RQL(x, y)\nx/y\n\njulia> X, Y = gens(RQL);\n\njulia> h = X/Y\nx/y\n\njulia> f == g == h\ntrue\n\njulia> f+g\n2*x/y\n\njulia> f*g\nx^2/y^2","category":"page"},{"location":"CommutativeAlgebra/localizations/#Data-Associated-to-Elements-of-Localized-Rings","page":"Localized Rings and Their Ideals","title":"Data Associated to Elements of Localized Rings","text":"","category":"section"},{"location":"CommutativeAlgebra/localizations/","page":"Localized Rings and Their Ideals","title":"Localized Rings and Their Ideals","text":"If Rloc is a localization of a multivariate polynomial ring R, and f is an element of Rloc, internally represented by a pair (r, u) of elements of R, then","category":"page"},{"location":"CommutativeAlgebra/localizations/","page":"Localized Rings and Their Ideals","title":"Localized Rings and Their Ideals","text":"parent(f) refers to Rloc,\nnumerator(f) to r, and\ndenominator(f) to u.","category":"page"},{"location":"CommutativeAlgebra/localizations/","page":"Localized Rings and Their Ideals","title":"Localized Rings and Their Ideals","text":"If RQL is a localization of a quotient RQ of a multivariate polynomial ring R, and f is an element of RQL, internally represented by a pair (r, u) of elements of R, then","category":"page"},{"location":"CommutativeAlgebra/localizations/","page":"Localized Rings and Their Ideals","title":"Localized Rings and Their Ideals","text":"parent(f) refers to RQL,\nnumerator(f) to the image of r in RQ, and\ndenominator(f) to the image of u in RQ.","category":"page"},{"location":"CommutativeAlgebra/localizations/","page":"Localized Rings and Their Ideals","title":"Localized Rings and Their Ideals","text":"That is, the behavior of the functions numerator and denominator reflects the mathematical viewpoint of representing f by pairs of elements of RQ and not the internal representation of f as pairs of elements of R.","category":"page"},{"location":"CommutativeAlgebra/localizations/#Examples-3","page":"Localized Rings and Their Ideals","title":"Examples","text":"","category":"section"},{"location":"CommutativeAlgebra/localizations/","page":"Localized Rings and Their Ideals","title":"Localized Rings and Their Ideals","text":"julia> R, (x, y, z) = polynomial_ring(QQ, [:x, :y, :z]);\n\njulia> P = ideal(R, [x])\nIdeal generated by\n  x\n\njulia> U = complement_of_prime_ideal(P)\nComplement\n  of prime ideal (x)\n  in multivariate polynomial ring in 3 variables over QQ\n\njulia> Rloc, iota = localization(U);\n\njulia> f = iota(x)/iota(y)\nx/y\n\njulia> parent(f)\nLocalization\n  of multivariate polynomial ring in 3 variables x, y, z\n    over rational field\n  at complement of prime ideal (x)\n\njulia> g = iota(y)/iota(z)\ny/z\n\njulia> r = numerator(f*g)\nx\n\njulia> u = denominator(f*g)\nz\n\njulia> typeof(r) == typeof(u) <: MPolyRingElem\ntrue","category":"page"},{"location":"CommutativeAlgebra/localizations/","page":"Localized Rings and Their Ideals","title":"Localized Rings and Their Ideals","text":"julia> T, t = polynomial_ring(QQ, :t);\n\njulia> K, a =  number_field(2*t^2-1, \"a\");\n\njulia> R, (x, y) = polynomial_ring(K, [:x, :y]);\n\njulia> I = ideal(R, [2*x^2-y^3, 2*x^2-y^5])\nIdeal generated by\n  2*x^2 - y^3\n  2*x^2 - y^5\n\njulia> P = ideal(R, [y-1, x-a])\nIdeal generated by\n  y - 1\n  x - a\n\njulia> U = complement_of_prime_ideal(P)\nComplement\n  of prime ideal (y - 1, x - a)\n  in multivariate polynomial ring in 2 variables over K\n\njulia> RQ, p = quo(R, I);\n\njulia> RQL, iota = localization(RQ, U);\n\njulia> phi = compose(p, iota);\n\njulia> f = phi(x)\nx\n\njulia> parent(f)\nLocalization\n  of quotient\n    of multivariate polynomial ring in 2 variables x, y\n      over number field of degree 2 over QQ\n    by ideal (2*x^2 - y^3, 2*x^2 - y^5)\n  at complement of prime ideal (y - 1, x - a)\n\njulia> g = f/phi(y)\nx/y\n\njulia> r = numerator(f*g)\nx^2\n\njulia> u = denominator(f*g)\ny\n\njulia> typeof(r) == typeof(u) <: MPolyQuoRingElem\ntrue","category":"page"},{"location":"CommutativeAlgebra/localizations/#Tests-on-Elements-of-Localized-Rings","page":"Localized Rings and Their Ideals","title":"Tests on Elements of Localized Rings","text":"","category":"section"},{"location":"CommutativeAlgebra/localizations/","page":"Localized Rings and Their Ideals","title":"Localized Rings and Their Ideals","text":"is_unit(f::MPolyLocRingElem)","category":"page"},{"location":"CommutativeAlgebra/localizations/#is_unit-Tuple{Oscar.MPolyLocRingElem}","page":"Localized Rings and Their Ideals","title":"is_unit","text":"is_unit(f::MPolyLocRingElem)\n\nReturn true, if f is a unit of parent(f), false otherwise.\n\nExamples\n\njulia> R, (x, y, z) = polynomial_ring(QQ, [:x, :y, :z]);\n\njulia> P = ideal(R, [x])\nIdeal generated by\n  x\n\njulia> U = complement_of_prime_ideal(P)\nComplement\n  of prime ideal (x)\n  in multivariate polynomial ring in 3 variables over QQ\n\njulia> Rloc, iota = localization(U);\n\njulia> is_unit(iota(x))\nfalse\n\njulia> is_unit(iota(y))\ntrue\n\n\n\n\n\n","category":"method"},{"location":"CommutativeAlgebra/localizations/","page":"Localized Rings and Their Ideals","title":"Localized Rings and Their Ideals","text":"is_unit(f::MPolyQuoLocRingElem)","category":"page"},{"location":"CommutativeAlgebra/localizations/#is_unit-Tuple{Oscar.MPolyQuoLocRingElem}","page":"Localized Rings and Their Ideals","title":"is_unit","text":"is_unit(f::MPolyQuoLocRingElem)\n\nReturn true, if f is a unit of parent(f), true otherwise.\n\nExamples\n\njulia> T, t = polynomial_ring(QQ, :t);\n\njulia> K, a =  number_field(2*t^2-1, \"a\");\n\njulia> R, (x, y) = polynomial_ring(K, [:x, :y]);\n\njulia> I = ideal(R, [2*x^2-y^3, 2*x^2-y^5])\nIdeal generated by\n  2*x^2 - y^3\n  2*x^2 - y^5\n\njulia> P = ideal(R, [y-1, x-a])\nIdeal generated by\n  y - 1\n  x - a\n\njulia> U = complement_of_prime_ideal(P)\nComplement\n  of prime ideal (y - 1, x - a)\n  in multivariate polynomial ring in 2 variables over K\n\njulia> RQ, p = quo(R, I);\n\njulia> RQL, iota = localization(RQ, U);\n\njulia> is_unit(iota(p(x)))\ntrue\n\n\n\n\n\n","category":"method"},{"location":"CommutativeAlgebra/localizations/#Homomorphisms-from-Localized-Rings","page":"Localized Rings and Their Ideals","title":"Homomorphisms from Localized Rings","text":"","category":"section"},{"location":"CommutativeAlgebra/localizations/","page":"Localized Rings and Their Ideals","title":"Localized Rings and Their Ideals","text":"The general abstract type for ring homomorphisms starting from localized rings is AbsLocalizedRingHom. For ring homomorphisms starting from localizations of multivariate polynomial rings, there is the concrete subtype MPolyLocalizedRingHom. For ring homomorphisms starting from quotients of multivariate polynomial rings, there is the concrete subtype MPolyQuoLocalizedRingHom. We describe the construction of such homomorphisms. Let","category":"page"},{"location":"CommutativeAlgebra/localizations/","page":"Localized Rings and Their Ideals","title":"Localized Rings and Their Ideals","text":"R be a multivariate polynomial ring\nU be a multiplicatively closed subset  of R,\nRQ = R/I be a quotient of R with projection map p : R to RQ,\nRloc (RQL) be the localization of R at U (of RQ at p(U)), and\nS be another ring.","category":"page"},{"location":"CommutativeAlgebra/localizations/","page":"Localized Rings and Their Ideals","title":"Localized Rings and Their Ideals","text":"Then, to give a ring homomorphism PHI  from Rloc to S (fromRQL to S) is the same as to give a ring homomorphism phi from R to S which sends elements of U to units in S (and elements of I to zero). That is, PHI is determined by composing it with the localization map R to Rloc (by composing it with the composition of the localization map RQ to RQL and the projection map R to RQ). The constructors below take this into account.","category":"page"},{"location":"CommutativeAlgebra/localizations/","page":"Localized Rings and Their Ideals","title":"Localized Rings and Their Ideals","text":"hom(Rloc::MPolyLocRing, S::Ring, F::Map)","category":"page"},{"location":"CommutativeAlgebra/localizations/#hom-Tuple{Oscar.MPolyLocRing, Ring, Map}","page":"Localized Rings and Their Ideals","title":"hom","text":"hom(Rloc::MPolyLocRing, S::Ring, phi::Map)\n\nGiven a localized ring Rlocof type MPolyLocRing, say Rloc is the localization  of a multivariate polynomial ring R at the multiplicatively closed subset U of R, and  given a homomorphism phi from R to S sending elements of U to units in S, return  the homomorphism from Rloc to S whose composition with the localization map is phi.\n\nhom(Rloc::MPolyLocRing, S::Ring, V::Vector)\n\nGiven a localized ring Rloc as above, and given a vector V of nvars elements of S, let phi  be the homomorphism from R to S which is determined by the entries of V as the images of the generators of R, and proceed as above.\n\nhom(RQL::MPolyQuoLocRing, S::Ring, phi::Map)\n\nGiven a localized ring RQLof type MPolyQuoLocRing, say RQL is the localization  of a quotient ring RQ of a multivariate polynomial ring R at the multiplicatively closed subset U of R, and  given a homomorphism phi from R to S sending elements of U to units in S and elements of the modulus of RQ to zero, return the homomorphism from Rloc to S whose composition with the localization map RQ -> RQL and the projection map R -> RQ is phi.\n\nhom(RQL::MPolyQuoLocRing, S::Ring, V::Vector)\n\nGiven a localized ring RQLas above, and given a vector V of nvars elements of S, let phi  be the homomorphism from R to S which is determined by the entries of V as the images of the generators of R, and proceed as above.\n\nwarning: Warning\nExcept from the case where the type of U is <: MPolyPowersOfElement, the condition on phi requiring that elements of U are send to units in S is not checked by the hom constructor.\n\nExamples\n\njulia> R, (x, y, z) = polynomial_ring(QQ, [:x, :y, :z]);\n\njulia> I = ideal(R, [y-x^2, z-x^3]);\n\njulia> RQ, p = quo(R, I);\n\njulia> UR = complement_of_point_ideal(R, [0, 0, 0]);\n\njulia> RQL, _ = localization(RQ, UR);\n\njulia> T, (t,) =  polynomial_ring(QQ, [:t]);\n\njulia> UT = complement_of_point_ideal(T, [0]);\n\njulia> TL, _ =  localization(T, UT);\n\njulia> PHI = hom(RQL, TL, TL.([t, t^2, t^3]))\nRing homomorphism\n  from localization of RQ at complement of maximal ideal\n  to localization of multivariate polynomial ring in 1 variable over QQ at complement of maximal ideal of point (0)\ndefined by\n  x -> t\n  y -> t^2\n  z -> t^3\n\njulia> PSI = hom(TL, RQL, RQL.([x]))\nRing homomorphism\n  from localization of multivariate polynomial ring in 1 variable over QQ at complement of maximal ideal of point (0)\n  to localization of RQ at complement of maximal ideal\ndefined by\n  t -> x\n\njulia> PHI(RQL(z))\nt^3\n\njulia> PSI(TL(t))\nx\n\n\n\n\n\n","category":"method"},{"location":"CommutativeAlgebra/localizations/","page":"Localized Rings and Their Ideals","title":"Localized Rings and Their Ideals","text":"Given a ring homomorphism PHI from Rloc to S (from RQL to S), domain(PHI) and codomain(PHI) refer to Rloc and S (RQL  and S), respectively. The corresponding homomorphism phi from R to S is recovered as follows:","category":"page"},{"location":"CommutativeAlgebra/localizations/","page":"Localized Rings and Their Ideals","title":"Localized Rings and Their Ideals","text":"restricted_map(PHI::MPolyLocalizedRingHom)","category":"page"},{"location":"CommutativeAlgebra/localizations/#restricted_map-Tuple{Oscar.MPolyLocalizedRingHom}","page":"Localized Rings and Their Ideals","title":"restricted_map","text":"restricted_map(PHI::MPolyLocalizedRingHom)\n\nrestricted_map(PHI::MPolyQuoLocalizedRingHom)\n\nGiven a ring homomorphism PHI starting from a localized multivariate polynomial ring (a localized quotient of a multivariate polynomial ring), return the composition of PHI  with the localization map (with the composition of the localization map and the projection map).\n\nExamples\n\njulia> R, (x, y, z) = polynomial_ring(QQ, [:x, :y, :z]);\n\njulia> I = ideal(R, [y-x^2, z-x^3]);\n\njulia> RQ, p = quo(R, I);\n\njulia> UR = complement_of_point_ideal(R, [0, 0, 0]);\n\njulia> RQL, _ = localization(RQ, UR);\n\njulia> T, (t,) =  polynomial_ring(QQ, [:t]);\n\njulia> UT = complement_of_point_ideal(T, [0]);\n\njulia> TL, _ =  localization(T, UT);\n\njulia> PHI = hom(RQL, TL, TL.([t, t^2, t^3]));\n\njulia> PSI = hom(TL, RQL, RQL.([x]));\n\njulia> phi = restricted_map(PHI)\nRing homomorphism\n  from multivariate polynomial ring in 3 variables over QQ\n  to localization of multivariate polynomial ring in 1 variable over QQ at complement of maximal ideal of point (0)\ndefined by\n  x -> t\n  y -> t^2\n  z -> t^3\n\njulia> psi = restricted_map(PSI)\nRing homomorphism\n  from multivariate polynomial ring in 1 variable over QQ\n  to localization of RQ at complement of maximal ideal\ndefined by\n  t -> x\n\n\n\n\n\n","category":"method"},{"location":"CommutativeAlgebra/localizations/#Ideals-in-Localized-Rings","page":"Localized Rings and Their Ideals","title":"Ideals in Localized Rings","text":"","category":"section"},{"location":"CommutativeAlgebra/localizations/#Types-3","page":"Localized Rings and Their Ideals","title":"Types","text":"","category":"section"},{"location":"CommutativeAlgebra/localizations/","page":"Localized Rings and Their Ideals","title":"Localized Rings and Their Ideals","text":"The general abstract type for ideals in localized rings is AbsLocalizedIdeal. For ideals in  localizations of multivariate polynomial rings, there is the concrete subtype MPolyLocalizedIdeal. For ideals in localizations of quotients of multivariate polynomial rings, there is the concrete subtype MPolyQuoLocalizedIdeal.","category":"page"},{"location":"CommutativeAlgebra/localizations/#Constructors-2","page":"Localized Rings and Their Ideals","title":"Constructors","text":"","category":"section"},{"location":"CommutativeAlgebra/localizations/","page":"Localized Rings and Their Ideals","title":"Localized Rings and Their Ideals","text":"Given a localization Rloc of a multivariate polynomial ring R, and given a vector V of elements of Rloc (of R),  the ideal of Rloc which is generated by (the images) of the entries of V is created by entering ideal(Rloc, V). The construction of ideals in localizations of quotients of multivariate polynomial rings is similar..","category":"page"},{"location":"CommutativeAlgebra/localizations/#Examples-4","page":"Localized Rings and Their Ideals","title":"Examples","text":"","category":"section"},{"location":"CommutativeAlgebra/localizations/","page":"Localized Rings and Their Ideals","title":"Localized Rings and Their Ideals","text":"julia> R, (x, y) = polynomial_ring(QQ, [:x, :y]);\n\njulia> f = x^3+y^4\nx^3 + y^4\n\njulia> V = [derivative(f, i) for i=1:2]\n2-element Vector{QQMPolyRingElem}:\n 3*x^2\n 4*y^3\n\njulia> U = complement_of_point_ideal(R, [0, 0]);\n\njulia> Rloc, _ = localization(R, U);\n\njulia> MI = ideal(Rloc, V)\nIdeal generated by\n  3*x^2\n  4*y^3","category":"page"},{"location":"CommutativeAlgebra/localizations/#Data-Associated-to-Ideals","page":"Localized Rings and Their Ideals","title":"Data Associated to Ideals","text":"","category":"section"},{"location":"CommutativeAlgebra/localizations/","page":"Localized Rings and Their Ideals","title":"Localized Rings and Their Ideals","text":"If I is an ideal of a localized multivariate polynomial ring  Rloc, then","category":"page"},{"location":"CommutativeAlgebra/localizations/","page":"Localized Rings and Their Ideals","title":"Localized Rings and Their Ideals","text":"base_ring(I) refers to Rloc,\ngens(I) to the generators of I,\nnumber_of_generators(I) / ngens(I) to the number of these generators, and\ngen(I, k) as well as I[k] to the k-th such generator.","category":"page"},{"location":"CommutativeAlgebra/localizations/","page":"Localized Rings and Their Ideals","title":"Localized Rings and Their Ideals","text":"Similarly, if I is an ideal of a localized quotient of a multivariate polynomial ring.","category":"page"},{"location":"CommutativeAlgebra/localizations/#Operations-on-Ideals","page":"Localized Rings and Their Ideals","title":"Operations on Ideals","text":"","category":"section"},{"location":"CommutativeAlgebra/localizations/","page":"Localized Rings and Their Ideals","title":"Localized Rings and Their Ideals","text":"If I,  J are ideals of a localized multivariate polynomial ring  Rloc, then","category":"page"},{"location":"CommutativeAlgebra/localizations/","page":"Localized Rings and Their Ideals","title":"Localized Rings and Their Ideals","text":"I^k refers to the k-th  power of I,\nI+J, I*J,  and intersect(I, J) to the sum, product, and intersection of I and  J, and\nquotient(I, J) as well as I:J to the ideal quotient of I by J.","category":"page"},{"location":"CommutativeAlgebra/localizations/","page":"Localized Rings and Their Ideals","title":"Localized Rings and Their Ideals","text":"Similarly, if I and J are ideals of a localized quotient of a multivariate polynomial ring.","category":"page"},{"location":"CommutativeAlgebra/localizations/#Tests-on-Ideals","page":"Localized Rings and Their Ideals","title":"Tests on Ideals","text":"","category":"section"},{"location":"CommutativeAlgebra/localizations/","page":"Localized Rings and Their Ideals","title":"Localized Rings and Their Ideals","text":"The usual tests f in J, issubset(I, J), and I == J are available.","category":"page"},{"location":"CommutativeAlgebra/localizations/#Saturation","page":"Localized Rings and Their Ideals","title":"Saturation","text":"","category":"section"},{"location":"CommutativeAlgebra/localizations/","page":"Localized Rings and Their Ideals","title":"Localized Rings and Their Ideals","text":"If Rloc is the localization of a multivariate polynomial ring R at a multiplicative subset U of R, then the ideal theory of Rloc is a simplified version of the ideal theory of R (see, for instance, [Eis95]). In particular, each ideal I of Rloc is the extension Jcdot Rloc of an ideal J of R. The ideal","category":"page"},{"location":"CommutativeAlgebra/localizations/","page":"Localized Rings and Their Ideals","title":"Localized Rings and Their Ideals","text":"fin R mid ufin J text for some  uin U","category":"page"},{"location":"CommutativeAlgebra/localizations/","page":"Localized Rings and Their Ideals","title":"Localized Rings and Their Ideals","text":"is independent of the choice of J and is the largest ideal of R which extends to I. It is, thus, the contraction of I to R,  that is, the preimage of I  under the localization map. We call this ideal the saturation of I over R.  In OSCAR, it is obtained by entering saturated_ideal(I).","category":"page"},{"location":"CommutativeAlgebra/localizations/","page":"Localized Rings and Their Ideals","title":"Localized Rings and Their Ideals","text":"If RQL is the localization of a quotient RQ of a multivariate polynomial ring R, and I is an ideal of RQL, then the return value of saturated_ideal(I) is the preimage of the saturation of I over RQ under the projection map R to RQ (and not the saturation of I over RQ itself).","category":"page"},{"location":"CommutativeAlgebra/localizations/","page":"Localized Rings and Their Ideals","title":"Localized Rings and Their Ideals","text":"saturated_ideal(I::MPolyLocalizedIdeal)","category":"page"},{"location":"CommutativeAlgebra/localizations/#saturated_ideal-Tuple{Oscar.MPolyLocalizedIdeal}","page":"Localized Rings and Their Ideals","title":"saturated_ideal","text":"saturated_ideal(I::MPolyLocalizedIdeal)\n\nGiven an ideal I of a localization, say, Rloc of a multivariate polynomial ring, say, R, return the saturation of I over R. That is, return the largest ideal of R whose extension to  Rloc is I. This is the preimage of I under the localization map.\n\nsaturated_ideal(I::MPolyQuoLocalizedIdeal)\n\nGiven an ideal I of a localization, say, RQL of a quotient, say, RQ of a multivariate  polynomial ring, say, R, return the preimage of the saturation of I over RQ under the  projection map R -> RQ.\n\nExamples\n\njulia> R, (x,) = polynomial_ring(QQ, [:x]);\n\njulia> U = powers_of_element(x)\nMultiplicative subset\n  of multivariate polynomial ring in 1 variable over QQ\n  given by the products of [x]\n\njulia> Rloc, iota = localization(R, U);\n\njulia> I = ideal(Rloc, [x+x^2])\nIdeal generated by\n  x^2 + x\n\njulia> SI = saturated_ideal(I)\nIdeal generated by\n  x + 1\n\njulia> base_ring(SI)\nMultivariate polynomial ring in 1 variable x\n  over rational field\n\njulia> U = complement_of_point_ideal(R, [0])\nComplement\n  of maximal ideal corresponding to rational point with coordinates (0)\n  in multivariate polynomial ring in 1 variable over QQ\n\njulia> Rloc, iota = localization(R, U);\n\njulia> I = ideal(Rloc, [x+x^2])\nIdeal generated by\n  x^2 + x\n\njulia> saturated_ideal(I)\nIdeal generated by\n  x\n\n\n\n\n\n","category":"method"},{"location":"DeveloperDocumentation/SubObjectIterator/#SubObjectIterator","page":"SubObjectIterator","title":"SubObjectIterator","text":"","category":"section"},{"location":"DeveloperDocumentation/SubObjectIterator/","page":"SubObjectIterator","title":"SubObjectIterator","text":"Many of the objects in the field of Polyhedral Geometry mask a BigObject from Polymake.jl. These big objects have properties which can easily be accessed via julia's dot syntax. The return commonly does not adhere to the mathematical or the typing conventions of Oscar; many properties encode information about a collection of mathematical objects within a single data object.","category":"page"},{"location":"DeveloperDocumentation/SubObjectIterator/","page":"SubObjectIterator","title":"SubObjectIterator","text":"The SubObjectIterator is a precise and flexible tool to directly access and/or process the desired properties of any Polymake.BigObject, but it requires specific interface definitions to work properly for each context. The user can thus profit from an easily understandable and usable iterator.","category":"page"},{"location":"DeveloperDocumentation/SubObjectIterator/","page":"SubObjectIterator","title":"SubObjectIterator","text":"This guide is meant to communicate the application of the SubObjectIterator for developers, utilizing existing code as reference and examples.","category":"page"},{"location":"DeveloperDocumentation/SubObjectIterator/#Creating-a-working-SubObjectIterator","page":"SubObjectIterator","title":"Creating a working SubObjectIterator","text":"","category":"section"},{"location":"DeveloperDocumentation/SubObjectIterator/","page":"SubObjectIterator","title":"SubObjectIterator","text":"The formal definition of the SubObjectIterator in src/PolyhedralGeometry/iterators is:","category":"page"},{"location":"DeveloperDocumentation/SubObjectIterator/","page":"SubObjectIterator","title":"SubObjectIterator","text":"struct SubObjectIterator{T} <: AbstractVector{T}\n    Obj::Polymake.BigObject\n    Acc::Function\n    n::Int\n    options::NamedTuple\nend","category":"page"},{"location":"DeveloperDocumentation/SubObjectIterator/","page":"SubObjectIterator","title":"SubObjectIterator","text":"An instance can be created by passing values for all fields, while options is optional.","category":"page"},{"location":"DeveloperDocumentation/SubObjectIterator/","page":"SubObjectIterator","title":"SubObjectIterator","text":"Trivially, Obj is the Polymake.BigObject whose property is to be accessed. The other fields will each be explained in an upcoming section.","category":"page"},{"location":"DeveloperDocumentation/SubObjectIterator/#Length","page":"SubObjectIterator","title":"Length","text":"","category":"section"},{"location":"DeveloperDocumentation/SubObjectIterator/","page":"SubObjectIterator","title":"SubObjectIterator","text":"As an AbstractVector, the SubObjectIterator has a length. Due to the nature of Polymake.BigObjects this length is constant for any property. Sometimes the length can easily be derived as a by-product of pre-computations when creating an instance of SubObjectIterator. To avoid performing unnecessary computations afterwards, the value is set at construction in n.","category":"page"},{"location":"DeveloperDocumentation/SubObjectIterator/#Access-function","page":"SubObjectIterator","title":"Access function","text":"","category":"section"},{"location":"DeveloperDocumentation/SubObjectIterator/","page":"SubObjectIterator","title":"SubObjectIterator","text":"Optimally retrieving and converting the elements varies strongly between the contexts in which a SubObjectIterator is created. Thus its getindex method redirects the call to the (internal) function Acc:","category":"page"},{"location":"DeveloperDocumentation/SubObjectIterator/","page":"SubObjectIterator","title":"SubObjectIterator","text":"function Base.getindex(iter::SubObjectIterator{T}, i::Base.Integer) where T\n    @boundscheck 1 <= i && i <= iter.n\n    return iter.Acc(T, iter.Obj, i; iter.options...)\nend","category":"page"},{"location":"DeveloperDocumentation/SubObjectIterator/","page":"SubObjectIterator","title":"SubObjectIterator","text":"From this call we can see that the access function's signature needs to satisfy certain requirements for the SubObjectIterator to work. The arguments are:","category":"page"},{"location":"DeveloperDocumentation/SubObjectIterator/","page":"SubObjectIterator","title":"SubObjectIterator","text":"T: The return type.\niter.Obj: The Polymake.BigObject whose property is to be accessed.\ni: The index.\niter.options: Additional arguments. Will be explained later.","category":"page"},{"location":"DeveloperDocumentation/SubObjectIterator/","page":"SubObjectIterator","title":"SubObjectIterator","text":"Let us look at an example how we can utilize this interface. The following is the implementation to access the rays of a Cone:","category":"page"},{"location":"DeveloperDocumentation/SubObjectIterator/","page":"SubObjectIterator","title":"SubObjectIterator","text":"rays(as::Type{RayVector{T}}, C::Cone) where T = SubObjectIterator{as}(pm_object(C), _ray_cone, n_rays(C))\n\n_ray_cone(::Type{T}, C::Polymake.BigObject, i::Base.Integer) where T = T(C.RAYS[i, :])","category":"page"},{"location":"DeveloperDocumentation/SubObjectIterator/","page":"SubObjectIterator","title":"SubObjectIterator","text":"Typing r = rays(RayVector{Polymake.Rational}, C) with a Cone C returns a SubObjectIterator over RayVector{Polymake.Rational} elements of length n_rays(C) with access function _ray_cone. With the given method of this function, getindex(r, i) returns a RayVector{Polymake.Rational} constructed from the i-th row of the property RAYS of the Polymake.BigObject.","category":"page"},{"location":"DeveloperDocumentation/SubObjectIterator/","page":"SubObjectIterator","title":"SubObjectIterator","text":"The user does never directly create a SubObjectIterator, so type restrictions made where it is created can be assumed to hold. In our example _ray_cone will always be called with T<:RayVector.","category":"page"},{"location":"DeveloperDocumentation/SubObjectIterator/","page":"SubObjectIterator","title":"SubObjectIterator","text":"One can define several methods of the access function to ideally read and process data. Consider facets(as::Type{T}, C::Cone). Depending on the return type we offer three methods:","category":"page"},{"location":"DeveloperDocumentation/SubObjectIterator/","page":"SubObjectIterator","title":"SubObjectIterator","text":"_facet_cone(::Type{T}, C::Polymake.BigObject, i::Base.Integer) where T<:Union{Polyhedron, AffineHalfspace} = T(-C.FACETS[[i], :], 0)\n\n_facet_cone(::Type{LinearHalfspace}, C::Polymake.BigObject, i::Base.Integer) = LinearHalfspace(-C.FACETS[[i], :])\n\n_facet_cone(::Type{Cone}, C::Polymake.BigObject, i::Base.Integer) = cone_from_inequalities(-C.FACETS[[i], :])","category":"page"},{"location":"DeveloperDocumentation/SubObjectIterator/#Additional-Methods","page":"SubObjectIterator","title":"Additional Methods","text":"","category":"section"},{"location":"DeveloperDocumentation/SubObjectIterator/","page":"SubObjectIterator","title":"SubObjectIterator","text":"The SubObjectIterator can moreover be understood as a mathematical collection the sense that one can","category":"page"},{"location":"DeveloperDocumentation/SubObjectIterator/","page":"SubObjectIterator","title":"SubObjectIterator","text":"ask for specific information encoded in the data or\nuse this collection as an argument for construction another mathematical object.","category":"page"},{"location":"DeveloperDocumentation/SubObjectIterator/","page":"SubObjectIterator","title":"SubObjectIterator","text":"The first case is covered by adding methods to specific internal functions. Remember implementation of rays discussed above. It makes sense to define a vector_matrix method on its output, encoding the rays of the cone as a single matrix based on a convention applied throughout Oscar. The function's implementation a user calls in this case is evaluated to these lines:","category":"page"},{"location":"DeveloperDocumentation/SubObjectIterator/","page":"SubObjectIterator","title":"SubObjectIterator","text":"vector_matrix(iter::SubObjectIterator{<:AbstractVector{Polymake.Rational}}) = matrix(QQ, Matrix{QQFieldElem}(_vector_matrix(Val(iter.Acc), iter.Obj; iter.options...)))\nvector_matrix(iter::SubObjectIterator{<:AbstractVector{Polymake.Integer}}) = matrix(ZZ, _vector_matrix(Val(iter.Acc), iter.Obj; iter.options...))\n_vector_matrix(::Any, ::Polymake.BigObject) = throw(ArgumentError(\"Vector Matrix not defined in this context.\"))","category":"page"},{"location":"DeveloperDocumentation/SubObjectIterator/","page":"SubObjectIterator","title":"SubObjectIterator","text":"Two functionalities are defined this way:","category":"page"},{"location":"DeveloperDocumentation/SubObjectIterator/","page":"SubObjectIterator","title":"SubObjectIterator","text":"The call of vector_matrix(iter) is redirected to _vector_matrix(Val(iter.Acc), iter.Obj). If that method is not defined for the value type of the access function, it falls back to throwing an error.\nThe matrix received from step 1 is converted from Polymake.jl format to Oscar format.","category":"page"},{"location":"DeveloperDocumentation/SubObjectIterator/","page":"SubObjectIterator","title":"SubObjectIterator","text":"So by defining the following we have a fully functional vector_matrix method in the context of rays:","category":"page"},{"location":"DeveloperDocumentation/SubObjectIterator/","page":"SubObjectIterator","title":"SubObjectIterator","text":"_vector_matrix(::Val{_ray_cone}, C::Polymake.BigObject) = C.RAYS","category":"page"},{"location":"DeveloperDocumentation/SubObjectIterator/","page":"SubObjectIterator","title":"SubObjectIterator","text":"The second case is solved with defining a special _matrix_for_polymake method. One just hast to name the internal function that returns the desired matrix. This way one has the ability to precisely control how the iterator works internally in specific contexts, even if there happen to be multiple additional matrix functions.","category":"page"},{"location":"DeveloperDocumentation/SubObjectIterator/","page":"SubObjectIterator","title":"SubObjectIterator","text":"Again, the call matrix_for_polymake(iter) will either redirect to the defined method or fall back to throwing an error if there is none:","category":"page"},{"location":"DeveloperDocumentation/SubObjectIterator/","page":"SubObjectIterator","title":"SubObjectIterator","text":"function matrix_for_polymake(iter::SubObjectIterator)\n    if hasmethod(_matrix_for_polymake, Tuple{Val{iter.Acc}})\n        return _matrix_for_polymake(Val(iter.Acc))(Val(iter.Acc), iter.Obj; iter.options...)\n    else\n        throw(ArgumentError(\"Matrix for Polymake not defined in this context.\"))\n    end\nend","category":"page"},{"location":"DeveloperDocumentation/SubObjectIterator/","page":"SubObjectIterator","title":"SubObjectIterator","text":"For rays(C::Cone) this reduces the implementation to the following line:","category":"page"},{"location":"DeveloperDocumentation/SubObjectIterator/","page":"SubObjectIterator","title":"SubObjectIterator","text":"_matrix_for_polymake(::Val{_ray_cone}) = _vector_matrix","category":"page"},{"location":"DeveloperDocumentation/SubObjectIterator/","page":"SubObjectIterator","title":"SubObjectIterator","text":"With matrix_for_polymake the output of rays can be handled as a usual matrix and constructors or other functions can easily be extended by additionally allowing SubObjectIterator as an argument type. E.g. the signature of one of the Cone constructors now looks like this while the body has not changed:","category":"page"},{"location":"DeveloperDocumentation/SubObjectIterator/","page":"SubObjectIterator","title":"SubObjectIterator","text":"Cone(R::Union{SubObjectIterator{<:RayVector}, Oscar.MatElem, AbstractMatrix}, L::Union{SubObjectIterator{<:RayVector}, Oscar.MatElem, AbstractMatrix, Nothing} = nothing; non_redundant::Bool = false)","category":"page"},{"location":"DeveloperDocumentation/SubObjectIterator/","page":"SubObjectIterator","title":"SubObjectIterator","text":"There also are linear_matrix_for_polymake and affine_matrix_for_polymake used in the context of linear and affine halfspaces/hyperplanes. Defining this functionality in a context works the same way as for matrix_for_polymake; you can create a new method of _linear_matrix_for_polymake or _affine_matrix_for_polymake. It suffices to define the most relevant of these two; the other one will be derived, if possible. Also, halfspace_matrix_pair is defined in terms of affine_matrix_for_polymake, so this does not need another implementation.","category":"page"},{"location":"DeveloperDocumentation/SubObjectIterator/","page":"SubObjectIterator","title":"SubObjectIterator","text":"The example code for rays(C::Cone) has covered every line of the implementation by now, but we had different code in between, so let us summarize and take a look at what the whole implementation actually looks like:","category":"page"},{"location":"DeveloperDocumentation/SubObjectIterator/","page":"SubObjectIterator","title":"SubObjectIterator","text":"rays(as::Type{RayVector{T}}, C::Cone) where T = SubObjectIterator{as}(pm_object(C), _ray_cone, n_rays(C))\n\n_ray_cone(::Type{T}, C::Polymake.BigObject, i::Base.Integer) where T = T(C.RAYS[i, :])\n\n_vector_matrix(::Val{_ray_cone}, C::Polymake.BigObject) = C.RAYS\n\n_matrix_for_polymake(::Val{_ray_cone}) = _vector_matrix","category":"page"},{"location":"DeveloperDocumentation/SubObjectIterator/#options","page":"SubObjectIterator","title":"options","text":"","category":"section"},{"location":"DeveloperDocumentation/SubObjectIterator/","page":"SubObjectIterator","title":"SubObjectIterator","text":"Sometimes you need further arguments to specify the returned data. These arguments are set at construction of the SubObjectIterator and later passed to the corresponding functions as keyword arguments.","category":"page"},{"location":"DeveloperDocumentation/SubObjectIterator/","page":"SubObjectIterator","title":"SubObjectIterator","text":"A good example how to use this is faces(C::Cone, face_dim::Int). It is not enough to know that our SubObjectIterator is set in the context of faces of cones; face_dim will be relevant for any type of access occurring in the future.","category":"page"},{"location":"DeveloperDocumentation/SubObjectIterator/","page":"SubObjectIterator","title":"SubObjectIterator","text":"function faces(C::Cone, face_dim::Int)\n   n = face_dim - length(lineality_space(C))\n   n < 1 && return nothing\n   return SubObjectIterator{Cone}(C.pm_cone, _face_cone, size(Polymake.polytope.faces_of_dim(pm_object(C), n), 1), (f_dim = n,))\nend","category":"page"},{"location":"DeveloperDocumentation/SubObjectIterator/","page":"SubObjectIterator","title":"SubObjectIterator","text":"When this method is called with meaningful input, it creates a SubObjectIterator where the last argument is a NamedTuple specifying that f_dim = n. The information encoded in this NamedTuple will be passed as keyword arguments when calling the access function or any additional method (reconsider their definitions). This allows us to directly ask for that data when implementing these methods:","category":"page"},{"location":"DeveloperDocumentation/SubObjectIterator/","page":"SubObjectIterator","title":"SubObjectIterator","text":"function _face_cone(::Type{Cone}, C::Polymake.BigObject, i::Base.Integer; f_dim::Int = 0)\n   return Cone(Polymake.polytope.Cone(RAYS = C.RAYS[collect(Polymake.to_one_based_indexing(Polymake.polytope.faces_of_dim(C, f_dim)[i])), :], LINEALITY_SPACE = C.LINEALITY_SPACE))\nend\n\nfunction _ray_indices(::Val{_face_cone}, C::Polymake.BigObject; f_dim::Int = 0)\n   f = Polymake.to_one_based_indexing(Polymake.polytope.faces_of_dim(C, f_dim))\n   return IncidenceMatrix([collect(f[i]) for i in 1:length(f)])\nend","category":"page"},{"location":"DeveloperDocumentation/SubObjectIterator/#Extending-the-interface","page":"SubObjectIterator","title":"Extending the interface","text":"","category":"section"},{"location":"DeveloperDocumentation/SubObjectIterator/","page":"SubObjectIterator","title":"SubObjectIterator","text":"The additional methods offer an intuitive way of interaction for the user, but their current selection is not carved in stone. You can easily add more similar methods by extending the list that is iterated over to generate the code. Which list that is usually depends on the output format. vector_matrix returns matrices with either integer or rational elements. The same capabilities hold for point_matrix and generator_matrix:","category":"page"},{"location":"DeveloperDocumentation/SubObjectIterator/","page":"SubObjectIterator","title":"SubObjectIterator","text":"for (sym, name) in ((\"point_matrix\", \"Point Matrix\"), (\"vector_matrix\", \"Vector Matrix\"), (\"generator_matrix\", \"Generator Matrix\"))\n    M = Symbol(sym)\n    _M = Symbol(string(\"_\", sym))\n    @eval begin\n        $M(iter::SubObjectIterator{<:AbstractVector{Polymake.Rational}}) = matrix(QQ, Matrix{QQFieldElem}($_M(Val(iter.Acc), iter.Obj; iter.options...)))\n        $M(iter::SubObjectIterator{<:AbstractVector{Polymake.Integer}}) = matrix(ZZ, $_M(Val(iter.Acc), iter.Obj; iter.options...))\n        $_M(::Any, ::Polymake.BigObject) = throw(ArgumentError(string($name, \" not defined in this context.\")))\n    end\nend","category":"page"},{"location":"DeveloperDocumentation/SubObjectIterator/","page":"SubObjectIterator","title":"SubObjectIterator","text":"The second string (name) of each pair determines the name that is printed in error messages.","category":"page"},{"location":"DeveloperDocumentation/SubObjectIterator/","page":"SubObjectIterator","title":"SubObjectIterator","text":"If required, one can of course write completely new functions to extend the interface.","category":"page"},{"location":"Nemo/algebraic/","page":"Algebraic numbers","title":"Algebraic numbers","text":"CurrentModule = Nemo\nDocTestSetup = quote\n    using Nemo\nend","category":"page"},{"location":"Nemo/algebraic/#Algebraic-numbers","page":"Algebraic numbers","title":"Algebraic numbers","text":"","category":"section"},{"location":"Nemo/algebraic/","page":"Algebraic numbers","title":"Algebraic numbers","text":"Nemo allows working with exact real and complex algebraic numbers.","category":"page"},{"location":"Nemo/algebraic/","page":"Algebraic numbers","title":"Algebraic numbers","text":"The default algebraic number type in Nemo is provided by Calcium. The associated field of algebraic numbers can be constructed using QQBar = algebraic_closure(QQ). We will leave out this line from all code blocks on this page for brevity.","category":"page"},{"location":"Nemo/algebraic/","page":"Algebraic numbers","title":"Algebraic numbers","text":"Library Element type Parent type\nCalcium QQBarFieldElem QQBarField","category":"page"},{"location":"Nemo/algebraic/","page":"Algebraic numbers","title":"Algebraic numbers","text":"Important note on performance","category":"page"},{"location":"Nemo/algebraic/","page":"Algebraic numbers","title":"Algebraic numbers","text":"The default algebraic number type represents algebraic numbers in canonical form using minimal polynomials. This works well for representing individual algebraic numbers, but it does not provide the best performance for field arithmetic. For fast calculation in overlinemathbbQ, CalciumField should typically be used instead (see the section on Exact real and complex numbers). Alternatively, to compute in a fixed subfield of overlinemathbbQ, you may fix a generator a and construct a number field to represent mathbbQ(a).","category":"page"},{"location":"Nemo/algebraic/#Algebraic-number-functionality","page":"Algebraic numbers","title":"Algebraic number functionality","text":"","category":"section"},{"location":"Nemo/algebraic/#Constructing-algebraic-numbers","page":"Algebraic numbers","title":"Constructing algebraic numbers","text":"","category":"section"},{"location":"Nemo/algebraic/","page":"Algebraic numbers","title":"Algebraic numbers","text":"Methods to construct algebraic numbers include:","category":"page"},{"location":"Nemo/algebraic/","page":"Algebraic numbers","title":"Algebraic numbers","text":"Conversion from other numbers and through arithmetic operations\nComputing the roots of a given polynomial\nComputing the eigenvalues of a given matrix\nRandom generation\nExact trigonometric functions (see later section)\nGuessing (see later section)","category":"page"},{"location":"Nemo/algebraic/","page":"Algebraic numbers","title":"Algebraic numbers","text":"Examples","category":"page"},{"location":"Nemo/algebraic/","page":"Algebraic numbers","title":"Algebraic numbers","text":"Arithmetic:","category":"page"},{"location":"Nemo/algebraic/","page":"Algebraic numbers","title":"Algebraic numbers","text":"julia> ZZRingElem(QQBar(3))\n3\n\njulia> QQFieldElem(QQBar(3) // 2)\n3//2\n\njulia> QQBar(-1) ^ (QQBar(1) // 3)\nRoot 0.500000 + 0.866025*im of x^2 - x + 1","category":"page"},{"location":"Nemo/algebraic/","page":"Algebraic numbers","title":"Algebraic numbers","text":"Solving the quintic equation:","category":"page"},{"location":"Nemo/algebraic/","page":"Algebraic numbers","title":"Algebraic numbers","text":"julia> R, x = polynomial_ring(QQ, \"x\")\n(Univariate polynomial ring in x over QQ, x)\n\njulia> v = roots(QQBar, x^5-x-1)\n5-element Vector{QQBarFieldElem}:\n Root 1.16730 of x^5 - x - 1\n Root 0.181232 + 1.08395*im of x^5 - x - 1\n Root 0.181232 - 1.08395*im of x^5 - x - 1\n Root -0.764884 + 0.352472*im of x^5 - x - 1\n Root -0.764884 - 0.352472*im of x^5 - x - 1\n\njulia> v[1]^5 - v[1] - 1 == 0\ntrue","category":"page"},{"location":"Nemo/algebraic/","page":"Algebraic numbers","title":"Algebraic numbers","text":"Computing exact eigenvalues of a matrix:","category":"page"},{"location":"Nemo/algebraic/","page":"Algebraic numbers","title":"Algebraic numbers","text":"julia> eigenvalues(QQBar, ZZ[1 1 0; 0 1 1; 1 0 1])\n3-element Vector{QQBarFieldElem}:\n Root 2.00000 of x - 2\n Root 0.500000 + 0.866025*im of x^2 - x + 1\n Root 0.500000 - 0.866025*im of x^2 - x + 1","category":"page"},{"location":"Nemo/algebraic/","page":"Algebraic numbers","title":"Algebraic numbers","text":"Interface","category":"page"},{"location":"Nemo/algebraic/","page":"Algebraic numbers","title":"Algebraic numbers","text":"roots(R::QQBarField, f::ZZPolyRingElem)\nroots(R::QQBarField, f::QQPolyRingElem)\neigenvalues(R::QQBarField, A::ZZMatrix)\neigenvalues_with_multiplicities(R::QQBarField, A::ZZMatrix)\neigenvalues(R::QQBarField, A::QQMatrix)\neigenvalues_with_multiplicities(R::QQBarField, A::QQMatrix)\nrand(R::QQBarField; degree::Int, bits::Int, randtype::Symbol=:null)","category":"page"},{"location":"Nemo/algebraic/#roots-Tuple{QQBarField, ZZPolyRingElem}","page":"Algebraic numbers","title":"roots","text":"roots(R::QQBarField, f::ZZPolyRingElem)\n\nReturn all the roots of the polynomial f in the field of algebraic numbers R. The output array is sorted in the default sort order for algebraic numbers. Roots of multiplicity higher than one are repeated according to their multiplicity.\n\n\n\n\n\n","category":"method"},{"location":"Nemo/algebraic/#roots-Tuple{QQBarField, QQPolyRingElem}","page":"Algebraic numbers","title":"roots","text":"roots(R::QQBarField, f::QQPolyRingElem)\n\nReturn all the roots of the polynomial f in the field of algebraic numbers R. The output array is sorted in the default sort order for algebraic numbers. Roots of multiplicity higher than one are repeated according to their multiplicity.\n\n\n\n\n\n","category":"method"},{"location":"Nemo/algebraic/#eigenvalues-Tuple{QQBarField, ZZMatrix}","page":"Algebraic numbers","title":"eigenvalues","text":"eigenvalues(R::QQBarField, A::ZZMatrix)\neigenvalues(R::QQBarField, A::QQMatrix)\n\nReturn the eigenvalues A in the field of algebraic numbers R. The output array is sorted in the default sort order for algebraic numbers.\n\n\n\n\n\neigenvalues(L::Field, M::MatElem{T}) where T <: RingElem\n\nReturn the eigenvalues of M over the field L.\n\n\n\n\n\n","category":"method"},{"location":"Nemo/algebraic/#eigenvalues_with_multiplicities-Tuple{QQBarField, ZZMatrix}","page":"Algebraic numbers","title":"eigenvalues_with_multiplicities","text":"eigenvalues_with_multiplicities(R::QQBarField, A::ZZMatrix)\neigenvalues_with_multiplicities(R::QQBarField, A::QQMatrix)\n\nReturn the eigenvalues A in the field of algebraic numbers R together with their algebraic multiplicities as a vector of tuples. The output array is sorted in the default sort order for algebraic numbers.\n\n\n\n\n\neigenvalues_with_multiplicities(L::Field, M::MatElem{T}) where T <: RingElem\n\nReturn the eigenvalues of M over the field L together with their algebraic multiplicities as a vector of tuples.\n\n\n\n\n\n","category":"method"},{"location":"Nemo/algebraic/#eigenvalues-Tuple{QQBarField, QQMatrix}","page":"Algebraic numbers","title":"eigenvalues","text":"eigenvalues(R::QQBarField, A::ZZMatrix)\neigenvalues(R::QQBarField, A::QQMatrix)\n\nReturn the eigenvalues A in the field of algebraic numbers R. The output array is sorted in the default sort order for algebraic numbers.\n\n\n\n\n\neigenvalues(L::Field, M::MatElem{T}) where T <: RingElem\n\nReturn the eigenvalues of M over the field L.\n\n\n\n\n\n","category":"method"},{"location":"Nemo/algebraic/#eigenvalues_with_multiplicities-Tuple{QQBarField, QQMatrix}","page":"Algebraic numbers","title":"eigenvalues_with_multiplicities","text":"eigenvalues_with_multiplicities(R::QQBarField, A::ZZMatrix)\neigenvalues_with_multiplicities(R::QQBarField, A::QQMatrix)\n\nReturn the eigenvalues A in the field of algebraic numbers R together with their algebraic multiplicities as a vector of tuples. The output array is sorted in the default sort order for algebraic numbers.\n\n\n\n\n\neigenvalues_with_multiplicities(L::Field, M::MatElem{T}) where T <: RingElem\n\nReturn the eigenvalues of M over the field L together with their algebraic multiplicities as a vector of tuples.\n\n\n\n\n\n","category":"method"},{"location":"Nemo/algebraic/#rand-Tuple{QQBarField}","page":"Algebraic numbers","title":"rand","text":"rand(R::QQBarField; degree::Int, bits::Int, randtype::Symbol=:null)\n\nReturn a random algebraic number with degree up to degree and coefficients up to bits in size. By default, both real and complex numbers are generated. Set the optional randtype to :real or :nonreal to generate a specific type of number. Note that nonreal numbers require degree at least 2.\n\n\n\n\n\n","category":"method"},{"location":"Nemo/algebraic/#Numerical-evaluation","page":"Algebraic numbers","title":"Numerical evaluation","text":"","category":"section"},{"location":"Nemo/algebraic/","page":"Algebraic numbers","title":"Algebraic numbers","text":"Examples","category":"page"},{"location":"Nemo/algebraic/","page":"Algebraic numbers","title":"Algebraic numbers","text":"Algebraic numbers can be evaluated numerically to arbitrary precision by converting to real or complex Arb fields:","category":"page"},{"location":"Nemo/algebraic/","page":"Algebraic numbers","title":"Algebraic numbers","text":"julia> RR = ArbField(64); RR(sqrt(QQBar(2)))\n[1.414213562373095049 +/- 3.45e-19]\n\njulia> CC = AcbField(32); CC(QQBar(-1) ^ (QQBar(1) // 4))\n[0.707106781 +/- 2.74e-10] + [0.707106781 +/- 2.74e-10]*im","category":"page"},{"location":"Nemo/algebraic/#Minimal-polynomials,-conjugates,-and-properties","page":"Algebraic numbers","title":"Minimal polynomials, conjugates, and properties","text":"","category":"section"},{"location":"Nemo/algebraic/","page":"Algebraic numbers","title":"Algebraic numbers","text":"Examples","category":"page"},{"location":"Nemo/algebraic/","page":"Algebraic numbers","title":"Algebraic numbers","text":"Retrieving the minimal polynomial and algebraic conjugates of a given algebraic number:","category":"page"},{"location":"Nemo/algebraic/","page":"Algebraic numbers","title":"Algebraic numbers","text":"julia> minpoly(polynomial_ring(ZZ, \"x\")[1], QQBar(1+2im))\nx^2 - 2*x + 5\n\njulia> conjugates(QQBar(1+2im))\n2-element Vector{QQBarFieldElem}:\n Root 1.00000 + 2.00000*im of x^2 - 2x + 5\n Root 1.00000 - 2.00000*im of x^2 - 2x + 5","category":"page"},{"location":"Nemo/algebraic/","page":"Algebraic numbers","title":"Algebraic numbers","text":"Interface","category":"page"},{"location":"Nemo/algebraic/","page":"Algebraic numbers","title":"Algebraic numbers","text":"iszero(x::QQBarFieldElem)\nisone(x::QQBarFieldElem)\nisinteger(x::QQBarFieldElem)\nis_rational(x::QQBarFieldElem)\nisreal(x::QQBarFieldElem)\ndegree(x::QQBarFieldElem)\nis_algebraic_integer(x::QQBarFieldElem)\nminpoly(R::ZZPolyRing, x::QQBarFieldElem)\nminpoly(R::QQPolyRing, x::QQBarFieldElem)\nconjugates(a::QQBarFieldElem)\ndenominator(x::QQBarFieldElem)\nnumerator(x::QQBarFieldElem)\nheight(x::QQBarFieldElem)\nheight_bits(x::QQBarFieldElem)","category":"page"},{"location":"Nemo/algebraic/#iszero-Tuple{QQBarFieldElem}","page":"Algebraic numbers","title":"iszero","text":"iszero(x::QQBarFieldElem)\n\nReturn whether x is the number 0.\n\n\n\n\n\n","category":"method"},{"location":"Nemo/algebraic/#isone-Tuple{QQBarFieldElem}","page":"Algebraic numbers","title":"isone","text":"isone(x::QQBarFieldElem)\n\nReturn whether x is the number 1.\n\n\n\n\n\n","category":"method"},{"location":"Nemo/algebraic/#isinteger-Tuple{QQBarFieldElem}","page":"Algebraic numbers","title":"isinteger","text":"isinteger(x::QQBarFieldElem)\n\nReturn whether x is an integer.\n\n\n\n\n\n","category":"method"},{"location":"Nemo/algebraic/#is_rational-Tuple{QQBarFieldElem}","page":"Algebraic numbers","title":"is_rational","text":"is_rational(x::QQBarFieldElem)\n\nReturn whether x is a rational number.\n\n\n\n\n\n","category":"method"},{"location":"Nemo/algebraic/#isreal-Tuple{QQBarFieldElem}","page":"Algebraic numbers","title":"isreal","text":"isreal(x::QQBarFieldElem)\n\nReturn whether x is a real number.\n\n\n\n\n\n","category":"method"},{"location":"Nemo/algebraic/#degree-Tuple{QQBarFieldElem}","page":"Algebraic numbers","title":"degree","text":"degree(x::QQBarFieldElem)\n\nReturn the degree of the minimal polynomial of x.\n\n\n\n\n\n","category":"method"},{"location":"Nemo/algebraic/#is_algebraic_integer-Tuple{QQBarFieldElem}","page":"Algebraic numbers","title":"is_algebraic_integer","text":"is_algebraic_integer(x::QQBarFieldElem)\n\nReturn whether x is an algebraic integer.\n\n\n\n\n\n","category":"method"},{"location":"Nemo/algebraic/#minpoly-Tuple{ZZPolyRing, QQBarFieldElem}","page":"Algebraic numbers","title":"minpoly","text":"minpoly(R::ZZPolyRing, x::QQBarFieldElem)\n\nReturn the minimal polynomial of x as an element of the polynomial ring R.\n\n\n\n\n\n","category":"method"},{"location":"Nemo/algebraic/#minpoly-Tuple{QQPolyRing, QQBarFieldElem}","page":"Algebraic numbers","title":"minpoly","text":"minpoly(R::ZZPolyRing, x::QQBarFieldElem)\n\nReturn the minimal polynomial of x as an element of the polynomial ring R.\n\n\n\n\n\n","category":"method"},{"location":"Nemo/algebraic/#conjugates-Tuple{QQBarFieldElem}","page":"Algebraic numbers","title":"conjugates","text":"conjugates(a::QQBarFieldElem)\n\nReturn all the roots of the polynomial f in the field of algebraic numbers R. The output array is sorted in the default sort order for algebraic numbers.\n\n\n\n\n\n","category":"method"},{"location":"Nemo/algebraic/#denominator-Tuple{QQBarFieldElem}","page":"Algebraic numbers","title":"denominator","text":"denominator(x::QQBarFieldElem)\n\nReturn the denominator of x, defined as the leading coefficient of the minimal polynomial of x. The result is returned as an ZZRingElem.\n\n\n\n\n\n","category":"method"},{"location":"Nemo/algebraic/#numerator-Tuple{QQBarFieldElem}","page":"Algebraic numbers","title":"numerator","text":"numerator(x::QQBarFieldElem)\n\nReturn the numerator of x, defined as x multiplied by its denominator. The result is an algebraic integer.\n\n\n\n\n\n","category":"method"},{"location":"Nemo/algebraic/#height-Tuple{QQBarFieldElem}","page":"Algebraic numbers","title":"height","text":"height(x::QQBarFieldElem)\n\nReturn the height of the algebraic number x. The result is an ZZRingElem integer.\n\n\n\n\n\n","category":"method"},{"location":"Nemo/algebraic/#height_bits-Tuple{QQBarFieldElem}","page":"Algebraic numbers","title":"height_bits","text":"height_bits(x::QQBarFieldElem)\n\nReturn the height of the algebraic number x measured in bits. The result is a Julia integer.\n\n\n\n\n\n","category":"method"},{"location":"Nemo/algebraic/#Complex-parts","page":"Algebraic numbers","title":"Complex parts","text":"","category":"section"},{"location":"Nemo/algebraic/","page":"Algebraic numbers","title":"Algebraic numbers","text":"Examples","category":"page"},{"location":"Nemo/algebraic/","page":"Algebraic numbers","title":"Algebraic numbers","text":"julia> real(sqrt(QQBar(1im)))\nRoot 0.707107 of 2x^2 - 1\n\njulia> abs(sqrt(QQBar(1im)))\nRoot 1.00000 of x - 1\n\njulia> floor(sqrt(QQBar(1000)))\nRoot 31.0000 of x - 31\n\njulia> sign(QQBar(-10-20im))\nRoot -0.447214 - 0.894427*im of 5x^4 + 6x^2 + 5","category":"page"},{"location":"Nemo/algebraic/","page":"Algebraic numbers","title":"Algebraic numbers","text":"Interface","category":"page"},{"location":"Nemo/algebraic/","page":"Algebraic numbers","title":"Algebraic numbers","text":"real(a::QQBarFieldElem)\nimag(a::QQBarFieldElem)\nabs(a::QQBarFieldElem)\nabs2(a::QQBarFieldElem)\nconj(a::QQBarFieldElem)\nsign(a::QQBarFieldElem)\ncsgn(a::QQBarFieldElem)\nsign_real(a::QQBarFieldElem)\nsign_imag(a::QQBarFieldElem)","category":"page"},{"location":"Nemo/algebraic/#real-Tuple{QQBarFieldElem}","page":"Algebraic numbers","title":"real","text":"real(a::QQBarFieldElem)\n\nReturn the real part of a.\n\n\n\n\n\n","category":"method"},{"location":"Nemo/algebraic/#imag-Tuple{QQBarFieldElem}","page":"Algebraic numbers","title":"imag","text":"imag(a::QQBarFieldElem)\n\nReturn the imaginary part of a.\n\n\n\n\n\n","category":"method"},{"location":"Nemo/algebraic/#abs-Tuple{QQBarFieldElem}","page":"Algebraic numbers","title":"abs","text":"abs(a::QQBarFieldElem)\n\nReturn the absolute value of a.\n\n\n\n\n\n","category":"method"},{"location":"Nemo/algebraic/#abs2-Tuple{QQBarFieldElem}","page":"Algebraic numbers","title":"abs2","text":"abs2(a::QQBarFieldElem)\n\nReturn the squared absolute value of a.\n\n\n\n\n\n","category":"method"},{"location":"Nemo/algebraic/#conj-Tuple{QQBarFieldElem}","page":"Algebraic numbers","title":"conj","text":"conj(a::QQBarFieldElem)\n\nReturn the complex conjugate of a.\n\n\n\n\n\n","category":"method"},{"location":"Nemo/algebraic/#sign-Tuple{QQBarFieldElem}","page":"Algebraic numbers","title":"sign","text":"sign(a::QQBarFieldElem)\n\nReturn the complex sign of a, defined as zero if a is zero and as a  a otherwise.\n\n\n\n\n\n","category":"method"},{"location":"Nemo/algebraic/#csgn-Tuple{QQBarFieldElem}","page":"Algebraic numbers","title":"csgn","text":"csgn(a::QQBarFieldElem)\n\nReturn the extension of the real sign function taking the value 1 strictly in the right half plane, -1 strictly in the left half plane, and the sign of the imaginary part when on the imaginary axis. Equivalently, operatornamecsgn(x) = x  sqrtx^2 except that the value is 0 at zero. The value is returned as a Julia integer.\n\n\n\n\n\n","category":"method"},{"location":"Nemo/algebraic/#sign_real-Tuple{QQBarFieldElem}","page":"Algebraic numbers","title":"sign_real","text":"sign_real(a::QQBarFieldElem)\n\nReturn the sign of the real part of a as a Julia integer.\n\n\n\n\n\n","category":"method"},{"location":"Nemo/algebraic/#sign_imag-Tuple{QQBarFieldElem}","page":"Algebraic numbers","title":"sign_imag","text":"sign_imag(a::QQBarFieldElem)\n\nReturn the sign of the imaginary part of a as a Julia integer.\n\n\n\n\n\n","category":"method"},{"location":"Nemo/algebraic/#Comparing-algebraic-numbers","page":"Algebraic numbers","title":"Comparing algebraic numbers","text":"","category":"section"},{"location":"Nemo/algebraic/","page":"Algebraic numbers","title":"Algebraic numbers","text":"The operators == and != check exactly for equality.","category":"page"},{"location":"Nemo/algebraic/","page":"Algebraic numbers","title":"Algebraic numbers","text":"We provide various comparison functions for ordering algebraic numbers:","category":"page"},{"location":"Nemo/algebraic/","page":"Algebraic numbers","title":"Algebraic numbers","text":"Standard comparison for real numbers (<, isless)\nReal parts\nImaginary parts\nAbsolute values\nAbsolute values of real or imaginary parts\nRoot sort order ","category":"page"},{"location":"Nemo/algebraic/","page":"Algebraic numbers","title":"Algebraic numbers","text":"The standard comparison will throw if either argument is nonreal.","category":"page"},{"location":"Nemo/algebraic/","page":"Algebraic numbers","title":"Algebraic numbers","text":"The various comparisons for complex parts are provided as separate operations since these functions are far more efficient than explicitly computing the complex parts and then doing real comparisons.","category":"page"},{"location":"Nemo/algebraic/","page":"Algebraic numbers","title":"Algebraic numbers","text":"The root sort order is a total order for complex algebraic numbers used to order the output of roots and conjugates canonically. We define this order as follows: real roots come first, in descending order. Nonreal roots are subsequently ordered first by real part in descending order, then in ascending order by the absolute value of the imaginary part, and then in descending order of the sign of the imaginary part. This implies that complex conjugate roots are adjacent, with the root in the upper half plane first.","category":"page"},{"location":"Nemo/algebraic/","page":"Algebraic numbers","title":"Algebraic numbers","text":"Examples","category":"page"},{"location":"Nemo/algebraic/","page":"Algebraic numbers","title":"Algebraic numbers","text":"julia> 1 < sqrt(QQBar(2)) < QQBar(3)//2\ntrue\n\njulia> x = QQBar(3+4im)\nRoot 3.00000 + 4.00000*im of x^2 - 6x + 25\n\njulia> is_equal_abs(x, -x)\ntrue\n\njulia> is_equal_abs_imag(x, 2-x)\ntrue\n\njulia> is_less_real(x, x // 2)\nfalse","category":"page"},{"location":"Nemo/algebraic/","page":"Algebraic numbers","title":"Algebraic numbers","text":"Interface","category":"page"},{"location":"Nemo/algebraic/","page":"Algebraic numbers","title":"Algebraic numbers","text":"is_equal_real(a::QQBarFieldElem, b::QQBarFieldElem)\nis_equal_imag(a::QQBarFieldElem, b::QQBarFieldElem)\nis_equal_abs(a::QQBarFieldElem, b::QQBarFieldElem)\nis_equal_abs_real(a::QQBarFieldElem, b::QQBarFieldElem)\nis_equal_abs_imag(a::QQBarFieldElem, b::QQBarFieldElem)\nis_less_real(a::QQBarFieldElem, b::QQBarFieldElem)\nis_less_imag(a::QQBarFieldElem, b::QQBarFieldElem)\nis_less_abs(a::QQBarFieldElem, b::QQBarFieldElem)\nis_less_abs_real(a::QQBarFieldElem, b::QQBarFieldElem)\nis_less_abs_imag(a::QQBarFieldElem, b::QQBarFieldElem)\nis_less_root_order(a::QQBarFieldElem, b::QQBarFieldElem)","category":"page"},{"location":"Nemo/algebraic/#is_equal_real-Tuple{QQBarFieldElem, QQBarFieldElem}","page":"Algebraic numbers","title":"is_equal_real","text":"is_equal_real(a::QQBarFieldElem, b::QQBarFieldElem)\n\nCompares the real parts of a and b.\n\n\n\n\n\n","category":"method"},{"location":"Nemo/algebraic/#is_equal_imag-Tuple{QQBarFieldElem, QQBarFieldElem}","page":"Algebraic numbers","title":"is_equal_imag","text":"is_equal_imag(a::QQBarFieldElem, b::QQBarFieldElem)\n\nCompares the imaginary parts of a and b.\n\n\n\n\n\n","category":"method"},{"location":"Nemo/algebraic/#is_equal_abs-Tuple{QQBarFieldElem, QQBarFieldElem}","page":"Algebraic numbers","title":"is_equal_abs","text":"is_equal_abs(a::QQBarFieldElem, b::QQBarFieldElem)\n\nCompares the absolute values of a and b.\n\n\n\n\n\n","category":"method"},{"location":"Nemo/algebraic/#is_equal_abs_real-Tuple{QQBarFieldElem, QQBarFieldElem}","page":"Algebraic numbers","title":"is_equal_abs_real","text":"is_equal_abs_real(a::QQBarFieldElem, b::QQBarFieldElem)\n\nCompares the absolute values of the real parts of a and b.\n\n\n\n\n\n","category":"method"},{"location":"Nemo/algebraic/#is_equal_abs_imag-Tuple{QQBarFieldElem, QQBarFieldElem}","page":"Algebraic numbers","title":"is_equal_abs_imag","text":"is_equal_abs_imag(a::QQBarFieldElem, b::QQBarFieldElem)\n\nCompares the absolute values of the imaginary parts of a and b.\n\n\n\n\n\n","category":"method"},{"location":"Nemo/algebraic/#is_less_real-Tuple{QQBarFieldElem, QQBarFieldElem}","page":"Algebraic numbers","title":"is_less_real","text":"is_less_real(a::QQBarFieldElem, b::QQBarFieldElem)\n\nCompares the real parts of a and b.\n\n\n\n\n\n","category":"method"},{"location":"Nemo/algebraic/#is_less_imag-Tuple{QQBarFieldElem, QQBarFieldElem}","page":"Algebraic numbers","title":"is_less_imag","text":"is_less_imag(a::QQBarFieldElem, b::QQBarFieldElem)\n\nCompares the imaginary parts of a and b.\n\n\n\n\n\n","category":"method"},{"location":"Nemo/algebraic/#is_less_abs-Tuple{QQBarFieldElem, QQBarFieldElem}","page":"Algebraic numbers","title":"is_less_abs","text":"is_less_abs(a::QQBarFieldElem, b::QQBarFieldElem)\n\nCompares the absolute values of a and b.\n\n\n\n\n\n","category":"method"},{"location":"Nemo/algebraic/#is_less_abs_real-Tuple{QQBarFieldElem, QQBarFieldElem}","page":"Algebraic numbers","title":"is_less_abs_real","text":"is_less_abs_real(a::QQBarFieldElem, b::QQBarFieldElem)\n\nCompares the absolute values of the real parts of a and b.\n\n\n\n\n\n","category":"method"},{"location":"Nemo/algebraic/#is_less_abs_imag-Tuple{QQBarFieldElem, QQBarFieldElem}","page":"Algebraic numbers","title":"is_less_abs_imag","text":"is_less_abs_imag(a::QQBarFieldElem, b::QQBarFieldElem)\n\nCompares the absolute values of the imaginary parts of a and b.\n\n\n\n\n\n","category":"method"},{"location":"Nemo/algebraic/#is_less_root_order-Tuple{QQBarFieldElem, QQBarFieldElem}","page":"Algebraic numbers","title":"is_less_root_order","text":"is_less_root_order(a::QQBarFieldElem, b::QQBarFieldElem)\n\nCompares the a and b in root sort order.\n\n\n\n\n\n","category":"method"},{"location":"Nemo/algebraic/#Roots-and-trigonometric-functions","page":"Algebraic numbers","title":"Roots and trigonometric functions","text":"","category":"section"},{"location":"Nemo/algebraic/","page":"Algebraic numbers","title":"Algebraic numbers","text":"Examples","category":"page"},{"location":"Nemo/algebraic/","page":"Algebraic numbers","title":"Algebraic numbers","text":"julia> root(QQBar(2), 5)\nRoot 1.14870 of x^5 - 2\n\njulia> sinpi(QQBar(7) // 13)\nRoot 0.992709 of 4096x^12 - 13312x^10 + 16640x^8 - 9984x^6 + 2912x^4 - 364x^2 + 13\n\njulia> tanpi(atanpi(sqrt(QQBar(2)) + 1))\nRoot 2.41421 of x^2 - 2x - 1\n\njulia> root_of_unity(QQBar, 5)\nRoot 0.309017 + 0.951057*im of x^4 + x^3 + x^2 + x + 1\n\njulia> root_of_unity(QQBar, 5, 4)\nRoot 0.309017 - 0.951057*im of x^4 + x^3 + x^2 + x + 1\n\njulia> w = (1 - sqrt(QQBar(-3)))//2\nRoot 0.500000 - 0.866025*im of x^2 - x + 1\n\njulia> is_root_of_unity(w)\ntrue\n\njulia> is_root_of_unity(w + 1)\nfalse\n\njulia> root_of_unity_as_args(w)\n(6, 5)","category":"page"},{"location":"Nemo/algebraic/","page":"Algebraic numbers","title":"Algebraic numbers","text":"Interface","category":"page"},{"location":"Nemo/algebraic/","page":"Algebraic numbers","title":"Algebraic numbers","text":"sqrt(a::QQBarFieldElem)\nroot(a::QQBarFieldElem, n::Int)\nroot_of_unity(C::QQBarField, n::Int)\nroot_of_unity(C::QQBarField, n::Int, k::Int)\nis_root_of_unity(a::QQBarFieldElem)\nroot_of_unity_as_args(a::QQBarFieldElem)\nexp_pi_i(a::QQBarFieldElem)\nlog_pi_i(a::QQBarFieldElem)\nsinpi(a::QQBarFieldElem)\ncospi(a::QQBarFieldElem)\nsincospi(a::QQBarFieldElem)\ntanpi(a::QQBarFieldElem)\nasinpi(a::QQBarFieldElem)\nacospi(a::QQBarFieldElem)\natanpi(a::QQBarFieldElem)","category":"page"},{"location":"Nemo/algebraic/#sqrt-Tuple{QQBarFieldElem}","page":"Algebraic numbers","title":"sqrt","text":"sqrt(a::QQBarFieldElem; check::Bool=true)\n\nReturn the principal square root of a.\n\n\n\n\n\n","category":"method"},{"location":"Nemo/algebraic/#root-Tuple{QQBarFieldElem, Int64}","page":"Algebraic numbers","title":"root","text":"root(a::QQBarFieldElem, n::Int)\n\nReturn the principal n-th root of a. Requires positive n.\n\n\n\n\n\n","category":"method"},{"location":"Nemo/algebraic/#root_of_unity-Tuple{QQBarField, Int64}","page":"Algebraic numbers","title":"root_of_unity","text":"root_of_unity(C::QQBarField, n::Int)\n\nReturn the root of unity e^2 pi i  n as an element of the field of algebraic numbers C.\n\n\n\n\n\n","category":"method"},{"location":"Nemo/algebraic/#root_of_unity-Tuple{QQBarField, Int64, Int64}","page":"Algebraic numbers","title":"root_of_unity","text":"root_of_unity(C::QQBarField, n::Int, k::Int)\n\nReturn the root of unity e^2 pi i k  n as an element of the field of algebraic numbers C.\n\n\n\n\n\n","category":"method"},{"location":"Nemo/algebraic/#is_root_of_unity-Tuple{QQBarFieldElem}","page":"Algebraic numbers","title":"is_root_of_unity","text":"is_root_of_unity(a::QQBarFieldElem)\n\nReturn whether the given algebraic number is a root of unity.\n\n\n\n\n\n","category":"method"},{"location":"Nemo/algebraic/#root_of_unity_as_args-Tuple{QQBarFieldElem}","page":"Algebraic numbers","title":"root_of_unity_as_args","text":"root_of_unity_as_args(a::QQBarFieldElem)\n\nReturn a pair of integers (q, p) such that the given a equals e^2 pi i p  q. The denominator q will be minimal, with 0 le p  q. Throws if a is not a root of unity.\n\n\n\n\n\n","category":"method"},{"location":"Nemo/algebraic/#exp_pi_i-Tuple{QQBarFieldElem}","page":"Algebraic numbers","title":"exp_pi_i","text":"exp_pi_i(a::QQBarFieldElem)\n\nReturn e^pi i a as an algebraic number. Throws if this value is transcendental.\n\n\n\n\n\n","category":"method"},{"location":"Nemo/algebraic/#log_pi_i-Tuple{QQBarFieldElem}","page":"Algebraic numbers","title":"log_pi_i","text":"log_pi_i(a::QQBarFieldElem)\n\nReturn log(a)  (pi i) as an algebraic number. Throws if this value is transcendental or undefined.\n\n\n\n\n\n","category":"method"},{"location":"Nemo/algebraic/#sinpi-Tuple{QQBarFieldElem}","page":"Algebraic numbers","title":"sinpi","text":"sinpi(a::QQBarFieldElem)\n\nReturn sin(pi a) as an algebraic number. Throws if this value is transcendental.\n\nExamples\n\njulia> QQBar = algebraic_closure(QQ);\n\njulia> x = sinpi(QQBar(1//3))\nRoot 0.866025 of 4x^2 - 3\n\njulia> sinpi(x)\nERROR: DomainError with Root 0.866025 of 4x^2 - 3:\nnonrational algebraic number\n\n\n\n\n\n","category":"method"},{"location":"Nemo/algebraic/#cospi-Tuple{QQBarFieldElem}","page":"Algebraic numbers","title":"cospi","text":"cospi(a::QQBarFieldElem)\n\nReturn cos(pi a) as an algebraic number. Throws if this value is transcendental.\n\nExamples\n\njulia> QQBar = algebraic_closure(QQ);\n\njulia> x = cospi(QQBar(1//6))\nRoot 0.866025 of 4x^2 - 3\n\njulia> cospi(x)\nERROR: DomainError with Root 0.866025 of 4x^2 - 3:\nnonrational algebraic number\n\n\n\n\n\n","category":"method"},{"location":"Nemo/algebraic/#sincospi-Tuple{QQBarFieldElem}","page":"Algebraic numbers","title":"sincospi","text":"sincospi(a::QQBarFieldElem)\n\nReturn sin(pi a) and cos(pi a) as a pair of algebraic numbers. Throws if either value is transcendental.\n\nExamples\n\njulia> QQBar = algebraic_closure(QQ);\n\njulia> s, c = sincospi(QQBar(1//3))\n(Root 0.866025 of 4x^2 - 3, Root 0.500000 of 2x - 1)\n\njulia> sincospi(s)\nERROR: DomainError with Root 0.866025 of 4x^2 - 3:\nnonrational algebraic number\n\n\n\n\n\n","category":"method"},{"location":"Nemo/algebraic/#tanpi-Tuple{QQBarFieldElem}","page":"Algebraic numbers","title":"tanpi","text":"tanpi(a::QQBarFieldElem)\n\nReturn tan(pi a) as an algebraic number. Throws if this value is transcendental or undefined.\n\n\n\n\n\n","category":"method"},{"location":"Nemo/algebraic/#asinpi-Tuple{QQBarFieldElem}","page":"Algebraic numbers","title":"asinpi","text":"asinpi(a::QQBarFieldElem)\n\nReturn operatornameasin(a)  pi as an algebraic number. Throws if this value is transcendental.\n\n\n\n\n\n","category":"method"},{"location":"Nemo/algebraic/#acospi-Tuple{QQBarFieldElem}","page":"Algebraic numbers","title":"acospi","text":"acospi(a::QQBarFieldElem)\n\nReturn operatornameacos(a)  pi as an algebraic number. Throws if this value is transcendental.\n\n\n\n\n\n","category":"method"},{"location":"Nemo/algebraic/#atanpi-Tuple{QQBarFieldElem}","page":"Algebraic numbers","title":"atanpi","text":"atanpi(a::QQBarFieldElem)\n\nReturn operatornameatan(a)  pi as an algebraic number. Throws if this value is transcendental or undefined.\n\n\n\n\n\n","category":"method"},{"location":"Nemo/algebraic/#Guessing","page":"Algebraic numbers","title":"Guessing","text":"","category":"section"},{"location":"Nemo/algebraic/","page":"Algebraic numbers","title":"Algebraic numbers","text":"Examples","category":"page"},{"location":"Nemo/algebraic/","page":"Algebraic numbers","title":"Algebraic numbers","text":"An algebraic number can be recovered from a numerical value:","category":"page"},{"location":"Nemo/algebraic/","page":"Algebraic numbers","title":"Algebraic numbers","text":"julia> RR = RealField(); guess(QQBar, RR(\"1.41421356 +/- 1e-6\"), 2)\nRoot 1.41421 of x^2 - 2","category":"page"},{"location":"Nemo/algebraic/","page":"Algebraic numbers","title":"Algebraic numbers","text":"Warning: the input should be an enclosure. If you have a floating-point approximation, you should add an error estimate; otherwise, at best the only algebraic number that can be guessed is the binary floating-point number itself, at worst no guess is possible.","category":"page"},{"location":"Nemo/algebraic/","page":"Algebraic numbers","title":"Algebraic numbers","text":"julia> RR = RealField();\n\njulia> x = RR(0.1)       # note: 53-bit binary approximation of 1//10 without radius\n[0.10000000000000000555 +/- 1.12e-21]\n\njulia> guess(QQBar, x, 1)\nERROR: No suitable algebraic number found\n\njulia> guess(QQBar, x + RR(\"+/- 1e-10\"), 1)\nRoot 0.100000 of 10x - 1","category":"page"},{"location":"Nemo/algebraic/","page":"Algebraic numbers","title":"Algebraic numbers","text":"Interface","category":"page"},{"location":"Nemo/algebraic/","page":"Algebraic numbers","title":"Algebraic numbers","text":"guess","category":"page"},{"location":"Nemo/algebraic/#guess","page":"Algebraic numbers","title":"guess","text":"guess(R::QQBarField, x::AcbFieldElem, maxdeg::Int, maxbits::Int=0)\nguess(R::QQBarField, x::ArbFieldElem, maxdeg::Int, maxbits::Int=0)\nguess(R::QQBarField, x::ComplexFieldElem, maxdeg::Int, maxbits::Int=0)\nguess(R::QQBarField, x::RealFieldElem, maxdeg::Int, maxbits::Int=0)\n\nTry to reconstruct an algebraic number from a given numerical enclosure x. The algorithm looks for candidates up to degree maxdeg and with coefficients up to size maxbits (which defaults to the precision of x if not given). Throws if no suitable algebraic number can be found.\n\nGuessing typically requires high precision to succeed, and it does not make much sense to call this function with input precision smaller than O(maxdeg cdot maxbits). If this function succeeds, then the output is guaranteed to be contained in the enclosure x, but failure does not prove that such an algebraic number with the specified parameters does not exist.\n\nThis function does a single iteration with the target parameters. For best performance, one should invoke this function repeatedly with successively larger parameters when the size of the intended solution is unknown or may be much smaller than a worst-case bound.\n\n\n\n\n\n","category":"function"},{"location":"CommutativeAlgebra/FrameWorks/ring_localizations/","page":"A Framework for Localizing Rings","title":"A Framework for Localizing Rings","text":"CurrentModule = Oscar\nDocTestSetup = Oscar.doctestsetup()","category":"page"},{"location":"CommutativeAlgebra/FrameWorks/ring_localizations/#A-Framework-for-Localizing-Rings","page":"A Framework for Localizing Rings","title":"A Framework for Localizing Rings","text":"","category":"section"},{"location":"CommutativeAlgebra/FrameWorks/ring_localizations/","page":"A Framework for Localizing Rings","title":"A Framework for Localizing Rings","text":"For the convenience of the developer, we outline a general framework for creating concrete instances of localized rings in OSCAR, addressing relevant abstract types as well as a standardized set of functions whose concrete behavior must be implemented.","category":"page"},{"location":"CommutativeAlgebra/FrameWorks/ring_localizations/","page":"A Framework for Localizing Rings","title":"A Framework for Localizing Rings","text":"We roughly follow the outline of the previous subsection on localizing multivariate rings which provides illustrating examples. With regard to notation, the name Rloc will refer to the localization of a commutative ring R with 1.","category":"page"},{"location":"CommutativeAlgebra/FrameWorks/ring_localizations/#Localized-Rings","page":"A Framework for Localizing Rings","title":"Localized Rings","text":"","category":"section"},{"location":"CommutativeAlgebra/FrameWorks/ring_localizations/","page":"A Framework for Localizing Rings","title":"A Framework for Localizing Rings","text":"All multiplicatively closed subsets should belong to the AbsMultSet abstract type and all localized rings should belong to the AbsLocalizedRing abstract type.","category":"page"},{"location":"CommutativeAlgebra/FrameWorks/ring_localizations/","page":"A Framework for Localizing Rings","title":"A Framework for Localizing Rings","text":"The basic functionality that has to be realized for any concrete instance of AbsMultSet is the containment check for elements in multiplicatively closed subsets via the in function.","category":"page"},{"location":"CommutativeAlgebra/FrameWorks/ring_localizations/","page":"A Framework for Localizing Rings","title":"A Framework for Localizing Rings","text":"For each concrete instance of AbsLocalizedRing, the localization constructor as well as the functions base_ring and inverted_set need to be implemented. Moreover, as for any other type of rings in OSCAR, methods for the standardized set of functions of OSCAR's general Ring Interface must be supplied.","category":"page"},{"location":"CommutativeAlgebra/FrameWorks/ring_localizations/#Elements-of-Localized-Rings","page":"A Framework for Localizing Rings","title":"Elements of Localized Rings","text":"","category":"section"},{"location":"CommutativeAlgebra/FrameWorks/ring_localizations/","page":"A Framework for Localizing Rings","title":"A Framework for Localizing Rings","text":"All elements of localized rings should belong to the AbsLocalizedRingElem abstract type.","category":"page"},{"location":"CommutativeAlgebra/FrameWorks/ring_localizations/","page":"A Framework for Localizing Rings","title":"A Framework for Localizing Rings","text":"Coercing (pairs of) elements of R into fractions in Rloc must be possible as indicated below:","category":"page"},{"location":"CommutativeAlgebra/FrameWorks/ring_localizations/","page":"A Framework for Localizing Rings","title":"A Framework for Localizing Rings","text":"   (Rloc::AbsLocalizedRing)(f::RingElem)\n   (Rloc::AbsLocalizedRing)(f::RingElem, g::RingElem; check::Bool=true)","category":"page"},{"location":"CommutativeAlgebra/FrameWorks/ring_localizations/","page":"A Framework for Localizing Rings","title":"A Framework for Localizing Rings","text":"The first constructor maps the element f of R to the fraction f//1 in Rloc. The second constructor takes a pair f, g of elements of R to the fraction f//g in Rloc. The default check = true stands for testing whether g is an admissible denominator. As this test is often expensive, it may be convenient to set check = false.","category":"page"},{"location":"CommutativeAlgebra/FrameWorks/ring_localizations/","page":"A Framework for Localizing Rings","title":"A Framework for Localizing Rings","text":"For any concrete instance of type AbsLocalizedRingElem, methods for the functions parent, numerator, and denominator must be provided. Moreover, if a cancelation function for the type of fractions under consideration is not yet available, such a function should be implemented and named reduce_fraction.","category":"page"},{"location":"CommutativeAlgebra/FrameWorks/ring_localizations/#Homomorphisms-From-Localized-Rings","page":"A Framework for Localizing Rings","title":"Homomorphisms From Localized Rings","text":"","category":"section"},{"location":"CommutativeAlgebra/FrameWorks/ring_localizations/","page":"A Framework for Localizing Rings","title":"A Framework for Localizing Rings","text":"The abstract type for homomorphisms from localized rings is MPolyLocalizedRingHom. For each concrete instance, the functions domain and codomain as well as restricted_map must be realized. Here, the latter function is meant to return the composition with the localization map.","category":"page"},{"location":"CommutativeAlgebra/FrameWorks/ring_localizations/#Ideals-in-Localized-Rings","page":"A Framework for Localizing Rings","title":"Ideals in Localized Rings","text":"","category":"section"},{"location":"CommutativeAlgebra/FrameWorks/ring_localizations/","page":"A Framework for Localizing Rings","title":"A Framework for Localizing Rings","text":"All ideals in localized rings belong to the abstract type AbsLocalizedIdeal. For a concrete instance, the constructors to be implemented are:","category":"page"},{"location":"CommutativeAlgebra/FrameWorks/ring_localizations/","page":"A Framework for Localizing Rings","title":"A Framework for Localizing Rings","text":"   ideal(W::AbsLocalizedRing, f::AbsLocalizedRingElem)\n   ideal(W::AbsLocalizedRing, v::Vector{LocalizedRingElemType}) where {LocalizedRingElemType<:AbsLocalizedRingElem}","category":"page"},{"location":"CommutativeAlgebra/FrameWorks/ring_localizations/","page":"A Framework for Localizing Rings","title":"A Framework for Localizing Rings","text":"The usual getter functions  base_ring, gens, number_of_generators, and gen   must be realized.","category":"page"},{"location":"CommutativeAlgebra/FrameWorks/ring_localizations/","page":"A Framework for Localizing Rings","title":"A Framework for Localizing Rings","text":"Moreover, a method for ideal membership via the in function is required.","category":"page"},{"location":"PolyhedralGeometry/fans/","page":"Polyhedral Fans","title":"Polyhedral Fans","text":"CurrentModule = Oscar\nDocTestSetup = Oscar.doctestsetup()","category":"page"},{"location":"PolyhedralGeometry/fans/#Polyhedral-Fans","page":"Polyhedral Fans","title":"Polyhedral Fans","text":"","category":"section"},{"location":"PolyhedralGeometry/fans/#Introduction","page":"Polyhedral Fans","title":"Introduction","text":"","category":"section"},{"location":"PolyhedralGeometry/fans/","page":"Polyhedral Fans","title":"Polyhedral Fans","text":"Let mathbbF be an ordered field; the default is that mathbbF=mathbbQ is the field of rational numbers and other fields are not yet supported everywhere in the implementation.","category":"page"},{"location":"PolyhedralGeometry/fans/","page":"Polyhedral Fans","title":"Polyhedral Fans","text":"A nonempty finite collection mathcalF of (polyhedral) cones in mathbbF^n, for n fixed, is a (polyhedral) fan if","category":"page"},{"location":"PolyhedralGeometry/fans/","page":"Polyhedral Fans","title":"Polyhedral Fans","text":"the set mathcalF is closed with respect to taking faces and\nif CDinmathcalF then Ccap D is a face of both, C and D.","category":"page"},{"location":"PolyhedralGeometry/fans/#Construction","page":"Polyhedral Fans","title":"Construction","text":"","category":"section"},{"location":"PolyhedralGeometry/fans/","page":"Polyhedral Fans","title":"Polyhedral Fans","text":"To construct a polyhedral fan, you must pass the rays of each cone in the fan, along with an IncidenceMatrix encoding which rays generate which cones.","category":"page"},{"location":"PolyhedralGeometry/fans/","page":"Polyhedral Fans","title":"Polyhedral Fans","text":"polyhedral_fan\npolyhedral_fan_from_rays_action","category":"page"},{"location":"PolyhedralGeometry/fans/#polyhedral_fan","page":"Polyhedral Fans","title":"polyhedral_fan","text":"polyhedral_fan(T, Rays::AbstractCollection[RayVector], LS::Union{AbstractCollection[RayVector], Nothing}, Incidence::IncidenceMatrix) where T<:scalar_types\n\nAssemble a polyhedral fan from ray generators, lineality generators, and an IncidenceMatrix indicating which rays form a cone.\n\nArguments\n\nT: Type or parent Field of scalar to use, defaults to QQFieldElem.\nRays::AbstractCollection[RayVector]: Rays generating the cones of the fan; encoded row-wise as representative vectors.\nLS::AbstractCollection[RayVector]: Contains row-wise generators of the lineality space of the fan. (optional argument)\nCones::IncidenceMatrix: An incidence matrix; there is a 1 at position (i,j) if cone i has ray j as extremal ray, and 0 otherwise.\n\nExamples\n\nTo obtain the upper half-space of the plane:\n\njulia> R = [1 0; 1 1; 0 1; -1 0; 0 -1];\n\njulia> IM = incidence_matrix([[1,2],[2,3],[3,4],[4,5],[1,5]]);\n\njulia> PF=polyhedral_fan(IM, R)\nPolyhedral fan in ambient dimension 2\n\nPolyhedral fan with lineality space:\n\njulia> R = [1 0 0; 0 0 1];\n\njulia> L = [0 1 0];\n\njulia> IM = incidence_matrix([[1],[2]]);\n\njulia> PF=polyhedral_fan(IM, R, L)\nPolyhedral fan in ambient dimension 3\n\njulia> lineality_dim(PF)\n1\n\n\n\n\n\npolyhedral_fan(cones::AbstractVector{Cone{T}}) where T<:scalar_types\n\nAssemble a polyhedral fan from a non-empty list of cones.\n\n\n\n\n\npolyhedral_fan(v::NormalToricVarietyType)\n\nReturn the fan of an abstract normal toric variety v.\n\nExamples\n\njulia> p2 = projective_space(NormalToricVariety, 2)\nNormal toric variety\n\njulia> polyhedral_fan(p2)\nPolyhedral fan in ambient dimension 2\n\n\n\n\n\n","category":"function"},{"location":"PolyhedralGeometry/fans/#polyhedral_fan_from_rays_action","page":"Polyhedral Fans","title":"polyhedral_fan_from_rays_action","text":"polyhedral_fan_from_rays_action([::Union{Type{T}, Field} = QQFieldElem,] Rays::AbstractCollection[RayVector], MC_reps::IncidenceMatrix, perms::AbstractVector{PermGroupElem}) where T<:scalar_types\n\nConstruct a polyhedral fan with a group action.\n\nArguments\n\nThe first argument either specifies the Type of its coefficients or their\n\nparent Field.\n\nRays: The rays of the fan\nMC_reps: IncidenceMatrix whose rows give the indices of the rays forming representatives of the maximal cones under the group action.\nperms: A vector of permutations PermGroupElem that form generators of the group acting on the rays of the fan.\n\n\n\n\n\n","category":"function"},{"location":"PolyhedralGeometry/fans/","page":"Polyhedral Fans","title":"Polyhedral Fans","text":"normal_fan(P::Polyhedron{T}) where T<:scalar_types\nface_fan(P::Polyhedron{T}) where T<:scalar_types","category":"page"},{"location":"PolyhedralGeometry/fans/#normal_fan-Union{Tuple{Polyhedron{T}}, Tuple{T}} where T<:Union{Float64, FieldElem}","page":"Polyhedral Fans","title":"normal_fan","text":"normal_fan(P::Polyhedron)\n\nReturn the normal fan of P. The maximal cones of the normal fan of P are dual to the edge cones at the vertices of P.\n\nExamples\n\nThe rays of a normal fan of a cube point in every positive and negative unit direction.\n\njulia> C = cube(3);\n\njulia> NF = normal_fan(C)\nPolyhedral fan in ambient dimension 3\n\njulia> rays(NF)\n6-element SubObjectIterator{RayVector{QQFieldElem}}:\n [1, 0, 0]\n [-1, 0, 0]\n [0, 1, 0]\n [0, -1, 0]\n [0, 0, 1]\n [0, 0, -1]\n\n\n\n\n\n","category":"method"},{"location":"PolyhedralGeometry/fans/#face_fan-Union{Tuple{Polyhedron{T}}, Tuple{T}} where T<:Union{Float64, FieldElem}","page":"Polyhedral Fans","title":"face_fan","text":"face_fan(P::Polyhedron)\n\nReturn the face fan of P. The polytope P has to contain the origin, then the maximal cones of the face fan of P are the cones over the facets of P.\n\nExamples\n\nBy definition, this bounded polyhedron's number of facets equals the amount of maximal cones of its face fan.\n\njulia> C = cross_polytope(3);\n\njulia> FF = face_fan(C)\nPolyhedral fan in ambient dimension 3\n\njulia> n_maximal_cones(FF) == n_facets(C)\ntrue\n\n\n\n\n\n","category":"method"},{"location":"PolyhedralGeometry/fans/#Auxiliary-functions","page":"Polyhedral Fans","title":"Auxiliary functions","text":"","category":"section"},{"location":"PolyhedralGeometry/fans/","page":"Polyhedral Fans","title":"Polyhedral Fans","text":"ambient_dim(PF::PolyhedralFan)\narrangement_polynomial\ndim(PF::PolyhedralFan)\nf_vector(PF::PolyhedralFan)\nis_complete(PF::PolyhedralFan)\nis_pointed(PF::PolyhedralFan)\nis_regular(PF::PolyhedralFan)\nis_simplicial(PF::PolyhedralFan)\nis_smooth(PF::PolyhedralFan{QQFieldElem})\nlineality_dim(PF::PolyhedralFan)\nlineality_space(PF::PolyhedralFan)\nmaximal_cones(PF::PolyhedralFan)\ncones(PF::PolyhedralFan, cone_dim::Int)\ncones(PF::PolyhedralFan)\nn_maximal_cones(PF::PolyhedralFan)\nn_cones(PF::PolyhedralFan)\nn_rays(PF::PolyhedralFan)\nrays(PF::PolyhedralFan)\nrays_modulo_lineality(PF::PolyhedralFan)\nprimitive_collections(PF::PolyhedralFan)\nstar_subdivision(PF::PolyhedralFan, n::Int)\nstar_subdivision(PF::PolyhedralFan, new_ray::AbstractVector{<:IntegerUnion})\n*(PF1::PolyhedralFan{QQFieldElem}, PF2::PolyhedralFan{QQFieldElem})","category":"page"},{"location":"PolyhedralGeometry/fans/#ambient_dim-Tuple{PolyhedralFan}","page":"Polyhedral Fans","title":"ambient_dim","text":"ambient_dim(PF::PolyhedralFan)\n\nReturn the ambient dimension PF, which is the dimension of the embedding space.\n\nThis is equal to the dimension of the fan if and only if the fan is full-dimensional.\n\nExamples\n\nThe normal fan of the 4-cube is embedded in the same ambient space.\n\njulia> ambient_dim(normal_fan(cube(4)))\n4\n\n\n\n\n\nambient_dim(TropV::TropicalVariety)\n\nSee ambient_dim(::PolyhedralComplex).\n\n\n\n\n\n","category":"method"},{"location":"PolyhedralGeometry/fans/#arrangement_polynomial","page":"Polyhedral Fans","title":"arrangement_polynomial","text":"arrangement_polynomial([ring::MPolyRing{<: FieldElem},] A::MatElem{<: FieldElem})\n\nGiven some AinmathbbF^ntimes d return the product of the linear forms corresponding to the rows.\n\nLet A be a ntimes d matrix with entries from a field mathbbF. The rows of A  are the normal vectors for a hyperplane arrangement mathcalA = H_1dotsH_nH_isubset mathbbF^d We have H_i = V(alpha_i), where alpha_iinmathbbFx_1dotsx_d is a linear form whose coefficients are the entries of the ith row.\n\nThen we have cup_H_iinmathcalAH_i = V(Pi^n_i=1alpha_i)\n\nOptionally one can select to use columns instead of rows in the following way:\n\narrangement_polynomial(...  ; hyperplanes=:in_cols)\n\nExample using standard ring and then custom ring.\n\njulia> A = matrix(QQ,[1 2 5//2; 0 0 1; 2 3 2; 1//2 3 5; 3 1 2; 7 8 1])\n[   1   2   5//2]\n[   0   0      1]\n[   2   3      2]\n[1//2   3      5]\n[   3   1      2]\n[   7   8      1]\n\njulia> factor(arrangement_polynomial(A))\n(1//4) * (2*x1 + 3*x2 + 2*x3) * (7*x1 + 8*x2 + x3) * (x1 + 6*x2 + 10*x3) * (2*x1 + 4*x2 + 5*x3) * x3 * (3*x1 + x2 + 2*x3)\n\njulia> R,_ = polynomial_ring(QQ, [:x, :y, :z])\n(Multivariate polynomial ring in 3 variables over QQ, QQMPolyRingElem[x, y, z])\n\njulia> factor(arrangement_polynomial(R, A))\n(1//4) * (2*x + 3*y + 2*z) * (7*x + 8*y + z) * (x + 6*y + 10*z) * (2*x + 4*y + 5*z) * z * (3*x + y + 2*z)\n\nTo use the columns instead, proceed in the following way:\n\njulia> A = matrix(QQ,[1 0 2 1//2 3 7;2 0 3 3 1 8;5//2 1 2 5 2 1]);\n\njulia> factor(arrangement_polynomial(A; hyperplanes=:in_cols))\n(1//4) * (2*x1 + 3*x2 + 2*x3) * (7*x1 + 8*x2 + x3) * (x1 + 6*x2 + 10*x3) * (2*x1 + 4*x2 + 5*x3) * x3 * (3*x1 + x2 + 2*x3)\n\n\n\n\n\n","category":"function"},{"location":"PolyhedralGeometry/fans/#dim-Tuple{PolyhedralFan}","page":"Polyhedral Fans","title":"dim","text":"dim(PF::PolyhedralFan)\n\nReturn the dimension of PF.\n\nExamples\n\nThis fan in the plane contains a 2-dimensional cone and is thus 2-dimensional itself.\n\njulia> PF = polyhedral_fan(incidence_matrix([[1, 2], [3]]), [1 0; 0 1; -1 -1]);\n\njulia> dim(PF)\n2\n\n\n\n\n\n","category":"method"},{"location":"PolyhedralGeometry/fans/#f_vector-Tuple{PolyhedralFan}","page":"Polyhedral Fans","title":"f_vector","text":"f_vector(PF::PolyhedralFan)\n\nCompute the vector (f₁f₂f_dim(PF)-1) where f_i is the number of faces of PF of dimension i.\n\nExamples\n\nThe f-vector of the normal fan of a polytope is the reverse of the f-vector of the polytope.\n\njulia> c = cube(3)\nPolytope in ambient dimension 3\n\njulia> f_vector(c)\n3-element Vector{ZZRingElem}:\n 8\n 12\n 6\n\n\njulia> nfc = normal_fan(c)\nPolyhedral fan in ambient dimension 3\n\njulia> f_vector(nfc)\n3-element Vector{ZZRingElem}:\n 6\n 12\n 8\n\n\n\n\n\n","category":"method"},{"location":"PolyhedralGeometry/fans/#is_complete-Tuple{PolyhedralFan}","page":"Polyhedral Fans","title":"is_complete","text":"is_complete(PF::PolyhedralFan)\n\nDetermine whether PF is complete, i.e. its support, the set-theoretic union of its cones, covers the whole space.\n\nExamples\n\nNormal fans of polytopes are complete.\n\njulia> is_complete(normal_fan(cube(3)))\ntrue\n\n\n\n\n\n","category":"method"},{"location":"PolyhedralGeometry/fans/#is_pointed-Tuple{PolyhedralFan}","page":"Polyhedral Fans","title":"is_pointed","text":"is_pointed(PF::PolyhedralFan)\n\nDetermine whether PF is pointed, i.e. all its cones are pointed.\n\nExamples\n\nThe normal fan of a non-fulldimensional polytope is not pointed.\n\njulia> C = convex_hull([0 0; 1 0])\nPolyhedron in ambient dimension 2\n\njulia> is_fulldimensional(C)\nfalse\n\njulia> nf = normal_fan(C)\nPolyhedral fan in ambient dimension 2\n\njulia> is_pointed(nf)\nfalse\n\njulia> lineality_dim(nf)\n1\n\n\n\n\n\n","category":"method"},{"location":"PolyhedralGeometry/fans/#is_regular-Tuple{PolyhedralFan}","page":"Polyhedral Fans","title":"is_regular","text":"is_regular(PF::PolyhedralFan)\n\nDetermine whether PF is regular, i.e. the normal fan of a polytope.\n\nExamples\n\nThis fan is not complete and thus not regular.\n\njulia> PF = polyhedral_fan(incidence_matrix([[1, 2], [3]]), [1 0; 0 1; -1 -1]);\n\njulia> is_regular(PF)\nfalse\n\n\n\n\n\n","category":"method"},{"location":"PolyhedralGeometry/fans/#is_simplicial-Tuple{PolyhedralFan}","page":"Polyhedral Fans","title":"is_simplicial","text":"is_simplicial(PF::PolyhedralFan)\n\nDetermine whether PF is simplicial, i.e. every cone should be generated by a basis of the ambient space.\n\nExamples\n\nThe normal_fan of the cube is simplicial, while the face_fan is not.\n\njulia> is_simplicial(normal_fan(cube(3)))\ntrue\n\njulia> is_simplicial(face_fan(cube(3)))\nfalse\n\n\n\n\n\n","category":"method"},{"location":"PolyhedralGeometry/fans/#is_smooth-Tuple{PolyhedralFan{QQFieldElem}}","page":"Polyhedral Fans","title":"is_smooth","text":"is_smooth(PF::PolyhedralFan{QQFieldElem})\n\nDetermine whether PF is smooth.\n\nExamples\n\nEven though the cones of this fan cover the positive orthant together, one of these und thus the whole fan is not smooth.\n\njulia> PF = polyhedral_fan(incidence_matrix([[1, 2], [2, 3]]), [0 1; 2 1; 1 0]);\n\njulia> is_smooth(PF)\nfalse\n\n\n\n\n\n","category":"method"},{"location":"PolyhedralGeometry/fans/#lineality_dim-Tuple{PolyhedralFan}","page":"Polyhedral Fans","title":"lineality_dim","text":"lineality_dim(PF::PolyhedralFan)\n\nReturn the dimension of the lineality space of the polyhedral fan PF, i.e. the dimension of the largest linear subspace.\n\nExamples\n\nThe dimension of the lineality space is zero if and only if the fan is pointed.\n\njulia> C = convex_hull([0 0; 1 0])\nPolyhedron in ambient dimension 2\n\njulia> is_fulldimensional(C)\nfalse\n\njulia> nf = normal_fan(C)\nPolyhedral fan in ambient dimension 2\n\njulia> is_pointed(nf)\nfalse\n\njulia> lineality_dim(nf)\n1\n\n\n\n\n\n","category":"method"},{"location":"PolyhedralGeometry/fans/#lineality_space-Tuple{PolyhedralFan}","page":"Polyhedral Fans","title":"lineality_space","text":"lineality_space(PF::PolyhedralFan)\n\nReturn a non-redundant matrix whose rows are generators of the lineality space of PF.\n\nExamples\n\nThis fan consists of two cones, one containing all the points with y  0 and one containing all the points with y  0. The fan's lineality is the common lineality of these two cones, i.e. in x-direction.\n\njulia> PF = polyhedral_fan(incidence_matrix([[1, 2, 3], [3, 4, 1]]), [1 0; 0 1; -1 0; 0 -1])\nPolyhedral fan in ambient dimension 2\n\njulia> lineality_space(PF)\n1-element SubObjectIterator{RayVector{QQFieldElem}}:\n [1, 0]\n\n\n\n\n\n","category":"method"},{"location":"PolyhedralGeometry/fans/#maximal_cones-Tuple{PolyhedralFan}","page":"Polyhedral Fans","title":"maximal_cones","text":"maximal_cones(PF::PolyhedralFan)\n\nReturn the maximal cones of PF.\n\nOptionally IncidenceMatrix can be passed as a first argument to return the incidence matrix specifying the maximal cones of PF. In that case, the indices refer to the output of rays_modulo_lineality(Cone).\n\nExamples\n\nHere we ask for the the number of rays for each maximal cone of the face fan of the 3-cube and use that maximal_cones returns an iterator.\n\njulia> PF = face_fan(cube(3));\n\njulia> for c in maximal_cones(PF)\n         println(n_rays(c))\n       end\n4\n4\n4\n4\n4\n4\n\njulia> maximal_cones(IncidenceMatrix, PF)\n6×8 IncidenceMatrix\n[1, 3, 5, 7]\n[2, 4, 6, 8]\n[1, 2, 5, 6]\n[3, 4, 7, 8]\n[1, 2, 3, 4]\n[5, 6, 7, 8]\n\n\n\n\n\n","category":"method"},{"location":"PolyhedralGeometry/fans/#cones-Tuple{PolyhedralFan, Int64}","page":"Polyhedral Fans","title":"cones","text":"cones(PF::PolyhedralFan, cone_dim::Int)\n\nReturn an iterator over the cones of PF of dimension cone_dim.\n\nExamples\n\nThe 12 edges of the 3-cube correspond to the 2-dimensional cones of its face fan:\n\njulia> PF = face_fan(cube(3));\n\njulia> cones(PF, 2)\n12-element SubObjectIterator{Cone{QQFieldElem}}:\n Polyhedral cone in ambient dimension 3\n Polyhedral cone in ambient dimension 3\n Polyhedral cone in ambient dimension 3\n Polyhedral cone in ambient dimension 3\n Polyhedral cone in ambient dimension 3\n Polyhedral cone in ambient dimension 3\n Polyhedral cone in ambient dimension 3\n Polyhedral cone in ambient dimension 3\n Polyhedral cone in ambient dimension 3\n Polyhedral cone in ambient dimension 3\n Polyhedral cone in ambient dimension 3\n Polyhedral cone in ambient dimension 3\n\n\n\n\n\n","category":"method"},{"location":"PolyhedralGeometry/fans/#cones-Tuple{PolyhedralFan}","page":"Polyhedral Fans","title":"cones","text":"cones(PF::PolyhedralFan)\n\nReturn the ray indices of all non-zero-dimensional cones in a polyhedral fan.\n\nExamples\n\njulia> PF = face_fan(cube(2))\nPolyhedral fan in ambient dimension 2\n\njulia> cones(PF)\n8×4 IncidenceMatrix\n[1, 3]\n[2, 4]\n[1, 2]\n[3, 4]\n[1]\n[3]\n[2]\n[4]\n\n\n\n\n\n","category":"method"},{"location":"PolyhedralGeometry/fans/#n_maximal_cones-Tuple{PolyhedralFan}","page":"Polyhedral Fans","title":"n_maximal_cones","text":"n_maximal_cones(PF::PolyhedralFan)\n\nReturn the number of maximal cones of PF.\n\nExamples\n\nThe cones given in this construction are non-redundant. Thus there are two maximal cones.\n\njulia> PF = polyhedral_fan(incidence_matrix([[1, 2], [3]]), [1 0; 0 1; -1 -1]);\n\njulia> n_maximal_cones(PF)\n2\n\n\n\n\n\n","category":"method"},{"location":"PolyhedralGeometry/fans/#n_cones-Tuple{PolyhedralFan}","page":"Polyhedral Fans","title":"n_cones","text":"n_cones(PF::PolyhedralFan)\n\nReturn the number of cones of PF.\n\nExamples\n\nThe cones given in this construction are non-redundant. There are six cones in this fan.\n\njulia> PF = polyhedral_fan(incidence_matrix([[1, 2], [3]]), [1 0; 0 1; -1 -1])\nPolyhedral fan in ambient dimension 2\n\njulia> n_cones(PF)\n4\n\n\n\n\n\n","category":"method"},{"location":"PolyhedralGeometry/fans/#n_rays-Tuple{PolyhedralFan}","page":"Polyhedral Fans","title":"n_rays","text":"n_rays(PF::PolyhedralFan)\n\nReturn the number of rays of PF.\n\nExamples\n\nThe 3-cube has 8 vertices. Accordingly, its face fan has 8 rays.\n\njulia> n_rays(face_fan(cube(3)))\n8\n\n\n\n\n\n","category":"method"},{"location":"PolyhedralGeometry/fans/#rays-Tuple{PolyhedralFan}","page":"Polyhedral Fans","title":"rays","text":"rays([as::Type{T} = RayVector,] PF::PolyhedralFan)\n\nReturn the rays of PF. The rays are defined to be the one-dimensional faces of its cones, so if PF has lineality, there are no rays.\n\nSee also rays_modulo_lineality.\n\nOptional arguments for as include\n\nRayVector.\n\nExamples\n\nThe rays of a normal fan of a cube point in every positive and negative unit direction.\n\njulia> C = cube(3);\n\njulia> NF = normal_fan(C);\n\njulia> rays(NF)\n6-element SubObjectIterator{RayVector{QQFieldElem}}:\n [1, 0, 0]\n [-1, 0, 0]\n [0, 1, 0]\n [0, -1, 0]\n [0, 0, 1]\n [0, 0, -1]\n\nAs for the Cone, the rays may be converted to a matrix using the matrix(ring, ...) function.\n\njulia> C = cube(3);\n\njulia> NF = normal_fan(C);\n\njulia> matrix(QQ, rays(NF))\n[ 1    0    0]\n[-1    0    0]\n[ 0    1    0]\n[ 0   -1    0]\n[ 0    0    1]\n[ 0    0   -1]\n\nThe following fan has no rays:\n\njulia> IM = incidence_matrix([[1,2],[2,3]]);\n\njulia> R = [1 0 0; 0 1 0; -1 0 0];\n\njulia> L = [0 0 1];\n\njulia> PF = polyhedral_fan(IM, R, L)\nPolyhedral fan in ambient dimension 3\n\njulia> rays(PF)\n0-element SubObjectIterator{RayVector{QQFieldElem}}\n\n\n\n\n\nrays(TropV::TropicalVariety)\n\nSee rays(::PolyhedralComplex).\n\n\n\n\n\n","category":"method"},{"location":"PolyhedralGeometry/fans/#rays_modulo_lineality-Tuple{PolyhedralFan}","page":"Polyhedral Fans","title":"rays_modulo_lineality","text":"rays_modulo_lineality(as, F::PolyhedralFan)\n\nReturn the rays of the polyhedral fan F up to lineality as a NamedTuple with two iterators. If F has lineality L, then the iterator rays_modulo_lineality iterates over representatives of the rays of F/L. The iterator lineality_basis gives a basis of the lineality space L.\n\nSee also rays and lineality_space.\n\nExamples\n\njulia> P = convex_hull(QQFieldElem, [0 0; 1 0])\nPolyhedron in ambient dimension 2\n\njulia> NF = normal_fan(P)\nPolyhedral fan in ambient dimension 2\n\njulia> rmlF = rays_modulo_lineality(NF)\n(rays_modulo_lineality = RayVector{QQFieldElem}[[1, 0], [-1, 0]], lineality_basis = RayVector{QQFieldElem}[[0, 1]])\n\njulia> rmlF.rays_modulo_lineality\n2-element SubObjectIterator{RayVector{QQFieldElem}}:\n [1, 0]\n [-1, 0]\n\njulia> rmlF.lineality_basis\n1-element SubObjectIterator{RayVector{QQFieldElem}}:\n [0, 1]\n\njulia> rays(NF)\n0-element SubObjectIterator{RayVector{QQFieldElem}}\n\n\n\n\n\nrays_modulo_lineality(TropV::TropicalVariety)\n\nSee rays_modulo_lineality(::PolyhedralComplex).\n\n\n\n\n\n","category":"method"},{"location":"PolyhedralGeometry/fans/#primitive_collections-Tuple{PolyhedralFan}","page":"Polyhedral Fans","title":"primitive_collections","text":"primitive_collections(PF::PolyhedralFan)\n\nReturn the primitive collections of a polyhedral fan.\n\nExamples\n\njulia> primitive_collections(normal_fan(simplex(3)))\n1-element Vector{Set{Int64}}:\n Set([4, 2, 3, 1])\n\n\n\n\n\n","category":"method"},{"location":"PolyhedralGeometry/fans/#star_subdivision-Tuple{PolyhedralFan, Int64}","page":"Polyhedral Fans","title":"star_subdivision","text":"star_subdivision(PF::PolyhedralFan, n::Int)\n\nReturn the star subdivision of a polyhedral fan at its n-th torus orbit. Note that this torus orbit need not be maximal. We follow definition 3.3.17 of [CLS11].\n\nExamples\n\njulia> star = star_subdivision(normal_fan(simplex(3)), 1)\nPolyhedral fan in ambient dimension 3\n\njulia> rays(star)\n5-element SubObjectIterator{RayVector{QQFieldElem}}:\n [1, 0, 0]\n [0, 1, 0]\n [0, 0, 1]\n [-1, -1, -1]\n [1, 1, 1]\n\njulia> ray_indices(maximal_cones(star))\n6×5 IncidenceMatrix\n[2, 3, 5]\n[1, 3, 5]\n[1, 2, 5]\n[2, 3, 4]\n[1, 3, 4]\n[1, 2, 4]\n\n\n\n\n\n","category":"method"},{"location":"PolyhedralGeometry/fans/#star_subdivision-Tuple{PolyhedralFan, AbstractVector{<:Union{Integer, ZZRingElem}}}","page":"Polyhedral Fans","title":"star_subdivision","text":"star_subdivision(PF::PolyhedralFan, new_ray::AbstractVector{<:IntegerUnion})\n\nReturn the star subdivision of a polyhedral fan by a primitive element of the underlying lattice. We follow the definition at the top of page 515 in [CLS11].\n\nExamples\n\njulia> fan = normal_fan(simplex(3))\nPolyhedral fan in ambient dimension 3\n\njulia> new_ray = [1, 1, 1];\n\njulia> star = star_subdivision(fan, new_ray)\nPolyhedral fan in ambient dimension 3\n\njulia> rays(star)\n5-element SubObjectIterator{RayVector{QQFieldElem}}:\n [1, 0, 0]\n [0, 1, 0]\n [0, 0, 1]\n [-1, -1, -1]\n [1, 1, 1]\n\njulia> ray_indices(maximal_cones(star))\n6×5 IncidenceMatrix\n[2, 3, 5]\n[1, 3, 5]\n[1, 2, 5]\n[2, 3, 4]\n[1, 3, 4]\n[1, 2, 4]\n\n\n\n\n\n","category":"method"},{"location":"PolyhedralGeometry/fans/#*-Tuple{PolyhedralFan{QQFieldElem}, PolyhedralFan{QQFieldElem}}","page":"Polyhedral Fans","title":"*","text":"*(PF1::PolyhedralFan{QQFieldElem}, PF2::PolyhedralFan{QQFieldElem})\n\nReturn the Cartesian/direct product of two polyhedral fans.\n\nExamples\n\njulia> normal_fan(simplex(2))*normal_fan(simplex(3))\nPolyhedral fan in ambient dimension 5\n\n\n\n\n\n","category":"method"},{"location":"NoncommutativeAlgebra/PBWAlgebras/creation/","page":"Creating PBW-Algebras","title":"Creating PBW-Algebras","text":"CurrentModule = Oscar\nDocTestSetup = Oscar.doctestsetup()","category":"page"},{"location":"NoncommutativeAlgebra/PBWAlgebras/creation/#Creating-PBW-Algebras","page":"Creating PBW-Algebras","title":"Creating PBW-Algebras","text":"","category":"section"},{"location":"NoncommutativeAlgebra/PBWAlgebras/creation/#Types","page":"Creating PBW-Algebras","title":"Types","text":"","category":"section"},{"location":"NoncommutativeAlgebra/PBWAlgebras/creation/","page":"Creating PBW-Algebras","title":"Creating PBW-Algebras","text":"PBW-algebras are modeled by objects of type PBWAlgRing{T, S} <: NCRing, their elements are objects of type PBWAlgElem{T, S} <: NCRingElem. Here,  T is the element type of the field over which the PBW-algebra is defined (the type S is added for internal use).","category":"page"},{"location":"NoncommutativeAlgebra/PBWAlgebras/creation/#Constructors","page":"Creating PBW-Algebras","title":"Constructors","text":"","category":"section"},{"location":"NoncommutativeAlgebra/PBWAlgebras/creation/","page":"Creating PBW-Algebras","title":"Creating PBW-Algebras","text":"The basic constructor below allows one to build PBW-algebras:","category":"page"},{"location":"NoncommutativeAlgebra/PBWAlgebras/creation/","page":"Creating PBW-Algebras","title":"Creating PBW-Algebras","text":"pbw_algebra(R::MPolyRing{T}, rel, ord::MonomialOrdering) where T","category":"page"},{"location":"NoncommutativeAlgebra/PBWAlgebras/creation/#pbw_algebra-Union{Tuple{T}, Tuple{MPolyRing{T}, Any, MonomialOrdering}} where T","page":"Creating PBW-Algebras","title":"pbw_algebra","text":"pbw_algebra(R::MPolyRing{T}, rel, ord::MonomialOrdering; check::Bool = true) where T\n\nGiven a multivariate polynomial ring R over a field, say R=Kx_1 dots x_n, given a strictly upper triangular matrix rel with entries in R of type c_ij cdot x_ix_j+d_ij, where the c_ij are nonzero scalars and where we think of the x_jx_i = c_ij cdot x_ix_j+d_ij as setting up relations in the free associative algebra Klangle x_1 dots  x_nrangle, and given an ordering ord on textMon(x_1 dots x_n), return the PBW-algebra\n\nA = Klangle x_1 dots  x_n mid x_jx_i = c_ij cdot x_ix_j+d_ij   1leq ij leq n rangle\n\nnote: Note\nThe input data gives indeed rise to  a PBW-algebra if:The ordering ord is admissible for A.\nThe standard monomials in Klangle x_1 dots  x_nrangle represent a K-basis for A.See the definition of PBW-algebras in the OSCAR documentation for details.\n\nnote: Note\nThe K-basis condition above is checked by default. This check may be skipped by passing check = false.\n\nExamples\n\njulia> R, (x, y, z) = QQ[:x, :y, :z];\n\njulia> L = [x*y, x*z, y*z + 1];\n\njulia> REL = strictly_upper_triangular_matrix(L);\n\njulia> A, (x, y, z) = pbw_algebra(R, REL, deglex(gens(R)))\n(PBW-algebra over rational field in x, y, z with relations y*x = x*y, z*x = x*z, z*y = y*z + 1, PBWAlgElem{QQFieldElem, Singular.n_Q}[x, y, z])\n\n\n\n\n\n","category":"method"},{"location":"NoncommutativeAlgebra/PBWAlgebras/creation/","page":"Creating PBW-Algebras","title":"Creating PBW-Algebras","text":"Some PBW-algebras are predefined in OSCAR.","category":"page"},{"location":"NoncommutativeAlgebra/PBWAlgebras/creation/#Weyl-Algebras","page":"Creating PBW-Algebras","title":"Weyl Algebras","text":"","category":"section"},{"location":"NoncommutativeAlgebra/PBWAlgebras/creation/","page":"Creating PBW-Algebras","title":"Creating PBW-Algebras","text":"The n-th Weyl algebra over a field K is the PBW-algebra","category":"page"},{"location":"NoncommutativeAlgebra/PBWAlgebras/creation/","page":"Creating PBW-Algebras","title":"Creating PBW-Algebras","text":"D_n(K)=K langle x_1ldots x_n partial _1dots partial _n mid partial_i x_i=x_ipartial _i +1 partial _i x_j=x_j partial _i  text  for  ineq jrangle","category":"page"},{"location":"NoncommutativeAlgebra/PBWAlgebras/creation/","page":"Creating PBW-Algebras","title":"Creating PBW-Algebras","text":"Here,  we tacitly assume that","category":"page"},{"location":"NoncommutativeAlgebra/PBWAlgebras/creation/","page":"Creating PBW-Algebras","title":"Creating PBW-Algebras","text":"x_j x_i=x_i x _j  text and   partial _j partial_i=partial_i partial _j  text for all   ij","category":"page"},{"location":"NoncommutativeAlgebra/PBWAlgebras/creation/","page":"Creating PBW-Algebras","title":"Creating PBW-Algebras","text":"Note that any  global monomial ordering on textMon_2n(x partial) is admissible for D_n(K).","category":"page"},{"location":"NoncommutativeAlgebra/PBWAlgebras/creation/","page":"Creating PBW-Algebras","title":"Creating PBW-Algebras","text":"The constructor below returns the algebras equipped with degrevlex.","category":"page"},{"location":"NoncommutativeAlgebra/PBWAlgebras/creation/","page":"Creating PBW-Algebras","title":"Creating PBW-Algebras","text":"weyl_algebra(K::Ring, xs::AbstractVector{<:VarName})","category":"page"},{"location":"NoncommutativeAlgebra/PBWAlgebras/creation/#weyl_algebra-Tuple{Ring, AbstractVector{<:Union{Char, AbstractString, Symbol}}}","page":"Creating PBW-Algebras","title":"weyl_algebra","text":"weyl_algebra(K::Ring, xs::AbstractVector{<:VarName})\n\nGiven a field K and a vector xs of,  say, n Strings, Symbols, or Characters, return the n-th Weyl algebra over K.\n\nThe generators of the returned algebra print according to the entries of xs. See the example below.\n\nExamples\n\njulia> D, (x, y, dx, dy) = weyl_algebra(QQ, [:x, :y])\n(Weyl-algebra over rational field in variables (x, y), PBWAlgElem{QQFieldElem, Singular.n_Q}[x, y, dx, dy])\n\njulia> dx*x\nx*dx + 1\n\n\n\n\n\n","category":"method"},{"location":"NoncommutativeAlgebra/PBWAlgebras/creation/#Universal-Enveloping-Algebras-of-Finite-Dimensional-Lie-Algebras","page":"Creating PBW-Algebras","title":"Universal Enveloping Algebras of Finite Dimensional Lie Algebras","text":"","category":"section"},{"location":"NoncommutativeAlgebra/PBWAlgebras/creation/","page":"Creating PBW-Algebras","title":"Creating PBW-Algebras","text":"Let mathfrak g be an n-dimensional Lie algebra over a field K, and let x_1 dots x_n be a K-basis of mathfrak g. Consider n indeterminates which are also denoted by x_1 dots x_n.  The universal enveloping algebra of mathfrak g is the PBW-algebra","category":"page"},{"location":"NoncommutativeAlgebra/PBWAlgebras/creation/","page":"Creating PBW-Algebras","title":"Creating PBW-Algebras","text":"U(mathfrak g)=K langle x_1ldots x_n mid x_jx_i = x_ix_j+x_j x_i   1leq ij leq n rangle","category":"page"},{"location":"NoncommutativeAlgebra/PBWAlgebras/creation/","page":"Creating PBW-Algebras","title":"Creating PBW-Algebras","text":"where x_j x_i corresponds to evaluating the Lie bracket x_j x_i_mathfrak g. That the standard monomials in U(mathfrak g) indeed form a K-basis for U(mathfrak g) is the content of the Poincartexte-Birkhoff-Witt theorem (the names PBW-basis and PBW-algebra are derived from this fact).","category":"page"},{"location":"NoncommutativeAlgebra/PBWAlgebras/creation/","page":"Creating PBW-Algebras","title":"Creating PBW-Algebras","text":"Note that any degree compatible global monomial ordering on mathbbN^n is admissible for U(mathfrak g).","category":"page"},{"location":"NoncommutativeAlgebra/PBWAlgebras/creation/","page":"Creating PBW-Algebras","title":"Creating PBW-Algebras","text":"The constructors below return the algebras equipped with degrevlex.","category":"page"},{"location":"NoncommutativeAlgebra/PBWAlgebras/creation/#Quantized-Enveloping-Algebras","page":"Creating PBW-Algebras","title":"Quantized Enveloping Algebras","text":"","category":"section"},{"location":"NoncommutativeAlgebra/PBWAlgebras/creation/#Non-Standard-Quantum-Deformation-of-so_3","page":"Creating PBW-Algebras","title":"Non-Standard Quantum Deformation of so_3","text":"","category":"section"},{"location":"NoncommutativeAlgebra/PBWAlgebras/creation/#Data-Associated-to-PBW-Algebras","page":"Creating PBW-Algebras","title":"Data Associated to PBW-Algebras","text":"","category":"section"},{"location":"NoncommutativeAlgebra/PBWAlgebras/creation/","page":"Creating PBW-Algebras","title":"Creating PBW-Algebras","text":"Given a PBW-algebra A over a field K, ","category":"page"},{"location":"NoncommutativeAlgebra/PBWAlgebras/creation/","page":"Creating PBW-Algebras","title":"Creating PBW-Algebras","text":"coefficient_ring(A) refers to K,\ngens(A) to the generators of A,\nnumber_of_generators(A) / ngens(A) to the number of these generators, and\ngen(A, i) as well as A[i] to the i-th such generator.","category":"page"},{"location":"NoncommutativeAlgebra/PBWAlgebras/creation/#Examples","page":"Creating PBW-Algebras","title":"Examples","text":"","category":"section"},{"location":"NoncommutativeAlgebra/PBWAlgebras/creation/","page":"Creating PBW-Algebras","title":"Creating PBW-Algebras","text":"julia> R, (x,y,z) = QQ[:x, :y, :z];\n\njulia> L = [x*y, x*z, y*z + 1];\n\njulia> REL = strictly_upper_triangular_matrix(L);\n\njulia> A, (x,y,z) = pbw_algebra(R, REL, deglex(gens(R)));\n\njulia> coefficient_ring(A)\nRational field\n\njulia> gens(A)\n3-element Vector{PBWAlgElem{QQFieldElem, Singular.n_Q}}:\n x\n y\n z\n\njulia> gen(A, 2)\ny\n\njulia> A[3]\nz \n\njulia> number_of_generators(A)\n3\n","category":"page"},{"location":"NoncommutativeAlgebra/PBWAlgebras/creation/#Elements-of-PBW-Algebras","page":"Creating PBW-Algebras","title":"Elements of PBW-Algebras","text":"","category":"section"},{"location":"NoncommutativeAlgebra/PBWAlgebras/creation/","page":"Creating PBW-Algebras","title":"Creating PBW-Algebras","text":"Elements of PBW-algebras are stored and printed in their standard representation.","category":"page"},{"location":"NoncommutativeAlgebra/PBWAlgebras/creation/#Constructors-2","page":"Creating PBW-Algebras","title":"Constructors","text":"","category":"section"},{"location":"NoncommutativeAlgebra/PBWAlgebras/creation/","page":"Creating PBW-Algebras","title":"Creating PBW-Algebras","text":"One way to create elements of a PBW-algebra A over a field K is to build them up from the generators of A using basic arithmetic as shown below:","category":"page"},{"location":"NoncommutativeAlgebra/PBWAlgebras/creation/#Examples-2","page":"Creating PBW-Algebras","title":"Examples","text":"","category":"section"},{"location":"NoncommutativeAlgebra/PBWAlgebras/creation/","page":"Creating PBW-Algebras","title":"Creating PBW-Algebras","text":"julia> R, (x,y,z) = QQ[:x, :y, :z];\n\njulia> L = [x*y, x*z, y*z + 1];\n\njulia> REL = strictly_upper_triangular_matrix(L);\n\njulia> A, (x,y,z) = pbw_algebra(R, REL, deglex(gens(R)));\n\njulia> f = 3*x^2+z*y\n3*x^2 + y*z + 1\n","category":"page"},{"location":"NoncommutativeAlgebra/PBWAlgebras/creation/","page":"Creating PBW-Algebras","title":"Creating PBW-Algebras","text":"Alternatively, there is the following constructor:","category":"page"},{"location":"NoncommutativeAlgebra/PBWAlgebras/creation/","page":"Creating PBW-Algebras","title":"Creating PBW-Algebras","text":"(A::PBWAlgRing)(cs::AbstractVector, es::AbstractVector{Vector{Int}})","category":"page"},{"location":"NoncommutativeAlgebra/PBWAlgebras/creation/","page":"Creating PBW-Algebras","title":"Creating PBW-Algebras","text":"Its return value is the element of  A  whose standard representation is built from the elements of cs as coefficients, and the elements of es as exponents.","category":"page"},{"location":"NoncommutativeAlgebra/PBWAlgebras/creation/#Examples-3","page":"Creating PBW-Algebras","title":"Examples","text":"","category":"section"},{"location":"NoncommutativeAlgebra/PBWAlgebras/creation/","page":"Creating PBW-Algebras","title":"Creating PBW-Algebras","text":"julia> R, (x,y,z) = QQ[:x, :y, :z];\n\njulia> L = [x*y, x*z, y*z + 1];\n\njulia> REL = strictly_upper_triangular_matrix(L);\n\njulia> A, (x,y,z) = pbw_algebra(R, REL, deglex(gens(R)));\n\njulia> f = 3*x^2+z*y\n3*x^2 + y*z + 1\n\njulia> g = A(QQ.([3, 1, 1]), [[2, 0, 0], [0, 1, 1], [0, 0, 0]])\n3*x^2 + y*z + 1\n\njulia> f == g\ntrue\n","category":"page"},{"location":"NoncommutativeAlgebra/PBWAlgebras/creation/","page":"Creating PBW-Algebras","title":"Creating PBW-Algebras","text":"An often more effective way to create elements is to use the corresponding build context as indicated below:","category":"page"},{"location":"NoncommutativeAlgebra/PBWAlgebras/creation/","page":"Creating PBW-Algebras","title":"Creating PBW-Algebras","text":"julia> R, (x,y,z) = QQ[:x, :y, :z];\n\njulia> L = [x*y, x*z, y*z + 1];\n\njulia> REL = strictly_upper_triangular_matrix(L);\n\njulia> A, (x,y,z) = pbw_algebra(R, REL, deglex(gens(R)));\n\njulia> B =  build_ctx(A);\n\njulia> for i = 1:5 push_term!(B, QQ(i), [i+1, i, i-1]) end\n\njulia> finish(B)\n5*x^6*y^5*z^4 + 4*x^5*y^4*z^3 + 3*x^4*y^3*z^2 + 2*x^3*y^2*z + x^2*y\n","category":"page"},{"location":"NoncommutativeAlgebra/PBWAlgebras/creation/#Special-Elements","page":"Creating PBW-Algebras","title":"Special Elements","text":"","category":"section"},{"location":"NoncommutativeAlgebra/PBWAlgebras/creation/","page":"Creating PBW-Algebras","title":"Creating PBW-Algebras","text":"Given a PBW-algebra A, zero(A) and one(A) refer to the additive and multiplicative identity of A, respectively. Relevant test calls on an element f of A are  iszero(f) and isone(f).","category":"page"},{"location":"NoncommutativeAlgebra/PBWAlgebras/creation/#Data-Associated-to-Elements-of-PBW-algebras","page":"Creating PBW-Algebras","title":"Data Associated to Elements of PBW-algebras","text":"","category":"section"},{"location":"NoncommutativeAlgebra/PBWAlgebras/creation/","page":"Creating PBW-Algebras","title":"Creating PBW-Algebras","text":"Given an element f of a PBW-algebra A, ","category":"page"},{"location":"NoncommutativeAlgebra/PBWAlgebras/creation/","page":"Creating PBW-Algebras","title":"Creating PBW-Algebras","text":"parent(f) refers to A,","category":"page"},{"location":"NoncommutativeAlgebra/PBWAlgebras/creation/#Opposite-Algebras","page":"Creating PBW-Algebras","title":"Opposite Algebras","text":"","category":"section"},{"location":"NoncommutativeAlgebra/PBWAlgebras/creation/","page":"Creating PBW-Algebras","title":"Creating PBW-Algebras","text":"opposite_algebra(A::PBWAlgRing)","category":"page"},{"location":"NoncommutativeAlgebra/PBWAlgebras/creation/#opposite_algebra-Tuple{PBWAlgRing}","page":"Creating PBW-Algebras","title":"opposite_algebra","text":"opposite_algebra(A::PBWAlgRing)\n\nReturn the opposite algebra of A.\n\nExamples\n\njulia> D, (x, y, dx, dy) = weyl_algebra(QQ, [:x, :y])\n(Weyl-algebra over rational field in variables (x, y), PBWAlgElem{QQFieldElem, Singular.n_Q}[x, y, dx, dy])\n\njulia> Dop, opp = opposite_algebra(D);\n\njulia> Dop\nPBW-algebra over rational field in dy, dx, y, x with relations dx*dy = dy*dx, y*dy = dy*y + 1, x*dy = dy*x, y*dx = dx*y, x*dx = dx*x + 1, x*y = y*x\n\njulia> opp\nMap to opposite of Weyl-algebra over rational field in variables (x, y)\n\njulia> opp(dx*x)\ndx*x + 1\n\n\n\n\n\n","category":"method"},{"location":"NoncommutativeAlgebra/PBWAlgebras/creation/","page":"Creating PBW-Algebras","title":"Creating PBW-Algebras","text":"If a map opp from a PBW-algebra to its opposite algebra is given, then inv(opp) refers to the inverse of opp.","category":"page"},{"location":"AlgebraicGeometry/SheafCohomology/sheaf_cohomology/","page":"Sheaves on Projective Space","title":"Sheaves on Projective Space","text":"CurrentModule = Oscar\nDocTestSetup = Oscar.doctestsetup()","category":"page"},{"location":"AlgebraicGeometry/SheafCohomology/sheaf_cohomology/#Sheaves-on-Projective-Space","page":"Sheaves on Projective Space","title":"Sheaves on Projective Space","text":"","category":"section"},{"location":"AlgebraicGeometry/SheafCohomology/sheaf_cohomology/","page":"Sheaves on Projective Space","title":"Sheaves on Projective Space","text":"We present two algorithms for computing sheaf cohomology over projective n-space. The algorithms are based on Tate resolutions via the Bernstein-Gelfand-Gelfand-correspondence as introduced in [EFS03] and on local cohomology (see [Eis98]), respectively. While the first algorithm makes use of syzygy computations over the exterior algebra, the second algorithm is based on syzygy computations over the symmetric algebra (see [DE02] for a tutorial). Thus, in most examples, the first algorithm is much faster.","category":"page"},{"location":"AlgebraicGeometry/SheafCohomology/sheaf_cohomology/","page":"Sheaves on Projective Space","title":"Sheaves on Projective Space","text":"sheaf_cohomology(M::ModuleFP{T}, l::Int, h::Int; algorithm::Symbol = :bgg) where {T <: MPolyDecRingElem}","category":"page"},{"location":"AlgebraicGeometry/SheafCohomology/sheaf_cohomology/#sheaf_cohomology-Union{Tuple{T}, Tuple{ModuleFP{T}, Int64, Int64}} where T<:MPolyDecRingElem","page":"Sheaves on Projective Space","title":"sheaf_cohomology","text":"sheaf_cohomology(M::ModuleFP{T}, l::Int, h::Int; algorithm::Symbol = :bgg) where {T <: MPolyDecRingElem}\n\nIf M is a graded module over a standard graded multivariate polynomial ring with coefficients in a field K,  say, and mathcal F = widetildeM is the coherent sheaf associated to M on the corresponding projective  space mathbb P^n(K), consider the cohomology groups H^i(mathbb P^n(K) mathcal F(d)) as vector spaces  over K, and return their dimensions h^i(mathbb P^n(K) mathcal F(d)) in the range of twists d  indicated by l and h. The result is presented as a table, where '-' indicates that h^i(mathbb P^n(K) mathcal F(d)) = 0. The line starting  with chi lists the Euler characteristic  of each twist under consideration. The values in the table can be accessed as shown in the  first example below. Note that this example addresses the cotangent bundle on projective 3-space, while the  second example is concerned with the structure sheaf of projective 4-space.\n\nThe keyword algorithm can be set to\n\n:bgg (use the Tate resolution via the Bernstein-Gelfand-Gelfand correspondence),\n:loccoh (use local cohomology).\n\nnote: Note\nDue to the shape of the Tate resolution, the algorithm addressed by bgg does not compute all values in the given range l  h. The missing values are indicated by a *. To determine all values in the range l  h, enter sheaf_cohomology(M, l-ngens(base_ring(M)), h+ngens(base_ring(M))).\n\njulia> R, x = polynomial_ring(QQ, :x => 1:4);\n\njulia> S, _= grade(R);\n\njulia> I = ideal(S, gens(S))\nIdeal generated by\n  x[1]\n  x[2]\n  x[3]\n  x[4]\n\njulia> FI = free_resolution(I)\nFree resolution of I\nS^4 <---- S^6 <---- S^4 <---- S^1 <---- 0\n0         1         2         3         4\n\njulia> M = cokernel(map(FI, 2));\n\njulia> tbl = sheaf_cohomology(M, -6, 2)\ntwist:  -6  -5  -4  -3  -2  -1   0   1   2\n------------------------------------------\n3:      70  36  15   4   -   -   -   -   *\n2:       *   -   -   -   -   -   -   -   -\n1:       *   *   -   -   -   -   1   -   -\n0:       *   *   *   -   -   -   -   -   6\n------------------------------------------\nchi:     *   *   *   4   -   -   1   -   *\n\njulia> tbl[0, 2]\n6\n\njulia> tbl[1, 0]\n1\n\njulia> sheaf_cohomology(M, -9, 5)\ntwist:   -9   -8   -7   -6   -5   -4   -3   -2   -1    0    1    2    3    4    5\n---------------------------------------------------------------------------------\n3:      280  189  120   70   36   15    4    -    -    -    -    -    *    *    *\n2:        *    -    -    -    -    -    -    -    -    -    -    -    -    *    *\n1:        *    *    -    -    -    -    -    -    -    1    -    -    -    -    *\n0:        *    *    *    -    -    -    -    -    -    -    -    6   20   45   84\n---------------------------------------------------------------------------------\nchi:      *    *    *   70   36   15    4    -    -    1    -    6    *    *    *\n\njulia> R, x = polynomial_ring(QQ, :x => 1:5);\n\njulia> S, _  = grade(R);\n\njulia> F = graded_free_module(S, 1);\n\njulia> sheaf_cohomology(F, -8, 3, algorithm = :loccoh)\ntwist:  -8  -7  -6  -5  -4  -3  -2  -1   0   1   2   3\n------------------------------------------------------\n4:      35  15   5   1   -   -   -   -   -   -   -   -\n3:       -   -   -   -   -   -   -   -   -   -   -   -\n2:       -   -   -   -   -   -   -   -   -   -   -   -\n1:       -   -   -   -   -   -   -   -   -   -   -   -\n0:       -   -   -   -   -   -   -   -   1   5  15  35\n------------------------------------------------------\nchi:    35  15   5   1   -   -   -   -   1   5  15  35\n\n\n\n\n\n","category":"method"},{"location":"Groups/tom/","page":"Tables of Marks","title":"Tables of Marks","text":"CurrentModule = Oscar\nDocTestSetup = Oscar.doctestsetup()","category":"page"},{"location":"Groups/tom/#Tables-of-Marks","page":"Tables of Marks","title":"Tables of Marks","text":"","category":"section"},{"location":"Groups/tom/","page":"Tables of Marks","title":"Tables of Marks","text":"The concept of a Table of Marks was introduced by W. Burnside in his book Theory  of Groups of Finite Order [Bur11]. Therefore a table of marks is sometimes called a Burnside matrix. The table of marks of a finite group G is a matrix whose rows and columns are labelled by the conjugacy classes of subgroups of G and where for two subgroups H and K the (H K)-entry is the number of fixed points of K in the transitive action of G on the right cosets of H in G. So the table of marks characterizes the set of all permutation representations of G. Moreover, the table of marks gives a compact description of the subgroup lattice of G, since from the numbers of fixed points the numbers of conjugates of a subgroup K contained in a subgroup H can be derived.","category":"page"},{"location":"Groups/tom/","page":"Tables of Marks","title":"Tables of Marks","text":"For small groups the table of marks of G can be constructed directly by first computing the entire subgroup lattice of G, see table_of_marks(G::Union{GAPGroup, FinGenAbGroup}). Besides that, the Table of Marks library [MNP24] provides access to several hundred tables of marks of simple groups and maximal subgroups of simple groups. These tables of marks can be fetched via the names of these groups, which coincide with the names of the character tables of these groups in the Character Table Library, see table_of_marks(id::String).","category":"page"},{"location":"Groups/tom/","page":"Tables of Marks","title":"Tables of Marks","text":"Like the library of character tables, the library of tables of marks can be used similar to group libraries (see Group libraries) in the sense that all_table_of_marks_names returns descriptions of all those available tables of marks that have certain properties.","category":"page"},{"location":"Groups/tom/#Construct-tables-of-marks","page":"Tables of Marks","title":"Construct tables of marks","text":"","category":"section"},{"location":"Groups/tom/","page":"Tables of Marks","title":"Tables of Marks","text":"GAPGroupTableOfMarks\ntable_of_marks(G::Union{GAPGroup, FinGenAbGroup})\ntable_of_marks(id::String)\nBase.show(io::IO, ::MIME\"text/plain\", tom::GAPGroupTableOfMarks)\nall_table_of_marks_names\nis_table_of_marks_name","category":"page"},{"location":"Groups/tom/#GAPGroupTableOfMarks","page":"Tables of Marks","title":"GAPGroupTableOfMarks","text":"GAPGroupTableOfMarks <: GroupTableOfMarks\n\nThis is the type of tables of marks that can delegate tasks to an underlying table of marks object in the GAP system (field GAPTable).\n\nA group can (but need not) be stored in the field group. If it is available then also the field isomorphism is available, its value is a bijective map from the group value to a group in GAP.\n\nObjects of type GAPGroupTableOfMarks support get_attribute.\n\n\n\n\n\n","category":"type"},{"location":"Groups/tom/#table_of_marks-Tuple{Union{FinGenAbGroup, Oscar.GAPGroup}}","page":"Tables of Marks","title":"table_of_marks","text":"table_of_marks(G::GAPGroup)\n\nReturn the table of marks of the finite group G.\n\nExamples\n\njulia> show(stdout, MIME(\"text/plain\"), table_of_marks(symmetric_group(3)))\nTable of marks of Sym(3)\n\n1: 6      \n2: 3 1    \n3: 2 . 2  \n4: 1 1 1 1\n\n\n\n\n\n","category":"method"},{"location":"Groups/tom/#table_of_marks-Tuple{String}","page":"Tables of Marks","title":"table_of_marks","text":"table_of_marks(id::String)\n\nReturn the table of marks for which id is an admissible name in GAP's library of tables of marks. If no such table is available then nothing is returned.\n\nExamples\n\njulia> println(table_of_marks(\"A5\"))\ntable of marks of A5\n\njulia> println(table_of_marks(\"J5\"))\nnothing\n\n\n\n\n\n","category":"method"},{"location":"Groups/tom/#show-Tuple{IO, MIME{Symbol(\"text/plain\")}, Oscar.GAPGroupTableOfMarks}","page":"Tables of Marks","title":"show","text":"Base.show(io::IO, ::MIME\"text/plain\", tom::GAPGroupTableOfMarks)\n\nDisplay the marks of tom and context information as a two-dimensional array.\n\nFirst a header is shown. If tom stores a group then the header describes this group, otherwise it is equal to the identifier(tom::GAPGroupTableOfMarks) value of tom.\nThen the matrix of marks of tom is shown in column portions that fit on the screen, together with row labels (the number i for the i-th row) on the left of each portion.\n\nOutput in LaTeX syntax can be created by calling show with second argument MIME(\"text/latex\").\n\nExamples\n\njulia> tom = table_of_marks(\"A5\");\n\njulia> show(stdout, MIME(\"text/plain\"), tom)\nA5\n\n1: 60                \n2: 30 2              \n3: 20 . 2            \n4: 15 3 . 3          \n5: 12 . . . 2        \n6: 10 2 1 . . 1      \n7:  6 2 . . 1 . 1    \n8:  5 1 2 1 . . . 1  \n9:  1 1 1 1 1 1 1 1 1\n\n\n\n\n\n","category":"method"},{"location":"Groups/tom/#all_table_of_marks_names","page":"Tables of Marks","title":"all_table_of_marks_names","text":"all_table_of_marks_names(L...; ordered_by = nothing)\n\nReturn a vector of strings that contains an admissible name of each table of marks in the library of tables of marks that satisfies the conditions in the vector L.\n\nThe supported conditions in L are the same as for all_character_table_names, and the returned vector contains the subset of those names returned by all_character_table_names with the same input for which a table of marks is available in the library.\n\nExamples\n\njulia> spor_names = all_table_of_marks_names(is_sporadic_simple => true);\n\njulia> println(spor_names[1:5])\n[\"Co3\", \"HS\", \"He\", \"J1\", \"J2\"]\n\njulia> spor_names = all_table_of_marks_names(is_sporadic_simple;\n         ordered_by = order);\n\njulia> println(spor_names[1:5])\n[\"M11\", \"M12\", \"J1\", \"M22\", \"J2\"]\n\njulia> length(all_table_of_marks_names(number_of_conjugacy_classes => 5))\n4\n\n\n\n\n\n","category":"function"},{"location":"Groups/tom/#is_table_of_marks_name","page":"Tables of Marks","title":"is_table_of_marks_name","text":"is_table_of_marks_name(name::String)\n\nReturn true if table_of_marks(name) returns a table of marks, and false otherwise\n\nExamples\n\njulia> is_table_of_marks_name(\"J1\")\ntrue\n\njulia> is_table_of_marks_name(\"J4\")\nfalse\n\n\n\n\n\n","category":"function"},{"location":"Groups/tom/#Attributes-and-operations-for-tables-of-marks","page":"Tables of Marks","title":"Attributes and operations for tables of marks","text":"","category":"section"},{"location":"Groups/tom/","page":"Tables of Marks","title":"Tables of Marks","text":"class_lengths(tom::GAPGroupTableOfMarks)\nidentifier(tom::GAPGroupTableOfMarks)\norder(tom::GAPGroupTableOfMarks)\norders_class_representatives(tom::GAPGroupTableOfMarks)\nrepresentative(tom::GAPGroupTableOfMarks, i::Int)","category":"page"},{"location":"Groups/tom/#class_lengths-Tuple{Oscar.GAPGroupTableOfMarks}","page":"Tables of Marks","title":"class_lengths","text":"class_lengths(tom::GAPGroupTableOfMarks)\n\nReturn the vector of the lengths of the conjugacy classes of subgroups for tom.\n\nExamples\n\njulia> println(class_lengths(table_of_marks(\"A5\")))\nZZRingElem[1, 15, 10, 5, 6, 10, 6, 5, 1]\n\n\n\n\n\n","category":"method"},{"location":"Groups/tom/#identifier-Tuple{Oscar.GAPGroupTableOfMarks}","page":"Tables of Marks","title":"identifier","text":"identifier(tom::GAPGroupTableOfMarks)\n\nReturn a string that identifies tom if tom belongs to the library of tables of marks, and an empty string otherwise.\n\nExamples\n\njulia> identifier(table_of_marks(\"A5\"))\n\"A5\"\n\njulia> identifier(table_of_marks(symmetric_group(3)))\n\"\"\n\nwarning: Note:\nThe identifier of a table of marks from the library is equal to the identifier of the corresponding library character table. In a few cases, this value differs from the GAP.Globals.Identifier value of the underlying GapObj of  the table of marks.\n\n\n\n\n\n","category":"method"},{"location":"Groups/tom/#order-Tuple{Oscar.GAPGroupTableOfMarks}","page":"Tables of Marks","title":"order","text":"order(::Type{T} = ZZRingElem, tom::GAPGroupTableOfMarks) where T <: IntegerUnion\n\nReturn the order of the group for which tom is the table of marks, as an instance of T.\n\nExamples\n\njulia> order(table_of_marks(symmetric_group(4)))\n24\n\n\n\n\n\n","category":"method"},{"location":"Groups/tom/#orders_class_representatives-Tuple{Oscar.GAPGroupTableOfMarks}","page":"Tables of Marks","title":"orders_class_representatives","text":"orders_class_representatives(tom::GAPGroupTableOfMarks)\n\nReturn the vector of the orders of conjugacy class representatives for tom, ordered according to the rows and columns of tom.\n\nExamples\n\njulia> println(orders_class_representatives(table_of_marks(\"A5\")))\nZZRingElem[1, 2, 3, 4, 5, 6, 10, 12, 60]\n\n\n\n\n\n","category":"method"},{"location":"Groups/tom/#representative-Tuple{Oscar.GAPGroupTableOfMarks, Int64}","page":"Tables of Marks","title":"representative","text":"representative(tom::GAPGroupTableOfMarks, i::Int)\n\nReturn a representative from the i-th class of subgroups of tom.\n\nAn exception is thrown if tom does not store a group, or if i is larger than length(tom).\n\nExamples\n\njulia> representative(table_of_marks(\"A5\"), 2)\nPermutation group of degree 5 and order 2\n\n\n\n\n\n","category":"method"},{"location":"Groups/tom/#Marks-vectors","page":"Tables of Marks","title":"Marks vectors","text":"","category":"section"},{"location":"Groups/tom/","page":"Tables of Marks","title":"Tables of Marks","text":"The mathbb Z-linear combinations of the rows of the table of marks of the group G can be interpreted as elements of the integral Burnside ring of G: The rows of the table represent the isomorphism classes of transitive G-sets, the sum of two rows represents the isomorphism class of the disjoint union of the two G-sets, and the pointwise product of two rows represents the isomorphism class of the Cartesian product of the two G-sets. The coefficients of the decomposition of a linear combination of rows can be computed by coordinates(chi::GAPGroupMarksVector).","category":"page"},{"location":"Groups/tom/","page":"Tables of Marks","title":"Tables of Marks","text":"The rows of a table of marks and their mathbb Z-linear combinations are implemented as marks vector objects, with parent the table of marks.","category":"page"},{"location":"Groups/tom/","page":"Tables of Marks","title":"Tables of Marks","text":"length and iteration:","category":"page"},{"location":"Groups/tom/","page":"Tables of Marks","title":"Tables of Marks","text":"The length of a marks vector is the number of columns of the table of marks. iteration is defined w.r.t. the ordering of columns.","category":"page"},{"location":"Groups/tom/","page":"Tables of Marks","title":"Tables of Marks","text":"arithmetic operations:","category":"page"},{"location":"Groups/tom/","page":"Tables of Marks","title":"Tables of Marks","text":"chi == psi: two marks vectors are equal if and only if they belong to the same table of marks and have the same values,\nchi + psi and chi - psi are the pointwise sum and difference, respectively, of the two marks vectors chi, psi,\nn * chi is the pointwise n-fold sum of chi, for an integer n,\nchi * psi is the pointwise product of chi and psi,\nzero(chi) is the marks vector that is zero on all classes,\none(chi) is the all-one marks vector, corresponding to the G-set that consists of one point,\nchi^n is the n-th power of chi, for positive integers n.","category":"page"},{"location":"Groups/tom/","page":"Tables of Marks","title":"Tables of Marks","text":"coordinates(chi::GAPGroupMarksVector)\nrestrict(chi::GAPGroupMarksVector, tbl::GAPGroupCharacterTable)","category":"page"},{"location":"Groups/tom/#coordinates-Tuple{Oscar.GAPGroupMarksVector}","page":"Tables of Marks","title":"coordinates","text":"coordinates(::Type{T} = ZZRingElem, chi::GAPGroupMarksVector)\n               where T <: Union{IntegerUnion, QQFieldElem}\n\nReturn the vector a_1 a_2 ldots a_n such that chi is equal to sum_i=1^n a_i ti where t is parent(chi).\n\nThe result is an instance of Vector{T}. Note that the result can be shorter than ncols(parent(chi)).\n\nExamples\n\njulia> tom = table_of_marks(symmetric_group(4));\n\njulia> chi = tom[3] * tom[6]\nmarks_vector(table of marks of Sym(4), ZZRingElem[72, 0, 4])\n\njulia> println(coordinates(Int, chi))\n[2, 0, 2]\n\n\n\n\n\n","category":"method"},{"location":"Groups/tom/#restrict-Tuple{Oscar.GAPGroupMarksVector, Oscar.GAPGroupCharacterTable}","page":"Tables of Marks","title":"restrict","text":"restrict(chi::GAPGroupMarksVector, tbl::GAPGroupCharacterTable)\n\nReturn the class function with parent tbl that is the restriction of chi. For that, parent(chi) and tbl must belong to the same group G.\n\nIf chi is the i-th row in the table of marks parent(chi) then the result is the permutation character of the action of G on the right cosets of its subgroup representative(parent(chi), i).\n\nExamples\n\njulia> tom = table_of_marks(\"A5\");  tbl = character_table(tom);\n\njulia> chi = tom[5]\nmarks_vector(table of marks of A5, ZZRingElem[12, 0, 0, 0, 2])\n\njulia> println(values(restrict(chi, tbl)))\nQQAbFieldElem{AbsSimpleNumFieldElem}[12, 0, 0, 2, 2]\n\n\n\n\n\n","category":"method"},{"location":"Groups/tom/#The-interface-between-tables-of-marks-and-character-tables","page":"Tables of Marks","title":"The interface between tables of marks and character tables","text":"","category":"section"},{"location":"Groups/tom/","page":"Tables of Marks","title":"Tables of Marks","text":"character_table(tom::GAPGroupTableOfMarks)\ntable_of_marks(tbl::GAPGroupCharacterTable)","category":"page"},{"location":"Groups/tom/#character_table-Tuple{Oscar.GAPGroupTableOfMarks}","page":"Tables of Marks","title":"character_table","text":"character_table(tom::GAPGroupTableOfMarks)\n\nReturn the character table of the group of tom. If tom belongs to the library of tables of marks then the corresponding character table from the library of character tables is returned, otherwise the character table of group(tom).\n\nExamples\n\njulia> g = symmetric_group(3);  tom = table_of_marks(g);\n\njulia> character_table(tom) == character_table(g)\ntrue\n\n\n\n\n\n","category":"method"},{"location":"Groups/tom/#table_of_marks-Tuple{Oscar.GAPGroupCharacterTable}","page":"Tables of Marks","title":"table_of_marks","text":"table_of_marks(tbl::GAPGroupCharacterTable)\n\nReturn the table of marks of the group of tbl. If tbl does not store a group and if the library of tables of marks contains the table of marks corresponding to tbl then this is returned, otherwise nothing.\n\nExamples\n\njulia> g = symmetric_group(3);  tbl = character_table(g);\n\njulia> table_of_marks(tbl) == table_of_marks(g)\ntrue\n\n\n\n\n\n","category":"method"},{"location":"Groups/products/","page":"Products of groups","title":"Products of groups","text":"CurrentModule = Oscar\nDocTestSetup = Oscar.doctestsetup()","category":"page"},{"location":"Groups/products/#Products-of-groups","page":"Products of groups","title":"Products of groups","text":"","category":"section"},{"location":"Groups/products/#Direct-products","page":"Products of groups","title":"Direct products","text":"","category":"section"},{"location":"Groups/products/","page":"Products of groups","title":"Products of groups","text":"DirectProductGroup\ndirect_product(L::AbstractVector{<:GAPGroup}; morphisms=false)\ninner_direct_product(L::AbstractVector{T}; morphisms=false) where T<:Union{PcGroup,FPGroup}\nnumber_of_factors(G::DirectProductGroup)\ncartesian_power(G::GAPGroup, n::Int)\ninner_cartesian_power(G::T, n::Int; morphisms=false) where T<: GAPGroup\nfactor_of_direct_product(G::DirectProductGroup, j::Int)\ncanonical_injection(G::DirectProductGroup, j::Int)\ncanonical_injections(G::DirectProductGroup)\ncanonical_projection(G::DirectProductGroup, j::Int)\ncanonical_projections(G::DirectProductGroup)\nwrite_as_full(G::DirectProductGroup)\nis_full_direct_product(G::DirectProductGroup)","category":"page"},{"location":"Groups/products/#DirectProductGroup","page":"Products of groups","title":"DirectProductGroup","text":"DirectProductGroup\n\nEither direct product of two or more groups of any type, or subgroup of a direct product of groups.\n\n\n\n\n\n","category":"type"},{"location":"Groups/products/#direct_product-Tuple{AbstractVector{<:Oscar.GAPGroup}}","page":"Products of groups","title":"direct_product","text":"direct_product(L::AbstractVector{<:GAPGroup}; morphisms)\ndirect_product(L::GAPGroup...)\n\nReturn the direct product of the groups in the collection L.\n\nThe keyword argument morphisms is false by default. If it is set true, then the output is a triple (G, emb, proj), where emb and proj are the vectors of the embeddings (resp. projections) of the direct product G.\n\nExamples\n\njulia> H = symmetric_group(3)\nSym(3)\n\njulia> K = symmetric_group(2)\nSym(2)\n\njulia> G = direct_product(H,K)\nDirect product of\n Sym(3)\n Sym(2)\n\njulia> elements(G)\n12-element Vector{Oscar.BasicGAPGroupElem{DirectProductGroup}}:\n ()\n (4,5)\n (2,3)\n (2,3)(4,5)\n (1,3,2)\n (1,3,2)(4,5)\n (1,3)\n (1,3)(4,5)\n (1,2,3)\n (1,2,3)(4,5)\n (1,2)\n (1,2)(4,5)\n\n\n\n\n\n","category":"method"},{"location":"Groups/products/#inner_direct_product-Union{Tuple{AbstractVector{T}}, Tuple{T}} where T<:Union{FPGroup, PcGroup}","page":"Products of groups","title":"inner_direct_product","text":"inner_direct_product(L::AbstractVector{T}; morphisms)\ninner_direct_product(L::T...)\n\nReturn a direct product of groups of the same type T as a group of type T. It works for T of the following types:\n\nPermGroup, PcGroup, SubPcGroup, FPGroup, SubFPGroup.\n\nThe keyword argument morphisms is false by default. If it is set true, then the output is a triple (G, emb, proj), where emb and proj are the vectors of the embeddings (resp. projections) of the direct product G.\n\n\n\n\n\n","category":"method"},{"location":"Groups/products/#number_of_factors-Tuple{DirectProductGroup}","page":"Products of groups","title":"number_of_factors","text":"number_of_factors(G::DirectProductGroup)\n\nReturn the number of factors of G.\n\n\n\n\n\n","category":"method"},{"location":"Groups/products/#cartesian_power-Tuple{Oscar.GAPGroup, Int64}","page":"Products of groups","title":"cartesian_power","text":"cartesian_power(G::GAPGroup, n::Int)\n\nReturn the direct product of n copies of G.\n\n\n\n\n\n","category":"method"},{"location":"Groups/products/#inner_cartesian_power-Union{Tuple{T}, Tuple{T, Int64}} where T<:Oscar.GAPGroup","page":"Products of groups","title":"inner_cartesian_power","text":"inner_cartesian_power(G::T, n::Int; morphisms)\n\nReturn the direct product of n copies of G as group of type T.\n\nThe keyword argument morphisms is false by default. If it is set true, then the output is a triple (G, emb, proj), where emb and proj are the vectors of the embeddings (resp. projections) of the direct product G.\n\n\n\n\n\n","category":"method"},{"location":"Groups/products/#factor_of_direct_product-Tuple{DirectProductGroup, Int64}","page":"Products of groups","title":"factor_of_direct_product","text":"factor_of_direct_product(G::DirectProductGroup, j::Int)\n\nReturn the j-th factor of G.\n\n\n\n\n\n","category":"method"},{"location":"Groups/products/#canonical_injection-Tuple{DirectProductGroup, Int64}","page":"Products of groups","title":"canonical_injection","text":"canonical_injection(G::DirectProductGroup, j::Int)\n\nReturn the injection of the j-th component of G into G, for j = 1,...,#factors of G. It is not defined for proper subgroups of direct products.\n\nExamples\n\njulia> H = symmetric_group(3)\nSym(3)\n\njulia> K = symmetric_group(2)\nSym(2)\n\njulia> G = direct_product(H, K)\nDirect product of\n Sym(3)\n Sym(2)\n\njulia> inj1 = canonical_injection(G, 1)\nGroup homomorphism\n  from Sym(3)\n  to direct product of\n   Sym(3)\n   Sym(2)\n\njulia> h = perm(H, [2,3,1])\n(1,2,3)\n\njulia> inj1(h)\n(1,2,3)\n\njulia> inj2 = canonical_injection(G, 2)\nGroup homomorphism\n  from Sym(2)\n  to direct product of\n   Sym(3)\n   Sym(2)\n\njulia> k = perm(K, [2,1])\n(1,2)\n\njulia> inj2(k)\n(4,5)\n\njulia> inj1(h)*inj2(k)\n(1,2,3)(4,5)\n\n\n\n\n\n","category":"method"},{"location":"Groups/products/#canonical_injections-Tuple{DirectProductGroup}","page":"Products of groups","title":"canonical_injections","text":"canonical_injections(G::DirectProductGroup)\n\nReturn the injection of the j-th component of G into G, for all j = 1,...,#factors of G. It is not defined for proper subgroups of direct products.\n\n\n\n\n\n","category":"method"},{"location":"Groups/products/#canonical_projection-Tuple{DirectProductGroup, Int64}","page":"Products of groups","title":"canonical_projection","text":"canonical_projection(G::DirectProductGroup, j::Int)\n\nReturn the projection of G into the j-th component of G, for j = 1,...,#factors of G.\n\nExamples\n\njulia> H = symmetric_group(3)\nSym(3)\n\njulia> K = symmetric_group(2)\nSym(2)\n\njulia> G = direct_product(H, K)\nDirect product of\n Sym(3)\n Sym(2)\n\njulia> proj1 = canonical_projection(G, 1)\nGroup homomorphism\n  from direct product of\n   Sym(3)\n   Sym(2)\n  to Sym(3)\n\njulia> proj2 = canonical_projection(G, 2)\nGroup homomorphism\n  from direct product of\n   Sym(3)\n   Sym(2)\n  to Sym(2)\n\njulia> g = perm([2,3,1,5,4])\n(1,2,3)(4,5)\n\njulia> proj1(g)\n(1,2,3)\n\njulia> proj2(g)\n(1,2)\n\n\n\n\n\n","category":"method"},{"location":"Groups/products/#canonical_projections-Tuple{DirectProductGroup}","page":"Products of groups","title":"canonical_projections","text":"canonical_projection(G::DirectProductGroup)\n\nReturn the projection of G into the j-th component of G, for all j = 1,...,#factors of G.\n\n\n\n\n\n","category":"method"},{"location":"Groups/products/#write_as_full-Tuple{DirectProductGroup}","page":"Products of groups","title":"write_as_full","text":"write_as_full(G::DirectProductGroup)\n\nIf G is a subgroup of the direct product G_1 times G_2 times cdots times G_n such that G has the form H_1 times H_2 times cdots times H_n, for subgroups H_i of G_i, return this full direct product of the H_i.\n\nAn exception is thrown if such H_i do not exist.\n\n\n\n\n\n","category":"method"},{"location":"Groups/products/#is_full_direct_product-Tuple{DirectProductGroup}","page":"Products of groups","title":"is_full_direct_product","text":"is_full_direct_product(G::DirectProductGroup)\n\nReturn whether G is direct product of its factors (false if it is a proper subgroup).\n\n\n\n\n\n","category":"method"},{"location":"Groups/products/#Semidirect-products","page":"Products of groups","title":"Semidirect products","text":"","category":"section"},{"location":"Groups/products/","page":"Products of groups","title":"Products of groups","text":"SemidirectProductGroup{S<:GAPGroup, T<:GAPGroup}\nsemidirect_product(N::S, f::GAPGroupHomomorphism{T,AutomorphismGroup{S}}, H::T) where S <: GAPGroup where T <: GAPGroup\nnormal_subgroup(G::SemidirectProductGroup)\nacting_subgroup(G::SemidirectProductGroup)\nhomomorphism_of_semidirect_product(G::SemidirectProductGroup)\nis_full_semidirect_product(G::SemidirectProductGroup)\ncanonical_injection(G::SemidirectProductGroup, n::Int)\ncanonical_projection(G::SemidirectProductGroup)","category":"page"},{"location":"Groups/products/#SemidirectProductGroup","page":"Products of groups","title":"SemidirectProductGroup","text":"SemidirectProductGroup{S,T}\n\nSemidirect product of two groups of type S and T respectively, or subgroup of a semidirect product of groups.\n\n\n\n\n\n","category":"type"},{"location":"Groups/products/#semidirect_product-Union{Tuple{S}, Tuple{T}, Tuple{S, GAPGroupHomomorphism{T, AutomorphismGroup{S}}, T}} where {T<:Oscar.GAPGroup, S<:Oscar.GAPGroup}","page":"Products of groups","title":"semidirect_product","text":"semidirect_product(N::S, f::GAPGroupHomomorphism, H::T)\n\nReturn the semidirect product of N and H, of type SemidirectProductGroup{S,T}, where f is a group homomorphism from H to the automorphism group of N.\n\n\n\n\n\n","category":"method"},{"location":"Groups/products/#normal_subgroup-Tuple{SemidirectProductGroup}","page":"Products of groups","title":"normal_subgroup","text":"normal_subgroup(G::SemidirectProductGroup)\n\nReturn N, where G is the semidirect product of the normal subgroup N and H.\n\n\n\n\n\n","category":"method"},{"location":"Groups/products/#acting_subgroup-Tuple{SemidirectProductGroup}","page":"Products of groups","title":"acting_subgroup","text":"acting_subgroup(G::SemidirectProductGroup)\n\nReturn H, where G is the semidirect product of the normal subgroup N and H.\n\n\n\n\n\n","category":"method"},{"location":"Groups/products/#homomorphism_of_semidirect_product-Tuple{SemidirectProductGroup}","page":"Products of groups","title":"homomorphism_of_semidirect_product","text":"homomorphism_of_semidirect_product(G::SemidirectProductGroup)\n\nReturn f, where G is the semidirect product of the normal subgroup N and the group H acting on N via the homomorphism h.\n\n\n\n\n\n","category":"method"},{"location":"Groups/products/#is_full_semidirect_product-Tuple{SemidirectProductGroup}","page":"Products of groups","title":"is_full_semidirect_product","text":"is_full_semidirect_product(G::SemidirectProductGroup)\n\nReturn whether G is a semidirect product of two groups, instead of a proper subgroup.\n\n\n\n\n\n","category":"method"},{"location":"Groups/products/#canonical_injection-Tuple{SemidirectProductGroup, Int64}","page":"Products of groups","title":"canonical_injection","text":"canonical_injection(G::SemidirectProductGroup, n::Int)\n\nReturn the injection of the n-th component of G into G, for n = 1,2. It is not defined for proper subgroups of semidirect products.\n\n\n\n\n\n","category":"method"},{"location":"Groups/products/#canonical_projection-Tuple{SemidirectProductGroup}","page":"Products of groups","title":"canonical_projection","text":"canonical_projection(G::SemidirectProductGroup)\n\nReturn the projection of G into the second component of G.\n\n\n\n\n\n","category":"method"},{"location":"Groups/products/#Wreath-products","page":"Products of groups","title":"Wreath products","text":"","category":"section"},{"location":"Groups/products/","page":"Products of groups","title":"Products of groups","text":"WreathProductGroup\nwreath_product(G::T, H::PermGroup) where T<: GAPGroup\nnormal_subgroup(W::WreathProductGroup)\nacting_subgroup(W::WreathProductGroup)\nhomomorphism_of_wreath_product(G::WreathProductGroup)\nis_full_wreath_product(G::WreathProductGroup)\ncanonical_projection(W::WreathProductGroup)\ncanonical_injection(W::WreathProductGroup, n::Int)\ncanonical_injections(W::WreathProductGroup)","category":"page"},{"location":"Groups/products/#WreathProductGroup","page":"Products of groups","title":"WreathProductGroup","text":"WreathProductGroup\n\nWreath product of a group G and a group of permutations H, or a generic group H together with the homomorphism a from H to a permutation group.\n\n\n\n\n\n","category":"type"},{"location":"Groups/products/#wreath_product-Union{Tuple{T}, Tuple{T, PermGroup}} where T<:Oscar.GAPGroup","page":"Products of groups","title":"wreath_product","text":"wreath_product(G::T, H::S, a::GAPGroupHomomorphism{S,PermGroup})\nwreath_product(G::T, H::PermGroup) where T<: Group\n\nReturn the wreath product of the group G and the group H, where H acts on n copies of G through the homomorphism a from H to a permutation group, and n is the number of moved points of Image(a).\n\nIf a is not specified, then H must be a group of permutations. In this case, n is NOT the number of moved points, but the degree of H.\n\nIf W is a wreath product of G and H, {g_1, ..., g_n} are elements of G and h in H, the element (g_1, ..., h) of W can be obtained by typing\n\nW(g_1,...,g_n, h).\n\nExamples\n\njulia> G = cyclic_group(3)\nPc group of order 3\n\njulia> H = symmetric_group(2)\nSym(2)\n\njulia> W = wreath_product(G,H)\n<group of size 18 with 2 generators>\n\njulia> a = gen(W,1)\nWreathProductElement(f1,<identity> of ...,())\n\njulia> b = gen(W,2)\nWreathProductElement(<identity> of ...,<identity> of ...,(1,2))\n\njulia> a*b\nWreathProductElement(f1,<identity> of ...,(1,2))\n\n\n\n\n\n","category":"method"},{"location":"Groups/products/#normal_subgroup-Tuple{WreathProductGroup}","page":"Products of groups","title":"normal_subgroup","text":"normal_subgroup(W::WreathProductGroup)\n\nReturn G, where W is the wreath product of G and H.\n\nExamples\n\njulia> G = cyclic_group(3)\nPc group of order 3\n\njulia> H = symmetric_group(2)\nSym(2)\n\njulia> W = wreath_product(G,H)\n<group of size 18 with 2 generators>\n\njulia> normal_subgroup(W)\nPc group of order 3\n\n\n\n\n\n","category":"method"},{"location":"Groups/products/#acting_subgroup-Tuple{WreathProductGroup}","page":"Products of groups","title":"acting_subgroup","text":"acting_subgroup(W::WreathProductGroup)\n\nReturn H, where W is the wreath product of G and H.\n\nExamples\n\njulia> G = cyclic_group(3)\nPc group of order 3\n\njulia> H = symmetric_group(2)\nSym(2)\n\njulia> W = wreath_product(G,H)\n<group of size 18 with 2 generators>\n\njulia> acting_subgroup(W)\nSym(2)\n\n\n\n\n\n","category":"method"},{"location":"Groups/products/#homomorphism_of_wreath_product-Tuple{WreathProductGroup}","page":"Products of groups","title":"homomorphism_of_wreath_product","text":"homomorphism_of_wreath_product(G::WreathProductGroup)\n\nIf W is the wreath product of G and H, then return the homomorphism f from H to Sym(n), where n is the number of copies of G.\n\n\n\n\n\n","category":"method"},{"location":"Groups/products/#is_full_wreath_product-Tuple{WreathProductGroup}","page":"Products of groups","title":"is_full_wreath_product","text":"is_full_wreath_product(G::WreathProductGroup)\n\nReturn whether G is a wreath product of two groups, instead of a proper subgroup.\n\n\n\n\n\n","category":"method"},{"location":"Groups/products/#canonical_projection-Tuple{WreathProductGroup}","page":"Products of groups","title":"canonical_projection","text":"canonical_projection(G::WreathProductGroup)\n\nReturn the projection of wreath_product(G,H) onto the permutation group H.\n\n\n\n\n\n","category":"method"},{"location":"Groups/products/#canonical_injection-Tuple{WreathProductGroup, Int64}","page":"Products of groups","title":"canonical_injection","text":"canonical_injection(G::WreathProductGroup, n::Int)\n\nReturn the injection of the n-th component of G into G. It is not defined for proper subgroups of wreath products.\n\n\n\n\n\n","category":"method"},{"location":"Groups/products/#canonical_injections-Tuple{WreathProductGroup}","page":"Products of groups","title":"canonical_injections","text":"canonical_injections(G::WreathProductGroup)\n\nReturn the injection of the n-th component of G into G for all n. It is not defined for proper subgroups of wreath products.\n\n\n\n\n\n","category":"method"},{"location":"AlgebraicGeometry/Miscellaneous/miscellaneous/","page":"Some Special Ideals","title":"Some Special Ideals","text":"CurrentModule = Oscar","category":"page"},{"location":"AlgebraicGeometry/Miscellaneous/miscellaneous/#Some-Special-Ideals","page":"Some Special Ideals","title":"Some Special Ideals","text":"","category":"section"},{"location":"AlgebraicGeometry/Miscellaneous/miscellaneous/","page":"Some Special Ideals","title":"Some Special Ideals","text":"This page is still in its development stage. Currently, it only contains the function below:","category":"page"},{"location":"AlgebraicGeometry/Miscellaneous/miscellaneous/#Grassmann-Plücker-Ideal","page":"Some Special Ideals","title":"Grassmann Plücker Ideal","text":"","category":"section"},{"location":"AlgebraicGeometry/Miscellaneous/miscellaneous/","page":"Some Special Ideals","title":"Some Special Ideals","text":"flag_pluecker_ideal\ngrassmann_pluecker_ideal","category":"page"},{"location":"AlgebraicGeometry/Miscellaneous/miscellaneous/#flag_pluecker_ideal","page":"Some Special Ideals","title":"flag_pluecker_ideal","text":"flag_pluecker_ideal(F::Union{Field, MPolyRing}, dimensions::Vector{Int}, n::Int; minimal::Bool=true)\n\nReturns the generators of the defining ideal for the complete flag variety  textFl(mathbbF (d_1dotsd_k) n), where (d_1dotsd_k) =dimensions, with d_jleq n-1,  denotes the rank.  That is, the vanishing set of this ideal corresponds to the space of k-step flags of linear subspaces V_1subsetdotssubset V_k in mathbbF^n, where textdim(V_j) = d_j.  You can obtain the generators for the complete flag variety of mathbbF^n by taking dimensions =(1dotsn-1) and n=n.  We remark that evaluating for F = QQ yields the same set of generators as any field of characteristic 0.\n\nThe first parameter can either be mathbbF, or a polynomial ring over mathbbF, with sum^k_j=1nchoose d_j variables. The parameter dimensions needs to be a vector of distinct increasing entries. Evaluating this function with the parameter minimal = true returns the reduced Gröbner basis for the flag Plücker ideal with respect to the degree reverse lexicographical order. For more details, see Theorem 14.6 [MS05]\n\nExamples\n\nComplete flag variety textFl(mathbbQ (123) 4). \n\njulia> flag_pluecker_ideal(QQ,[1,2,3],4)\nIdeal generated by\n  x[[2, 4]]*x[[1, 2, 3]] - x[[2, 3]]*x[[1, 2, 4]] + x[[1, 2]]*x[[2, 3, 4]]\n  x[[1, 4]]*x[[1, 2, 3]] - x[[1, 3]]*x[[1, 2, 4]] + x[[1, 2]]*x[[1, 3, 4]]\n  -x[[3, 4]]*x[[1, 2, 3]] - x[[1, 3]]*x[[2, 3, 4]] + x[[2, 3]]*x[[1, 3, 4]]\n  -x[[1, 4]]*x[[2, 3, 4]] + x[[2, 4]]*x[[1, 3, 4]] - x[[3, 4]]*x[[1, 2, 4]]\n  -x[[1]]*x[[2, 3, 4]] + x[[2]]*x[[1, 3, 4]] - x[[3]]*x[[1, 2, 4]] + x[[4]]*x[[1, 2, 3]]\n  -x[[1, 4]]*x[[2, 3]] + x[[2, 4]]*x[[1, 3]] - x[[3, 4]]*x[[1, 2]]\n  -x[[1]]*x[[2, 3]] + x[[2]]*x[[1, 3]] - x[[3]]*x[[1, 2]]\n  -x[[2]]*x[[3, 4]] + x[[3]]*x[[2, 4]] - x[[4]]*x[[2, 3]]\n  -x[[1]]*x[[3, 4]] + x[[3]]*x[[1, 4]] - x[[4]]*x[[1, 3]]\n  -x[[1]]*x[[2, 4]] + x[[2]]*x[[1, 4]] - x[[4]]*x[[1, 2]]\n\n\nFlag variety textFl(mathbbQ(13)4).\n\njulia> flag_pluecker_ideal(QQ,[1,3],4)\nIdeal generated by\n  -x[[1]]*x[[2, 3, 4]] + x[[2]]*x[[1, 3, 4]] - x[[3]]*x[[1, 2, 4]] + x[[4]]*x[[1, 2, 3]]\n\nAn example with a custom ring as input.\n\njulia> R, _ = polynomial_ring(QQ, 8)\n(Multivariate polynomial ring in 8 variables over QQ, QQMPolyRingElem[x1, x2, x3, x4, x5, x6, x7, x8])\n\njulia> flag_pluecker_ideal(R, [1,3], 4; minimal=false)\nIdeal generated by\n  x1*x6 - x2*x5 + x3*x7 - x4*x8\n\n\n\n\n\n","category":"function"},{"location":"AlgebraicGeometry/Miscellaneous/miscellaneous/#grassmann_pluecker_ideal","page":"Some Special Ideals","title":"grassmann_pluecker_ideal","text":"grassmann_pluecker_ideal([ring::MPolyRing,] subspace_dimension::Int, ambient_dimension::Int)\n\nGiven a (possibly graded) ring, an ambient dimension n and a subspace dimension d, return the ideal in the ring generated by the Plücker relations. If the input ring is not graded, return the ideal in the ring with the standard grading. If the ring is not specified return the ideal in a multivariate polynomial ring over the rationals with variables indexed by elements of nchoose d with the standard grading.\n\nThe Grassmann-Plücker ideal is the homogeneous ideal generated by the relations defined by  the Plücker Embedding of the Grassmannian. That is given Gr(k n) the Moduli  space of all k-dimensional subspaces of an n-dimensional vector space, the relations are given by all d times d minors of a d times n matrix. For the algorithm see [Stu93].\n\nExamples\n\njulia> grassmann_pluecker_ideal(2, 4)\nIdeal generated by\n  x[[1, 2]]*x[[3, 4]] - x[[1, 3]]*x[[2, 4]] + x[[1, 4]]*x[[2, 3]]\n\njulia> R, x = polynomial_ring(residue_ring(ZZ, 7)[1], :x => (1:2, 1:3))\n(Multivariate polynomial ring in 6 variables over ZZ/(7), zzModMPolyRingElem[x[1, 1] x[1, 2] x[1, 3]; x[2, 1] x[2, 2] x[2, 3]])\n\njulia> grassmann_pluecker_ideal(R, 2, 4)\nIdeal generated by\n  x[1, 1]*x[2, 3] + 6*x[2, 1]*x[1, 3] + x[1, 2]*x[2, 2]\n\n\n\n\n\n","category":"function"},{"location":"AlgebraicGeometry/Miscellaneous/miscellaneous/#Contact","page":"Some Special Ideals","title":"Contact","text":"","category":"section"},{"location":"AlgebraicGeometry/Miscellaneous/miscellaneous/","page":"Some Special Ideals","title":"Some Special Ideals","text":"Please direct questions about this part of OSCAR to the following people:","category":"page"},{"location":"AlgebraicGeometry/Miscellaneous/miscellaneous/","page":"Some Special Ideals","title":"Some Special Ideals","text":"Wolfram Decker.","category":"page"},{"location":"AlgebraicGeometry/Miscellaneous/miscellaneous/","page":"Some Special Ideals","title":"Some Special Ideals","text":"You can ask questions in the OSCAR Slack.","category":"page"},{"location":"AlgebraicGeometry/Miscellaneous/miscellaneous/","page":"Some Special Ideals","title":"Some Special Ideals","text":"Alternatively, you can raise an issue on github.","category":"page"},{"location":"Groups/permgroup/","page":"Permutation groups","title":"Permutation groups","text":"CurrentModule = Oscar\nDocTestSetup = Oscar.doctestsetup()","category":"page"},{"location":"Groups/permgroup/#Permutation-groups","page":"Permutation groups","title":"Permutation groups","text":"","category":"section"},{"location":"Groups/permgroup/#Constructing-permutation-groups","page":"Permutation groups","title":"Constructing permutation groups","text":"","category":"section"},{"location":"Groups/permgroup/","page":"Permutation groups","title":"Permutation groups","text":"Permutation groups can be defined as symmetric groups, alternating groups or their subgroups.","category":"page"},{"location":"Groups/permgroup/","page":"Permutation groups","title":"Permutation groups","text":"PermGroup\nPermGroupElem\nsymmetric_group\nalternating_group\npermutation_group\n@permutation_group","category":"page"},{"location":"Groups/permgroup/#PermGroup","page":"Permutation groups","title":"PermGroup","text":"PermGroup\n\nGroups of permutations. Every group of this type is a subgroup of Sym(n) for some n.\n\nExamples\n\nsymmetric_group(n::Int): the symmetric group Sym(n)\nalternating_group(n::Int): the alternating group Alt(n)\nsubgroups of Sym(n)\ndihedral_group(PermGroup, n::Int): the dihedral group of order n as a group of permutations. Same holds replacing dihedral_group by quaternion_group\n\nIf G is a permutation group and x is a permutation, G(x) returns a permutation x with parent G; an exception is thrown if x does not embed into G.\n\njulia> G=symmetric_group(5)\nSym(5)\n\njulia> x=cperm([1,2,3])\n(1,2,3)\n\njulia> parent(x)\nSym(3)\n\njulia> y=G(x)\n(1,2,3)\n\njulia> parent(y)\nSym(5)\n\nIf G is a permutation group and x is a vector of integers, G(x) returns a PermGroupElem with parent G; an exception is thrown if the element does not embed into G.\n\nExamples\n\njulia> G = symmetric_group(6)\nSym(6)\n\njulia> x = G([2,4,6,1,3,5])\n(1,2,4)(3,6,5)\n\njulia> parent(x)\nSym(6)\n\n\n\n\n\n","category":"type"},{"location":"Groups/permgroup/#PermGroupElem","page":"Permutation groups","title":"PermGroupElem","text":"PermGroupElem\n\nElement of a group of permutations. It is displayed as product of disjoint cycles.\n\nAssumptions:\n\nfor x,y in Sym(n), the product xy is read from left to right;\nfor x in Sym(n) and i in {1,...,n}, i^x and x(i) return the image of i under the action of x.\n\n\n\n\n\n","category":"type"},{"location":"Groups/permgroup/#symmetric_group","page":"Permutation groups","title":"symmetric_group","text":"symmetric_group(n::Int)\n\nReturn the full symmetric group on the set {1, 2, ..., n}.\n\nExamples\n\njulia> G = symmetric_group(5)\nSym(5)\n\njulia> order(G)\n120\n\n\n\n\n\n\n","category":"function"},{"location":"Groups/permgroup/#alternating_group","page":"Permutation groups","title":"alternating_group","text":"alternating_group(n::Int)\n\nReturn the full alternating group on the set {1, 2, ..., n}..\n\nExamples\n\njulia> G = alternating_group(5)\nAlt(5)\n\njulia> order(G)\n60\n\n\n\n\n\n\n","category":"function"},{"location":"Groups/permgroup/#permutation_group","page":"Permutation groups","title":"permutation_group","text":"permutation_group(n::IntegerUnion, perms::Vector{PermGroupElem})\n\nReturn the permutation group of degree n that is generated by the elements in perms.\n\nExamples\n\njulia> x = cperm([1,2,3], [4,5]);  y = cperm([1,4]);\n\njulia> permutation_group(5, [x, y])\nPermutation group of degree 5\n\n\n\n\n\n","category":"function"},{"location":"Groups/permgroup/#@permutation_group","page":"Permutation groups","title":"@permutation_group","text":"@permutation_group(n, gens...)\n\nInput the permutation group of degree n with generators gens..., given by permutations in cycle notation.\n\nExamples\n\njulia> g = @permutation_group(7, (1,2), (1,2,3)(4,5))\nPermutation group of degree 7\n\njulia> degree(g)\n7\n\n\n\n\n\n","category":"macro"},{"location":"Groups/permgroup/","page":"Permutation groups","title":"Permutation groups","text":"projective_general_linear_group\nprojective_special_linear_group\nprojective_symplectic_group\nprojective_orthogonal_group\nprojective_special_orthogonal_group\nprojective_omega_group\nprojective_unitary_group\nprojective_special_unitary_group","category":"page"},{"location":"Groups/permgroup/#projective_general_linear_group","page":"Permutation groups","title":"projective_general_linear_group","text":"projective_general_linear_group(n::Int, q::Int)\n\nReturn the factor group of general_linear_group, called with the same parameters, by its scalar matrices. The group is represented as a permutation group.\n\nExamples\n\njulia> g = projective_general_linear_group(2, 3)\nPermutation group of degree 4 and order 24\n\njulia> order(g)\n24\n\n\n\n\n\n","category":"function"},{"location":"Groups/permgroup/#projective_special_linear_group","page":"Permutation groups","title":"projective_special_linear_group","text":"projective_special_linear_group(n::Int, q::Int)\n\nReturn the factor group of special_linear_group, called with the same parameters, by its scalar matrices. The group is represented as a permutation group.\n\nExamples\n\njulia> g = projective_special_linear_group(2, 3)\nPermutation group of degree 4 and order 12\n\njulia> order(g)\n12\n\n\n\n\n\n","category":"function"},{"location":"Groups/permgroup/#projective_symplectic_group","page":"Permutation groups","title":"projective_symplectic_group","text":"projective_symplectic_group(n::Int, q::Int)\n\nReturn the factor group of symplectic_group, called with the same parameters, by its scalar matrices. The group is represented as a permutation group.\n\nExamples\n\njulia> g = projective_symplectic_group(2, 3)\nPermutation group of degree 4 and order 12\n\njulia> order(g)\n12\n\n\n\n\n\n","category":"function"},{"location":"Groups/permgroup/#projective_orthogonal_group","page":"Permutation groups","title":"projective_orthogonal_group","text":"projective_orthogonal_group(e::Int, n::Int, q::Int)\n\nReturn the factor group of orthogonal_group, called with the same parameters, by its scalar matrices.\n\nAs for orthogonal_group, e can be omitted if n is odd.\n\nExamples\n\njulia> g = projective_orthogonal_group(1, 4, 3);  order(g)\n576\n\njulia> g = projective_orthogonal_group(3, 3);  order(g)\n24\n\n\n\n\n\n","category":"function"},{"location":"Groups/permgroup/#projective_special_orthogonal_group","page":"Permutation groups","title":"projective_special_orthogonal_group","text":"projective_special_orthogonal_group(e::Int, n::Int, q::Int)\n\nReturn the factor group of special_orthogonal_group, called with the same parameters, by its scalar matrices.\n\nAs for special_orthogonal_group, e can be omitted if n is odd.\n\nExamples\n\njulia> g = projective_special_orthogonal_group(1, 4, 3);  order(g)\n288\n\njulia> g = projective_special_orthogonal_group(3, 3);  order(g)\n24\n\n\n\n\n\n","category":"function"},{"location":"Groups/permgroup/#projective_omega_group","page":"Permutation groups","title":"projective_omega_group","text":"projective_omega_group(e::Int, n::Int, q::Int)\n\nReturn the factor group of omega_group, called with the same parameters, by its scalar matrices.\n\nAs for omega_group, e can be omitted if n is odd.\n\nExamples\n\njulia> g = projective_omega_group(1, 4, 3);  order(g)\n144\n\njulia> g = projective_omega_group(3, 3);  order(g)\n12\n\n\n\n\n\n","category":"function"},{"location":"Groups/permgroup/#projective_unitary_group","page":"Permutation groups","title":"projective_unitary_group","text":"projective_unitary_group(n::Int, q::Int)\n\nReturn the factor group of unitary_group, called with the same parameters, by its scalar matrices. The group is represented as a permutation group.\n\nExamples\n\njulia> g = projective_unitary_group(2, 3)\nPermutation group of degree 10 and order 24\n\njulia> order(g)\n24\n\n\n\n\n\n","category":"function"},{"location":"Groups/permgroup/#projective_special_unitary_group","page":"Permutation groups","title":"projective_special_unitary_group","text":"projective_special_unitary_group(n::Int, q::Int)\n\nReturn the factor group of special_unitary_group, called with the same parameters, by its scalar matrices. The group is represented as a permutation group.\n\nExamples\n\njulia> g = projective_special_unitary_group(2, 3)\nPermutation group of degree 10 and order 12\n\njulia> order(g)\n12\n\n\n\n\n\n","category":"function"},{"location":"Groups/permgroup/#Operations-for-permutation-groups","page":"Permutation groups","title":"Operations for permutation groups","text":"","category":"section"},{"location":"Groups/permgroup/","page":"Permutation groups","title":"Permutation groups","text":"All operations, properties and attributes for general groups described in the previous sections are supported for permutation groups. In addition there are some specific to permutation groups.","category":"page"},{"location":"Groups/permgroup/","page":"Permutation groups","title":"Permutation groups","text":"In OSCAR, every permutation group has a degree n, that corresponds to the size of the set on which G acts.","category":"page"},{"location":"Groups/permgroup/","page":"Permutation groups","title":"Permutation groups","text":"degree(x::PermGroup)\nsmaller_degree_permutation_representation(G::PermGroup)","category":"page"},{"location":"Groups/permgroup/#degree-Tuple{PermGroup}","page":"Permutation groups","title":"degree","text":"degree(G::PermGroup) -> Int\n\nReturn the degree of G as a permutation group, that is, an integer n that is stored in G, with the following meaning.\n\nG embeds into symmetric_group(n).\nTwo permutation groups of different degrees are regarded as not equal, even if they contain the same permutations.\nSubgroups constructed with derived_subgroup, sylow_subgroup, etc., get the same degree as the given group.\nThe range 1:degree(G) is used as the default set of points on which G and its element acts.\nOne can use the syntax G(H) in order to get a group that consists of the same permutations as H but has the same degree as G, provided that the elements of H move only points up to degree(G).\n\nnote: Note\nThe degree of a group of permutations is not necessarily equal to the largest moved point of the group G. For example, the trivial subgroup of symmetric_group(n) has degree n even though it fixes n.\n\nExamples\n\njulia> s4 = symmetric_group(4);\n\njulia> degree(s4)\n4\n\njulia> t4 = trivial_subgroup(symmetric_group(4))[1];\n\njulia> degree(t4)\n4\n\njulia> t5 = trivial_subgroup(symmetric_group(5))[1];\n\njulia> t4 == t5\nfalse\n\njulia> t4 == s4(t5)\ntrue\n\njulia> show(Vector(gen(symmetric_group(4), 2)))\n[2, 1, 3, 4]\njulia> show(Vector(gen(symmetric_group(5), 2)))\n[2, 1, 3, 4, 5]\n\n\n\n\n\n","category":"method"},{"location":"Groups/permgroup/#smaller_degree_permutation_representation-Tuple{PermGroup}","page":"Permutation groups","title":"smaller_degree_permutation_representation","text":"smaller_degree_permutation_representation(G::PermGroup) -> PermGroup, map\n\nReturn an isomorphic permutation group of smaller or equal degree and the isomorphism from G to that group.\n\nExamples\n\njulia> g = symmetric_group(4);\n\njulia> s, _ = sylow_subgroup(g, 3);\n\njulia> rho = smaller_degree_permutation_representation(s)\n(Permutation group of degree 3 and order 3, Hom: s -> permutation group)\n\n\n\n\n\n","category":"method"},{"location":"Groups/permgroup/","page":"Permutation groups","title":"Permutation groups","text":"The following functions deal with the natural action of a given permutation group G.","category":"page"},{"location":"Groups/permgroup/","page":"Permutation groups","title":"Permutation groups","text":"is_transitive(G::PermGroup, L::AbstractVector{Int} = 1:degree(G))\ntransitivity(G::PermGroup, L::AbstractVector{Int} = 1:degree(G))\nis_primitive(G::PermGroup, L::AbstractVector{Int} = 1:degree(G))\nis_regular(G::PermGroup, L::AbstractVector{Int} = 1:degree(G))\nis_semiregular(G::PermGroup, L::AbstractVector{Int} = 1:degree(G))\nrank_action(G::PermGroup, L::AbstractVector{Int} = 1:degree(G))\nblocks(G::PermGroup, L::AbstractVector{Int} = moved_points(G))\nmaximal_blocks(G::PermGroup, L::AbstractVector{Int} = moved_points(G))\nminimal_block_reps(G::PermGroup, L::AbstractVector{Int} = moved_points(G))\nall_blocks(G::PermGroup)","category":"page"},{"location":"Groups/permgroup/#is_transitive","page":"Permutation groups","title":"is_transitive","text":"is_transitive(G::PermGroup, L::AbstractVector{Int} = 1:degree(G))\n\nReturn whether G acts transitively on L, that is, L is an orbit of G.\n\nExamples\n\njulia> G = symmetric_group(6);\n\njulia> is_transitive(G)\ntrue\n\njulia> is_transitive(sylow_subgroup(G, 2)[1])\nfalse\n\njulia> is_transitive(stabilizer(G, 1)[1])\nfalse\n\n\n\n\n\n","category":"function"},{"location":"Groups/permgroup/#transitivity","page":"Permutation groups","title":"transitivity","text":"transitivity(G::PermGroup, L::AbstractVector{Int} = 1:degree(G))\n\nReturn the maximum k such that G acts k-transitively on L, that is, every k-tuple of points in L can be mapped simultaneously to every other k-tuple by an element of G.\n\nThe output is 0 if G acts intransitively on L, and an exception is thrown if G does not act on L.\n\nExamples\n\njulia> transitivity(mathieu_group(24))\n5\n\njulia> transitivity(symmetric_group(6))\n6\n\njulia> transitivity(symmetric_group(6), 1:7)\n0\n\njulia> transitivity(symmetric_group(6), 1:5)\nERROR: ArgumentError: the group does not act\n\n\n\n\n\n","category":"function"},{"location":"Groups/permgroup/#is_primitive","page":"Permutation groups","title":"is_primitive","text":"is_primitive(G::PermGroup, L::AbstractVector{Int} = 1:degree(G))\n\nReturn whether the action of G on L is primitive, that is, the action is transitive and the point stabilizers are maximal in G.\n\nExamples\n\njulia> G = alternating_group(6);\n\njulia> mx = filter(is_transitive, map(representative, maximal_subgroup_classes(G)))\n3-element Vector{PermGroup}:\n Permutation group of degree 6 and order 24\n Permutation group of degree 6 and order 36\n Permutation group of degree 6 and order 60\n\njulia> [(order(H), is_primitive(H)) for H in mx]\n3-element Vector{Tuple{ZZRingElem, Bool}}:\n (24, 0)\n (36, 0)\n (60, 1)\n\n\n\n\n\n","category":"function"},{"location":"Groups/permgroup/#is_regular","page":"Permutation groups","title":"is_regular","text":"is_regular(G::PermGroup, L::AbstractVector{Int} = 1:degree(G))\n\nReturn whether the action of G on L is regular (i.e., transitive and semiregular).\n\nExamples\n\njulia> G = symmetric_group(6);\n\njulia> H = sub(G, [G([2, 3, 4, 5, 6, 1])])[1]\nPermutation group of degree 6\n\njulia> is_regular(H)\ntrue\n\njulia> is_regular(G)\nfalse\n\n\n\n\n\n","category":"function"},{"location":"Groups/permgroup/#is_semiregular","page":"Permutation groups","title":"is_semiregular","text":"is_semiregular(G::PermGroup, L::AbstractVector{Int} = 1:degree(G))\n\nReturn whether the action of G on L is semiregular (i.e., the stabilizer of each point is the identity).\n\nExamples\n\njulia> G = symmetric_group(6);\n\njulia> H = sub(G, [G([2, 3, 1, 5, 6, 4])])[1]\nPermutation group of degree 6\n\njulia> is_semiregular(H)\ntrue\n\njulia> is_regular(H)\nfalse\n\n\n\n\n\n","category":"function"},{"location":"Groups/permgroup/#rank_action","page":"Permutation groups","title":"rank_action","text":"rank_action(G::PermGroup, L::AbstractVector{Int} = 1:degree(G))\n\nReturn the rank of the transitive action of G on L. This is defined as the number of G-orbits in the action on ordered pairs of points in L, and is equal to the number of orbits of the stabilizer of a point in L on L, see [Cam99] Section 1.11.\n\nAn exception is thrown if G is not transitive on L.\n\nExamples\n\njulia> G = symmetric_group(4); rank_action(G)  # 4-transitive\n2\n\njulia> H = sylow_subgroup(G, 2)[1]\nPermutation group of degree 4 and order 8\n\njulia> rank_action(H)  # not 2-transitive\n3\n\njulia> K = stabilizer(G, 1)[1]\nPermutation group of degree 4 and order 6\n\njulia> rank_action(K, 2:4)  # 2-transitive\n2\n\njulia> rank_action(K, 3:5)\nERROR: ArgumentError: the group is not transitive\n\n\n\n\n\n","category":"function"},{"location":"Groups/permgroup/#blocks","page":"Permutation groups","title":"blocks","text":"blocks(G::PermGroup, L::AbstractVector{Int} = moved_points(G))\n\nReturn a G-set that is a block system for the action of G on L, i.e., a non-trivial partition of L preserved by the action of G.\n\nHere, L must be a subvector of 1:degree(G) on which G acts transitively. G may move points outside L, in this case the restriction of the action of the set stabilizer of L in G to L is considered.\n\nAn exception is thrown if this action is not transitive.\n\nExamples\n\njulia> g = sylow_subgroup(symmetric_group(4), 2)[1]\nPermutation group of degree 4 and order 8\n\njulia> collect(blocks(g))\n2-element Vector{Vector{Int64}}:\n [1, 2]\n [3, 4]\n\n\n\n\n\n","category":"function"},{"location":"Groups/permgroup/#maximal_blocks","page":"Permutation groups","title":"maximal_blocks","text":"maximal_blocks(G::PermGroup, L::AbstractVector{Int} = moved_points(G))\n\nReturn a G-set that is a maximal block system for the action of G on L, i.e., a maximal non-trivial partition of L preserved by the action of G.\n\nHere, L must be a subvector of 1:degree(G) on which G acts transitively. G may move points outside L, in this case the restriction of the action of the set stabilizer of L in G to L is considered.\n\nAn exception is thrown if this action is not transitive.\n\nExamples\n\njulia> G = transitive_group(8, 2)\nPermutation group of degree 8\n\njulia> collect(maximal_blocks(G))\n2-element Vector{Vector{Int64}}:\n [1, 2, 3, 8]\n [4, 5, 6, 7]\n\n\n\n\n\n","category":"function"},{"location":"Groups/permgroup/#minimal_block_reps","page":"Permutation groups","title":"minimal_block_reps","text":"minimal_block_reps(G::PermGroup, L::AbstractVector{Int} = moved_points(G))\n\nReturn a vector of block representatives for all minimal non-trivial block systems for the action of G on L.\n\nHere, L must be a subvector of 1:degree(G) on which G acts transitively. G may move points outside L, in this case the restriction of the action of the set stabilizer of L in G to L is considered.\n\nAn exception is thrown if this action is not transitive.\n\nExamples\n\njulia> G = transitive_group(8, 2)\nPermutation group of degree 8\n\njulia> minimal_block_reps(G)\n3-element Vector{Vector{Int64}}:\n [1, 3]\n [1, 5]\n [1, 7]\n\n\n\n\n\n","category":"function"},{"location":"Groups/permgroup/#all_blocks-Tuple{PermGroup}","page":"Permutation groups","title":"all_blocks","text":"all_blocks(G::PermGroup)\n\nReturn a vector of smallest representatives of all block systems for the action of G on the set of moved points of G.\n\nExamples\n\njulia> G = transitive_group(8, 2)\nPermutation group of degree 8\n\njulia> all_blocks(G)\n6-element Vector{Vector{Int64}}:\n [1, 2, 3, 8]\n [1, 5]\n [1, 3, 5, 7]\n [1, 3]\n [1, 3, 4, 6]\n [1, 7]\n\n\n\n\n\n","category":"method"},{"location":"Groups/permgroup/","page":"Permutation groups","title":"Permutation groups","text":"The following functions allow efficiently \"recognizing\" certain permutation groups as alternating or symmetric groups.","category":"page"},{"location":"Groups/permgroup/","page":"Permutation groups","title":"Permutation groups","text":"is_natural_symmetric_group(G::GAPGroup)\nis_isomorphic_to_symmetric_group(G::GAPGroup)\nis_natural_alternating_group(G::GAPGroup)\nis_isomorphic_to_alternating_group(G::GAPGroup)","category":"page"},{"location":"Groups/permgroup/#is_natural_symmetric_group-Tuple{Oscar.GAPGroup}","page":"Permutation groups","title":"is_natural_symmetric_group","text":"is_natural_symmetric_group(G::GAPGroup)\n\nReturn true if G is a permutation group acting as the symmetric group on its moved points, and false otherwise.\n\n\n\n\n\n","category":"method"},{"location":"Groups/permgroup/#is_isomorphic_to_symmetric_group-Tuple{Oscar.GAPGroup}","page":"Permutation groups","title":"is_isomorphic_to_symmetric_group","text":"is_isomorphic_to_symmetric_group(G::GAPGroup)\n\nReturn true if G is isomorphic to a symmetric group, and false otherwise.\n\n\n\n\n\n","category":"method"},{"location":"Groups/permgroup/#is_natural_alternating_group-Tuple{Oscar.GAPGroup}","page":"Permutation groups","title":"is_natural_alternating_group","text":"is_natural_alternating_group(G::GAPGroup)\n\nReturn true if G is a permutation group acting as the alternating group on its moved points, and false otherwise.\n\n\n\n\n\n","category":"method"},{"location":"Groups/permgroup/#is_isomorphic_to_alternating_group-Tuple{Oscar.GAPGroup}","page":"Permutation groups","title":"is_isomorphic_to_alternating_group","text":"is_isomorphic_to_alternating_group(G::GAPGroup)\n\nReturn true if G is isomorphic to an alternating group, and false otherwise.\n\n\n\n\n\n","category":"method"},{"location":"Groups/permgroup/#Permutations","page":"Permutation groups","title":"Permutations","text":"","category":"section"},{"location":"Groups/permgroup/","page":"Permutation groups","title":"Permutation groups","text":"Permutations in OSCAR are displayed as products of disjoint cycles, as in GAP. An explicit permutation can be built using the functions perm, cperm, or @perm.","category":"page"},{"location":"Groups/permgroup/","page":"Permutation groups","title":"Permutation groups","text":"perm\ncperm\n@perm","category":"page"},{"location":"Groups/permgroup/#perm","page":"Permutation groups","title":"perm","text":"perm(L::AbstractVector{<:IntegerUnion})\n\nReturn the permutation x which maps every i from 1 to n= length(L) to Li. The parent of x is set to symmetric_group(n). An exception is thrown if L does not contain every integer from 1 to n exactly once.\n\nThe parent group of x is set to symmetric_group(n).\n\nExamples\n\njulia> x = perm([2,4,6,1,3,5])\n(1,2,4)(3,6,5)\n\njulia> parent(x)\nSym(6)\n\n\n\n\n\nperm(G::PermGroup, L::AbstractVector{<:IntegerUnion})\n(G::PermGroup)(L::AbstractVector{<:IntegerUnion})\n\nReturn the permutation x which maps every i from 1 to n= length(L) to Li. The parent of x is G. An exception is thrown if x is not contained in G or L does not contain every integer from 1 to n exactly once.\n\nExamples\n\njulia> perm(symmetric_group(6),[2,4,6,1,3,5])\n(1,2,4)(3,6,5)\n\nEquivalent permutations can be created using cperm and @perm\n\njulia> x = perm(symmetric_group(8),[2,3,1,5,4,7,8,6])\n(1,2,3)(4,5)(6,7,8)\n\njulia> y = cperm([1,2,3],[4,5],[6,7,8])\n(1,2,3)(4,5)(6,7,8)\n\njulia> x == y\ntrue\n\njulia> z = @perm (1,2,3)(4,5)(6,7,8)\n(1,2,3)(4,5)(6,7,8)\n\njulia> x == z\ntrue\n\n\n\n\n\n","category":"function"},{"location":"Groups/permgroup/#cperm","page":"Permutation groups","title":"cperm","text":"cperm(L::AbstractVector{<:T}...) where T <: IntegerUnion\ncperm(L::AbstractVector{<:AbstractVector{T}}) where T <: IntegerUnion\ncperm(G::PermGroup, L::AbstractVector{<:T}...)\ncperm(G::PermGroup, L::AbstractVector{<:AbstractVector{T}}) where T <: IntegerUnion\n\nFor given lists a_1 a_2 ldots a_n b_1 b_2 ldots  b_m ldots of positive integers, return the permutation x = (a_1 a_2 ldots a_n) * (b_1 b_2 ldots b_m) * ldots. Arrays of the form [n, n+1, ..., n+k] can be replaced by n:n+k.\n\nThe parent of x is G. If G is not specified then the parent of x is set to symmetric_group(n), where n is the largest integer that occurs in an entry of L. However this incurs non-trivial overhead and so it is generally better to provide G explicitly.\n\nAn exception is thrown if x is not contained in G, or one of the given vectors is empty or contains duplicates.\n\nSee also perm and @perm for other ways to create permutations.\n\nExamples\n\njulia> cperm([1,2,3],4:7)\n(1,2,3)(4,5,6,7)\n\njulia> cperm([1,2],[2,3])  # cycles may overlap\n(1,3,2)\n\njulia> cperm()\n()\n\njulia> p = cperm([1,2,3],[7])\n(1,2,3)\n\njulia> degree(p)\n7\n\nTwo permutations coincide if, and only if, they move the same points and their parent groups have the same degree.\n\njulia> G = symmetric_group(5);\n\njulia> A = alternating_group(5);\n\njulia> x = cperm(G, [1,2,3]);\n\njulia> y = cperm(A, [1,2,3]);\n\njulia> z = cperm([1,2,3]); parent(z)\nSym(3)\n\njulia> x == y\ntrue\n\njulia> x == z\nfalse\n\nIn the example above, x and y are equal because both act on a set of cardinality 5, while x and z are different because x belongs to Sym(5) and z belongs to Sym(3).\n\ncperm can also handle cycles passed in inside of a vector\n\njulia> x = cperm([[1,2],[3,4]])\n(1,2)(3,4)\n\njulia> y = cperm([1,2],[3,4])\n(1,2)(3,4)\n\njulia> x == y\ntrue\n\n\n\n\n\n","category":"function"},{"location":"Groups/permgroup/#@perm","page":"Permutation groups","title":"@perm","text":"@perm ex\n\nInput a permutation in cycle notation. Supports arbitrary expressions for generating the integer entries of the cycles. The parent group is inferred  to be the symmetric group with a degree of the highest integer referenced  in the permutation.\n\nThe actual work is done by cperm. Thus, for the time being, cycles which are not disjoint actually are supported.\n\nExamples\n\njulia> x = @perm (1,2,3)(4,5)(factorial(3),7,8)\n(1,2,3)(4,5)(6,7,8)\n\njulia> parent(x)\nSym(8)\n\njulia> y = cperm([1,2,3],[4,5],[6,7,8])\n(1,2,3)(4,5)(6,7,8)\n\njulia> x == y\ntrue\n\njulia> z = perm(symmetric_group(8),[2,3,1,5,4,7,8,6])\n(1,2,3)(4,5)(6,7,8)\n\njulia> x == z\ntrue\n\n\n\n\n\n@perm n gens\n\nInput a list of permutations in cycle notation, created as elements of the symmetric group of degree n, i.e., symmetric_group(n), by invoking cperm suitably.\n\nExamples\n\njulia> gens = @perm 14 [\n              (1,10)\n              (2,11)\n              (3,12)\n              (4,13)\n              (5,14)\n              (6,8)\n              (7,9)\n              (1,2,3,4,5,6,7)(8,9,10,11,12,13,14)\n              (1,2)(10,11)\n             ]\n9-element Vector{PermGroupElem}:\n (1,10)\n (2,11)\n (3,12)\n (4,13)\n (5,14)\n (6,8)\n (7,9)\n (1,2,3,4,5,6,7)(8,9,10,11,12,13,14)\n (1,2)(10,11)\n \njulia> parent(gens[1])\nSym(14)\n\n\n\n\n\n","category":"macro"},{"location":"Groups/permgroup/","page":"Permutation groups","title":"Permutation groups","text":"The function Vector{T} works in the opposite way with respect to perm:","category":"page"},{"location":"Groups/permgroup/","page":"Permutation groups","title":"Permutation groups","text":"Vector(x::PermGroupElem, n::Int = x.parent.deg)","category":"page"},{"location":"Groups/permgroup/#Vector","page":"Permutation groups","title":"Vector","text":"Vector{T}(x::PermGroupElem, n::Int = x.parent.deg) where T <: IntegerUnion\nVector(x::PermGroupElem, n::Int = x.parent.deg)\n\nReturn the list of length n that contains x(i) at position i. If not specified, T is set as Int.\n\nExamples\n\njulia> pi = cperm(1:3)\n(1,2,3)\njulia> Vector(pi)\n3-element Vector{Int64}:\n 2\n 3\n 1\njulia> Vector(pi, 2)\n2-element Vector{Int64}:\n 2\n 3\njulia> Vector(pi, 4)\n4-element Vector{Int64}:\n 2\n 3\n 1\n 4\njulia> Vector{ZZRingElem}(pi, 2)\n2-element Vector{ZZRingElem}:\n 2\n 3\n\n\n\n\n\n","category":"type"},{"location":"Groups/permgroup/#Operations-on-permutations","page":"Permutation groups","title":"Operations on permutations","text":"","category":"section"},{"location":"Groups/permgroup/","page":"Permutation groups","title":"Permutation groups","text":"sign(g::PermGroupElem)\nisodd(g::PermGroupElem)\niseven(g::PermGroupElem)\ncycle_structure(g::PermGroupElem)\ncycles(g::PermGroupElem)","category":"page"},{"location":"Groups/permgroup/#sign-Tuple{PermGroupElem}","page":"Permutation groups","title":"sign","text":"sign(g::PermGroupElem) -> Int\n\nReturn the sign of the permutation g.\n\nThe sign of a permutation g is defined as (-1)^k where k is the number of cycles of g of even length.\n\nExamples\n\njulia> sign(cperm(1:2))\n-1\n\njulia> sign(cperm(1:3))\n1\n\n\n\n\n\n","category":"method"},{"location":"Groups/permgroup/#isodd-Tuple{PermGroupElem}","page":"Permutation groups","title":"isodd","text":"isodd(g::PermGroupElem)\n\nReturn true if the permutation g is odd, false otherwise.\n\nA permutation is odd if it has an odd number of cycles of even length. Equivalently, a permutation is odd if it has sign -1.\n\nExamples\n\njulia> isodd(cperm(1:2))\ntrue\n\njulia> isodd(cperm(1:3))\nfalse\n\njulia> isodd(cperm(1:2,3:4))\nfalse\n\n\n\n\n\n","category":"method"},{"location":"Groups/permgroup/#iseven-Tuple{PermGroupElem}","page":"Permutation groups","title":"iseven","text":"iseven(g::PermGroupElem)\n\nReturn true if the permutation g is even, false otherwise.\n\nA permutation is even if it has an even number of cycles of even length. Equivalently, a permutation is even if it has sign +1.\n\nExamples\n\njulia> iseven(cperm(1:2))\nfalse\n\njulia> iseven(cperm(1:3))\ntrue\n\njulia> iseven(cperm(1:2,3:4))\ntrue\n\n\n\n\n\n","category":"method"},{"location":"Groups/permgroup/#cycle_structure-Tuple{PermGroupElem}","page":"Permutation groups","title":"cycle_structure","text":"cycle_structure(g::PermGroupElem) -> CycleType\n\nReturn the cycle structure of the permutation g as a cycle type. A cycle type behaves similar to a vector of pairs k => n indicating that there are n cycles of length k.\n\nExamples\n\njulia> g = cperm(1:3, 4:5, 6:7, 8:10, 11:15)\n(1,2,3)(4,5)(6,7)(8,9,10)(11,12,13,14,15)\n\njulia> cycle_structure(g)\n3-element Oscar.CycleType:\n 2 => 2\n 3 => 2\n 5 => 1\n\njulia> g = cperm()\n()\n\njulia> cycle_structure(g)\n1-element Oscar.CycleType:\n 1 => 1\n\n\n\n\n\n","category":"method"},{"location":"Groups/permgroup/#cycles-Tuple{PermGroupElem}","page":"Permutation groups","title":"cycles","text":"cycles(g::PermGroupElem)\n\nReturn all cycles (including trivial ones) of the permutation g as a sorted list of integer vectors.\n\nExamples\n\njulia> g = cperm(1:3, 6:7, 8:10, 11:15)\n(1,2,3)(6,7)(8,9,10)(11,12,13,14,15)\n\njulia> cycles(g)\n6-element Vector{Vector{Int64}}:\n [1, 2, 3]\n [4]\n [5]\n [6, 7]\n [8, 9, 10]\n [11, 12, 13, 14, 15]\n\njulia> g = cperm()\n()\n\njulia> cycles(g)\n1-element Vector{Vector{Int64}}:\n [1]\n\n\n\n\n\n","category":"method"},{"location":"Groups/permgroup/#Permutations-as-functions","page":"Permutation groups","title":"Permutations as functions","text":"","category":"section"},{"location":"Groups/permgroup/","page":"Permutation groups","title":"Permutation groups","text":"A permutation can be viewed as a function on the set {1,...,n}, hence it can be evaluated on integers.","category":"page"},{"location":"Groups/permgroup/","page":"Permutation groups","title":"Permutation groups","text":"note: Note\nThe multiplication between permutations works from the left to the right. So, if x and y are permutations and n is an integer, then (x*y)(n) = (y(x(n)), NOT x(y(n)). This works also if the argument is not in the range 1:n; in such a case, the output coincides with the input.","category":"page"},{"location":"Groups/permgroup/","page":"Permutation groups","title":"Permutation groups","text":"julia> x = cperm([1,2,3,4,5]);\n\njulia> x(2)\n3\n\njulia> x(6)\n6","category":"page"},{"location":"Groups/permgroup/#Cycle-structures","page":"Permutation groups","title":"Cycle structures","text":"","category":"section"},{"location":"Groups/permgroup/","page":"Permutation groups","title":"Permutation groups","text":"For a permutation, its cycle structure cycle_structure determines the degree, order, number of moved points, sign.","category":"page"},{"location":"Groups/permgroup/","page":"Permutation groups","title":"Permutation groups","text":"degree(::CycleType)\niseven(::CycleType)\nisodd(::CycleType)\norder(::Type{T}, c::CycleType) where T\nsign(::CycleType)","category":"page"},{"location":"Groups/permgroup/#degree-Tuple{Oscar.CycleType}","page":"Permutation groups","title":"degree","text":"degree(c::CycleType) -> Int\n\nReturn the degree of the permutations with cycle structure c.\n\nExamples\n\njulia> g = symmetric_group(3);\n\njulia> all(x -> degree(cycle_structure(x)) == degree(g), gens(g))\ntrue\n\n\n\n\n\n","category":"method"},{"location":"Groups/permgroup/#iseven-Tuple{Oscar.CycleType}","page":"Permutation groups","title":"iseven","text":"iseven(c::CycleType) -> Bool\n\nReturn whether the permutations with cycle structure c are even.\n\nExamples\n\njulia> g = symmetric_group(3);\n\njulia> all(x -> iseven(cycle_structure(x)) == iseven(x), gens(g))\ntrue\n\n\n\n\n\n","category":"method"},{"location":"Groups/permgroup/#isodd-Tuple{Oscar.CycleType}","page":"Permutation groups","title":"isodd","text":"isodd(c::CycleType) -> Bool\n\nReturn whether the permutations with cycle structure c are odd.\n\nExamples\n\njulia> g = symmetric_group(3);\n\njulia> all(x -> isodd(cycle_structure(x)) == isodd(x), gens(g))\ntrue\n\n\n\n\n\n","category":"method"},{"location":"Groups/permgroup/#order-Union{Tuple{T}, Tuple{Type{T}, Oscar.CycleType}} where T","page":"Permutation groups","title":"order","text":"order(::Type{T} = ZZRingElem, c::CycleType) where T <: IntegerUnion\n\nReturn the order of the permutations with cycle structure c.\n\nExamples\n\njulia> g = symmetric_group(3);\n\njulia> all(x -> order(cycle_structure(x)) == order(x), gens(g))\ntrue\n\n\n\n\n\n","category":"method"},{"location":"Groups/permgroup/#sign-Tuple{Oscar.CycleType}","page":"Permutation groups","title":"sign","text":"sign(c::CycleType) -> Int\n\nReturn the sign of the permutations with cycle structure c.\n\nExamples\n\njulia> g = symmetric_group(3);\n\njulia> all(x -> sign(cycle_structure(x)) == sign(x), gens(g))\ntrue\n\n\n\n\n\n","category":"method"},{"location":"Groups/permgroup/","page":"Permutation groups","title":"Permutation groups","text":"cycle_structures(G::PermGroup)","category":"page"},{"location":"Groups/permgroup/#cycle_structures-Tuple{PermGroup}","page":"Permutation groups","title":"cycle_structures","text":"cycle_structures(G::PermGroup) -> Set{CycleType}\n\nReturn the set of cycle structures of elements in G, see cycle_structure.\n\nExamples\n\njulia> g = symmetric_group(3);\n\njulia> sort!(collect(cycle_structures(g)))\n3-element Vector{Oscar.CycleType}:\n [1 => 1, 2 => 1]\n [1 => 3]\n [3 => 1]\n\n\n\n\n\n","category":"method"},{"location":"TropicalGeometry/variety/#Tropical-varieties","page":"Tropical varieties","title":"Tropical varieties","text":"","category":"section"},{"location":"TropicalGeometry/variety/#Introduction","page":"Tropical varieties","title":"Introduction","text":"","category":"section"},{"location":"TropicalGeometry/variety/","page":"Tropical varieties","title":"Tropical varieties","text":"Tropial varieties (in OSCAR) are weighted polyhedral complexes.  They may arise as tropicalizations of polynomial ideals or from operations on the more specialized types of tropical varieties, such as the stable intersection of tropical hypersurfaces.  For more on the first, see","category":"page"},{"location":"TropicalGeometry/variety/","page":"Tropical varieties","title":"Tropical varieties","text":"Chapter 3 in [MS15]\nChapter 2.8 in [Jos21]","category":"page"},{"location":"TropicalGeometry/variety/#Note:","page":"Tropical varieties","title":"Note:","text":"","category":"section"},{"location":"TropicalGeometry/variety/","page":"Tropical varieties","title":"Tropical varieties","text":"Objects of type TropicalVariety need to be embedded, abstract tropical varieties are currently not supported.\nThe type TropicalVariety can be thought of as supertype of TropicalHypersurface, TropicalCurve, and TropicalLinearSpace in the sense that the latter three should have all properties and features of the former.\nEmbedded tropical varieties are polyhedral complexes with multiplicities and should have all properties of polyhedral complexes","category":"page"},{"location":"TropicalGeometry/variety/#Constructor","page":"Tropical varieties","title":"Constructor","text":"","category":"section"},{"location":"TropicalGeometry/variety/","page":"Tropical varieties","title":"Tropical varieties","text":"Objects of type TropicalVariety can be constructed as follows:","category":"page"},{"location":"TropicalGeometry/variety/","page":"Tropical varieties","title":"Tropical varieties","text":"tropical_variety(Sigma::PolyhedralComplex, mult::Vector{ZZRingElem}, minOrMax::Union{typeof(min),typeof(max)}=min)","category":"page"},{"location":"TropicalGeometry/variety/#tropical_variety","page":"Tropical varieties","title":"tropical_variety","text":"tropical_variety(Sigma::PolyhedralComplex, mult, minOrMax::Union{typeof(min),typeof(max)}=min)\n\nReturn the TropicalVariety whose polyhedral complex is Sigma with multiplicities mult and convention minOrMax. Here, mult is optional can be specified as a Vector{ZZRingElem} which represents a list of multiplicities on the maximal polyhedra in the order of maximal_polyhedra(Sigma).  If mult is unspecified, then all multiplicities are set to one.\n\nExamples\n\njulia> Sigma = polyhedral_complex(incidence_matrix([[1],[2]]), [[0],[1]])\nPolyhedral complex in ambient dimension 1\n\njulia> tropical_variety(Sigma)\nMin tropical variety\n\njulia> mult = ones(ZZRingElem, n_maximal_polyhedra(Sigma))\n2-element Vector{ZZRingElem}:\n 1\n 1\n\njulia> tropical_variety(Sigma,mult,min)\nMin tropical variety\n\njulia> mult = ZZ.([1,2])\n2-element Vector{ZZRingElem}:\n 1\n 2\n\njulia> tropical_variety(Sigma,mult,max)\nMax tropical variety\n\n\n\n\n\n\n","category":"function"},{"location":"TropicalGeometry/variety/#Properties","page":"Tropical varieties","title":"Properties","text":"","category":"section"},{"location":"TropicalGeometry/variety/","page":"Tropical varieties","title":"Tropical varieties","text":"Objects of type TropicalVariety (and TropicalHypersurface, TropicalCurve, TropicalLinearSpace) have the following properties:","category":"page"},{"location":"TropicalGeometry/variety/","page":"Tropical varieties","title":"Tropical varieties","text":"polyhedral_complex(TropV::TropicalVariety)\nambient_dim(TropV::TropicalVariety)\ncodim(TropV::TropicalVariety)\ndim(TropV::TropicalVariety)\nf_vector(TropV::TropicalVariety)\nlineality_dim(TropV::TropicalVariety)\nlineality_space(TropV::TropicalVariety)\nmaximal_polyhedra(TropV::TropicalVariety)\nmaximal_polyhedra_and_multiplicities(TropV::TropicalVariety)\nminimal_faces(TropV::TropicalVariety)\nmultiplicities(TropV::TropicalVariety)\nn_maximal_polyhedra(TropV::TropicalVariety)\nn_polyhedra(TropV::TropicalVariety)\nn_vertices(TropV::TropicalVariety)\nis_pure(TropV::TropicalVariety)\nis_simplicial(TropV::TropicalVariety)\nrays(TropV::TropicalVariety)\nrays_modulo_lineality(TropV::TropicalVariety)\nvertices_and_rays(TropV::TropicalVariety)\nvertices(TropV::TropicalVariety)\nvisualize(TropV::TropicalVariety)","category":"page"},{"location":"TropicalGeometry/variety/#polyhedral_complex-Tuple{TropicalVariety}","page":"Tropical varieties","title":"polyhedral_complex","text":"polyhedral_complex(TropV::TropicalVariety)\n\nReturn the polyhedral complex of a tropical variety.\n\n\n\n\n\n","category":"method"},{"location":"TropicalGeometry/variety/#ambient_dim-Tuple{TropicalVariety}","page":"Tropical varieties","title":"ambient_dim","text":"ambient_dim(TropV::TropicalVariety)\n\nSee ambient_dim(::PolyhedralComplex).\n\n\n\n\n\n","category":"method"},{"location":"TropicalGeometry/variety/#codim-Tuple{TropicalVariety}","page":"Tropical varieties","title":"codim","text":"codim(TropV::TropicalVariety)\n\nSee codim(::PolyhedralComplex).\n\n\n\n\n\n","category":"method"},{"location":"TropicalGeometry/variety/#dim-Tuple{TropicalVariety}","page":"Tropical varieties","title":"dim","text":"dim(TropV::TropicalVariety)\n\nSee dim(::PolyhedralComplex).\n\n\n\n\n\n","category":"method"},{"location":"TropicalGeometry/variety/#f_vector-Tuple{TropicalVariety}","page":"Tropical varieties","title":"f_vector","text":"f_vector(TropV::TropicalVariety)\n\nSee f_vector(::PolyhedralComplex).\n\n\n\n\n\n","category":"method"},{"location":"TropicalGeometry/variety/#lineality_dim-Tuple{TropicalVariety}","page":"Tropical varieties","title":"lineality_dim","text":"lineality_dim(TropV::TropicalVariety)\n\nSee lineality_dim(::PolyhedralComplex).\n\n\n\n\n\n","category":"method"},{"location":"TropicalGeometry/variety/#lineality_space-Tuple{TropicalVariety}","page":"Tropical varieties","title":"lineality_space","text":"lineality_space(TropV::TropicalVariety)\n\nSee lineality_space(::PolyhedralComplex).\n\n\n\n\n\n","category":"method"},{"location":"TropicalGeometry/variety/#maximal_polyhedra-Tuple{TropicalVariety}","page":"Tropical varieties","title":"maximal_polyhedra","text":"maximal_polyhedra(TropV::TropicalVariety)\n\nSee maximal_polyhedra(::PolyhedralComplex).\n\n\n\n\n\n","category":"method"},{"location":"TropicalGeometry/variety/#maximal_polyhedra_and_multiplicities-Tuple{TropicalVariety}","page":"Tropical varieties","title":"maximal_polyhedra_and_multiplicities","text":"maximal_polyhedra_and_multiplicities(TropV::TropicalVariety)\n\nReturn the maximal polyhedra and multiplicities of TropV.\n\nExamples\n\njulia> R,(x1,x2) = polynomial_ring(QQ,4);\n\njulia> nu = tropical_semiring_map(QQ,2);\n\njulia> f = 2*x1^2+x1*x2+x2^2+1\n2*x1^2 + x1*x2 + x2^2 + 1\n\njulia> TropH = tropical_hypersurface(f,nu)\nMin tropical hypersurface\n\njulia> maximal_polyhedra_and_multiplicities(TropH)\n5-element Vector{Tuple{Polyhedron{QQFieldElem}, ZZRingElem}}:\n (Polyhedron in ambient dimension 4, 1)\n (Polyhedron in ambient dimension 4, 1)\n (Polyhedron in ambient dimension 4, 2)\n (Polyhedron in ambient dimension 4, 1)\n (Polyhedron in ambient dimension 4, 2)\n\n\n\n\n\n\n","category":"method"},{"location":"TropicalGeometry/variety/#minimal_faces-Tuple{TropicalVariety}","page":"Tropical varieties","title":"minimal_faces","text":"minimal_faces(TropV::TropicalVariety)\n\nSee minimal_faces(::PolyhedralComplex).\n\n\n\n\n\n","category":"method"},{"location":"TropicalGeometry/variety/#multiplicities-Tuple{TropicalVariety}","page":"Tropical varieties","title":"multiplicities","text":"multiplicities(TropV::TropicalVariety)\n\nReturn the multiplicities of TropV.  Order is the same as maximal_polyhedra.\n\nExamples\n\njulia> R,(x1,x2) = polynomial_ring(QQ,4);\n\njulia> nu = tropical_semiring_map(QQ,2);\n\njulia> f = 2*x1^2+x1*x2+x2^2+1\n2*x1^2 + x1*x2 + x2^2 + 1\n\njulia> TropH = tropical_hypersurface(f,nu)\nMin tropical hypersurface\n\njulia> multiplicities(TropH)\n5-element Vector{ZZRingElem}:\n 1\n 1\n 2\n 1\n 2\n\n\n\n\n\n\n","category":"method"},{"location":"TropicalGeometry/variety/#n_maximal_polyhedra-Tuple{TropicalVariety}","page":"Tropical varieties","title":"n_maximal_polyhedra","text":"n_maximal_polyhedra(TropV::TropicalVariety)\n\nSee n_maximal_polyhedra(::PolyhedralComplex).\n\n\n\n\n\n","category":"method"},{"location":"TropicalGeometry/variety/#n_polyhedra-Tuple{TropicalVariety}","page":"Tropical varieties","title":"n_polyhedra","text":"n_polyhedra(TropV::TropicalVariety)\n\nSee n_polyhedra(::PolyhedralComplex).\n\n\n\n\n\n","category":"method"},{"location":"TropicalGeometry/variety/#n_vertices-Tuple{TropicalVariety}","page":"Tropical varieties","title":"n_vertices","text":"n_vertices(TropV::TropicalVariety)\n\nSee n_vertices(::PolyhedralComplex).\n\n\n\n\n\n","category":"method"},{"location":"TropicalGeometry/variety/#is_pure-Tuple{TropicalVariety}","page":"Tropical varieties","title":"is_pure","text":"is_pure(TropV::TropicalVariety)\n\nSee is_pure(::PolyhedralComplex).\n\n\n\n\n\n","category":"method"},{"location":"TropicalGeometry/variety/#is_simplicial-Tuple{TropicalVariety}","page":"Tropical varieties","title":"is_simplicial","text":"is_simplicial(TropV::TropicalVariety)\n\nSee is_simplicial(::PolyhedralComplex).\n\n\n\n\n\n","category":"method"},{"location":"TropicalGeometry/variety/#rays-Tuple{TropicalVariety}","page":"Tropical varieties","title":"rays","text":"rays(TropV::TropicalVariety)\n\nSee rays(::PolyhedralComplex).\n\n\n\n\n\n","category":"method"},{"location":"TropicalGeometry/variety/#rays_modulo_lineality-Tuple{TropicalVariety}","page":"Tropical varieties","title":"rays_modulo_lineality","text":"rays_modulo_lineality(TropV::TropicalVariety)\n\nSee rays_modulo_lineality(::PolyhedralComplex).\n\n\n\n\n\n","category":"method"},{"location":"TropicalGeometry/variety/#vertices_and_rays-Tuple{TropicalVariety}","page":"Tropical varieties","title":"vertices_and_rays","text":"vertices_and_rays(TropV::TropicalVariety)\n\nSee vertices_and_rays(::PolyhedralComplex).\n\n\n\n\n\n","category":"method"},{"location":"TropicalGeometry/variety/#vertices-Tuple{TropicalVariety}","page":"Tropical varieties","title":"vertices","text":"vertices(TropV::TropicalVariety)\n\nSee vertices(::PolyhedralComplex).\n\n\n\n\n\n","category":"method"},{"location":"TropicalGeometry/variety/#visualize-Tuple{TropicalVariety}","page":"Tropical varieties","title":"visualize","text":"visualize(TropV::TropicalVariety)\n\nSee visualize(::PolyhedralComplex).\n\n\n\n\n\n","category":"method"},{"location":"General/other/#Notes-for-users-of-other-computer-algebra-systems","page":"Notes for users of other computer algebra systems","title":"Notes for users of other computer algebra systems","text":"","category":"section"},{"location":"General/other/#General-differences","page":"Notes for users of other computer algebra systems","title":"General differences","text":"","category":"section"},{"location":"General/other/","page":"Notes for users of other computer algebra systems","title":"Notes for users of other computer algebra systems","text":"Julia evaluates 2^100 to 0 because 2 is regarded as a 64 bit integer. Write ZZRingElem(2)^100 to get a long.","category":"page"},{"location":"General/other/#Notes-for-GAP-users","page":"Notes for users of other computer algebra systems","title":"Notes for GAP users","text":"","category":"section"},{"location":"General/other/","page":"Notes for users of other computer algebra systems","title":"Notes for users of other computer algebra systems","text":"This section describes differences between GAP and Oscar. (Hints about using GAP in Oscar can be found in the section about GAP Integration.)","category":"page"},{"location":"General/other/","page":"Notes for users of other computer algebra systems","title":"Notes for users of other computer algebra systems","text":"The syntax of the languages is slightly different.\nIn GAP, equality of two objects is checked with =, and one assigns a value to a variable with :=. In Julia, equality is checked with ==, and = denotes assignment. Similarly, inequality of objects is checked with <> in GAP and with != in Julia.\nIn GAP, the operator not is used to negate boolean expressions, whereas ! is used in Julia.\nIn GAP, object identity is checked with the function IsIdenticalObj, whereas the infix operator === (with negation !==) is used in Julia.\nIn GAP, if statements have the form\nif condition1 then\n  statements1\nelif condition2 then\n  statements2\nelse\n  statements3\nfi;\nwhereas the Julia syntax is\nif condition1\n  statements1\nelseif condition2\n  statements2\nelse\n  statements3\nend\nSimilarly, GAP's for loops have the form\nfor var in list do\n  statements\nod;\nwhereas the Julia syntax is\nfor var in list\n  statements\nend\n(The situation with while loops is analogous.)\nThe interactive sessions behave differently.\nWhen an error occurs or when the user hits ctrl-C in a GAP session, usually a break loop is entered, from which one can either try to continue the computations, by entering return, or return to the GAP prompt, by entering quit; in the latter case, some objects may be corrupted afterwards.\nIn a Julia session, one gets automatically back to the Julia prompt when an error occurs or when the user hits ctrl-C, and again some objects may be corrupted afterwards.\nVariable names in GAP and Julia are recommended to be written in camel case and snake case, respectively, see Naming conventions. For example, the GAP function SylowSubgroup corresponds to Oscar's sylow_subgroup.\nThus the GAP rule that the names of user variables should start with a lowercase letter, in order to avoid clashes with system variables, does not make sense in Julia.\nMoreover, global Oscar variables are not write protected, contrary to most global GAP variables. Thus there is always the danger that assignments overwrite Julia functions. For example, it is tempting to use gens, hom, and map as names for variables, but Julia or Oscar define them already.\n(Also copying some lines of code from an Oscar function into a Julia session can be dangerous in this sense, because some names of local variables of the function may coincide with the names of global variables.)\nGAP provides natural embeddings of many algebraic structures. For example, two finite fields of the same characteristic are embedded into each other whenever this makes sense, and the elements of the smaller field are regarded also as elements of the larger field. Analogously, subfields of cyclotomic fields are naturally embedded into each other, and in fact their elements are internally represented w.r.t. the smallest possible cyclotomic field.\nIn Oscar, this is not the case. Each element of an algebraic structure has a parent, and operations involving several elements (such as arithmetic operations) are usually restricted to the situation that their parents coincide. One has to explicitly coerce a given element into a different parent if necessary.\nThe consequences can be quite subtle. Each permutation group in Oscar has a fixed degree, and the function is_transitive checks whether its argument is transitive on the points from 1 to the degree. In GAP, however, the function IsTransitive, called with a permutation group, checks whether this group is transitive on the points which are moved by it. Thus the group generated by the permutation (1, 2, 4) is regarded as transitive in GAP but as intransitive in Oscar.","category":"page"},{"location":"General/other/#Notes-for-Polymake-users","page":"Notes for users of other computer algebra systems","title":"Notes for Polymake users","text":"","category":"section"},{"location":"General/other/","page":"Notes for users of other computer algebra systems","title":"Notes for users of other computer algebra systems","text":"OSCAR (and Julia) is 1-based, meaning that it counts from 1, rather than from 0 like polymake. For most properties we have taken care of the translation but be aware that it might pop up at some point and generate confusion.\nFor convenience, Polymake.jl provides Polymake.to_one_based_indexing and Polymake.to_zero_based_indexing.\nPolyhedra and polyhedral complexes in OSCAR are represented inhomogeneously, i.e. without the leading 1 for vertices or 0 for rays. Hence constructors take points, rays, and lineality generators separately.\nuser_methods cannot be accessed via Julia's dot syntax, i.e. something like\nc = Polymake.polytope.cube(3)\nc.AMBIENT_DIM\nwill not work. Instead user_methods are attached as Julia functions in their respective application. They are always written in lowercase. In the example the following works:\nc = Polymake.polytope.cube(3)\nPolymake.polytope.ambient_dim(c)","category":"page"},{"location":"Groups/grouplib/","page":"Group libraries","title":"Group libraries","text":"CurrentModule = Oscar\nDocTestSetup = Oscar.doctestsetup()","category":"page"},{"location":"Groups/grouplib/#Group-libraries","page":"Group libraries","title":"Group libraries","text":"","category":"section"},{"location":"Groups/grouplib/#Transitive-permutation-groups-of-small-degree","page":"Group libraries","title":"Transitive permutation groups of small degree","text":"","category":"section"},{"location":"Groups/grouplib/","page":"Group libraries","title":"Group libraries","text":"The functions in this section are wrappers for the GAP library of transitive permutation groups up to degree 48, via the GAP package TransGrp [Hul23].","category":"page"},{"location":"Groups/grouplib/","page":"Group libraries","title":"Group libraries","text":"(The groups of degrees 32 and 48 are currently not automatically available in Oscar, one has to install additional data in order to access them.)","category":"page"},{"location":"Groups/grouplib/","page":"Group libraries","title":"Group libraries","text":"The arrangement and the names of the groups of degree up to 15 is the same as given in [CHM98]. With the exception of the symmetric and alternating group (which are represented as symmetric_group and alternating_group) the generators for these groups also conform to this paper with the only difference that 0 (which is not permitted in GAP for permutations to act on) is always replaced by the degree.","category":"page"},{"location":"Groups/grouplib/","page":"Group libraries","title":"Group libraries","text":"The arrangement for all degrees is intended to be equal to the arrangement within the systems GAP and Magma, thus it should be safe to refer to particular (classes of) groups by their index numbers.","category":"page"},{"location":"Groups/grouplib/","page":"Group libraries","title":"Group libraries","text":"all_transitive_groups\nhas_number_of_transitive_groups\nhas_transitive_group_identification\nhas_transitive_groups\nnumber_of_transitive_groups\ntransitive_group\ntransitive_group_identification","category":"page"},{"location":"Groups/grouplib/#all_transitive_groups","page":"Group libraries","title":"all_transitive_groups","text":"all_transitive_groups(L...)\n\nReturn the list of all transitive groups (up to permutation isomorphism) satisfying the conditions described by the arguments. These conditions may be of one of the following forms:\n\nfunc => intval selects groups for which the function func returns intval\nfunc => list selects groups for which the function func returns any element inside list\nfunc selects groups for which the function func returns true\n!func selects groups for which the function func returns false\n\nAs a special case, the first argument may also be one of the following:\n\nintval selects groups whose degree equals intval; this is equivalent to degree => intval\nintlist selects groups whose degree is in intlist; this is equivalent to degree => intlist\n\nThe following functions are currently supported as values for func:\n\ndegree\nis_abelian\nis_almost_simple\nis_cyclic\nis_nilpotent\nis_perfect\nis_primitive\nis_quasisimple\nis_simple\nis_sporadic_simple\nis_solvable\nis_supersolvable\nis_transitive\nnumber_of_conjugacy_classes\nnumber_of_moved_points\norder\ntransitivity\n\nThe type of the returned groups is PermGroup.\n\nExamples\n\njulia> all_transitive_groups(4)\n5-element Vector{PermGroup}:\n Permutation group of degree 4\n Permutation group of degree 4\n Permutation group of degree 4\n Alt(4)\n Sym(4)\n\njulia> all_transitive_groups(degree => 3:5, is_abelian)\n4-element Vector{PermGroup}:\n Alt(3)\n Permutation group of degree 4\n Permutation group of degree 4\n Permutation group of degree 5\n\n\n\n\n\n","category":"function"},{"location":"Groups/grouplib/#has_number_of_transitive_groups","page":"Group libraries","title":"has_number_of_transitive_groups","text":"has_number_of_transitive_groups(deg::Int)\n\nReturn whether the number transitive groups groups of degree deg are available for use via number_of_transitive_groups.\n\nExamples\n\njulia> has_number_of_transitive_groups(30)\ntrue\n\njulia> has_number_of_transitive_groups(64)\nfalse\n\n\n\n\n\n","category":"function"},{"location":"Groups/grouplib/#has_transitive_group_identification","page":"Group libraries","title":"has_transitive_group_identification","text":"has_transitive_group_identification(deg::Int)\n\nReturn whether identification of transitive groups groups of degree deg is available via transitive_group_identification.\n\nExamples\n\njulia> has_transitive_group_identification(30)\ntrue\n\njulia> has_transitive_group_identification(64)\nfalse\n\n\n\n\n\n","category":"function"},{"location":"Groups/grouplib/#has_transitive_groups","page":"Group libraries","title":"has_transitive_groups","text":"has_transitive_groups(deg::Int)\n\nReturn whether the transitive groups groups of degree deg are available for use. This function should be used to test for the scope of the library available.\n\nExamples\n\njulia> has_transitive_groups(30)\ntrue\n\njulia> has_transitive_groups(64)\nfalse\n\n\n\n\n\n","category":"function"},{"location":"Groups/grouplib/#number_of_transitive_groups","page":"Group libraries","title":"number_of_transitive_groups","text":"number_of_transitive_groups(deg::Int)\n\nReturn the number of transitive groups of degree deg, up to permutation isomorphism.\n\nExamples\n\njulia> number_of_transitive_groups(30)\n5712\n\njulia> number_of_transitive_groups(64)\nERROR: ArgumentError: the number of transitive groups of degree 64 is not available\n\n\n\n\n\n","category":"function"},{"location":"Groups/grouplib/#transitive_group","page":"Group libraries","title":"transitive_group","text":"transitive_group(deg::Int, i::Int)\n\nReturn the i-th group in the catalogue of transitive groups over the set {1, ..., deg} in GAP's Transitive Groups Library. The output is a group of type PermGroup.\n\nExamples\n\njulia> transitive_group(5,4)\nAlt(5)\n\njulia> transitive_group(5,6)\nERROR: ArgumentError: there are only 5 transitive groups of degree 5, not 6\n\n\n\n\n\n","category":"function"},{"location":"Groups/grouplib/#transitive_group_identification","page":"Group libraries","title":"transitive_group_identification","text":"transitive_group_identification(G::PermGroup)\n\nReturn a pair (d,n) such that G is permutation isomorphic with transitive_group(d,n), where G acts transitively on d points.\n\nIf G is not transitive on its moved points, or if the transitive groups of degree d are not available, an exception is thrown.\n\nExamples\n\njulia> G = symmetric_group(7);  m = transitive_group_identification(G)\n(7, 7)\n\njulia> order(transitive_group(m...)) == order(G)\ntrue\n\njulia> S = sub(G, [perm([1, 3, 4, 5, 2])])[1]\nPermutation group of degree 7\n\njulia> is_transitive(S)\nfalse\n\njulia> is_transitive(S, moved_points(S))\ntrue\n\njulia> m = transitive_group_identification(S)\n(4, 1)\n\njulia> order(transitive_group(m...)) == order(S)\ntrue\n\njulia> transitive_group_identification(symmetric_group(64))\nERROR: ArgumentError: identification of transitive groups of degree 64 are not available\n\njulia> S = sub(G, [perm([1,3,4,5,2,7,6])])[1];\n\njulia> transitive_group_identification(S)\nERROR: ArgumentError: group is not transitive on its moved points\n\n\n\n\n\n","category":"function"},{"location":"Groups/grouplib/#Primitive-permutation-groups-of-small-degree","page":"Group libraries","title":"Primitive permutation groups of small degree","text":"","category":"section"},{"location":"Groups/grouplib/","page":"Group libraries","title":"Group libraries","text":"The functions in this section are wrappers for the GAP library of primitive permutation groups up to degree 8191, via the GAP package PrimGrp [HRR23]. See the documentation of this package for more information about the source of the data.","category":"page"},{"location":"Groups/grouplib/","page":"Group libraries","title":"Group libraries","text":"all_primitive_groups\nhas_number_of_primitive_groups\nhas_primitive_group_identification\nhas_primitive_groups\nnumber_of_primitive_groups\nprimitive_group\nprimitive_group_identification","category":"page"},{"location":"Groups/grouplib/#all_primitive_groups","page":"Group libraries","title":"all_primitive_groups","text":"all_primitive_groups(L...)\n\nReturn the list of all primitive permutation groups (up to permutation isomorphism) satisfying the conditions described by the arguments. These conditions may be of one of the following forms:\n\nfunc => intval selects groups for which the function func returns intval\nfunc => list selects groups for which the function func returns any element inside list\nfunc selects groups for which the function func returns true\n!func selects groups for which the function func returns false\n\nAs a special case, the first argument may also be one of the following:\n\nintval selects groups whose degree equals intval; this is equivalent to degree => intval\nintlist selects groups whose degree is in intlist; this is equivalent to degree => intlist\n\nThe following functions are currently supported as values for func:\n\ndegree\nis_abelian\nis_almost_simple\nis_cyclic\nis_nilpotent\nis_perfect\nis_primitive\nis_quasisimple\nis_simple\nis_sporadic_simple\nis_solvable\nis_supersolvable\nis_transitive\nnumber_of_conjugacy_classes\nnumber_of_moved_points\norder\ntransitivity\n\nThe type of the returned groups is PermGroup.\n\nExamples\n\njulia> all_primitive_groups(4)\n2-element Vector{PermGroup}:\n Alt(4)\n Sym(4)\n\njulia> all_primitive_groups(degree => 3:5, is_abelian)\n2-element Vector{PermGroup}:\n Alt(3)\n Permutation group of degree 5 and order 5\n\n\n\n\n\n","category":"function"},{"location":"Groups/grouplib/#has_number_of_primitive_groups","page":"Group libraries","title":"has_number_of_primitive_groups","text":"has_number_of_primitive_groups(deg::Int)\n\nReturn true if the number of primitive permutation groups of degree deg is available via number_of_primitive_groups, otherwise false.\n\nCurrently the number of primitive permutation groups is available up to degree 4095.\n\nExamples\n\njulia> has_number_of_primitive_groups(50)\ntrue\n\njulia> has_number_of_primitive_groups(5000)\nfalse\n\n\n\n\n\n","category":"function"},{"location":"Groups/grouplib/#has_primitive_group_identification","page":"Group libraries","title":"has_primitive_group_identification","text":"has_primitive_group_identification(deg::Int)\n\nReturn true if identification is supported for the primitive permutation groups of degree deg via primitive_group_identification, otherwise false.\n\nCurrently identification is available for all primitive permutation groups up to degree 4095.\n\nExamples\n\njulia> has_primitive_group_identification(50)\ntrue\n\njulia> has_primitive_group_identification(5000)\nfalse\n\n\n\n\n\n","category":"function"},{"location":"Groups/grouplib/#has_primitive_groups","page":"Group libraries","title":"has_primitive_groups","text":"has_primitive_groups(deg::Int)\n\nReturn true if the primitive permutation groups of degree deg are available via primitive_group and all_primitive_groups, otherwise false.\n\nCurrently all primitive permutation groups up to degree 4095 are available.\n\nExamples\n\njulia> has_primitive_groups(50)\ntrue\n\njulia> has_primitive_groups(5000)\nfalse\n\n\n\n\n\n","category":"function"},{"location":"Groups/grouplib/#number_of_primitive_groups","page":"Group libraries","title":"number_of_primitive_groups","text":"number_of_primitive_groups(deg::Int)\n\nReturn the number of primitive permutation groups of degree deg, up to permutation isomorphism.\n\nExamples\n\njulia> number_of_primitive_groups(10)\n9\n\njulia> number_of_primitive_groups(4096)\nERROR: ArgumentError: the number of primitive permutation groups of degree 4096 is not available\n\n\n\n\n\n","category":"function"},{"location":"Groups/grouplib/#primitive_group","page":"Group libraries","title":"primitive_group","text":"primitive_group(deg::Int, i::Int)\n\nReturn the i-th group in the catalogue of primitive permutation groups over the set {1, ..., deg} in GAP's library of primitive permutation groups. The output is a group of type PermGroup.\n\nExamples\n\njulia> primitive_group(10,1)\nPermutation group of degree 10 and order 60\n\njulia> primitive_group(10,10)\nERROR: ArgumentError: there are only 9 primitive permutation groups of degree 10, not 10\n\n\n\n\n\n","category":"function"},{"location":"Groups/grouplib/#primitive_group_identification","page":"Group libraries","title":"primitive_group_identification","text":"primitive_group_identification(G::PermGroup)\n\nReturn a pair (d,n) such that G is permutation isomorphic with primitive_group(d,n), where G acts primitively on d points.\n\nIf G is not primitive on its moved points, or if the primitive permutation groups of degree d are not available, an exception is thrown.\n\nExamples\n\njulia> G = symmetric_group(7);  m = primitive_group_identification(G)\n(7, 7)\n\njulia> order(primitive_group(m...)) == order(G)\ntrue\n\njulia> S = stabilizer(G, 1)[1]\nPermutation group of degree 7 and order 720\n\njulia> is_primitive(S)\nfalse\n\njulia> is_primitive(S, moved_points(S))\ntrue\n\njulia> m = primitive_group_identification(S)\n(6, 4)\n\njulia> order(primitive_group(m...)) == order(S)\ntrue\n\njulia> primitive_group_identification(symmetric_group(4096))\nERROR: ArgumentError: identification of primitive permutation groups of degree 4096 is not available\n\njulia> S = sub(G, [perm([1,3,4,5,2,7,6])])[1];\n\njulia> primitive_group_identification(S)\nERROR: ArgumentError: group is not primitive on its moved points\n\n\n\n\n\n","category":"function"},{"location":"Groups/grouplib/#Perfect-groups-of-small-order","page":"Group libraries","title":"Perfect groups of small order","text":"","category":"section"},{"location":"Groups/grouplib/","page":"Group libraries","title":"Group libraries","text":"The functions in this section are wrappers for the GAP library of finite perfect groups which provides, up to isomorphism, a list of all perfect groups whose sizes are less than 2cdot 10^6. The groups of most orders up to 10^6 have been enumerated by Derek Holt and Wilhelm Plesken, see [HP89]. For orders 86016, 368640, or 737280 this work only counted the groups (but did not explicitly list them), the groups of orders 61440, 122880, 172032, 245760, 344064, 491520, 688128, or 983040 were omitted.","category":"page"},{"location":"Groups/grouplib/","page":"Group libraries","title":"Group libraries","text":"Several additional groups omitted from the book [HP89] have also been included. Two groups – one of order 450000 with a factor group of type A_6 and the one of order 962280 – were found in 2005 by Jack Schmidt. Two groups of order 243000 and one each of orders 729000, 871200, 878460 were found in 2020 by Alexander Hulpke.","category":"page"},{"location":"Groups/grouplib/","page":"Group libraries","title":"Group libraries","text":"The perfect groups of size less than 2cdot 10^6 which had not been classified in the work of Holt and Plesken have been enumerated by Alexander Hulpke, see [Hul22]. They are stored directly and provide less construction information in their names.","category":"page"},{"location":"Groups/grouplib/","page":"Group libraries","title":"Group libraries","text":"As all groups are stored by presentations, a permutation representation is obtained by coset enumeration. Note that some of the library groups do not have a faithful permutation representation of small degree. Computations in these groups may be rather time consuming.","category":"page"},{"location":"Groups/grouplib/","page":"Group libraries","title":"Group libraries","text":"all_perfect_groups\nhas_number_of_perfect_groups\nhas_perfect_group_identification\nhas_perfect_groups\nnumber_of_perfect_groups\norders_perfect_groups\nperfect_group\nperfect_group_identification","category":"page"},{"location":"Groups/grouplib/#all_perfect_groups","page":"Group libraries","title":"all_perfect_groups","text":"all_perfect_groups(L...)\n\nReturn the list of all perfect groups (up to permutation isomorphism) satisfying the conditions described by the arguments. These conditions may be of one of the following forms:\n\nfunc => intval selects groups for which the function func returns intval\nfunc => list selects groups for which the function func returns any element inside list\nfunc selects groups for which the function func returns true\n!func selects groups for which the function func returns false\n\nAs a special case, the first argument may also be one of the following:\n\nintval selects groups whose order equals intval; this is equivalent to order => intval\nintlist selects groups whose order is in intlist; this is equivalent to order => intlist\n\nThe following functions are currently supported as values for func:\n\nis_quasisimple\nis_simple\nis_sporadic_simple\nnumber_of_conjugacy_classes\norder\n\nThe type of the returned groups is PermGroup.\n\nExamples\n\njulia> all_perfect_groups(7200)\n2-element Vector{PermGroup}:\n Permutation group of degree 29 and order 7200\n Permutation group of degree 288 and order 7200\n\njulia> all_perfect_groups(order => 1:200, !is_simple)\n2-element Vector{PermGroup}:\n Permutation group of degree 1 and order 1\n Permutation group of degree 24 and order 120\n\n\n\n\n\n","category":"function"},{"location":"Groups/grouplib/#has_number_of_perfect_groups","page":"Group libraries","title":"has_number_of_perfect_groups","text":"has_number_of_perfect_groups(n::Int)\n\nReturn true if the number of perfect groups of order n are available via number_of_perfect_groups, otherwise false.\n\nCurrently the number of perfect groups is available up to order 2 cdot 10^6.\n\nExamples\n\njulia> has_number_of_perfect_groups(7200)\ntrue\n\njulia> has_number_of_perfect_groups(2*10^6+1)\nfalse\n\n\n\n\n\n","category":"function"},{"location":"Groups/grouplib/#has_perfect_group_identification","page":"Group libraries","title":"has_perfect_group_identification","text":"has_perfect_group_identification(n::Int)\n\nReturn true if identification is supported for the perfect groups of order n via perfect_group_identification, otherwise false.\n\nCurrently identification is available for all perfect groups up to order 2 cdot 10^6.\n\nExamples\n\njulia> has_perfect_group_identification(7200)\ntrue\n\njulia> has_perfect_group_identification(2*10^6+1)\nfalse\n\n\n\n\n\n","category":"function"},{"location":"Groups/grouplib/#has_perfect_groups","page":"Group libraries","title":"has_perfect_groups","text":"has_perfect_groups(deg::Int)\n\nReturn true if the perfect groups of order n are available via perfect_group and all_perfect_groups, otherwise false.\n\nCurrently all perfect groups up to order 2 cdot 10^6 are available.\n\nExamples\n\njulia> has_perfect_groups(7200)\ntrue\n\njulia> has_perfect_groups(2*10^6+1)\nfalse\n\n\n\n\n\n","category":"function"},{"location":"Groups/grouplib/#number_of_perfect_groups","page":"Group libraries","title":"number_of_perfect_groups","text":"number_of_perfect_groups(n::IntegerUnion)\n\nReturn the number of perfect groups of order n, up to isomorphism.\n\nExamples\n\njulia> number_of_perfect_groups(60)\n1\n\njulia> number_of_perfect_groups(1966080)\n7344\n\n\n\n\n\n","category":"function"},{"location":"Groups/grouplib/#orders_perfect_groups","page":"Group libraries","title":"orders_perfect_groups","text":"orders_perfect_groups()\n\nReturn a sorted vector of all numbers to 2 cdot 10^6 that occur as orders of perfect groups.\n\nExamples\n\njulia> orders_perfect_groups()[1:10]\n10-element Vector{Int64}:\n   1\n  60\n 120\n 168\n 336\n 360\n 504\n 660\n 720\n 960\n\n\n\n\n\n","category":"function"},{"location":"Groups/grouplib/#perfect_group","page":"Group libraries","title":"perfect_group","text":"perfect_group(::Type{T} = PermGroup, n::IntegerUnion, k::IntegerUnion)\n\nReturn the k-th group of order n and type T in the catalogue of perfect groups in GAP's Perfect Groups Library. The type T can be either PermGroup or FPGroup.\n\nExamples\n\njulia> perfect_group(60, 1)\nPermutation group of degree 5 and order 60\n\njulia> gens(ans)\n2-element Vector{PermGroupElem}:\n (1,2)(4,5)\n (2,3,4)\n\njulia> perfect_group(FPGroup, 60, 1)\nFinitely presented group of order 60\n\njulia> gens(ans)\n2-element Vector{FPGroupElem}:\n a\n b\n\njulia> perfect_group(60, 2)\nERROR: ArgumentError: there are only 1 perfect groups of order 60\n\n\n\n\n\n","category":"function"},{"location":"Groups/grouplib/#perfect_group_identification","page":"Group libraries","title":"perfect_group_identification","text":"perfect_group_identification(G::GAPGroup)\n\nReturn (n, m) such that G is isomorphic with perfect_group(n, m). If G is not perfect, an exception is thrown.\n\nExamples\n\njulia> perfect_group_identification(alternating_group(5))\n(60, 1)\n\njulia> perfect_group_identification(SL(2,7))\n(336, 1)\n\n\n\n\n\n","category":"function"},{"location":"Groups/grouplib/#Groups-of-small-order","page":"Group libraries","title":"Groups of small order","text":"","category":"section"},{"location":"Groups/grouplib/","page":"Group libraries","title":"Group libraries","text":"The functions in this section are wrappers for the GAP library of the following groups.","category":"page"},{"location":"Groups/grouplib/","page":"Group libraries","title":"Group libraries","text":"The GAP package SmallGrp [BEO23] provides","category":"page"},{"location":"Groups/grouplib/","page":"Group libraries","title":"Group libraries","text":"those of order at most 2000 (except those of order 1024),\nthose of cubefree order at most 50000,\nthose of order p^7 for the primes p = 3 5 7 11,\nthose of order p^n for n leq 6 and all primes p,\nthose of order q^n p where q^n divides 2^8, 3^6, 5^5 or 7^4 and p is an arbitrary prime not equal to q,\nthose of squarefree order,\nthose whose order factorises into at most 3 primes.","category":"page"},{"location":"Groups/grouplib/","page":"Group libraries","title":"Group libraries","text":"The GAP package SOTGrps [Pan23] provides","category":"page"},{"location":"Groups/grouplib/","page":"Group libraries","title":"Group libraries","text":"those whose order factorises into at most 4 primes,\nthose of order p^4 q where p and q are distinct primes.","category":"page"},{"location":"Groups/grouplib/","page":"Group libraries","title":"Group libraries","text":"The GAP package SglPPow [VE22]  provides","category":"page"},{"location":"Groups/grouplib/","page":"Group libraries","title":"Group libraries","text":"those of order p^7 for primes p  11,\nthose of order 3^8.","category":"page"},{"location":"Groups/grouplib/","page":"Group libraries","title":"Group libraries","text":"all_small_groups\nhas_number_of_small_groups\nhas_small_group_identification\nhas_small_groups\nnumber_of_small_groups\nsmall_group\nsmall_group_identification","category":"page"},{"location":"Groups/grouplib/#all_small_groups","page":"Group libraries","title":"all_small_groups","text":"all_small_groups(L...)\n\nReturn the list of all groups (up to isomorphism) satisfying the conditions described by the arguments. These conditions may be of one of the following forms:\n\nfunc => intval selects groups for which the function func returns intval\nfunc => list selects groups for which the function func returns any element inside list\nfunc selects groups for which the function func returns true\n!func selects groups for which the function func returns false\n\nAs a special case, the first argument may also be one of the following:\n\nintval selects groups whose order equals intval; this is equivalent to order => intval\nintlist selects groups whose order is in intlist; this is equivalent to order => intlist\n\nNote that at least one of the conditions must impose a limit on the group order, otherwise an exception is thrown.\n\nThe following functions are currently supported as values for func:\n\nexponent\nis_abelian\nis_almost_simple\nis_cyclic\nis_nilpotent\nis_perfect\nis_quasisimple\nis_simple\nis_sporadic_simple\nis_solvable\nis_supersolvable\nnumber_of_conjugacy_classes\norder\n\nThe type of the returned groups is PcGroup if the group is solvable, PermGroup otherwise.\n\nExamples\n\nList all abelian non-cyclic groups of order 12:\n\njulia> all_small_groups(12, !is_cyclic, is_abelian)\n1-element Vector{PcGroup}:\n Pc group of order 12\n\nList groups of order 1 to 10 which are not abelian:\n\njulia> all_small_groups(1:10, !is_abelian)\n4-element Vector{PcGroup}:\n Pc group of order 6\n Pc group of order 8\n Pc group of order 8\n Pc group of order 10\n\n\n\n\n\n","category":"function"},{"location":"Groups/grouplib/#has_number_of_small_groups","page":"Group libraries","title":"has_number_of_small_groups","text":"has_number_of_small_groups(n::IntegerUnion)\n\nReturn true if the number of groups of order n is known, otherwise false.\n\nExamples\n\njulia> has_number_of_small_groups(1024)\ntrue\n\njulia> has_number_of_small_groups(2048)\nfalse\n\n\n\n\n\n","category":"function"},{"location":"Groups/grouplib/#has_small_group_identification","page":"Group libraries","title":"has_small_group_identification","text":"has_small_group_identification(n::IntegerUnion)\n\nReturn true if identification for groups of order n is available via small_group_identification, otherwise false.\n\nExamples\n\njulia> has_small_group_identification(256)\ntrue\n\njulia> has_small_group_identification(512)\nfalse\n\n\n\n\n\n","category":"function"},{"location":"Groups/grouplib/#has_small_groups","page":"Group libraries","title":"has_small_groups","text":"has_small_groups(n::IntegerUnion)\n\nReturn true if the groups of order n are available via small_group and all_small_groups, otherwise false.\n\nExamples\n\njulia> has_small_groups(512)\ntrue\n\njulia> has_small_groups(1024)\nfalse\n\n\n\n\n\n","category":"function"},{"location":"Groups/grouplib/#number_of_small_groups","page":"Group libraries","title":"number_of_small_groups","text":"number_of_small_groups(n::IntegerUnion)\n\nReturn the number of groups of order n, up to isomorphism.\n\nExamples\n\njulia> number_of_small_groups(8)\n5\n\njulia> number_of_small_groups(4096)\nERROR: ArgumentError: the number of groups of order 4096 is not available\n\njulia> number_of_small_groups(next_prime(ZZRingElem(2)^64))\n1\n\n\n\n\n\n","category":"function"},{"location":"Groups/grouplib/#small_group","page":"Group libraries","title":"small_group","text":"small_group(::Type{T}, n::IntegerUnion, i::IntegerUnion) where T\nsmall_group(n::IntegerUnion, i::IntegerUnion)\n\nReturn the i-th group of order n in the Small Groups Library. If a type T is specified then an attempt is made to return the result with that type. If T is omitted then the resulting group will have type PcGroup if it is solvable, otherwise it will be of type PermGroup.\n\nExamples\n\njulia> small_group(60, 4)\nPc group of order 60\n\njulia> small_group(60, 5)\nPermutation group of degree 5 and order 60\n\njulia> small_group(PcGroup, 60, 4)\nPc group of order 60\n\n\n\n\n\n","category":"function"},{"location":"Groups/grouplib/#small_group_identification","page":"Group libraries","title":"small_group_identification","text":"small_group_identification(G::Group)\n\nReturn a pair of integer (n, m), where G is isomorphic with small_group(n, m).\n\nExamples\n\njulia> small_group_identification(alternating_group(5))\n(60, 5)\n\njulia> small_group_identification(symmetric_group(20))\nERROR: ArgumentError: identification is not available for groups of order 2432902008176640000\n\n\n\n\n\n","category":"function"},{"location":"Groups/grouplib/#Atlas-of-Group-Representations","page":"Group libraries","title":"Atlas of Group Representations","text":"","category":"section"},{"location":"Groups/grouplib/","page":"Group libraries","title":"Group libraries","text":"The functions in this section give access to data in the Atlas of Group Representations [ATLAS]. The isomorphism types of the groups in question are specified via names for the groups, which coincide with the names of the corresponding character tables in the library of character tables, see character_table(id::String, p::Int = 0).","category":"page"},{"location":"Groups/grouplib/","page":"Group libraries","title":"Group libraries","text":"number_of_atlas_groups\nall_atlas_group_infos\natlas_group\natlas_subgroup","category":"page"},{"location":"Groups/grouplib/#number_of_atlas_groups","page":"Group libraries","title":"number_of_atlas_groups","text":"number_of_atlas_groups([::Type{T}, ]name::String) where T <: Union{PermGroup, MatrixGroup}\n\nReturn the number of groups from the Atlas of Group Representations whose isomorphism type is given by name and have the type T.\n\nExamples\n\njulia> number_of_atlas_groups(\"A5\")\n18\n\njulia> number_of_atlas_groups(PermGroup, \"A5\")\n3\n\njulia> number_of_atlas_groups(MatrixGroup, \"A5\")\n15\n\n\n\n\n\n\n","category":"function"},{"location":"Groups/grouplib/#all_atlas_group_infos","page":"Group libraries","title":"all_atlas_group_infos","text":"all_atlas_group_infos(name::String, L...)\n\nReturn the vector of dictionaries that describe Atlas groups whose isomorphism types are given by name and which satisfy the conditions in L. These conditions may be of one of the following forms:\n\nfunc => intval selects groups for which the function func returns intval\nfunc => list selects groups for which the function func returns any element inside list\nfunc selects groups for which the function func returns true\n!func selects groups for which the function func returns false\n\nThe following functions are currently supported as values for func:\n\nFor permutation groups\n\ndegree\nis_primitive\nis_transitive\nrank_action\ntransitivity\n\nand for matrix groups\n\nbase_ring\ncharacter\ncharacteristic\ndim\n\nExamples\n\njulia> info = all_atlas_group_infos(\"A5\", degree => [5, 6])\n2-element Vector{Dict{Symbol, Any}}:\n Dict(:constituents => [1, 4], :repname => \"A5G1-p5B0\", :degree => 5, :name => \"A5\")\n Dict(:constituents => [1, 5], :repname => \"A5G1-p6B0\", :degree => 6, :name => \"A5\")\n\njulia> atlas_group(info[1])\nPermutation group of degree 5 and order 60\n\njulia> info = all_atlas_group_infos(\"A5\", dim => 4, characteristic => 3)\n1-element Vector{Dict{Symbol, Any}}:\n Dict(:dim => 4, :constituents => [4], :repname => \"A5G1-f3r4B0\", :name => \"A5\")\n\njulia> atlas_group(info[1])\nMatrix group of degree 4\n  over prime field of characteristic 3\n\n\n\n\n\n\n","category":"function"},{"location":"Groups/grouplib/#atlas_group","page":"Group libraries","title":"atlas_group","text":"atlas_group([::Type{T}, ]name::String) where T <: Union{PermGroup, MatrixGroup}\n\nReturn a group from the Atlas of Group Representations whose isomorphism type is given by name and have the type T. If T is not given then PermGroup is chosen if a permutation group for name is available, and MatrixGroup otherwise.\n\nExamples\n\njulia> atlas_group(\"A5\")  # alternating group A5\nPermutation group of degree 5 and order 60\n\njulia> atlas_group(MatrixGroup, \"A5\")\nMatrix group of degree 4\n  over prime field of characteristic 2\n\njulia> atlas_group(\"M11\")  # Mathieu group M11\nPermutation group of degree 11 and order 7920\n\njulia> atlas_group(\"M\")  # Monster group M\nERROR: ArgumentError: the group atlas does not provide a representation for M\n\n\n\n\n\natlas_group(info::Dict)\n\nReturn the group from the Atlas of Group Representations that is defined by info. Typically, info is obtained from all_atlas_group_infos.\n\nExamples\n\njulia> info = all_atlas_group_infos(\"A5\", degree => 5)\n1-element Vector{Dict{Symbol, Any}}:\n Dict(:constituents => [1, 4], :repname => \"A5G1-p5B0\", :degree => 5, :name => \"A5\")\n\njulia> atlas_group(info[1])\nPermutation group of degree 5 and order 60\n\n\n\n\n\n\n","category":"function"},{"location":"Groups/grouplib/#atlas_subgroup","page":"Group libraries","title":"atlas_subgroup","text":"atlas_subgroup(G::GAPGroup, nr::Int)\natlas_subgroup([::Type{T}, ]name::String, nr::Int) where T <: Union{PermGroup, MatrixGroup}\natlas_subgroup(info::Dict, nr::Int)\n\nReturn a pair (H, emb) where H is a representative of the nr-th class of maximal subgroups of the group G, and emb is an embedding of H into G.\n\nThe group G can be given as the first argument, in this case it is assumed that G has been created with atlas_group. Otherwise G is the group obtained by calling atlas_group with (T and) name or with info.\n\nIf the Atlas of Group Representations does not provide the information to compute G or to compute generators of H from G then an exception is thrown.\n\nExamples\n\njulia> g = atlas_group(\"M11\");  # Mathieu group M11\n\njulia> h1, emb = atlas_subgroup(g, 1);  h1\nPermutation group of degree 11 and order 720\n\njulia> order(h1)  # largest maximal subgroup of M11\n720\n\njulia> h2, emb = atlas_subgroup(\"M11\", 1);  h2\nPermutation group of degree 11 and order 720\n\njulia> h3, emb = atlas_subgroup(MatrixGroup, \"M11\", 1 );  h3\nMatrix group of degree 10\n  over prime field of characteristic 2\n\njulia> info = all_atlas_group_infos(\"M11\", degree => 11);\n\njulia> h4, emb = atlas_subgroup(info[1], 1);  h4\nPermutation group of degree 11 and order 720\n\n\n\n\n\n","category":"function"},{"location":"StraightLinePrograms/intro/","page":"Introduction","title":"Introduction","text":"CurrentModule = Oscar","category":"page"},{"location":"StraightLinePrograms/intro/#Introduction","page":"Introduction","title":"Introduction","text":"","category":"section"},{"location":"StraightLinePrograms/intro/","page":"Introduction","title":"Introduction","text":"This is the documentation of the straight-line programs (SLP) implementation by Rafael Fourquet. Originally this was supposed to become a separate Julia module, however it has now been incorporated into the OSCAR core.","category":"page"},{"location":"StraightLinePrograms/intro/","page":"Introduction","title":"Introduction","text":"The main SLP type is SLProgram, to which other types can \"compile\" (or \"transpile\"). The easiest way to create an SLProgram is to combine \"generators\":","category":"page"},{"location":"StraightLinePrograms/intro/","page":"Introduction","title":"Introduction","text":"julia> using Oscar;\n\njulia> using Oscar.StraightLinePrograms; const SLP = Oscar.StraightLinePrograms;\n\njulia> x, y, z = SLP.gens(SLProgram, 3)\n3-element Vector{SLProgram{Union{}}}:\n x\n y\n z\n\njulia> p = (x*y^2 + 1.3*z)^-1\n#1 = ^   y  2  ==>  y^2\n#2 = *   x #1  ==>  (x*y^2)\n#3 = * 1.3  z  ==>  (1.3*z)\n#4 = +  #2 #3  ==>  ((x*y^2) + (1.3*z))\n#5 = ^  #4 -1  ==>  ((x*y^2) + (1.3*z))^-1\nreturn: #5","category":"page"},{"location":"StraightLinePrograms/intro/","page":"Introduction","title":"Introduction","text":"On the right side of the above output is the representation of the computation so far. It's done via another SLP type (tentatively) called Lazy which represent \"formulas\" as trees:","category":"page"},{"location":"StraightLinePrograms/intro/","page":"Introduction","title":"Introduction","text":"julia> using Oscar;\n\njulia> using Oscar.StraightLinePrograms; const SLP = Oscar.StraightLinePrograms;\n\njulia> x, y, z = SLP.gens(SLProgram, 3);\n\njulia> p = (x*y^2 + 1.3*z)^-1;\n\njulia> X, Y, Z = SLP.gens(Lazy, 3)\n3-element Vector{Lazy}:\n x\n y\n z\n\njulia> q = (X*Y^2 + 1.3*Z)^-1\n((x*y^2) + (1.3*z))^-1\n\njulia> f = SLP.evaluate(p, [X, Y, Z])\n((x*y^2) + (1.3*z))^-1\n\njulia> SLP.evaluate(f, [X, Y, Z]) == f\ntrue\n\njulia> SLP.evaluate(p, Any[x, y, z]) == p\ntrue\n\njulia> dump(q) # q::Lazy is a tree\nOscar.StraightLinePrograms.Lazy\n  x: Oscar.StraightLinePrograms.Exp\n    p: Oscar.StraightLinePrograms.Plus\n      xs: Array{Oscar.StraightLinePrograms.LazyRec}((2,))\n        1: Oscar.StraightLinePrograms.Times\n          xs: Array{Oscar.StraightLinePrograms.LazyRec}((2,))\n            1: Oscar.StraightLinePrograms.Input\n              n: Int64 1\n            2: Oscar.StraightLinePrograms.Exp\n              p: Oscar.StraightLinePrograms.Input\n                n: Int64 2\n              e: Int64 2\n        2: Oscar.StraightLinePrograms.Times\n          xs: Array{Oscar.StraightLinePrograms.LazyRec}((2,))\n            1: Oscar.StraightLinePrograms.Const{Float64}\n              c: Float64 1.3\n            2: Oscar.StraightLinePrograms.Input\n              n: Int64 3\n    e: Int64 -1\n  gens: Array{Symbol}((3,))\n    1: Symbol x\n    2: Symbol y\n    3: Symbol z","category":"page"},{"location":"StraightLinePrograms/intro/","page":"Introduction","title":"Introduction","text":"Evaluation of SLPs is done via evaluate, which can take a vector of anything which supports the operations used in the SLP (e.g. *, + and ^ in this example; - is also supported but division not yet). Note that currently, the eltype of the input vector for SLProgram must be a supertype of any intermediate computation (so it's always safe to pass a Vector{Any}).","category":"page"},{"location":"StraightLinePrograms/intro/","page":"Introduction","title":"Introduction","text":"julia> using Oscar;\n\njulia> using Oscar.StraightLinePrograms; const SLP = Oscar.StraightLinePrograms;\n\njulia> x, y, z = SLP.gens(SLProgram, 3);\n\njulia> p = (x*y^2 + 1.3*z)^-1;\n\njulia> X, Y, Z = SLP.gens(Lazy, 3);\n\n\njulia> SLP.evaluate(p, [2.0, 3.0, 5.0])\n0.04081632653061224\n\njulia> SLP.evaluate(X*Y^2, ['a', 'b'])\n\"abb\"","category":"page"},{"location":"StraightLinePrograms/intro/#Returning-multiple-values","page":"Introduction","title":"Returning multiple values","text":"","category":"section"},{"location":"StraightLinePrograms/intro/","page":"Introduction","title":"Introduction","text":"There is a low-level interface to return multiple values from an SLProgram; for example, to return the second and last intermediate values from p above, we would \"assign\" these values to positions #1 and #2, delete all other positions (via the \"keep\" operation), and return the resulting array (the one used for intermediate computations):","category":"page"},{"location":"StraightLinePrograms/intro/","page":"Introduction","title":"Introduction","text":"julia> using Oscar;\n\njulia> using Oscar.StraightLinePrograms; const SLP = Oscar.StraightLinePrograms;\n\njulia> x, y, z = SLP.gens(SLProgram, 3);\n\njulia> p = (x*y^2 + 1.3*z)^-1;\n\njulia> X, Y, Z = SLP.gens(Lazy, 3);\n\n\njulia> SLP.pushop!(p, SLP.assign, SLP.Arg(2), SLP.Arg(1))\n       SLP.pushop!(p, SLP.assign, SLP.Arg(5), SLP.Arg(2))\n       SLP.pushop!(p, SLP.keep, SLP.Arg(2))\n       SLP.setmultireturn!(p)\n#1 = ^   y  2  ==>  y^2\n#2 = *   x #1  ==>  (x*y^2)\n#3 = * 1.3  z  ==>  (1.3*z)\n#4 = +  #2 #3  ==>  ((x*y^2) + (1.3*z))\n#5 = ^  #4 -1  ==>  ((x*y^2) + (1.3*z))^-1\n#1 =    #2     ==>  (x*y^2)\n#2 =    #5     ==>  ((x*y^2) + (1.3*z))^-1\nkeep: #1..#2\nreturn: [#1, #2]\n\njulia> SLP.evaluate(p, [X, Y, Z])\nlist([(x*y^2), ((x*y^2) + (1.3*z))^-1])","category":"page"},{"location":"StraightLinePrograms/intro/#Straight-line-decisions","page":"Introduction","title":"Straight line decisions","text":"","category":"section"},{"location":"StraightLinePrograms/intro/","page":"Introduction","title":"Introduction","text":"A \"decision\" is a special operation which allows to stop prematurely the execution of the program if a condition is false, and the program returns true if no condition failed. Currently, the interface is modeled after GAP's SLPs and defaults to testing the AbstractAlgebra.order of an element. More specifically, test(prg, n::Integer) tests whether the order of the result of prg is equal to n, and dec1 & dec2 chains two programs with a short-circuiting behavior:","category":"page"},{"location":"StraightLinePrograms/intro/","page":"Introduction","title":"Introduction","text":"julia> p1 = SLP.test(x*y^2, 2)\n#1 = ^ y  2  ==>  y^2\n#2 = * x #1  ==>  (xy^2)\ntest: order(#2) == 2 || return false\nreturn: true\n\njulia> p2 = SLP.test(y, 4)\ntest: order(y) == 4 || return false\nreturn: true\n\njulia> p1 & p2\n#1 = ^ y  2  ==>  y^2\n#2 = * x #1  ==>  (xy^2)\ntest: order(#2) == 2 || return false\ntest: order(y) == 4 || return false\nreturn: true\n\njulia> SLP.evaluate(p1 & p2, [X, Y])\ntest((xy^2), 2) & test(y, 4)\n\njulia> using AbstractAlgebra; perm1, perm2 = perm\"(1, 4)\", perm\"(1, 3, 4, 2)\";\n\njulia> SLP.evaluate(p1 & p2, [perm1, perm2])\ntrue\n\njulia> SLP.evaluate(p1 & p2, [perm2, perm1])\nfalse","category":"page"},{"location":"StraightLinePrograms/intro/#Contact","page":"Introduction","title":"Contact","text":"","category":"section"},{"location":"StraightLinePrograms/intro/","page":"Introduction","title":"Introduction","text":"Please direct questions about this part of OSCAR to the following people:","category":"page"},{"location":"StraightLinePrograms/intro/","page":"Introduction","title":"Introduction","text":"Thomas Breuer,\nRaphael Fourquet.","category":"page"},{"location":"StraightLinePrograms/intro/","page":"Introduction","title":"Introduction","text":"You can ask questions in the OSCAR Slack.","category":"page"},{"location":"StraightLinePrograms/intro/","page":"Introduction","title":"Introduction","text":"Alternatively, you can raise an issue on github.","category":"page"},{"location":"Combinatorics/EnumerativeCombinatorics/schur_polynomials/#Schur-polynomials","page":"Schur polynomials","title":"Schur polynomials","text":"","category":"section"},{"location":"Combinatorics/EnumerativeCombinatorics/schur_polynomials/","page":"Schur polynomials","title":"Schur polynomials","text":"Given a partition lambda with n parts, the Schur polynomial is defined to be the polynomial","category":"page"},{"location":"Combinatorics/EnumerativeCombinatorics/schur_polynomials/","page":"Schur polynomials","title":"Schur polynomials","text":"s_lambda = sum x_1^m_1dots x_n^m_n","category":"page"},{"location":"Combinatorics/EnumerativeCombinatorics/schur_polynomials/","page":"Schur polynomials","title":"Schur polynomials","text":"where the sum is taken over all semistandard tableaux T of shape lambda and m_i is the weight of i in T.","category":"page"},{"location":"Combinatorics/EnumerativeCombinatorics/schur_polynomials/","page":"Schur polynomials","title":"Schur polynomials","text":"There are two different algorithms for the computation of a Schur polynomial implemented which are automatically selected depending on the size of the input.","category":"page"},{"location":"Combinatorics/EnumerativeCombinatorics/schur_polynomials/","page":"Schur polynomials","title":"Schur polynomials","text":"For small integers or if ngeq 10, the combinatorial algorithm is used. This algorithm directly applies the above definition.","category":"page"},{"location":"Combinatorics/EnumerativeCombinatorics/schur_polynomials/","page":"Schur polynomials","title":"Schur polynomials","text":"In the other cases, Cauchy's bialternant formula","category":"page"},{"location":"Combinatorics/EnumerativeCombinatorics/schur_polynomials/","page":"Schur polynomials","title":"Schur polynomials","text":"s_lambda(x_1 dots x_n) = prod_1leq i  j leq n (x_i - x_j)^-1\nbeginvmatrix\nx_1^lambda_1 + n - 1  x_2^lambda_1 + n - 1  dots  x_n^lambda_1 + n - 1 \nx_1^lambda_2 + n - 2  x_2^lambda_2 + n - 2  dots  x_n^lambda_2 + n - 2 \nvdots  vdots  ddots  vdots \nx_1^lambda_n  x_2^lambda_n  dots  x_n^lambda_n\nendvmatrix","category":"page"},{"location":"Combinatorics/EnumerativeCombinatorics/schur_polynomials/","page":"Schur polynomials","title":"Schur polynomials","text":"is used.","category":"page"},{"location":"Combinatorics/EnumerativeCombinatorics/schur_polynomials/","page":"Schur polynomials","title":"Schur polynomials","text":"schur_polynomial","category":"page"},{"location":"Combinatorics/EnumerativeCombinatorics/schur_polynomials/#schur_polynomial","page":"Schur polynomials","title":"schur_polynomial","text":"schur_polynomial([R::ZZMPolyRing], lambda::Partition, n::Int = length(lambda))\n\nReturn the Schur polynomial s of the partition lambda in n variables.\n\nThe ambient ring of s may optionally be supplied as a first argument.\n\nExamples\n\njulia> R, _ = ZZ[:a, :b, :c];\n\njulia> schur_polynomial(R, partition([2, 1]))\na^2*b + a*b^2\n\njulia> schur_polynomial(R, partition([2, 1]), 3)\na^2*b + a^2*c + a*b^2 + 2*a*b*c + a*c^2 + b^2*c + b*c^2\n\njulia> schur_polynomial(partition([2]))\nx1^2\n\n\n\n\n\n","category":"function"},{"location":"TropicalGeometry/semiring_map/#Tropical-semiring-maps","page":"Tropical semiring maps","title":"Tropical semiring maps","text":"","category":"section"},{"location":"TropicalGeometry/semiring_map/#Introduction","page":"Tropical semiring maps","title":"Introduction","text":"","category":"section"},{"location":"TropicalGeometry/semiring_map/","page":"Tropical semiring maps","title":"Tropical semiring maps","text":"In OSCAR, a TropicalSemiringMap is a map nu KtomathbbT from a field K to a tropical semiring mathbbT satisfying","category":"page"},{"location":"TropicalGeometry/semiring_map/","page":"Tropical semiring maps","title":"Tropical semiring maps","text":"finiteness: nu(a)=pminfty if and only if a=0,\nmultiplicativity: nu(acdot b)=nu(a)+nu(b),\nsuperadditivity: nu(acdot b)geqmin(nu(a)nu(b)) (in the order defined in Section 2.7 of [Jos21]).","category":"page"},{"location":"TropicalGeometry/semiring_map/","page":"Tropical semiring maps","title":"Tropical semiring maps","text":"Most commonly, nu(a)=-mathrmval(a) if mathbbT is the min-plus semiring, and nu(a)=+mathrmval(a) if mathbbT is the max-plus semiring, for some valuation mathrmvalK^astrightarrowmathbbR.  Essentially, nu captures a valuation on K as well as a choice of min- or max-convention.  They are an optional input for most tropical functions over valued fields (the default being the trivial valuation and the min-convention).","category":"page"},{"location":"TropicalGeometry/semiring_map/#Constructor","page":"Tropical semiring maps","title":"Constructor","text":"","category":"section"},{"location":"TropicalGeometry/semiring_map/","page":"Tropical semiring maps","title":"Tropical semiring maps","text":"Tropical semiring maps can be constructed as follows:","category":"page"},{"location":"TropicalGeometry/semiring_map/","page":"Tropical semiring maps","title":"Tropical semiring maps","text":"tropical_semiring_map(K::Field, minOrMax::Union{typeof(min),typeof(max)}=min)\ntropical_semiring_map(K::QQField, p::Union{RingElem,Integer,Rational}, minOrMax::Union{typeof(min),typeof(max)}=min)\ntropical_semiring_map(Kt::Generic.RationalFunctionField, t::Generic.RationalFunctionFieldElem, minOrMax::Union{typeof(min),typeof(max)}=min)","category":"page"},{"location":"TropicalGeometry/semiring_map/#tropical_semiring_map","page":"Tropical semiring maps","title":"tropical_semiring_map","text":"tropical_semiring_map(K::Field, minOrMax::Union{typeof(min),typeof(max)}=min)\n\nReturn a map nu from K to the min (default) or max tropical semiring T such that nu(0)=zero(T) and nu(c)=one(T) for c non-zero.  In other words, nu extends the trivial valuation on K.\n\nExamples\n\njulia> nu = tropical_semiring_map(QQ) # arbitrary rings possible\nMap into Min tropical semiring encoding the trivial valuation on Rational field\n\njulia> nu(1)\n(0)\n\njulia> nu(0)\ninfty\n\njulia> nu = tropical_semiring_map(QQ,max) # arbitrary rings possible\nMap into Max tropical semiring encoding the trivial valuation on Rational field\n\njulia> nu(1)\n(0)\n\njulia> nu(0)\n-infty\n\n\n\n\n\n\n","category":"function"},{"location":"TropicalGeometry/semiring_map/#tropical_semiring_map-2","page":"Tropical semiring maps","title":"tropical_semiring_map","text":"tropical_semiring_map(QQ::QQField, p::QQFieldElem, minOrMax::Union{typeof(min),typeof(max)}=min)\n\nReturn a map nu from QQ to the min (default) or max tropical semiring T such that nu(0)=zero(T) and nu(c)=+/-val(c) for c non-zero, where val denotes the p-adic valuation.  Requires p to be a prime.\n\nExamples\n\njulia> nu_2 = tropical_semiring_map(QQ,2)\nMap into Min tropical semiring encoding the 2-adic valuation on Rational field\n\njulia> nu_2(4)\n(2)\n\njulia> nu_2(1//4)\n(-2)\n\njulia> nu_2 = tropical_semiring_map(QQ,2,max);\n\njulia> nu_2(4)\n(-2)\n\njulia> nu_2(1//4)\n(2)\n\n\n\n\n\n\n","category":"function"},{"location":"TropicalGeometry/semiring_map/#tropical_semiring_map-3","page":"Tropical semiring maps","title":"tropical_semiring_map","text":"tropical_semiring_map(Kt::Generic.RationalFunctionField, t::Generic.RationalFunctionFieldElem, minOrMax::Union{typeof(min),typeof(max)}=min)\n\nReturn a map nu from rational function field Kt to the min (default) or max tropical semiring T such that nu(0)=zero(T) and nu(c)=+/-val(c) for c non-zero, where val denotes the t-adic valuation with uniformizer t.  Requires t to be non-constant and have denominator 1.\n\nExamples\n\njulia> Kt,t = rational_function_field(QQ,\"t\");\n\njulia> nu_t = tropical_semiring_map(Kt,t)\nMap into Min tropical semiring encoding the t-adic valuation on Rational function field over QQ\n\njulia> nu_t(t^2)\n(2)\n\njulia> nu_t(1//t^2)\n(-2)\n\njulia> nu_t = tropical_semiring_map(Kt,t,max)\nMap into Max tropical semiring encoding the t-adic valuation on Rational function field over QQ\n\njulia> nu_t(t^2)\n(-2)\n\njulia> nu_t(1//t^2)\n(2)\n\n\n\n\n\n\n","category":"function"},{"location":"NoncommutativeAlgebra/PBWAlgebras/intro/","page":"Introduction","title":"Introduction","text":"CurrentModule = Oscar\nDocTestSetup = Oscar.doctestsetup()","category":"page"},{"location":"NoncommutativeAlgebra/PBWAlgebras/intro/#Introduction","page":"Introduction","title":"Introduction","text":"","category":"section"},{"location":"NoncommutativeAlgebra/PBWAlgebras/intro/","page":"Introduction","title":"Introduction","text":"We start our discussion of PBW-algebras by recalling their definition. Let K be a field. Given a set of variables x=x_1 ldots x_n we write leftlangle xrightrangle=langle x_1ldots x_n rangle for the free monoid on x. That is, the elements of langle x rangle are the words in the finite alphabet x, multiplication means concatenation of words, and the identity element is the empty word. The free associative K-algebra generated by x_1dots x_n is the corresponding monoid algebra","category":"page"},{"location":"NoncommutativeAlgebra/PBWAlgebras/intro/","page":"Introduction","title":"Introduction","text":"K langle xrangle= K langle x_1dots x_n rangle","category":"page"},{"location":"NoncommutativeAlgebra/PBWAlgebras/intro/","page":"Introduction","title":"Introduction","text":"We consider quotients of type A = Klangle x_1 dots x_n rangleJ, for some n and some two-sided ideal J of Klangle x_1 dots x_n rangle. In case J is given by a finite set of two-sided generators g_1 dots g_r, we say that A is generated by x_1 dots x_n, subject to the relations g_1 = 0 dots g_r = 0, and write","category":"page"},{"location":"NoncommutativeAlgebra/PBWAlgebras/intro/","page":"Introduction","title":"Introduction","text":"A = Klangle x_1 dots  x_n mid g_k=0  1leq k leq r rangle","category":"page"},{"location":"NoncommutativeAlgebra/PBWAlgebras/intro/","page":"Introduction","title":"Introduction","text":"The relations considered in this chapter are \"commutation relations\", written as","category":"page"},{"location":"NoncommutativeAlgebra/PBWAlgebras/intro/","page":"Introduction","title":"Introduction","text":"x_jx_i = c_ijx_ix_j+d_ij","category":"page"},{"location":"NoncommutativeAlgebra/PBWAlgebras/intro/","page":"Introduction","title":"Introduction","text":"Working with Gröbner bases requires that we take monomial orderings into account (see the section on Gröbner bases in the commutative algebra chapter for monomial orderings). In our context here, we use the following notation. A standard monomial in K langle x rangle is a word of type x^alpha=x_1^alpha_1cdots x_n^alpha_n where alpha=(alpha_1dotsalpha_n)inmathbb N^n. A standard polynomial in K langle x rangle is a K-linear combination of standard monomials. Each global monomial ordering  on Kx gives rise to a (total) well-ordering on the set of standard monomials. Abusing our notation, we denote the induced ordering again by , and refer to it as a global monomial ordering on A. Given , it makes sense to speak of the leading monomial textLM_(f) of a standard polynomial 0neq f in K langle x rangle The notion of a global elimination ordering with respect to a subset of  x_1ldots x_n  carries over from Kx to A.","category":"page"},{"location":"NoncommutativeAlgebra/PBWAlgebras/intro/","page":"Introduction","title":"Introduction","text":"Definition.   Let A be a K-algebra of type","category":"page"},{"location":"NoncommutativeAlgebra/PBWAlgebras/intro/","page":"Introduction","title":"Introduction","text":"A = Klangle x_1 dots  x_n mid x_jx_i = c_ijx_ix_j+d_ij   1leq ij leq n rangle","category":"page"},{"location":"NoncommutativeAlgebra/PBWAlgebras/intro/","page":"Introduction","title":"Introduction","text":"where the c_ijin K are nonzero scalars, and the d_ijin Klangle x_1 dots  x_nrangle are  standard polynomials. Then A is called a PBW-algebra if the following two conditions hold:","category":"page"},{"location":"NoncommutativeAlgebra/PBWAlgebras/intro/","page":"Introduction","title":"Introduction","text":"(1)  There exists a global monomial ordering  on A such that","category":"page"},{"location":"NoncommutativeAlgebra/PBWAlgebras/intro/","page":"Introduction","title":"Introduction","text":"d_ij=0 text or  x_ix_j textLM_(d_ij) text for all  1leq ij leq n","category":"page"},{"location":"NoncommutativeAlgebra/PBWAlgebras/intro/","page":"Introduction","title":"Introduction","text":"(2)  The standard monomials in K langle x rangle represent a K-basis for A.  We then refer to this basis as a PBW-basis for A. ","category":"page"},{"location":"NoncommutativeAlgebra/PBWAlgebras/intro/","page":"Introduction","title":"Introduction","text":"Every ordering as in (1) is called admissible for the given relations or simply admissible for A.","category":"page"},{"location":"NoncommutativeAlgebra/PBWAlgebras/intro/","page":"Introduction","title":"Introduction","text":"Given a PBW-algebra A as above, we sometimes abuse our notation by denoting the class of a standard monomial x^alpha in A also by x^alpha, and refer to this class as a standard monomial in A. As these monomials form a K-basis for A, every element 0neq fin A has a unique representation","category":"page"},{"location":"NoncommutativeAlgebra/PBWAlgebras/intro/","page":"Introduction","title":"Introduction","text":"f=sum c_alphax^alpha  text with nonzero coefficients   c_alphain K","category":"page"},{"location":"NoncommutativeAlgebra/PBWAlgebras/intro/","page":"Introduction","title":"Introduction","text":"We refer to this representation as the standard representation of f, with coefficients c_alpha, and exponents alpha.","category":"page"},{"location":"NoncommutativeAlgebra/PBWAlgebras/intro/","page":"Introduction","title":"Introduction","text":"note: Note\nPBW-algebras are also known as G-algebras or algebras of solvable type. See Remark 1 in [LS03] for a brief historical account.","category":"page"},{"location":"NoncommutativeAlgebra/PBWAlgebras/intro/","page":"Introduction","title":"Introduction","text":"Proposition.   Let A be a PBW-algebra. Then:","category":"page"},{"location":"NoncommutativeAlgebra/PBWAlgebras/intro/","page":"Introduction","title":"Introduction","text":"A is an integral domain,\nA is (left and right) Noetherian.","category":"page"},{"location":"NoncommutativeAlgebra/PBWAlgebras/intro/","page":"Introduction","title":"Introduction","text":"Given any associative K-algebra A = (A + cdot), its opposite algebra is defined by setting A^textop = (A + ast), where fast g=gcdot f for all f gin A If","category":"page"},{"location":"NoncommutativeAlgebra/PBWAlgebras/intro/","page":"Introduction","title":"Introduction","text":"A = Klangle x_1 dots  x_n mid x_jx_i = c_ij x_ix_j+d_ij   1leq ij leq n rangle","category":"page"},{"location":"NoncommutativeAlgebra/PBWAlgebras/intro/","page":"Introduction","title":"Introduction","text":"is a PBW-algebra, then A^textop is again a PBW-algebra in a natural way. Indeed, consider the automorphism textop of Klangle x_1 dots  x_nrangle which sends a word x_i_1cdots x_i_r to the \"opposite word\" x^textop=x_i_rcdots x_i_1. Apply this automorphism to the relations of A to obtain the \"opposite relations\"","category":"page"},{"location":"NoncommutativeAlgebra/PBWAlgebras/intro/","page":"Introduction","title":"Introduction","text":"x_ix_j = c_ijx_jx_i+d_ij^textop","category":"page"},{"location":"NoncommutativeAlgebra/PBWAlgebras/intro/","page":"Introduction","title":"Introduction","text":"Also, if alpha=(alpha_1 ldots alpha_n)in mathbbN^n, then set alpha^textop =(alpha_n ldots alpha_1)in mathbbN^n, and if  is an admissible monomial ordering for A, then define the \"opposite ordering\" $ >^{\\text{op}}$ by setting","category":"page"},{"location":"NoncommutativeAlgebra/PBWAlgebras/intro/","page":"Introduction","title":"Introduction","text":"alpha ^textop  beta Leftrightarrow  alpha^textop  beta^textop","category":"page"},{"location":"NoncommutativeAlgebra/PBWAlgebras/intro/","page":"Introduction","title":"Introduction","text":"Finally, reverse the order of the variables: set x ^textop=x_n ldots x_1, and consider the free associative K-algebra K langle x^textoprangle = K langle x_ndots x_1 rangle Altogether, we obtain a PBW-algebra which can be naturally identified with A^textop:","category":"page"},{"location":"NoncommutativeAlgebra/PBWAlgebras/intro/","page":"Introduction","title":"Introduction","text":"A ^textop  = Klangle x_n dots  x_1 mid x_ix_j = c_ijx_jx_i+d_ij^textop   1leq ij leq n rangle","category":"page"},{"location":"NoncommutativeAlgebra/PBWAlgebras/intro/","page":"Introduction","title":"Introduction","text":"with admissible ordering ^textop.","category":"page"},{"location":"NoncommutativeAlgebra/PBWAlgebras/intro/","page":"Introduction","title":"Introduction","text":"When implementing functionality for PBW-algebras, taking the opposite algebra into account often allows one to focus on left ideals, left modules, and left Gröbner bases: Given a PBW-algebra A, right Gröbner bases in A are found by computing left Gröbner bases in A^textop. Here, Gröbner bases are considered with respect to an admissible ordering  for A and the opposite ordering ^textop for A^textop, respectively. Each left Gröbner basis of  a two-sided ideal I is also a right Gröbner basis of I. Moreover, there is an algorithm which, starting from a left Gröbner basis of I, computes a two-sided Gröbner basis of I (see, for example,  [DL06]). ","category":"page"},{"location":"PolyhedralGeometry/Polyhedra/auxiliary/","page":"Auxiliary functions","title":"Auxiliary functions","text":"CurrentModule = Oscar","category":"page"},{"location":"PolyhedralGeometry/Polyhedra/auxiliary/#Auxiliary-functions","page":"Auxiliary functions","title":"Auxiliary functions","text":"","category":"section"},{"location":"PolyhedralGeometry/Polyhedra/auxiliary/#Geometric-data","page":"Auxiliary functions","title":"Geometric data","text":"","category":"section"},{"location":"PolyhedralGeometry/Polyhedra/auxiliary/","page":"Auxiliary functions","title":"Auxiliary functions","text":"facets(P::Polyhedron)\nvertices(as::Type{PointVector{T}}, P::Polyhedron{T}) where {T<:scalar_types}\nrays(as::Type{RayVector{T}}, P::Polyhedron{T}) where {T<:scalar_types}\nrays_modulo_lineality(P::Polyhedron{T}) where T<:scalar_types\nminimal_faces(P::Polyhedron{T}) where T<:scalar_types\naffine_hull(P::Polyhedron{T}) where T<:scalar_types\nambient_dim(P::Polyhedron)\ndim(P::Polyhedron)\ncodim(P::Polyhedron)\nis_bounded(P::Polyhedron)\nis_feasible(P::Polyhedron)\nis_fulldimensional(P::Polyhedron)\nis_lattice_polytope(P::Polyhedron{QQFieldElem})\nlineality_dim(P::Polyhedron)\nlineality_space(P::Polyhedron{T}) where T<:scalar_types\nrecession_cone(P::Polyhedron{T}) where T<:scalar_types\nrelative_interior_point(P::Polyhedron{T}) where T<:scalar_types","category":"page"},{"location":"PolyhedralGeometry/Polyhedra/auxiliary/#facets-Tuple{Polyhedron}","page":"Auxiliary functions","title":"facets","text":"facets(as::Type{T} = AffineHalfspace, P::Polyhedron)\n\nReturn the facets of P in the format defined by as.\n\nThe allowed values for as are\n\nHalfspace (or its subtype AffineHalfspace),\nPolyhedron,\nPair.\n\nExamples\n\nWe can retrieve the six facets of the 3-dimensional cube this way:\n\njulia> C = cube(3);\n\njulia> facets(Polyhedron, C)\n6-element SubObjectIterator{Polyhedron{QQFieldElem}}:\n Polytope in ambient dimension 3\n Polytope in ambient dimension 3\n Polytope in ambient dimension 3\n Polytope in ambient dimension 3\n Polytope in ambient dimension 3\n Polytope in ambient dimension 3\n\njulia> facets(Halfspace, C)\n6-element SubObjectIterator{AffineHalfspace{QQFieldElem}} over the halfspaces of R^3 described by:\n-x_1 <= 1\nx_1 <= 1\n-x_2 <= 1\nx_2 <= 1\n-x_3 <= 1\nx_3 <= 1\n\n\n\n\n\nfacets(P::Polyhedron)\n\nReturn the facets of P as halfspaces.\n\nExamples\n\nWe can retrieve the six facets of the 3-dimensional cube this way:\n\njulia> C = cube(3);\n\njulia> facets(C)\n6-element SubObjectIterator{AffineHalfspace{QQFieldElem}} over the halfspaces of R^3 described by:\n-x_1 <= 1\nx_1 <= 1\n-x_2 <= 1\nx_2 <= 1\n-x_3 <= 1\nx_3 <= 1\n\n\n\n\n\n","category":"method"},{"location":"PolyhedralGeometry/Polyhedra/auxiliary/#vertices-Union{Tuple{T}, Tuple{Type{PointVector{T}}, Polyhedron{T}}} where T<:Union{Float64, FieldElem}","page":"Auxiliary functions","title":"vertices","text":"vertices([as::Type{T} = PointVector,] P::Polyhedron)\n\nReturn an iterator over the vertices of P in the format defined by as. The vertices are defined to be the zero-dimensional faces, so if P has lineality, there are no vertices, only minimal faces.\n\nSee also minimal_faces and rays.\n\nOptional arguments for as include\n\nPointVector.\n\nExamples\n\nThe following code computes the vertices of the Minkowski sum of a triangle and a square:\n\njulia> P = simplex(2) + cube(2);\n\njulia> vertices(PointVector, P)\n5-element SubObjectIterator{PointVector{QQFieldElem}}:\n [-1, -1]\n [2, -1]\n [2, 1]\n [-1, 2]\n [1, 2]\n\njulia> point_matrix(vertices(P))\n[-1   -1]\n[ 2   -1]\n[ 2    1]\n[-1    2]\n[ 1    2]\n\nA half-space (here in 3-space) has no vertices:\n\njulia> UH = polyhedron([-1 0 0], [0])\nPolyhedron in ambient dimension 3\n\njulia> vertices(UH)\n0-element SubObjectIterator{PointVector{QQFieldElem}}\n\n\n\n\n\n","category":"method"},{"location":"PolyhedralGeometry/Polyhedra/auxiliary/#rays-Union{Tuple{T}, Tuple{Type{RayVector{T}}, Polyhedron{T}}} where T<:Union{Float64, FieldElem}","page":"Auxiliary functions","title":"rays","text":"rays([as::Type{T} = RayVector,] P::Polyhedron)\n\nReturn a minimal set of generators of the cone of unbounded directions of P (i.e. its rays) in the format defined by as. The rays are defined to be the one-dimensional faces of the recession cone, so if P has lineality, there are no rays.\n\nSee also rays_modulo_lineality, recession_cone and vertices.\n\nOptional arguments for as include\n\nRayVector.\n\nExamples\n\nWe can verify that the positive orthant of the plane is generated by the two rays in positive unit direction:\n\njulia> PO = convex_hull([0 0], [1 0; 0 1]);\n\njulia> rays(RayVector, PO)\n2-element SubObjectIterator{RayVector{QQFieldElem}}:\n [1, 0]\n [0, 1]\n\njulia> rays(PO)\n2-element SubObjectIterator{RayVector{QQFieldElem}}:\n [1, 0]\n [0, 1]\n\njulia> matrix(QQ, rays(PO))\n[1   0]\n[0   1]\n\njulia> matrix(ZZ, rays(PO))\n[1   0]\n[0   1]\n\nA half-space has no rays:\n\njulia> UH = polyhedron([-1 0 0], [0])\nPolyhedron in ambient dimension 3\n\njulia> rays(UH)\n0-element SubObjectIterator{RayVector{QQFieldElem}}\n\n\n\n\n\n","category":"method"},{"location":"PolyhedralGeometry/Polyhedra/auxiliary/#rays_modulo_lineality-Union{Tuple{Polyhedron{T}}, Tuple{T}} where T<:Union{Float64, FieldElem}","page":"Auxiliary functions","title":"rays_modulo_lineality","text":"rays_modulo_lineality(as, P::Polyhedron)\n\nReturn the rays of the recession cone of P up to lineality as a NamedTuple with two iterators. If P has lineality L, then the iterator rays_modulo_lineality iterates over representatives of the rays of P/L. The iterator lineality_basis gives a basis of the lineality space L.\n\nSee also rays and lineality_space.\n\nExamples\n\njulia> P = convex_hull([0 0 1], [0 1 0], [1 0 0])\nPolyhedron in ambient dimension 3\n\njulia> rmlP = rays_modulo_lineality(P)\n(rays_modulo_lineality = RayVector{QQFieldElem}[[0, 1, 0]], lineality_basis = RayVector{QQFieldElem}[[1, 0, 0]])\n\njulia> rmlP.rays_modulo_lineality\n1-element SubObjectIterator{RayVector{QQFieldElem}}:\n [0, 1, 0]\n\njulia> rmlP.lineality_basis\n1-element SubObjectIterator{RayVector{QQFieldElem}}:\n [1, 0, 0]\n\n\n\n\n\n","category":"method"},{"location":"PolyhedralGeometry/Polyhedra/auxiliary/#minimal_faces-Union{Tuple{Polyhedron{T}}, Tuple{T}} where T<:Union{Float64, FieldElem}","page":"Auxiliary functions","title":"minimal_faces","text":"minimal_faces(as, P::Polyhedron)\n\nReturn the minimal faces of a polyhedron as a NamedTuple with two iterators. For a polyhedron without lineality, the base_points are the vertices. If P has lineality L, then every minimal face is an affine translation p+L, where p is only unique modulo L. The return type is a dict, the key :base_points gives an iterator over such p, and the key :lineality_basis lets one access a basis for the lineality space L of P.\n\nSee also vertices and lineality_space.\n\nExamples\n\nThe polyhedron P is just a line through the origin:\n\njulia> P = convex_hull([0 0], nothing, [1 0])\nPolyhedron in ambient dimension 2\n\njulia> lineality_dim(P)\n1\n\njulia> vertices(P)\n0-element SubObjectIterator{PointVector{QQFieldElem}}\n\njulia> minimal_faces(P)\n(base_points = PointVector{QQFieldElem}[[0, 0]], lineality_basis = RayVector{QQFieldElem}[[1, 0]])\n\n\n\n\n\n","category":"method"},{"location":"PolyhedralGeometry/Polyhedra/auxiliary/#affine_hull-Union{Tuple{Polyhedron{T}}, Tuple{T}} where T<:Union{Float64, FieldElem}","page":"Auxiliary functions","title":"affine_hull","text":"affine_hull(P::Polytope)\n\nReturn the (affine) hyperplanes generating the affine hull of P.\n\nExamples\n\nThis triangle in mathbbR^4 is contained in the plane defined by P =  (x_1 x_2 x_3 x_4)  x_3 = 2  x_4 = 5 .\n\njulia> t = convex_hull([0 0 2 5; 1 0 2 5; 0 1 2 5]);\n\njulia> affine_hull(t)\n2-element SubObjectIterator{AffineHyperplane{QQFieldElem}} over the hyperplanes of R^4 described by:\nx_3 = 2\nx_4 = 5\n\n\n\n\n\n","category":"method"},{"location":"PolyhedralGeometry/Polyhedra/auxiliary/#ambient_dim-Tuple{Polyhedron}","page":"Auxiliary functions","title":"ambient_dim","text":"ambient_dim(P::Polyhedron)\n\nReturn the ambient dimension of P.\n\nExamples\n\njulia> V = [1 2 3; 1 3 2; 2 1 3; 2 3 1; 3 1 2; 3 2 1];\n\njulia> P = convex_hull(V);\n\njulia> ambient_dim(P)\n3\n\n\n\n\n\n","category":"method"},{"location":"PolyhedralGeometry/Polyhedra/auxiliary/#dim-Tuple{Polyhedron}","page":"Auxiliary functions","title":"dim","text":"dim(P::Polyhedron)\n\nReturn the dimension of P.\n\nExamples\n\njulia> V = [1 2 3; 1 3 2; 2 1 3; 2 3 1; 3 1 2; 3 2 1];\n\njulia> P = convex_hull(V);\n\njulia> dim(P)\n2\n\n\n\n\n\n","category":"method"},{"location":"PolyhedralGeometry/Polyhedra/auxiliary/#codim-Tuple{Polyhedron}","page":"Auxiliary functions","title":"codim","text":"codim(P::Polyhedron)\n\nReturn the codimension of P.\n\nExamples\n\njulia> V = [1 2 3; 1 3 2; 2 1 3; 2 3 1; 3 1 2; 3 2 1];\n\njulia> P = convex_hull(V);\n\njulia> codim(P)\n1\n\n\n\n\n\n","category":"method"},{"location":"PolyhedralGeometry/Polyhedra/auxiliary/#is_bounded-Tuple{Polyhedron}","page":"Auxiliary functions","title":"is_bounded","text":"is_bounded(P::Polyhedron)\n\nCheck whether P is bounded.\n\nExamples\n\njulia> P = polyhedron([1 -3; -1 1; -1 0; 0 -1],[1,1,1,1]);\n\njulia> is_bounded(P)\nfalse\n\n\n\n\n\n","category":"method"},{"location":"PolyhedralGeometry/Polyhedra/auxiliary/#is_feasible-Tuple{Polyhedron}","page":"Auxiliary functions","title":"is_feasible","text":"is_feasible(P::Polyhedron)\n\nCheck whether P is feasible, i.e. non-empty.\n\nExamples\n\njulia> P = polyhedron([1 -1; -1 1; -1 0; 0 -1],[-1,-1,1,1]);\n\njulia> is_feasible(P)\nfalse\n\n\n\n\n\n","category":"method"},{"location":"PolyhedralGeometry/Polyhedra/auxiliary/#is_fulldimensional-Tuple{Polyhedron}","page":"Auxiliary functions","title":"is_fulldimensional","text":"is_fulldimensional(P::Polyhedron)\n\nCheck whether P is full-dimensional.\n\nExamples\n\njulia> V = [1 2 3; 1 3 2; 2 1 3; 2 3 1; 3 1 2; 3 2 1];\n\njulia> is_fulldimensional(convex_hull(V))\nfalse\n\n\n\n\n\n","category":"method"},{"location":"PolyhedralGeometry/Polyhedra/auxiliary/#is_lattice_polytope-Tuple{Polyhedron{QQFieldElem}}","page":"Auxiliary functions","title":"is_lattice_polytope","text":"is_lattice_polytope(P::Polyhedron{QQFieldElem})\n\nCheck whether P is a lattice polytope, i.e. it is bounded and has integral vertices.\n\nExamples\n\njulia> c = cube(3)\nPolytope in ambient dimension 3\n\njulia> is_lattice_polytope(c)\ntrue\n\njulia> c = cube(3, 0, 4//3)\nPolytope in ambient dimension 3\n\njulia> is_lattice_polytope(c)\nfalse\n\n\n\n\n\n","category":"method"},{"location":"PolyhedralGeometry/Polyhedra/auxiliary/#lineality_dim-Tuple{Polyhedron}","page":"Auxiliary functions","title":"lineality_dim","text":"lineality_dim(P::Polyhedron)\n\nReturn the dimension of the lineality space, i.e. the dimension of the largest affine subspace contained in P.\n\nExamples\n\nPolyhedron with one lineality direction.\n\njulia> C = convex_hull([0 0], [1 0], [1 1])\nPolyhedron in ambient dimension 2\n\njulia> lineality_dim(C)\n1\n\n\n\n\n\n","category":"method"},{"location":"PolyhedralGeometry/Polyhedra/auxiliary/#lineality_space-Union{Tuple{Polyhedron{T}}, Tuple{T}} where T<:Union{Float64, FieldElem}","page":"Auxiliary functions","title":"lineality_space","text":"lineality_space(P::Polyhedron)\n\nReturn a matrix whose row span is the lineality space of P.\n\nExamples\n\nDespite not being reflected in this construction of the upper half-plane, its lineality in x-direction is recognized:\n\njulia> UH = convex_hull([0 0],[0 1; 1 0; -1 0]);\n\njulia> lineality_space(UH)\n1-element SubObjectIterator{RayVector{QQFieldElem}}:\n [1, 0]\n\n\n\n\n\n","category":"method"},{"location":"PolyhedralGeometry/Polyhedra/auxiliary/#recession_cone-Union{Tuple{Polyhedron{T}}, Tuple{T}} where T<:Union{Float64, FieldElem}","page":"Auxiliary functions","title":"recession_cone","text":"recession_cone(P::Polyhedron)\n\nReturn the recession cone of P.\n\nExamples\n\njulia> P = polyhedron([1 -2; -1 1; -1 0; 0 -1],[2,1,1,1]);\n\njulia> vertices(P)\n3-element SubObjectIterator{PointVector{QQFieldElem}}:\n [0, -1]\n [-1, 0]\n [-1, -1]\n\njulia> recession_cone(P)\nPolyhedral cone in ambient dimension 2\n\njulia> rays(recession_cone(P))\n2-element SubObjectIterator{RayVector{QQFieldElem}}:\n [1, 1//2]\n [1, 1]\n\n\n\n\n\n","category":"method"},{"location":"PolyhedralGeometry/Polyhedra/auxiliary/#relative_interior_point-Union{Tuple{Polyhedron{T}}, Tuple{T}} where T<:Union{Float64, FieldElem}","page":"Auxiliary functions","title":"relative_interior_point","text":"relative_interior_point(P::Polyhedron)\n\nCompute a point in the relative interior point of P, i.e. a point in P not contained in any facet.\n\nExamples\n\nThe square -11^3 has the origin as a relative interior point.\n\njulia> square = cube(2)\nPolytope in ambient dimension 2\n\njulia> relative_interior_point(square)\n2-element PointVector{QQFieldElem}:\n 0\n 0\n\njulia> vertices(square)\n4-element SubObjectIterator{PointVector{QQFieldElem}}:\n [-1, -1]\n [1, -1]\n [-1, 1]\n [1, 1]\n\njulia> matrix(QQ, vertices(square))\n[-1   -1]\n[ 1   -1]\n[-1    1]\n[ 1    1]\n\n\n\n\n\n","category":"method"},{"location":"PolyhedralGeometry/Polyhedra/auxiliary/#Combinatorial-data","page":"Auxiliary functions","title":"Combinatorial data","text":"","category":"section"},{"location":"PolyhedralGeometry/Polyhedra/auxiliary/","page":"Auxiliary functions","title":"Auxiliary functions","text":"n_facets(P::Polyhedron)\nn_vertices(P::Polyhedron)\nf_vector(P::Polyhedron)\nfacet_sizes(P::Polyhedron)\ng_vector(P::Polyhedron)\nh_vector(P::Polyhedron)\nvertex_sizes(P::Polyhedron)","category":"page"},{"location":"PolyhedralGeometry/Polyhedra/auxiliary/#n_facets-Tuple{Polyhedron}","page":"Auxiliary functions","title":"n_facets","text":"n_facets(P::Polyhedron)\n\nReturn the number of facets of P.\n\nExamples\n\nThe number of facets of the 5-dimensional cross polytope can be retrieved via the following line:\n\njulia> n_facets(cross_polytope(5))\n32\n\n\n\n\n\n","category":"method"},{"location":"PolyhedralGeometry/Polyhedra/auxiliary/#n_vertices-Tuple{Polyhedron}","page":"Auxiliary functions","title":"n_vertices","text":"n_vertices(P::Polyhedron)\n\nReturn the number of vertices of P.\n\nExamples\n\nThe 3-cube's number of vertices can be obtained with this input:\n\njulia> C = cube(3);\n\njulia> n_vertices(C)\n8\n\n\n\n\n\n","category":"method"},{"location":"PolyhedralGeometry/Polyhedra/auxiliary/#f_vector-Tuple{Polyhedron}","page":"Auxiliary functions","title":"f_vector","text":"f_vector(P::Polyhedron)\n\nReturn the vector (f₀f₁f₂f_dim(P) - 1) where f_i is the number of faces of P of dimension i.\n\nExamples\n\nHere we compute the f-vector of the 5-cube:\n\njulia> f_vector(cube(5))\n5-element Vector{ZZRingElem}:\n 32\n 80\n 80\n 40\n 10\n\n\n\n\n\n","category":"method"},{"location":"PolyhedralGeometry/Polyhedra/auxiliary/#facet_sizes-Tuple{Polyhedron}","page":"Auxiliary functions","title":"facet_sizes","text":"facet_sizes(P::Polyhedron{T})\n\nNumber of vertices in each facet. \n\nExamples\n\njulia> p = johnson_solid(4) \nPolytope in ambient dimension 3 with EmbeddedAbsSimpleNumFieldElem type coefficients\n\njulia> facet_sizes(p)\n10-element Vector{Int64}:\n 8\n 4\n 3\n 4\n 4\n 3\n 4\n 3\n 3\n 4\n\n\n\n\n\n","category":"method"},{"location":"PolyhedralGeometry/Polyhedra/auxiliary/#g_vector-Tuple{Polyhedron}","page":"Auxiliary functions","title":"g_vector","text":"g_vector(P::Polyhedron)\n\nReturn the (toric) g-vector of a polytope. Defined by g_0 = 1 and g_k = h_k - h_k-1, for 1 leq k leq lceil (d+1)2rceil where h is the h-vector and d=dim(P). Undefined for unbounded polyhedra.\n\nExamples\n\njulia> g_vector(cross_polytope(3))\n2-element Vector{ZZRingElem}:\n 1\n 2\n\n\n\n\n\n","category":"method"},{"location":"PolyhedralGeometry/Polyhedra/auxiliary/#h_vector-Tuple{Polyhedron}","page":"Auxiliary functions","title":"h_vector","text":"h_vector(P::Polyhedron)\n\nReturn the (toric) h-vector of a polytope. For simplicial polytopes this is a linear transformation of the f-vector. Undefined for unbounded polyhedra.\n\nExamples\n\njulia> h_vector(cross_polytope(3))\n4-element Vector{ZZRingElem}:\n 1\n 3\n 3\n 1\n\n\n\n\n\n","category":"method"},{"location":"PolyhedralGeometry/Polyhedra/auxiliary/#vertex_sizes-Tuple{Polyhedron}","page":"Auxiliary functions","title":"vertex_sizes","text":"vertex_sizes(P::Polyhedron{T})\n\nNumber of incident facets for each vertex.\n\nExamples\n\njulia> vertex_sizes(bipyramid(simplex(2)))\n5-element Vector{Int64}:\n 4\n 4\n 4\n 3\n 3\n\n\n\n\n\n","category":"method"},{"location":"PolyhedralGeometry/Polyhedra/auxiliary/#Groups","page":"Auxiliary functions","title":"Groups","text":"","category":"section"},{"location":"PolyhedralGeometry/Polyhedra/auxiliary/","page":"Auxiliary functions","title":"Auxiliary functions","text":"linear_symmetries(P::Polyhedron)\ncombinatorial_symmetries(P::Polyhedron)\nautomorphism_group(P::Polyhedron)\nautomorphism_group_generators(P::Polyhedron)\nautomorphism_group(IM::IncidenceMatrix)\nautomorphism_group_generators(IM::IncidenceMatrix)","category":"page"},{"location":"PolyhedralGeometry/Polyhedra/auxiliary/#linear_symmetries-Tuple{Polyhedron}","page":"Auxiliary functions","title":"linear_symmetries","text":"linear_symmetries(P::Polyhedron)\n\nGet the group of linear symmetries on the vertices of a polyhedron. These are morphisms of the form xmapsto Ax+b,with A a matrix and b a vector, that preserve the polyhedron P. The result is given as permutations of the vertices (or rather vertex indices) of P.\n\nExamples\n\nThe 3-dimensional cube has 48 linear symmetries.\n\njulia> c = cube(3)\nPolytope in ambient dimension 3\n\njulia> G = linear_symmetries(c)\nPermutation group of degree 8\n\njulia> order(G)\n48\n\nThe quadrangle one obtains from moving one vertex of the square out along the diagonal has two linear symmetries.\n\njulia> quad = convex_hull([0 0; 1 0; 2 2; 0 1])\nPolyhedron in ambient dimension 2\n\njulia> G = linear_symmetries(quad)\nPermutation group of degree 4\n\njulia> order(G)\n2\n\n\n\n\n\n","category":"method"},{"location":"PolyhedralGeometry/Polyhedra/auxiliary/#combinatorial_symmetries-Tuple{Polyhedron}","page":"Auxiliary functions","title":"combinatorial_symmetries","text":"combinatorial_symmetries(P::Polyhedron)\n\nCompute the combinatorial symmetries (i.e., automorphisms of the face lattice) of a given polytope P.  The result is given as permutations of the vertices (or rather vertex indices) of P. This group contains the linear_symmetries as a subgroup.\n\nExamples\n\nThe quadrangle one obtains from moving one vertex of the square out along the diagonal has eight combinatorial symmetries, but only two linear symmetries.\n\njulia> quad = convex_hull([0 0; 1 0; 2 2; 0 1])\nPolyhedron in ambient dimension 2\n\njulia> G = combinatorial_symmetries(quad)\nPermutation group of degree 4\n\njulia> order(G)\n8\n\njulia> G = linear_symmetries(quad)\nPermutation group of degree 4\n\njulia> order(G)\n2\n\n\n\n\n\n","category":"method"},{"location":"PolyhedralGeometry/Polyhedra/auxiliary/#automorphism_group-Tuple{Polyhedron}","page":"Auxiliary functions","title":"automorphism_group","text":"automorphism_group(P::Polyhedron; type = :combinatorial, action = :all)\n\nCompute the group of automorphisms of a polyhedron. The parameters and return values are the same as for automorphism_group_generators(P::Polyhedron; type = :combinatorial, action = :all) except that groups are returned instead of generators of groups.\n\n\n\n\n\n","category":"method"},{"location":"PolyhedralGeometry/Polyhedra/auxiliary/#automorphism_group_generators-Tuple{Polyhedron}","page":"Auxiliary functions","title":"automorphism_group_generators","text":"automorphism_group_generators(P::Polyhedron; type = :combinatorial, action = :all)\n\nCompute generators of the group of automorphisms of a polyhedron.\n\nThe optional parameter type takes two values:\n\n:combinatorial (default) – Return the combinatorial symmetries, the   automorphisms of the face lattice.\n:linear – Return the linear automorphisms.\n\nThe optional parameter action takes three values:\n\n:all (default) – Return the generators of the permutation action on both   vertices and facets as a Dict{Symbol, Vector{PermGroupElem}}.\n:on_vertices – Only return generators of the permutation action on the   vertices.\n:on_facets – Only return generators of the permutation action on the   facets.\n\nThe return value is a Dict{Symbol, Vector{PermGroupElem}} with two entries, one for the key :on_vertices containing the generators for the action permuting the vertices, and :on_facets for the facets.\n\nExamples\n\nCompute the automorphisms of the 3dim cube:\n\njulia> c = cube(3)\nPolytope in ambient dimension 3\n\njulia> automorphism_group_generators(c)\nDict{Symbol, Vector{PermGroupElem}} with 2 entries:\n  :on_vertices => [(3,5)(4,6), (2,3)(6,7), (1,2)(3,4)(5,6)(7,8)]\n  :on_facets   => [(3,5)(4,6), (1,3)(2,4), (1,2)]\n\njulia> automorphism_group_generators(c; action = :on_vertices)\n3-element Vector{PermGroupElem}:\n (3,5)(4,6)\n (2,3)(6,7)\n (1,2)(3,4)(5,6)(7,8)\n\njulia> automorphism_group_generators(c; action = :on_facets)\n3-element Vector{PermGroupElem}:\n (3,5)(4,6)\n (1,3)(2,4)\n (1,2)\n\nCompute the automorphisms of a non-quadratic quadrangle. Since it has less symmetry than the square, it has less linear symmetries.\n\njulia> quad = convex_hull([0 0; 1 0; 2 2; 0 1])\nPolyhedron in ambient dimension 2\n\njulia> automorphism_group_generators(quad)\nDict{Symbol, Vector{PermGroupElem}} with 2 entries:\n  :on_vertices => [(2,4), (1,2)(3,4)]\n  :on_facets   => [(1,2)(3,4), (1,3)]\n\njulia> automorphism_group_generators(quad; type = :combinatorial)\nDict{Symbol, Vector{PermGroupElem}} with 2 entries:\n  :on_vertices => [(2,4), (1,2)(3,4)]\n  :on_facets   => [(1,2)(3,4), (1,3)]\n\njulia> automorphism_group_generators(quad; type = :linear)\nDict{Symbol, Vector{PermGroupElem}} with 2 entries:\n  :on_vertices => [(2,4)]\n  :on_facets   => [(1,2)(3,4)]\n\n\n\n\n\n","category":"method"},{"location":"PolyhedralGeometry/Polyhedra/auxiliary/#automorphism_group-Tuple{IncidenceMatrix}","page":"Auxiliary functions","title":"automorphism_group","text":"automorphism_group(IM::IncidenceMatrix; action = :all)\n\nCompute the group of automorphisms of an IncidenceMatrix. The parameters and return values are the same as for automorphism_group_generators(IM::IncidenceMatrix; action = :all) except that groups are returned instead of generators of groups.\n\n\n\n\n\n","category":"method"},{"location":"PolyhedralGeometry/Polyhedra/auxiliary/#automorphism_group_generators-Tuple{IncidenceMatrix}","page":"Auxiliary functions","title":"automorphism_group_generators","text":"automorphism_group_generators(IM::IncidenceMatrix; action = :all)\n\nCompute the generators of the group of automorphisms of an IncidenceMatrix. \n\nThe optional parameter action takes three values:\n\n:all (default) – Return the generators of the permutation action on both   columns and rows as a Dict{Symbol, Vector{PermGroupElem}}.\n:on_cols – Only return generators of the permutation action on the   columns.\n:on_rows – Only return generators of the permutation action on the   rows.\n\nExamples\n\nCompute the automorphisms of the incidence matrix of the 3dim cube:\n\njulia> c = cube(3)\nPolytope in ambient dimension 3\n\njulia> IM = vertex_indices(facets(c))\n6×8 IncidenceMatrix\n[1, 3, 5, 7]\n[2, 4, 6, 8]\n[1, 2, 5, 6]\n[3, 4, 7, 8]\n[1, 2, 3, 4]\n[5, 6, 7, 8]\n\n\njulia> automorphism_group_generators(IM)\nDict{Symbol, Vector{PermGroupElem}} with 2 entries:\n  :on_cols => [(3,5)(4,6), (2,3)(6,7), (1,2)(3,4)(5,6)(7,8)]\n  :on_rows => [(3,5)(4,6), (1,3)(2,4), (1,2)]\n\njulia> automorphism_group_generators(IM; action = :on_rows)\n3-element Vector{PermGroupElem}:\n (3,5)(4,6)\n (1,3)(2,4)\n (1,2)\n\njulia> automorphism_group_generators(IM; action = :on_cols)\n3-element Vector{PermGroupElem}:\n (3,5)(4,6)\n (2,3)(6,7)\n (1,2)(3,4)(5,6)(7,8)\n\n\n\n\n\n","category":"method"},{"location":"PolyhedralGeometry/Polyhedra/auxiliary/#Other","page":"Auxiliary functions","title":"Other","text":"","category":"section"},{"location":"PolyhedralGeometry/Polyhedra/auxiliary/","page":"Auxiliary functions","title":"Auxiliary functions","text":"all_triangulations\nboundary_lattice_points(P::Polyhedron{QQFieldElem})\nBase.in(v::AbstractVector, P::Polyhedron)\nBase.issubset(P::Polyhedron{T}, Q::Polyhedron{T}) where T<:scalar_types\nehrhart_polynomial(P::Polyhedron{QQFieldElem})\nehrhart_polynomial(R::QQPolyRing, P::Polyhedron{QQFieldElem})\nh_star_polynomial(P::Polyhedron{QQFieldElem})\nh_star_polynomial(R::QQPolyRing, P::Polyhedron{QQFieldElem})\ninterior_lattice_points(P::Polyhedron{QQFieldElem})\nis_normal(P::Polyhedron{QQFieldElem})\nis_simple(P::Polyhedron)\nis_smooth(P::Polyhedron{QQFieldElem})\nis_very_ample(P::Polyhedron{QQFieldElem})\nis_archimedean_solid(P::Polyhedron)\nis_johnson_solid(P::Polyhedron)\nis_platonic_solid(P::Polyhedron)\nlattice_points(P::Polyhedron{QQFieldElem})\nlattice_volume(P::Polyhedron{QQFieldElem})\nnormalized_volume(P::Polyhedron)\npolarize(P::Polyhedron{T}) where T<:scalar_types\nproject_full(P::Polyhedron{T}) where T<:scalar_types\nprint_constraints(io::IO, A::AnyVecOrMat, b::AbstractVector; trivial::Bool = false, numbered::Bool = false, cmp = :lte)\nprint_constraints(io::IO, P::Polyhedron; trivial::Bool = false, numbered::Bool = false)\nregular_triangulations\nregular_triangulation\nsecondary_polytope\nsolve_ineq(as::Type{T}, A::ZZMatrix, b::ZZMatrix) where {T}\nsolve_mixed(as::Type{T}, A::ZZMatrix, b::ZZMatrix, C::ZZMatrix, d::ZZMatrix) where {T}\nsolve_mixed(as::Type{T}, A::ZZMatrix, b::ZZMatrix, C::ZZMatrix) where {T}\nsolve_non_negative(as::Type{T}, A::ZZMatrix, b::ZZMatrix) where {T}\nsupport_function(P::Polyhedron{T}; convention::Symbol = :max) where T<:scalar_types\nvolume(P::Polyhedron{T}) where T<:scalar_types","category":"page"},{"location":"PolyhedralGeometry/Polyhedra/auxiliary/#all_triangulations","page":"Auxiliary functions","title":"all_triangulations","text":"all_triangulations(pts::AbstractCollection[PointVector]; full=false)\n\nCompute all triangulations on the points given as the rows of pts. Optionally select full=true to output full triangulations only, i.e. those that use all given points.\n\nThe return type is a Vector{Vector{Vector{Int}}} where each Vector{Vector{Int}} encodes a triangulation, in which a Vector{Int} encodes a simplex as the set of indices of the vertices of the simplex. I.e. the Vector{Int} [1,2,4] corresponds to the simplex that is the convex hull of the first, second, and fourth input point.\n\nExamples\n\njulia> c = cube(2,0,1)\nPolytope in ambient dimension 2\n\njulia> V = vertices(c)\n4-element SubObjectIterator{PointVector{QQFieldElem}}:\n [0, 0]\n [1, 0]\n [0, 1]\n [1, 1]\n\njulia> all_triangulations(V)\n2-element Vector{Vector{Vector{Int64}}}:\n [[1, 2, 3], [2, 3, 4]]\n [[1, 2, 4], [1, 3, 4]]\n\n\n\n\n\nall_triangulations(P::Polyhedron)\n\nCompute all triangulations that can be formed using the vertices of the given bounded and full-dimensional polytope P.\n\nThe return type is a Vector{Vector{Vector{Int}}} where each Vector{Vector{Int}} encodes a triangulation, in which a Vector{Int} encodes a simplex as the set of indices of the vertices of the simplex. I.e. the Vector{Int} [1,2,4] corresponds to the simplex that is the convex hull of the first, second, and fourth input point.\n\nExamples\n\njulia> c = cube(2,0,1)\nPolytope in ambient dimension 2\n\njulia> all_triangulations(c)\n2-element Vector{Vector{Vector{Int64}}}:\n [[1, 2, 3], [2, 3, 4]]\n [[1, 2, 4], [1, 3, 4]]\n\n\n\n\n\n","category":"function"},{"location":"PolyhedralGeometry/Polyhedra/auxiliary/#boundary_lattice_points-Tuple{Polyhedron{QQFieldElem}}","page":"Auxiliary functions","title":"boundary_lattice_points","text":"boundary_lattice_points(P::Polyhedron)\n\nReturn the integer points contained in the boundary of the bounded polyhedron P.\n\nExamples\n\njulia> c = polarize(cube(3))\nPolytope in ambient dimension 3\n\njulia> boundary_lattice_points(c)\n6-element SubObjectIterator{PointVector{ZZRingElem}}:\n [-1, 0, 0]\n [0, -1, 0]\n [0, 0, -1]\n [0, 0, 1]\n [0, 1, 0]\n [1, 0, 0]\n\njulia> matrix(ZZ, boundary_lattice_points(c))\n[-1    0    0]\n[ 0   -1    0]\n[ 0    0   -1]\n[ 0    0    1]\n[ 0    1    0]\n[ 1    0    0]\n\n\n\n\n\n","category":"method"},{"location":"PolyhedralGeometry/Polyhedra/auxiliary/#in-Tuple{AbstractVector, Polyhedron}","page":"Auxiliary functions","title":"in","text":"in(v::AbstractVector, P::Polyhedron)\n\nCheck whether the vector v is contained in the polyhedron P.\n\nExamples\n\nThe positive orthant only contains vectors with non-negative entries:\n\njulia> PO = polyhedron([-1 0; 0 -1], [0, 0]);\n\njulia> [1, 2] in PO\ntrue\n\njulia> [1, -2] in PO\nfalse\n\n\n\n\n\n","category":"method"},{"location":"PolyhedralGeometry/Polyhedra/auxiliary/#issubset-Union{Tuple{T}, Tuple{Polyhedron{T}, Polyhedron{T}}} where T<:Union{Float64, FieldElem}","page":"Auxiliary functions","title":"issubset","text":"issubset(P::Polyhedron, Q::Polyhedron)\n\nCheck whether P is a subset of the polyhedron Q.\n\nExamples\n\njulia> P = cube(3,0,1)\nPolytope in ambient dimension 3\n\njulia> Q = cube(3,-1,2)\nPolytope in ambient dimension 3\n\njulia> issubset(P, Q)\ntrue\n\njulia> issubset(Q, P)\nfalse\n\n\n\n\n\n","category":"method"},{"location":"PolyhedralGeometry/Polyhedra/auxiliary/#ehrhart_polynomial-Tuple{Polyhedron{QQFieldElem}}","page":"Auxiliary functions","title":"ehrhart_polynomial","text":"ehrhart_polynomial(P::Polyhedron{QQFieldElem})\n\nCompute the Ehrhart polynomial of P.\n\nExamples\n\njulia> c = cube(3)\nPolytope in ambient dimension 3\n\njulia> ehrhart_polynomial(c)\n8*x^3 + 12*x^2 + 6*x + 1\n\n\n\n\n\n","category":"method"},{"location":"PolyhedralGeometry/Polyhedra/auxiliary/#ehrhart_polynomial-Tuple{QQPolyRing, Polyhedron{QQFieldElem}}","page":"Auxiliary functions","title":"ehrhart_polynomial","text":"ehrhart_polynomial(R::QQMPolyRing, P::Polyhedron{QQFieldElem})\n\nCompute the Ehrhart polynomial of P and return it as a polynomial in R.\n\nExamples\n\njulia> R, x = polynomial_ring(QQ, :x)\n(Univariate polynomial ring in x over QQ, x)\n\njulia> c = cube(3)\nPolytope in ambient dimension 3\n\njulia> ehrhart_polynomial(R, c)\n8*x^3 + 12*x^2 + 6*x + 1\n\n\n\n\n\n","category":"method"},{"location":"PolyhedralGeometry/Polyhedra/auxiliary/#h_star_polynomial-Tuple{Polyhedron{QQFieldElem}}","page":"Auxiliary functions","title":"h_star_polynomial","text":"h_star_polynomial(P::Polyhedron)\n\nCompute the h^* polynomial of P.\n\nExamples\n\njulia> c = cube(3)\nPolytope in ambient dimension 3\n\njulia> h_star_polynomial(c)\nx^3 + 23*x^2 + 23*x + 1\n\n\n\n\n\n","category":"method"},{"location":"PolyhedralGeometry/Polyhedra/auxiliary/#h_star_polynomial-Tuple{QQPolyRing, Polyhedron{QQFieldElem}}","page":"Auxiliary functions","title":"h_star_polynomial","text":"h_star_polynomial(R::QQMPolyRing, P::Polyhedron)\n\nCompute the h^* polynomial of P and return it as a polynomial in R.\n\nExamples\n\njulia> R, x = polynomial_ring(QQ, :x)\n(Univariate polynomial ring in x over QQ, x)\n\njulia> c = cube(3)\nPolytope in ambient dimension 3\n\njulia> h_star_polynomial(R, c)\nx^3 + 23*x^2 + 23*x + 1\n\n\n\n\n\n","category":"method"},{"location":"PolyhedralGeometry/Polyhedra/auxiliary/#interior_lattice_points-Tuple{Polyhedron{QQFieldElem}}","page":"Auxiliary functions","title":"interior_lattice_points","text":"interior_lattice_points(P::Polyhedron)\n\nReturn the integer points contained in the interior of the bounded polyhedron P.\n\nExamples\n\njulia> c = cube(3)\nPolytope in ambient dimension 3\n\njulia> interior_lattice_points(c)\n1-element SubObjectIterator{PointVector{ZZRingElem}}:\n [0, 0, 0]\n\njulia> matrix(ZZ, interior_lattice_points(c))\n[0   0   0]\n\n\n\n\n\n","category":"method"},{"location":"PolyhedralGeometry/Polyhedra/auxiliary/#is_normal-Tuple{Polyhedron{QQFieldElem}}","page":"Auxiliary functions","title":"is_normal","text":"is_normal(P::Polyhedron{QQFieldElem})\n\nCheck whether P is normal.\n\nExamples\n\nThe 3-cube is normal.\n\njulia> C = cube(3)\nPolytope in ambient dimension 3\n\njulia> is_normal(C)\ntrue\n\nBut this pyramid is not:\n\njulia> P = convex_hull([0 0 0; 0 1 1; 1 1 0; 1 0 1]);\n\njulia> is_normal(P)\nfalse\n\n\n\n\n\n","category":"method"},{"location":"PolyhedralGeometry/Polyhedra/auxiliary/#is_simple-Tuple{Polyhedron}","page":"Auxiliary functions","title":"is_simple","text":"is_simple(P::Polyhedron)\n\nCheck whether P is simple.\n\nExamples\n\njulia> c = cube(2,0,1)\nPolytope in ambient dimension 2\n\njulia> is_simple(c)\ntrue\n\n\n\n\n\n","category":"method"},{"location":"PolyhedralGeometry/Polyhedra/auxiliary/#is_smooth-Tuple{Polyhedron{QQFieldElem}}","page":"Auxiliary functions","title":"is_smooth","text":"is_smooth(P::Polyhedron{QQFieldElem})\n\nCheck whether P is smooth.\n\nExamples\n\nA cube is always smooth.\n\njulia> C = cube(8);\n\njulia> is_smooth(C)\ntrue\n\n\n\n\n\n","category":"method"},{"location":"PolyhedralGeometry/Polyhedra/auxiliary/#is_very_ample-Tuple{Polyhedron{QQFieldElem}}","page":"Auxiliary functions","title":"is_very_ample","text":"is_very_ample(P::Polyhedron{QQFieldElem})\n\nCheck whether P is very ample.\n\nExamples\n\njulia> c = cube(3)\nPolytope in ambient dimension 3\n\njulia> is_very_ample(c)\ntrue\n\njulia> P = convex_hull([0 0 0; 1 1 0; 1 0 1; 0 1 1])\nPolyhedron in ambient dimension 3\n\njulia> is_very_ample(P)\nfalse\n\n\n\n\n\n","category":"method"},{"location":"PolyhedralGeometry/Polyhedra/auxiliary/#is_archimedean_solid-Tuple{Polyhedron}","page":"Auxiliary functions","title":"is_archimedean_solid","text":"is_archimedean_solid(P::Polyhedron)\n\nCheck whether P is an Archimedean solid, i.e., a 3-dimensional vertex transitive polytope with regular facets, but not a prism or antiprism.\n\nSee also archimedean_solid.\n\nnote: Note\nThis will only recognize algebraically precise solids, i.e. no solids with approximate coordinates.\n\nExamples\n\njulia> TO = archimedean_solid(\"truncated_octahedron\")\nPolytope in ambient dimension 3\n\njulia> is_archimedean_solid(TO)\ntrue\n\njulia> T = tetrahedron()\nPolytope in ambient dimension 3\n\njulia> is_archimedean_solid(T)\nfalse\n\n\n\n\n\n","category":"method"},{"location":"PolyhedralGeometry/Polyhedra/auxiliary/#is_johnson_solid-Tuple{Polyhedron}","page":"Auxiliary functions","title":"is_johnson_solid","text":"is_johnson_solid(P::Polyhedron)\n\nCheck whether P is a Johnson solid, i.e., a 3-dimensional polytope with regular faces that is not vertex transitive.\n\nSee also johnson_solid.\n\nnote: Note\nThis will only recognize algebraically precise solids, i.e. no solids with approximate coordinates.\n\nExamples\n\njulia> J = johnson_solid(37)\nPolytope in ambient dimension 3 with EmbeddedAbsSimpleNumFieldElem type coefficients\n\njulia> is_johnson_solid(J)\ntrue\n\n\n\n\n\n","category":"method"},{"location":"PolyhedralGeometry/Polyhedra/auxiliary/#is_platonic_solid-Tuple{Polyhedron}","page":"Auxiliary functions","title":"is_platonic_solid","text":"is_platonic_solid(P::Polyhedron)\n\nCheck whether P is a Platonic solid.\n\nSee also platonic_solid.\n\nnote: Note\nThis will only recognize algebraically precise solids, i.e. no solids with approximate coordinates.\n\nExamples\n\njulia> is_platonic_solid(cube(3))\ntrue\n\n\n\n\n\n","category":"method"},{"location":"PolyhedralGeometry/Polyhedra/auxiliary/#lattice_points-Tuple{Polyhedron{QQFieldElem}}","page":"Auxiliary functions","title":"lattice_points","text":"lattice_points(P::Polyhedron)\n\nReturn the integer points contained in the bounded polyhedron P.\n\nExamples\n\njulia> S = 2 * simplex(2);\n\njulia> lattice_points(S)\n6-element SubObjectIterator{PointVector{ZZRingElem}}:\n [0, 0]\n [0, 1]\n [0, 2]\n [1, 0]\n [1, 1]\n [2, 0]\n\njulia> matrix(ZZ, lattice_points(S))\n[0   0]\n[0   1]\n[0   2]\n[1   0]\n[1   1]\n[2   0]\n\n\n\n\n\n","category":"method"},{"location":"PolyhedralGeometry/Polyhedra/auxiliary/#lattice_volume-Tuple{Polyhedron{QQFieldElem}}","page":"Auxiliary functions","title":"lattice_volume","text":"lattice_volume(P::Polyhedron{QQFieldElem})\n\nReturn the lattice volume of P.\n\nExamples\n\njulia> C = cube(2);\n\njulia> lattice_volume(C)\n8\n\n\n\n\n\n","category":"method"},{"location":"PolyhedralGeometry/Polyhedra/auxiliary/#normalized_volume-Tuple{Polyhedron}","page":"Auxiliary functions","title":"normalized_volume","text":"normalized_volume(P::Polyhedron)\n\nReturn the (normalized) volume of P.\n\nExamples\n\njulia> C = cube(2);\n\njulia> normalized_volume(C)\n8\n\n\n\n\n\n","category":"method"},{"location":"PolyhedralGeometry/Polyhedra/auxiliary/#polarize-Union{Tuple{Polyhedron{T}}, Tuple{T}} where T<:Union{Float64, FieldElem}","page":"Auxiliary functions","title":"polarize","text":"polarize(P::Polyhedron)\n\nReturn the polar dual of the polyhedron P, consisting of all linear functions whose evaluation on P does not exceed 1.\n\nExamples\n\njulia> square = cube(2)\nPolytope in ambient dimension 2\n\njulia> P = polarize(square)\nPolytope in ambient dimension 2\n\njulia> vertices(P)\n4-element SubObjectIterator{PointVector{QQFieldElem}}:\n [1, 0]\n [-1, 0]\n [0, 1]\n [0, -1]\n\n\n\n\n\n","category":"method"},{"location":"PolyhedralGeometry/Polyhedra/auxiliary/#project_full-Union{Tuple{Polyhedron{T}}, Tuple{T}} where T<:Union{Float64, FieldElem}","page":"Auxiliary functions","title":"project_full","text":"project_full(P::Polyhedron)\n\nProject the polyhedron down such that it becomes full dimensional in the new ambient space.\n\nExamples\n\njulia> P = convex_hull([1 0 0; 0 0 0])\nPolyhedron in ambient dimension 3\n\njulia> is_fulldimensional(P)\nfalse\n\njulia> p = project_full(P)\nPolyhedron in ambient dimension 1\n\njulia> is_fulldimensional(p)\ntrue\n\n\n\n\n\n","category":"method"},{"location":"PolyhedralGeometry/Polyhedra/auxiliary/#print_constraints-Tuple{IO, Union{MatElem, AbstractVecOrMat}, AbstractVector}","page":"Auxiliary functions","title":"print_constraints","text":"print_constraints([io = stdout,] A::AnyVecOrMat, b::AbstractVector; trivial = false, numbered = false, cmp = :lte)\n\nPretty print the constraints given by P(Ab) =  x   Ax  b .\n\nOptional & Keyword Arguments\n\nio::IO: Target IO where the  constraints are printed to.\ntrivial::Bool: If true, include trivial inequalities.\nnumbered::Bool: If true, the each constraint is printed with the index corresponding to the input AnyVecOrMat.\ncmp::Symbol: Defines the string used for the comparison sign; supports :lte (less than or equal) and :eq (equal).\n\nTrivial inequalities are always counted for numbering, even when omitted.\n\nExamples\n\njulia> print_constraints([-1 0 4 5; 4 4 4 3; 1 0 0 0; 0 0 0 0; 0 0 0 0; 9 9 9 9], [0, 1, 2, 3, -4, 5]; numbered = true)\n1: -x_1 + 4*x_3 + 5*x_4 <= 0\n2: 4*x_1 + 4*x_2 + 4*x_3 + 3*x_4 <= 1\n3: x_1 <= 2\n5: 0 <= -4\n6: 9*x_1 + 9*x_2 + 9*x_3 + 9*x_4 <= 5\n\njulia> print_constraints([-1 0 4 5; 4 4 4 3; 1 0 0 0; 0 0 0 0; 0 0 0 0; 9 9 9 9], [0, 1, 2, 3, -4, 5]; trivial = true)\n-x_1 + 4*x_3 + 5*x_4 <= 0\n4*x_1 + 4*x_2 + 4*x_3 + 3*x_4 <= 1\nx_1 <= 2\n0 <= 3\n0 <= -4\n9*x_1 + 9*x_2 + 9*x_3 + 9*x_4 <= 5\n\n\n\n\n\n","category":"method"},{"location":"PolyhedralGeometry/Polyhedra/auxiliary/#print_constraints-Tuple{IO, Polyhedron}","page":"Auxiliary functions","title":"print_constraints","text":"print_constraints([io = stdout,] P::Polyhedron; trivial = false, numbered = false)\n\nPretty print the constraints given by P(Ab) =  x   Ax  b .\n\nOptional & Keyword Arguments\n\nio::IO: Target IO where the  constraints are printed to.\ntrivial::Bool: If true, include trivial inequalities.\nnumbered::Bool: If true, the each constraint is printed with the index corresponding to the input AnyVecOrMat.\n\nTrivial inequalities are always counted for numbering, even when omitted.\n\nExamples\n\nThe 3-cube is given by -1  x_i  1  i  1 2 3.\n\njulia> print_constraints(cube(3))\n-x_1 <= 1\nx_1 <= 1\n-x_2 <= 1\nx_2 <= 1\n-x_3 <= 1\nx_3 <= 1\n\n\n\n\n\n","category":"method"},{"location":"PolyhedralGeometry/Polyhedra/auxiliary/#regular_triangulations","page":"Auxiliary functions","title":"regular_triangulations","text":"regular_triangulations(pts::AbstractCollection[PointVector]; full=false)\n\nCompute all regular triangulations on the points given as the rows of pts.\n\nA triangulation is regular if it can be induced by weights, i.e. attach a weight to every point, take the convex hull of these new vectors and then take the subdivision corresponding to the facets visible from below (lower envelope). Optionally specify full, i.e. that every triangulation must use all points.\n\nThe return type is a Vector{Vector{Vector{Int}}} where each Vector{Vector{Int}} encodes a triangulation, in which a Vector{Int} encodes a simplex as the set of indices of the vertices of the simplex. I.e. the Vector{Int} [1,2,4] corresponds to the simplex that is the convex hull of the first, second, and fourth input point.\n\nExamples\n\njulia> c = cube(2,0,1)\nPolytope in ambient dimension 2\n\njulia> V = vertices(c)\n4-element SubObjectIterator{PointVector{QQFieldElem}}:\n [0, 0]\n [1, 0]\n [0, 1]\n [1, 1]\n\njulia> regular_triangulations(V)\n2-element Vector{Vector{Vector{Int64}}}:\n [[1, 2, 3], [2, 3, 4]]\n [[1, 2, 4], [1, 3, 4]]\n\n\n\n\n\nregular_triangulations(P::Polyhedron)\n\nCompute all regular triangulations that can be formed using the vertices of the given bounded and full-dimensional polytope P.\n\nA triangulation is regular if it can be induced by weights, i.e. attach a weight to every point, take the convex hull of these new vectors and then take the subdivision corresponding to the facets visible from below (lower envelope).\n\nThe return type is a Vector{Vector{Vector{Int}}} where each Vector{Vector{Int}} encodes a triangulation, in which a Vector{Int} encodes a simplex as the set of indices of the vertices of the simplex. I.e. the Vector{Int} [1,2,4] corresponds to the simplex that is the convex hull of the first, second, and fourth input point.\n\nExamples\n\njulia> c = cube(2,0,1)\nPolytope in ambient dimension 2\n\njulia> regular_triangulations(c)\n2-element Vector{Vector{Vector{Int64}}}:\n [[1, 2, 3], [2, 3, 4]]\n [[1, 2, 4], [1, 3, 4]]\n\n\n\n\n\n","category":"function"},{"location":"PolyhedralGeometry/Polyhedra/auxiliary/#regular_triangulation","page":"Auxiliary functions","title":"regular_triangulation","text":"regular_triangulation(pts::AbstractCollection[PointVector]; full=false)\n\nComputes ONE regular triangulations on the points given as the rows of pts.\n\nA triangulation is regular if it can be induced by weights, i.e. attach a weight to every point, take the convex hull of these new vectors and then take the subdivision corresponding to the facets visible from below (lower envelope). Optionally specify full, i.e. that every triangulation must use all points.\n\nAs for regular_triangulation(pts::AnyVecOrMat; full=false) the return type is Vector{Vector{Vector{Int}}}. Here, only one triangulation is computed, so the outer vector is of length one. Its entry of type Vector{Vector{Int}} encodes the triangulation in question. Recall that a Vector{Int} encodes a simplex as the set of indices of the vertices of the simplex. I.e. the Vector{Int} [1,2,4] corresponds to the simplex that is the convex hull of the first, second, and fourth input point.\n\nExamples\n\njulia> c = cube(2,0,1)\nPolytope in ambient dimension 2\n\njulia> V = vertices(c)\n4-element SubObjectIterator{PointVector{QQFieldElem}}:\n [0, 0]\n [1, 0]\n [0, 1]\n [1, 1]\n\njulia> regular_triangulation(V)\n1-element Vector{Vector{Vector{Int64}}}:\n [[1, 2, 3], [2, 3, 4]]\n\n\n\n\n\nregular_triangulation(P::Polyhedron)\n\nComputes ONE regular triangulations that can be formed using the vertices of the given bounded and full-dimensional polytope P.\n\nA triangulation is regular if it can be induced by weights, i.e. attach a weight to every point, take the convex hull of these new vectors and then take the subdivision corresponding to the facets visible from below (lower envelope).\n\nAs for regular_triangulations(P::Polyhedron) the return type is Vector{Vector{Vector{Int}}}. Here, only one triangulation is computed, so the outer vector is of length one. Its entry of type Vector{Vector{Int}} encodes the triangulation in question. Recall that a Vector{Int} encodes a simplex as the set of indices of the vertices of the simplex. I.e. the Vector{Int} [1,2,4] corresponds to the simplex that is the convex hull of the first, second, and fourth input point.\n\nExamples\n\njulia> c = cube(2,0,1)\nPolytope in ambient dimension 2\n\njulia> regular_triangulation(c)\n1-element Vector{Vector{Vector{Int64}}}:\n [[1, 2, 3], [2, 3, 4]]\n\n\n\n\n\n","category":"function"},{"location":"PolyhedralGeometry/Polyhedra/auxiliary/#secondary_polytope","page":"Auxiliary functions","title":"secondary_polytope","text":"secondary_polytope(P::Polyhedron)\n\nCompute the secondary polytope of a polyhedron, i.e. the convex hull of all the gkz vectors of all its (regular) triangulations. A triangulation here means only using the vertices of P.\n\nExamples\n\nCompute the secondary polytope of the cube.\n\njulia> c = cube(3)\nPolytope in ambient dimension 3\n\njulia> sc = secondary_polytope(c)\nPolytope in ambient dimension 8\n\n\n\n\n\n","category":"function"},{"location":"PolyhedralGeometry/Polyhedra/auxiliary/#solve_ineq-Union{Tuple{T}, Tuple{Type{T}, ZZMatrix, ZZMatrix}} where T","page":"Auxiliary functions","title":"solve_ineq","text":"solve_ineq(as::Type{T}, A::ZZMatrix, b::ZZMatrix) where {T}\n\nSolve Ax=b, assumes finite set of solutions.\n\nThe output type may be specified in the variable as:\n\nZZMatrix (default) a matrix with integers is returned.\nSubObjectIterator{PointVector{ZZRingElem}} an iterator over integer points is returned.\n\nExamples\n\nThe following gives the vertices of the square. The solutions are the rows of the output. Note that the output can be permuted, hence we sort it.\n\njulia> A = ZZMatrix([1 0; 0 1; -1 0; 0 -1]);\n\njulia> b = zero_matrix(ZZ, 4,1); b[1,1]=1; b[2,1]=1; b[3,1]=0; b[4,1]=0;\n\njulia> sortslices(Matrix{BigInt}(solve_ineq(A, b)), dims=1)\n4×2 Matrix{BigInt}:\n 0  0\n 0  1\n 1  0\n 1  1\n\njulia> typeof(solve_ineq(A,b))\nZZMatrix\n\njulia> typeof(solve_ineq(ZZMatrix, A,b))\nZZMatrix\n\njulia> typeof(solve_ineq(SubObjectIterator{PointVector{ZZRingElem}}, A,b))\nSubObjectIterator{PointVector{ZZRingElem}}\n\n\n\n\n\n","category":"method"},{"location":"PolyhedralGeometry/Polyhedra/auxiliary/#solve_mixed-Union{Tuple{T}, Tuple{Type{T}, Vararg{ZZMatrix, 4}}} where T","page":"Auxiliary functions","title":"solve_mixed","text":"solve_mixed(as::Type{T}, A::ZZMatrix, b::ZZMatrix, C::ZZMatrix, d::ZZMatrix) where {T}\n\nSolve Ax = b under Cx = d, assumes a finite solution set.\n\nThe output type may be specified in the variable as:\n\nZZMatrix (default) a matrix with integers is returned. The solutions are the (transposed) rows of the output.\nSubObjectIterator{PointVector{ZZRingElem}} an iterator over integer points is returned.\n\nExamples\n\nFind all (x_1 x_2)inmathbbZ^2 such that x_1+x_2=7, x_1ge 2, and x_2ge 3. Note that the output can be permuted, hence we sort it.\n\njulia> A = ZZMatrix([1 1]);\n\njulia> b = zero_matrix(ZZ, 1,1); b[1,1]=7;\n\njulia> C = ZZMatrix([1 0; 0 1]);\n\njulia> d = zero_matrix(ZZ,2,1); d[1,1]=2; d[2,1]=3;\n\njulia> sortslices(Matrix{BigInt}(solve_mixed(A, b, C, d)), dims=1)\n3×2 Matrix{BigInt}:\n 2  5\n 3  4\n 4  3\n\njulia> typeof(solve_mixed(A, b, C, d))\nZZMatrix\n\njulia> typeof(solve_mixed(ZZMatrix, A, b, C, d))\nZZMatrix\n\njulia> it = solve_mixed(SubObjectIterator{PointVector{ZZRingElem}}, A, b, C);\n\njulia> typeof(it)\nSubObjectIterator{PointVector{ZZRingElem}}\n\njulia> for x in it\n       print(A*x,\" \")\n       end\n[7] [7] [7] [7] [7] [7] [7] [7] \n\n\n\n\n\n","category":"method"},{"location":"PolyhedralGeometry/Polyhedra/auxiliary/#solve_mixed-Union{Tuple{T}, Tuple{Type{T}, ZZMatrix, ZZMatrix, ZZMatrix}} where T","page":"Auxiliary functions","title":"solve_mixed","text":"solve_mixed(as::Type{T}, A::ZZMatrix, b::ZZMatrix, C::ZZMatrix) where {T}\n\nSolve Ax = b under Cx = 0, assumes a finite solution set.\n\nThe output type may be specified in the variable as:\n\nZZMatrix (default) a matrix with integers is returned. The solutions are the (transposed) rows of the output.\nSubObjectIterator{PointVector{ZZRingElem}} an iterator over integer points is returned.\n\nExamples\n\nFind all (x_1 x_2)inmathbbZ^2_ge 0 such that x_1+x_2=3. Note that the output can be permuted, hence we sort it.\n\njulia> A = ZZMatrix([1 1]);\n\njulia> b = zero_matrix(ZZ, 1,1); b[1,1]=3;\n\njulia> C = ZZMatrix([1 0; 0 1]);\n\njulia> sortslices(Matrix{BigInt}(solve_mixed(A, b, C)), dims=1)\n4×2 Matrix{BigInt}:\n 0  3\n 1  2\n 2  1\n 3  0\n\njulia> typeof(solve_mixed(A, b, C))\nZZMatrix\n\njulia> typeof(solve_mixed(ZZMatrix, A, b, C))\nZZMatrix\n\njulia> it = solve_mixed(SubObjectIterator{PointVector{ZZRingElem}}, A, b, C);\n\njulia> typeof(it)\nSubObjectIterator{PointVector{ZZRingElem}}\n\njulia> for x in it\n       print(A*x,\" \")\n       end\n[3] [3] [3] [3] \n\n\n\n\n\n","category":"method"},{"location":"PolyhedralGeometry/Polyhedra/auxiliary/#solve_non_negative-Union{Tuple{T}, Tuple{Type{T}, ZZMatrix, ZZMatrix}} where T","page":"Auxiliary functions","title":"solve_non_negative","text":"solve_non_negative(as::Type{T}, A::ZZMatrix, b::ZZMatrix) where {T}\n\nFind all solutions to Ax = b, x=0. Assumes a finite set of solutions.\n\nThe output type may be specified in the variable as:\n\nZZMatrix (default) a matrix with integers is returned.\nSubObjectIterator{PointVector{ZZRingElem}} an iterator over integer points is returned.\n\nExamples\n\nFind all (x_1 x_2)inmathbbZ^2_ge 0 such that x_1+x_2=3. The solutions are the rows of the output. Note that the output can be permuted, hence we sort it.\n\njulia> A = ZZMatrix([1 1]);\n\njulia> b = zero_matrix(ZZ, 1,1); b[1,1]=3;\n\njulia> sortslices(Matrix{BigInt}(solve_non_negative(A, b)), dims=1)\n4×2 Matrix{BigInt}:\n 0  3\n 1  2\n 2  1\n 3  0\n\njulia> typeof(solve_non_negative(A,b))\nZZMatrix\n\njulia> typeof(solve_non_negative(ZZMatrix, A,b))\nZZMatrix\n\njulia> typeof(solve_non_negative(SubObjectIterator{PointVector{ZZRingElem}}, A,b))\nSubObjectIterator{PointVector{ZZRingElem}}\n\n\n\n\n\n","category":"method"},{"location":"PolyhedralGeometry/Polyhedra/auxiliary/#support_function-Union{Tuple{Polyhedron{T}}, Tuple{T}} where T<:Union{Float64, FieldElem}","page":"Auxiliary functions","title":"support_function","text":"support_function(P::Polyhedron; convention::Symbol = :max)\n\nProduce a function h(ω) = maxdot(xω)  x in P. max may be changed to min by setting convention = :min.\n\nExamples\n\njulia> P = cube(3) + simplex(3);\n\njulia> φ = support_function(P);\n\njulia> φ([1,2,3])\n9\n\njulia> ψ = support_function(P, convention = :min);\n\njulia> ψ([1,2,3])\n-6\n\n\n\n\n\n","category":"method"},{"location":"PolyhedralGeometry/Polyhedra/auxiliary/#volume-Union{Tuple{Polyhedron{T}}, Tuple{T}} where T<:Union{Float64, FieldElem}","page":"Auxiliary functions","title":"volume","text":"volume(P::Polyhedron)\n\nReturn the (Euclidean) volume of P.\n\nExamples\n\njulia> C = cube(2);\n\njulia> volume(C)\n4\n\n\n\n\n\n","category":"method"},{"location":"NumberTheory/abelian_closure/","page":"Abelian closure of the rationals","title":"Abelian closure of the rationals","text":"CurrentModule = Oscar","category":"page"},{"location":"NumberTheory/abelian_closure/#Abelian-closure-of-the-rationals","page":"Abelian closure of the rationals","title":"Abelian closure of the rationals","text":"","category":"section"},{"location":"NumberTheory/abelian_closure/","page":"Abelian closure of the rationals","title":"Abelian closure of the rationals","text":"The abelian closure mathbfQ^textab is the maximal abelian extension of mathbfQ inside a fixed algebraic closure and can explicitly described as","category":"page"},{"location":"NumberTheory/abelian_closure/","page":"Abelian closure of the rationals","title":"Abelian closure of the rationals","text":"mathbfQ^mathrmab = mathbfQ(zeta_n mid n in mathbfN)","category":"page"},{"location":"NumberTheory/abelian_closure/","page":"Abelian closure of the rationals","title":"Abelian closure of the rationals","text":"the union of all cyclotomic extensions. Here for n in mathbfN we denote by zeta_n a primitive n-th root of unity.","category":"page"},{"location":"NumberTheory/abelian_closure/#Creation-of-the-abelian-closure-and-elements","page":"Abelian closure of the rationals","title":"Creation of the abelian closure and elements","text":"","category":"section"},{"location":"NumberTheory/abelian_closure/","page":"Abelian closure of the rationals","title":"Abelian closure of the rationals","text":"abelian_closure(::QQField)","category":"page"},{"location":"NumberTheory/abelian_closure/#abelian_closure-Tuple{QQField}","page":"Abelian closure of the rationals","title":"abelian_closure","text":"abelian_closure(QQ::QQField; sparse::Bool = false)\n\nReturn a pair (K, z) consisting of the abelian closure K of the rationals and a generator z that can be used to construct primitive roots of unity in K.\n\nAn optional keyword argument sparse can be set to true to switch to a  sparse representation. Depending on the application this can be much faster or slower.\n\nExamples\n\njulia> K, z = abelian_closure(QQ);\n\njulia> z(36)\nzeta(36)\n\njulia> K, z = abelian_closure(QQ, sparse = true);\n\njulia> z(36)\n-zeta(36, 9)*zeta(36, 4)^4 - zeta(36, 9)*zeta(36, 4)\n\n\n\n\n\n\n","category":"method"},{"location":"NumberTheory/abelian_closure/","page":"Abelian closure of the rationals","title":"Abelian closure of the rationals","text":"Given the abelian closure, the generator can be recovered as follows:","category":"page"},{"location":"NumberTheory/abelian_closure/","page":"Abelian closure of the rationals","title":"Abelian closure of the rationals","text":"gen(::QQAbField{AbsSimpleNumField})\natlas_irrationality\natlas_description","category":"page"},{"location":"NumberTheory/abelian_closure/#gen-Tuple{QQAbField{AbsSimpleNumField}}","page":"Abelian closure of the rationals","title":"gen","text":"gen(K::QQAbField)\n\nReturn the generator of the abelian closure K that can be used to construct primitive roots of unity.\n\n\n\n\n\n","category":"method"},{"location":"NumberTheory/abelian_closure/#atlas_irrationality","page":"Abelian closure of the rationals","title":"atlas_irrationality","text":"atlas_irrationality([F::AbsSimpleNumField, ]description::String)\n\nReturn the value encoded by description. If F is given and is a cyclotomic field that contains the value then the result is in F, if F is not given then the result has type QQAbFieldElem.\n\ndescription is assumed to have the format defined in [CCNPW85], Chapter 6, Section 10.\n\nExamples\n\njulia> Oscar.with_unicode() do\n         show(atlas_irrationality(\"r5\"))\n       end;\n-2*ζ(5)^3 - 2*ζ(5)^2 - 1\n\njulia> atlas_irrationality(cyclotomic_field(5)[1], \"r5\")\n-2*z_5^3 - 2*z_5^2 - 1\n\njulia> Oscar.with_unicode() do\n         show(atlas_irrationality(\"i\"))\n       end;\nζ(4)\n\njulia> Oscar.with_unicode() do\n         show(atlas_irrationality(\"b7*3\"))\n       end;\n-ζ(7)^4 - ζ(7)^2 - ζ(7) - 1\n\njulia> Oscar.with_unicode() do\n         show(atlas_irrationality(\"3y'''24*13-2&5\"))\n       end;\n-5*ζ(24)^7 - 2*ζ(24)^5 + 2*ζ(24)^3 - 3*ζ(24)\n\n\n\n\n\n","category":"function"},{"location":"NumberTheory/abelian_closure/#atlas_description","page":"Abelian closure of the rationals","title":"atlas_description","text":"atlas_description(val::QQAbFieldElem)\n\nReturn a string in the format defined in [CCNPW85], Chapter 6, Section 10, describing val. Applying atlas_irrationality to the result yields val.\n\nExamples\n\njulia> K, z = abelian_closure(QQ);\n\njulia> val = z(5) + z(5)^4;\n\njulia> str = Oscar.atlas_description(val)\n\"b5\"\n\njulia> val == atlas_irrationality(str)\ntrue\n\n\n\n\n\n","category":"function"},{"location":"NumberTheory/abelian_closure/#Printing","page":"Abelian closure of the rationals","title":"Printing","text":"","category":"section"},{"location":"NumberTheory/abelian_closure/","page":"Abelian closure of the rationals","title":"Abelian closure of the rationals","text":"The n-th primitive root of the abelian closure of will by default be printed as z(n). The printing can be manipulated using the following functions:","category":"page"},{"location":"NumberTheory/abelian_closure/","page":"Abelian closure of the rationals","title":"Abelian closure of the rationals","text":"gen(::QQAbField, ::String)\nset_variable!(::QQAbField, ::String)\nget_variable(::QQAbField)","category":"page"},{"location":"NumberTheory/abelian_closure/#gen-Tuple{QQAbField, String}","page":"Abelian closure of the rationals","title":"gen","text":"gen(K::QQAbField, s::String)\n\nReturn the generator of the abelian closure K that can be used to construct primitive roots of unity. The string s will be used during printing.\n\n\n\n\n\n","category":"method"},{"location":"NumberTheory/abelian_closure/#set_variable!-Tuple{QQAbField, String}","page":"Abelian closure of the rationals","title":"set_variable!","text":"set_variable!(K::QQAbField, s::String)\n\nChange the printing of the primitive n-th root of the abelian closure of the rationals to s(n), where s is the supplied string.\n\n\n\n\n\n","category":"method"},{"location":"NumberTheory/abelian_closure/#get_variable-Tuple{QQAbField}","page":"Abelian closure of the rationals","title":"get_variable","text":"get_variable(K::QQAbField)\n\nReturn the string used to print the primitive n-th root of the abelian closure of the rationals.\n\n\n\n\n\n","category":"method"},{"location":"NumberTheory/abelian_closure/#Examples","page":"Abelian closure of the rationals","title":"Examples","text":"","category":"section"},{"location":"NumberTheory/abelian_closure/","page":"Abelian closure of the rationals","title":"Abelian closure of the rationals","text":"julia> K, z = abelian_closure(QQ);\n\njulia> z(4)\nz(4)\n\njulia> ζ = gen(K, \"ζ\")\nGenerator of abelian closure of Q\n\njulia> ζ(5) + ζ(3)\nζ(15)^5 + ζ(15)^3","category":"page"},{"location":"NumberTheory/abelian_closure/#Reduction-to-characteristic-p","page":"Abelian closure of the rationals","title":"Reduction to characteristic p","text":"","category":"section"},{"location":"NumberTheory/abelian_closure/","page":"Abelian closure of the rationals","title":"Abelian closure of the rationals","text":"reduce(val::QQAbFieldElem, F::FinField)","category":"page"},{"location":"NumberTheory/abelian_closure/#reduce-Tuple{QQAbFieldElem, FinField}","page":"Abelian closure of the rationals","title":"reduce","text":"reduce(val::QQAbFieldElem, F::FinField)\n\nReturn the element of F that is the p-modular reduction of val, where p is the characteristic of F. An exception is thrown if val cannot be reduced modulo p or if the reduction does not lie in F.\n\nExamples\n\njulia> K, z = abelian_closure(QQ);\n\njulia> F = GF(2, 3);\n\njulia> reduce(z(7), F)\no\n\n\n\n\n\n","category":"method"},{"location":"AlgebraicGeometry/ToricVarieties/ToricMorphisms/","page":"ToricMorphisms","title":"ToricMorphisms","text":"CurrentModule = Oscar","category":"page"},{"location":"AlgebraicGeometry/ToricVarieties/ToricMorphisms/#ToricMorphisms","page":"ToricMorphisms","title":"ToricMorphisms","text":"","category":"section"},{"location":"AlgebraicGeometry/ToricVarieties/ToricMorphisms/","page":"ToricMorphisms","title":"ToricMorphisms","text":"A class of morphisms among toric varieties are described by certain lattice morphisms. Let N_1 and N_2 be lattices and Sigma_1, Sigma_2 fans in N_1 and N_2 respectively. A mathbbZ-linear map","category":"page"},{"location":"AlgebraicGeometry/ToricVarieties/ToricMorphisms/","page":"ToricMorphisms","title":"ToricMorphisms","text":"overlinephi colon N_1 to N_2","category":"page"},{"location":"AlgebraicGeometry/ToricVarieties/ToricMorphisms/","page":"ToricMorphisms","title":"ToricMorphisms","text":"is said to be compatible with the fans Sigma_1 and Sigma_2 if for every cone sigma_1 in Sigma_1, there exists a cone sigma_2 in Sigma_2 such that overlinephi_mathbbR(sigma_1) subseteq sigma_2.","category":"page"},{"location":"AlgebraicGeometry/ToricVarieties/ToricMorphisms/","page":"ToricMorphisms","title":"ToricMorphisms","text":"By theorem 3.3.4 [CLS11], such a map overlinephi induces a morphism phi colon X_Sigma_1 to X_Sigma_2 of the toric varieties, and those morphisms are exactly the toric morphisms.","category":"page"},{"location":"AlgebraicGeometry/ToricVarieties/ToricMorphisms/#Constructors","page":"ToricMorphisms","title":"Constructors","text":"","category":"section"},{"location":"AlgebraicGeometry/ToricVarieties/ToricMorphisms/#Generic-constructors-with-specified-codomain","page":"ToricMorphisms","title":"Generic constructors with specified codomain","text":"","category":"section"},{"location":"AlgebraicGeometry/ToricVarieties/ToricMorphisms/","page":"ToricMorphisms","title":"ToricMorphisms","text":"toric_morphism(domain::NormalToricVarietyType, mapping_matrix::ZZMatrix, codomain::NormalToricVarietyType; check=true)\ntoric_morphism(domain::NormalToricVarietyType, grid_morphism::FinGenAbGroupHom, codomain::NormalToricVarietyType; check=true)","category":"page"},{"location":"AlgebraicGeometry/ToricVarieties/ToricMorphisms/#toric_morphism-Tuple{Union{AffineNormalToricVariety, CyclicQuotientSingularity, NormalToricVariety}, ZZMatrix, Union{AffineNormalToricVariety, CyclicQuotientSingularity, NormalToricVariety}}","page":"ToricMorphisms","title":"toric_morphism","text":"toric_morphism(domain::NormalToricVarietyType, mapping_matrix::ZZMatrix, codomain::NormalToricVarietyType; check=true)\n\nConstruct the toric morphism with given domain and associated to the lattice morphism given by the mapping_matrix.\n\nIf the codomain is left out, it will be determined whether the image of the domain fan is itself a polyhedral fan. In that case the codomain is assumed to be the associated toric variety.\n\nAll checks can be disabled with check=false.\n\nExamples\n\njulia> domain = projective_space(NormalToricVariety, 1)\nNormal toric variety\n\njulia> codomain = hirzebruch_surface(NormalToricVariety, 2)\nNormal toric variety\n\njulia> mapping_matrix = matrix(ZZ, [0 1])\n[0   1]\n\njulia> toric_morphism(domain, mapping_matrix, codomain)\nToric morphism\n\n\n\n\n\n","category":"method"},{"location":"AlgebraicGeometry/ToricVarieties/ToricMorphisms/#toric_morphism-Tuple{Union{AffineNormalToricVariety, CyclicQuotientSingularity, NormalToricVariety}, FinGenAbGroupHom, Union{AffineNormalToricVariety, CyclicQuotientSingularity, NormalToricVariety}}","page":"ToricMorphisms","title":"toric_morphism","text":"toric_morphism(domain::NormalToricVarietyType, grid_morphism::FinGenAbGroupHom, codomain::NormalToricVarietyType; check=true)\n\nConstruct the toric morphism from the domain to the codomain with map given by the grid_morphism.\n\nIf the codomain is left out, it will be determined whether the image of the domain fan is itself a polyhedral fan. In that case the codomain is assumed to be the associated toric variety.\n\nAll checks can be disabled with check=false.\n\nExamples\n\njulia> domain = projective_space(NormalToricVariety, 1)\nNormal toric variety\n\njulia> codomain = hirzebruch_surface(NormalToricVariety, 2)\nNormal toric variety\n\njulia> mapping_matrix = matrix(ZZ, [[0, 1]])\n[0   1]\n\njulia> grid_morphism = hom(character_lattice(domain), character_lattice(codomain), mapping_matrix)\nMap\n  from Z\n  to Z^2\n\njulia> toric_morphism(domain, grid_morphism, codomain)\nToric morphism\n\n\n\n\n\n","category":"method"},{"location":"AlgebraicGeometry/ToricVarieties/ToricMorphisms/#Special-constructors","page":"ToricMorphisms","title":"Special constructors","text":"","category":"section"},{"location":"AlgebraicGeometry/ToricVarieties/ToricMorphisms/","page":"ToricMorphisms","title":"ToricMorphisms","text":"toric_identity_morphism(variety::NormalToricVarietyType)","category":"page"},{"location":"AlgebraicGeometry/ToricVarieties/ToricMorphisms/#toric_identity_morphism-Tuple{Union{AffineNormalToricVariety, CyclicQuotientSingularity, NormalToricVariety}}","page":"ToricMorphisms","title":"toric_identity_morphism","text":"toric_identity_morphism(variety::NormalToricVarietyType)\n\nConstruct the toric identity morphism from variety to variety.\n\nExamples\n\njulia> toric_identity_morphism(hirzebruch_surface(NormalToricVariety, 2))\nToric morphism\n\n\n\n\n\n","category":"method"},{"location":"AlgebraicGeometry/ToricVarieties/ToricMorphisms/#Attributes-of-Toric-Morphisms","page":"ToricMorphisms","title":"Attributes of Toric Morphisms","text":"","category":"section"},{"location":"AlgebraicGeometry/ToricVarieties/ToricMorphisms/#General-attributes","page":"ToricMorphisms","title":"General attributes","text":"","category":"section"},{"location":"AlgebraicGeometry/ToricVarieties/ToricMorphisms/","page":"ToricMorphisms","title":"ToricMorphisms","text":"domain(tm::ToricMorphism)\nimage(tm::ToricMorphism)\ncodomain(tm::ToricMorphism)\ngrid_morphism(tm::ToricMorphism)\nmorphism_on_torusinvariant_weil_divisor_group(tm::ToricMorphism)\nmorphism_on_torusinvariant_cartier_divisor_group(tm::ToricMorphism)\nmorphism_on_class_group(tm::ToricMorphism)\nmorphism_on_picard_group(tm::ToricMorphism)\ncovering_morphism(f::ToricMorphism)","category":"page"},{"location":"AlgebraicGeometry/ToricVarieties/ToricMorphisms/#domain-Tuple{ToricMorphism}","page":"ToricMorphisms","title":"domain","text":"domain(tm::ToricMorphism)\n\nReturn the domain of the toric morphism tm.\n\nExamples\n\njulia> F4 = hirzebruch_surface(NormalToricVariety, 4)\nNormal toric variety\n\njulia> domain(toric_identity_morphism(F4))\nNormal toric variety\n\n\n\n\n\n","category":"method"},{"location":"AlgebraicGeometry/ToricVarieties/ToricMorphisms/#image-Tuple{ToricMorphism}","page":"ToricMorphisms","title":"image","text":"image(F::FreeMod{R}, A::MatElem{R}) where R\n\nReturn the image of A as an object of type SubquoModule with ambient free module F.\n\nExamples\n\njulia> R, (x,y,z) = polynomial_ring(QQ, [:x, :y, :z]);\n\njulia> F = free_module(R, 2)\nFree module of rank 2 over R\n\njulia> A = R[x y; 2*x^2 3*y^2]\n[    x       y]\n[2*x^2   3*y^2]\n \njulia> M = image(F, A)\nSubmodule with 2 generators\n  1: x*e[1] + y*e[2]\n  2: 2*x^2*e[1] + 3*y^2*e[2]\nrepresented as subquotient with no relations\n\njulia> ambient_free_module(M) === F\ntrue\n\njulia> Rg, (x, y, z) = graded_polynomial_ring(QQ, [:x, :y, :z]);\n\njulia> F = graded_free_module(Rg, [8,8])\nGraded free module Rg^2([-8]) of rank 2 over Rg\n\njulia> A = Rg[x y; 2*x^2 3*y^2]\n[    x       y]\n[2*x^2   3*y^2]\n \njulia> M = image(F, A)\nGraded submodule of F with 2 generators\n  1: x*e[1] + y*e[2]\n  2: 2*x^2*e[1] + 3*y^2*e[2]\nrepresented as subquotient with no relations\n\njulia> ambient_free_module(M) === F\ntrue\n\njulia> degrees_of_generators(M)\n2-element Vector{FinGenAbGroupElem}:\n [9]\n [10]\n\n\n\n\n\n","category":"method"},{"location":"AlgebraicGeometry/ToricVarieties/ToricMorphisms/#codomain-Tuple{ToricMorphism}","page":"ToricMorphisms","title":"codomain","text":"codomain(tm::ToricMorphism)\n\nReturn the codomain of the toric morphism tm.\n\nExamples\n\njulia> F4 = hirzebruch_surface(NormalToricVariety, 4)\nNormal toric variety\n\njulia> codomain(toric_identity_morphism(F4))\nNormal toric variety\n\n\n\n\n\n","category":"method"},{"location":"AlgebraicGeometry/ToricVarieties/ToricMorphisms/#grid_morphism-Tuple{ToricMorphism}","page":"ToricMorphisms","title":"grid_morphism","text":"grid_morphism(tm::ToricMorphism)\n\nReturn the underlying grid morphism of the toric morphism tm.\n\nExamples\n\njulia> F4 = hirzebruch_surface(NormalToricVariety, 4)\nNormal toric variety\n\njulia> grid_morphism(toric_identity_morphism(F4))\nMap\n  from Z^2\n  to Z^2\n\n\n\n\n\n","category":"method"},{"location":"AlgebraicGeometry/ToricVarieties/ToricMorphisms/#morphism_on_torusinvariant_weil_divisor_group-Tuple{ToricMorphism}","page":"ToricMorphisms","title":"morphism_on_torusinvariant_weil_divisor_group","text":"morphism_on_torusinvariant_weil_divisor_group(tm::ToricMorphism)\n\nFor a given toric morphism tm, this method computes the corresponding map of the torusinvariant Weil divisors.\n\nExamples\n\njulia> F4 = hirzebruch_surface(NormalToricVariety, 4)\nNormal toric variety\n\njulia> morphism_on_torusinvariant_weil_divisor_group(toric_identity_morphism(F4))\nMap\n  from Z^4\n  to Z^4\n\n\n\n\n\n","category":"method"},{"location":"AlgebraicGeometry/ToricVarieties/ToricMorphisms/#morphism_on_torusinvariant_cartier_divisor_group-Tuple{ToricMorphism}","page":"ToricMorphisms","title":"morphism_on_torusinvariant_cartier_divisor_group","text":"morphism_on_torusinvariant_cartier_divisor_group(tm::ToricMorphism)\n\nFor a given toric morphism tm, this method computes the corresponding map of the Cartier divisors.\n\nExamples\n\njulia> F4 = hirzebruch_surface(NormalToricVariety, 4)\nNormal toric variety\n\njulia> morphism_on_torusinvariant_cartier_divisor_group(toric_identity_morphism(F4))\nMap\n  from Z^4\n  to Z^4\n\n\n\n\n\n","category":"method"},{"location":"AlgebraicGeometry/ToricVarieties/ToricMorphisms/#morphism_on_class_group-Tuple{ToricMorphism}","page":"ToricMorphisms","title":"morphism_on_class_group","text":"morphism_on_class_group(tm::ToricMorphism)\n\nFor a given toric morphism tm, this method computes the corresponding map of the Class groups.\n\nExamples\n\njulia> F4 = hirzebruch_surface(NormalToricVariety, 4)\nNormal toric variety\n\njulia> morphism_on_class_group(toric_identity_morphism(F4))\nMap\n  from Z^2\n  to Z^2\n\n\n\n\n\n","category":"method"},{"location":"AlgebraicGeometry/ToricVarieties/ToricMorphisms/#morphism_on_picard_group-Tuple{ToricMorphism}","page":"ToricMorphisms","title":"morphism_on_picard_group","text":"morphism_on_picard_group(tm::ToricMorphism)\n\nFor a given toric morphism tm, this method computes the corresponding map of the Picard groups.\n\nExamples\n\njulia> F4 = hirzebruch_surface(NormalToricVariety, 4)\nNormal toric variety\n\njulia> morphism_on_picard_group(toric_identity_morphism(F4))\nMap\n  from Z^2\n  to Z^2\n\n\n\n\n\n","category":"method"},{"location":"AlgebraicGeometry/ToricVarieties/ToricMorphisms/#covering_morphism-Tuple{ToricMorphism}","page":"ToricMorphisms","title":"covering_morphism","text":"covering_morphism(f::ToricMorphism)\n\nFor a given toric morphism tm, we can compute the corresponding morphism of covered schemes. The following demonstrates this for the blow-up morphism of a blow-up of the projective space.\n\nExamples\n\njulia> IP2 = projective_space(NormalToricVariety, 2)\nNormal toric variety\n\njulia> bl = blow_up(IP2, [1, 1]);\n\njulia> cov_bl = covering_morphism(bl);\n\njulia> domain(cov_bl)\nCovering\n  described by patches\n    1: normal toric variety\n    2: normal toric variety\n    3: normal toric variety\n    4: normal toric variety\n  in the coordinate(s)\n    1: [x_1_1, x_2_1]\n    2: [x_1_2, x_2_2]\n    3: [x_1_3, x_2_3]\n    4: [x_1_4, x_2_4]\n\njulia> codomain(cov_bl)\nCovering\n  described by patches\n    1: normal toric variety\n    2: normal toric variety\n    3: normal toric variety\n  in the coordinate(s)\n    1: [x_1_1, x_2_1]\n    2: [x_1_2, x_2_2]\n    3: [x_1_3, x_2_3]\n\n\n\n\n\n","category":"method"},{"location":"AlgebraicGeometry/ToricVarieties/ToricMorphisms/#Special-attributes-of-toric-varieties","page":"ToricMorphisms","title":"Special attributes of toric varieties","text":"","category":"section"},{"location":"AlgebraicGeometry/ToricVarieties/ToricMorphisms/","page":"ToricMorphisms","title":"ToricMorphisms","text":"To every toric variety v we can associate a special toric variety, the Cox variety. By definition, the Cox variety is such that the mapping matrix of the toric morphism from the Cox variety to the variety v is simply given by the ray generators of the variety v. Put differently, if there are exactly N ray generators for the fan of v, then the Cox variety of v has a fan for which the ray generators are the standard basis of mathbbR^N and the maximal cones are one to one to the maximal cones of the fan of v.","category":"page"},{"location":"AlgebraicGeometry/ToricVarieties/ToricMorphisms/","page":"ToricMorphisms","title":"ToricMorphisms","text":"morphism_from_cox_variety(variety::NormalToricVarietyType)\ncox_variety(variety::NormalToricVarietyType)","category":"page"},{"location":"AlgebraicGeometry/ToricVarieties/ToricMorphisms/#morphism_from_cox_variety-Tuple{Union{AffineNormalToricVariety, CyclicQuotientSingularity, NormalToricVariety}}","page":"ToricMorphisms","title":"morphism_from_cox_variety","text":"morphism_from_cox_variety(variety::NormalToricVarietyType)\n\nReturn the quotient morphism from the Cox variety to the toric variety in question.\n\nExamples\n\njulia> F4 = hirzebruch_surface(NormalToricVariety, 4)\nNormal toric variety\n\njulia> morphism_from_cox_variety(F4)\nToric morphism\n\n\n\n\n\n","category":"method"},{"location":"AlgebraicGeometry/ToricVarieties/ToricMorphisms/#cox_variety-Tuple{Union{AffineNormalToricVariety, CyclicQuotientSingularity, NormalToricVariety}}","page":"ToricMorphisms","title":"cox_variety","text":"cox_variety(variety::NormalToricVarietyType)\n\nReturn the Cox variety of the toric variety in question.\n\nExamples\n\njulia> F4 = hirzebruch_surface(NormalToricVariety, 4)\nNormal toric variety\n\njulia> cox_variety(F4)\nNormal toric variety\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/quad_forms/introduction/#Introduction","page":"Introduction","title":"Introduction","text":"","category":"section"},{"location":"Hecke/manual/quad_forms/introduction/","page":"Introduction","title":"Introduction","text":"CurrentModule = Hecke","category":"page"},{"location":"Hecke/manual/quad_forms/introduction/","page":"Introduction","title":"Introduction","text":"This chapter deals with quadratic and hermitian spaces, and lattices there of. Note that even though quadratic spaces/lattices are theoretically a special case of hermitian spaces/lattices, a particular distinction is made here. As a note for knowledgeable users, only methods regarding hermitian spaces/lattices over degree 1 and degree 2 extensions of number fields are implemented up to now.","category":"page"},{"location":"Hecke/manual/quad_forms/introduction/#Definitions-and-vocabulary","page":"Introduction","title":"Definitions and vocabulary","text":"","category":"section"},{"location":"Hecke/manual/quad_forms/introduction/","page":"Introduction","title":"Introduction","text":"We begin by collecting the necessary definitions and vocabulary. The terminology follows mainly [Kir16]","category":"page"},{"location":"Hecke/manual/quad_forms/introduction/#Quadratic-and-hermitian-spaces","page":"Introduction","title":"Quadratic and hermitian spaces","text":"","category":"section"},{"location":"Hecke/manual/quad_forms/introduction/","page":"Introduction","title":"Introduction","text":"Let K be a number field and let E be a finitely generated etale algebra over K of dimension 1 or 2, i.e. E=K or E is a separable extension of K of degree 2. In both cases, EK is endowed with an K-linear involution overlinephantomx colon E to E for which K is the fixed field (in the case E=K, this is simply the identity of K).","category":"page"},{"location":"Hecke/manual/quad_forms/introduction/","page":"Introduction","title":"Introduction","text":"A hermitian space V over EK is a finite-dimensional E-vector space, together with a sesquilinear (with respect to the involution of EK) morphism Phi colon V times V to E. In the trivial case E=K, Phi is therefore a K-bilinear morphism and we called (V Phi) a quadratic hermitian space over K.","category":"page"},{"location":"Hecke/manual/quad_forms/introduction/","page":"Introduction","title":"Introduction","text":"We will always work with an implicit canonical basis e_1 ldots e_n of V. In view of this, hermitian spaces over EK are in bijection with hermitian matrices with entries in E, with respect to the involution overlinephantomx. In particular, there is a bijection between quadratic hermitian spaces over K and symmetric matrices with entries in K. For any basis B = (v_1 ldots v_n) of (V Phi), we call the matrix G_B = (Phi(v_i v_j))_1 leq i j leq n in E^n times n the Gram matrix of (V Phi) associated to B. If B is the implicit fixed canonical basis of (V Phi), we simply talk about the Gram matrix of (V Phi).","category":"page"},{"location":"Hecke/manual/quad_forms/introduction/","page":"Introduction","title":"Introduction","text":"For a hermitian space V, we refer to the field E as the base ring of V and to overlinephantomx as the involution of V. Meanwhile, the field K is referred to as the fixed field of V.","category":"page"},{"location":"Hecke/manual/quad_forms/introduction/","page":"Introduction","title":"Introduction","text":"By abuse of language, non-quadratic hermitian spaces are sometimes simply called hermitian spaces and, in contrast, quadratic hermitian spaces are called quadratic spaces. In a general context, an arbitrary space (quadratic or hermitian) is referred to as a space throughout this chapter.","category":"page"},{"location":"Hecke/manual/quad_forms/introduction/#Quadratic-and-hermitian-lattices","page":"Introduction","title":"Quadratic and hermitian lattices","text":"","category":"section"},{"location":"Hecke/manual/quad_forms/introduction/","page":"Introduction","title":"Introduction","text":"Let V be a space over EK. A finitely generated mathcal O_E-submodule L of V is called a hermitian lattice. By extension of vocabulary if V is quadratic (i.e. E=K), L is called a quadratic hermitian lattice. We call V the ambient space of L and Lotimes_mathcal O_E E the rational span of L.","category":"page"},{"location":"Hecke/manual/quad_forms/introduction/","page":"Introduction","title":"Introduction","text":"For a hermitian lattice L, we refer to E as the base field of L and to the ring mathcal O_E as the base ring of L. We also call overlinephantomx colon E to E the involution of L. Finally, we refer to the field K fixed by this involution as the fixed field of L and to mathcal O_K as the fixed ring of L.","category":"page"},{"location":"Hecke/manual/quad_forms/introduction/","page":"Introduction","title":"Introduction","text":"Once again by abuse of language, non-quadratic hermitian lattices are sometimes simply called hermitian lattices and quadratic lattices refer to quadratic hermitian lattices. Therefore, in a general context, an arbitrary lattice is referred to as a lattice in this chapter.","category":"page"},{"location":"Hecke/manual/quad_forms/introduction/#References","page":"Introduction","title":"References","text":"","category":"section"},{"location":"Hecke/manual/quad_forms/introduction/","page":"Introduction","title":"Introduction","text":"Many of the implemented algorithms for computing with quadratic and hermitian lattices over number fields are based on the Magma implementation of Markus Kirschmer, which can be found here.","category":"page"},{"location":"Hecke/manual/quad_forms/introduction/","page":"Introduction","title":"Introduction","text":"Most of the definitions and results are taken from:","category":"page"},{"location":"Hecke/manual/quad_forms/introduction/","page":"Introduction","title":"Introduction","text":"[Kir16] : Definite quadratic and hermitian forms with small class number. Habilitationsschrift. RWTH Aachen University, 2016. pdf","category":"page"},{"location":"Hecke/manual/quad_forms/introduction/","page":"Introduction","title":"Introduction","text":"[Kir19] : Determinant groups of hermitian lattices over local fields, Archiv der Mathematik, 113 (2019), no. 4, 337–347. pdf","category":"page"},{"location":"Hecke/manual/elliptic_curves/basics/#Basics","page":"Basics","title":"Basics","text":"","category":"section"},{"location":"Hecke/manual/elliptic_curves/basics/","page":"Basics","title":"Basics","text":"CurrentModule = Hecke\nDocTestSetup = quote\n    using Hecke\nend\n","category":"page"},{"location":"Hecke/manual/elliptic_curves/basics/#Creation","page":"Basics","title":"Creation","text":"","category":"section"},{"location":"Hecke/manual/elliptic_curves/basics/","page":"Basics","title":"Basics","text":"elliptic_curve\nelliptic_curve_from_j_invariant","category":"page"},{"location":"Hecke/manual/elliptic_curves/basics/#elliptic_curve","page":"Basics","title":"elliptic_curve","text":"elliptic_curve([K::Field], x::Vector; check::Bool = true) -> EllipticCurve\n\nConstruct an elliptic curve with Weierstrass equation specified by the coefficients in x, which must have either length 2 or 5.\n\nPer default, it is checked whether the discriminant is non-zero. This can be disabled by setting check = false.\n\nExamples\n\njulia> elliptic_curve(QQ, [1, 2, 3, 4, 5])\nElliptic curve with equation\ny^2 + x*y + 3*y = x^3 + 2*x^2 + 4*x + 5\n\njulia> elliptic_curve(GF(3), [1, 1])\nElliptic curve with equation\ny^2 = x^3 + x + 1\n\n\n\n\n\n","category":"function"},{"location":"Hecke/manual/elliptic_curves/basics/#elliptic_curve_from_j_invariant","page":"Basics","title":"elliptic_curve_from_j_invariant","text":"elliptic_curve_from_j_invariant(j::FieldElem) -> EllipticCurve\n\nReturn an elliptic curve with the given j-invariant.\n\nExamples\n\njulia> K = GF(3)\nPrime field of characteristic 3\n\njulia> elliptic_curve_from_j_invariant(K(2))\nElliptic curve with equation\ny^2 + x*y = x^3 + 1\n\n\n\n\n\n","category":"function"},{"location":"Hecke/manual/elliptic_curves/basics/#Basic-properties","page":"Basics","title":"Basic properties","text":"","category":"section"},{"location":"Hecke/manual/elliptic_curves/basics/","page":"Basics","title":"Basics","text":"base_field(::EllipticCurve)\nbase_change(::Field, ::EllipticCurve)\nbase_change(::Any, ::EllipticCurve)\ncoefficients(::EllipticCurve)\na_invariants(::EllipticCurve)\nb_invariants(::EllipticCurve)\nc_invariants(::EllipticCurve)\ndiscriminant(::EllipticCurve)\nj_invariant(::EllipticCurve)\nequation(::EllipticCurve)\nhyperelliptic_polynomials(::EllipticCurve)","category":"page"},{"location":"Hecke/manual/elliptic_curves/basics/#base_field-Tuple{EllipticCurve}","page":"Basics","title":"base_field","text":"base_field(E::EllipticCurve) -> Field\n\nReturn the base field over which E is defined.\n\n\n\n\n\nbase_field(C::HypellCrv) -> Field\n\nReturn the base field over which C is defined.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/elliptic_curves/basics/#base_change-Tuple{Field, EllipticCurve}","page":"Basics","title":"base_change","text":"base_change(K::Field, E::EllipticCurve) -> EllipticCurve\n\nReturn the base change of the elliptic curve E over K if coercion is possible.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/elliptic_curves/basics/#base_change-Tuple{Any, EllipticCurve}","page":"Basics","title":"base_change","text":"base_change(f, E::EllipticCurve) -> EllipticCurve\n\nReturn the base change of the elliptic curve E using the map f.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/elliptic_curves/basics/#coefficients-Tuple{EllipticCurve}","page":"Basics","title":"coefficients","text":"coefficients(E::EllipticCurve{T}) -> Tuple{T, T, T, T, T}\n\nReturn the Weierstrass coefficients of E as a tuple (a1, a2, a3, a4, a6) such that E is given by y^2 + a1xy + a3y = x^3 + a2x^2 + a4x + a6.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/elliptic_curves/basics/#a_invariants-Tuple{EllipticCurve}","page":"Basics","title":"a_invariants","text":"a_invariants(E::EllipticCurve{T}) -> Tuple{T, T, T, T, T}\n\nReturn the Weierstrass coefficients of E as a tuple (a_1 a_2 a_3 a_4 a_6) such that E is given by y^2 + a_1xy + a_3y = x^3 + a_2x^2 + a_4x + a_6.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/elliptic_curves/basics/#b_invariants-Tuple{EllipticCurve}","page":"Basics","title":"b_invariants","text":"b_invariants(E::EllipticCurve{T}) -> Tuple{T, T, T, T}\n\nReturn the b-invariants of E as a tuple (b_2 b_4 b_6 b_8).\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/elliptic_curves/basics/#c_invariants-Tuple{EllipticCurve}","page":"Basics","title":"c_invariants","text":"c_invariants(E::EllipticCurve{T}) -> Tuple{T, T}\n\nReturn the c-invariants of E as a tuple (c_4 c_6).\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/elliptic_curves/basics/#discriminant-Tuple{EllipticCurve}","page":"Basics","title":"discriminant","text":"discriminant(E::EllipticCurve) -> FieldElem\n\nReturn the discriminant of E.\n\n\n\n\n\ndiscriminant(C::HypellCrv{T}) -> T\n\nCompute the discriminant of C.\n\n\n\n\n\ndiscriminant(O::AlgssRelOrd)\n\nReturns the discriminant of O.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/elliptic_curves/basics/#j_invariant-Tuple{EllipticCurve}","page":"Basics","title":"j_invariant","text":"j_invariant(E::EllipticCurve) -> FieldElem\n\nCompute the j-invariant of E.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/elliptic_curves/basics/#equation-Tuple{EllipticCurve}","page":"Basics","title":"equation","text":"equation([R::MPolyRing,] E::EllipticCurve) -> MPolyRingElem\n\nReturn the equation defining the elliptic curve E as a bivariate polynomial. If the polynomial ring R is specified, it must by a bivariate polynomial ring.\n\nExamples\n\njulia> E = elliptic_curve(QQ, [1, 2, 3, 4, 5]);\n\njulia> equation(E)\n-x^3 - 2*x^2 + x*y - 4*x + y^2 + 3*y - 5\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/elliptic_curves/basics/#hyperelliptic_polynomials-Tuple{EllipticCurve}","page":"Basics","title":"hyperelliptic_polynomials","text":"hyperelliptic_polynomials([R::PolyRing,] E::EllipticCurve) -> PolyRingElem, PolyRingElem\n\nReturn univariate polynomials f h such that E is given by y^2 + h*y = f.\n\nExamples\n\njulia> E = elliptic_curve(QQ, [1, 2, 3, 4, 5]);\n\njulia> hyperelliptic_polynomials(E)\n(x^3 + 2*x^2 + 4*x + 5, x + 3)\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/elliptic_curves/basics/#Points","page":"Basics","title":"Points","text":"","category":"section"},{"location":"Hecke/manual/elliptic_curves/basics/","page":"Basics","title":"Basics","text":"    (E::EllipticCurve)(coords::Vector; check::Bool = true)","category":"page"},{"location":"Hecke/manual/elliptic_curves/basics/","page":"Basics","title":"Basics","text":"Return the point P of E with coordinates specified by coords, which can be either affine coordinates (length(coords) == 2) or projective coordinates (length(coords) == 3).","category":"page"},{"location":"Hecke/manual/elliptic_curves/basics/","page":"Basics","title":"Basics","text":"Per default, it is checked whether the point lies on E. This can be disabled by setting check = false.","category":"page"},{"location":"Hecke/manual/elliptic_curves/basics/#Examples","page":"Basics","title":"Examples","text":"","category":"section"},{"location":"Hecke/manual/elliptic_curves/basics/","page":"Basics","title":"Basics","text":"julia> E = elliptic_curve(QQ, [1, 2]);\n\njulia> E([1, -2])\nPoint  (1 : -2 : 1)  of Elliptic curve with equation\ny^2 = x^3 + x + 2\n\njulia> E([2, -4, 2])\nPoint  (1 : -2 : 1)  of Elliptic curve with equation\ny^2 = x^3 + x + 2","category":"page"},{"location":"Hecke/manual/elliptic_curves/basics/","page":"Basics","title":"Basics","text":"infinity(::EllipticCurve)\nparent(::EllipticCurvePoint)\nis_on_curve(::EllipticCurve, ::Vector)\n+(P::EllipticCurvePoint{T}, Q::EllipticCurvePoint{T}) where {T}\ndivision_points(::EllipticCurvePoint, ::Int)","category":"page"},{"location":"Hecke/manual/elliptic_curves/basics/#infinity-Tuple{EllipticCurve}","page":"Basics","title":"infinity","text":"infinity(E::EllipticCurve) -> EllipticCurvePoint\n\nReturn the point at infinity with project coordinates 0  1  0.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/elliptic_curves/basics/#parent-Tuple{EllipticCurvePoint}","page":"Basics","title":"parent","text":"parent(P::EllipticCurvePoint) -> EllipticCurve\n\nReturn the elliptic curve on which P lies.\n\nExamples\n\njulia> E = elliptic_curve(QQ, [1, 2]);\n\njulia> P = E([1, -2]);\n\njulia> E == parent(P)\ntrue\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/elliptic_curves/basics/#is_on_curve-Tuple{EllipticCurve, Vector}","page":"Basics","title":"is_on_curve","text":"is_on_curve(E::EllipticCurve, coords::Vector) -> Bool\n\nReturn true if coords defines a point on E and false otherwise. The array coords must have length 2.\n\nExamples\n\njulia> E = elliptic_curve(QQ, [1, 2]);\n\njulia> is_on_curve(E, [1, -2])\ntrue\n\njulia> is_on_curve(E, [1, -1])\nfalse\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/elliptic_curves/basics/#+-Union{Tuple{T}, Tuple{EllipticCurvePoint{T}, EllipticCurvePoint{T}}} where T","page":"Basics","title":"+","text":"+(P::EllipticCurvePoint, Q::EllipticCurvePoint) -> EllipticCurvePoint\n\nAdd two points on an elliptic curve.\n\nExamples\n\njulia> E = elliptic_curve(QQ, [1, 2]);\n\njulia> P = E([1, -2]);\n\njulia> P + P\nPoint  (-1 : 0 : 1)  of Elliptic curve with equation\ny^2 = x^3 + x + 2\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/elliptic_curves/basics/#division_points-Tuple{EllipticCurvePoint, Int64}","page":"Basics","title":"division_points","text":"division_points(P::EllipticCurvePoint, m::Int) -> EllipticCurvePoint\n\nCompute the set of points Q defined over the base field such that mQ = P. Returns the empty list if no such points exist.\n\nExamples\n\njulia> E = elliptic_curve(QQ, [1, 2]);\n\njulia> division_points(infinity(E), 2)\n2-element Vector{EllipticCurvePoint{QQFieldElem}}:\n Point  (0 : 1 : 0)  of Elliptic curve with equation\ny^2 = x^3 + x + 2\n Point  (-1 : 0 : 1)  of Elliptic curve with equation\ny^2 = x^3 + x + 2\n\n\n\n\n\n","category":"method"},{"location":"TropicalGeometry/curve/#Tropical-curves","page":"Tropical curves","title":"Tropical curves","text":"","category":"section"},{"location":"TropicalGeometry/curve/#Introduction","page":"Tropical curves","title":"Introduction","text":"","category":"section"},{"location":"TropicalGeometry/curve/","page":"Tropical curves","title":"Tropical curves","text":"A tropical curve is a graph with multiplicities on its edges.  If embedded, it is a polyhedral complex of dimension (at most) one.","category":"page"},{"location":"TropicalGeometry/curve/#Note:","page":"Tropical curves","title":"Note:","text":"","category":"section"},{"location":"TropicalGeometry/curve/","page":"Tropical curves","title":"Tropical curves","text":"The type TropicalCurve can be thought of as subtype of TropicalVariety in the sense that it should have all properties and features of the latter.","category":"page"},{"location":"TropicalGeometry/curve/#Construction","page":"Tropical curves","title":"Construction","text":"","category":"section"},{"location":"TropicalGeometry/curve/","page":"Tropical curves","title":"Tropical curves","text":"In addition to converting from TropicalVariety, objects of type TropicalCurve can be constructed from:","category":"page"},{"location":"TropicalGeometry/curve/","page":"Tropical curves","title":"Tropical curves","text":"","category":"page"},{"location":"TropicalGeometry/curve/#Properties","page":"Tropical curves","title":"Properties","text":"","category":"section"},{"location":"TropicalGeometry/curve/","page":"Tropical curves","title":"Tropical curves","text":"In addition to the properties inherited from TropicalVariety, objects of type TropicalCurve have the following exclusive properties:","category":"page"},{"location":"TropicalGeometry/curve/","page":"Tropical curves","title":"Tropical curves","text":"graph(tc::TropicalCurve)","category":"page"},{"location":"TropicalGeometry/curve/#graph-Tuple{TropicalCurve}","page":"Tropical curves","title":"graph","text":"graph(f::AbsAffineSchemeMor)\n\nReturn the graph of f  X  Y as a subscheme of XY as well as the two projections to X and Y.\n\nExamples\n\njulia> Y = affine_space(QQ,3)\nAffine space of dimension 3\n  over rational field\nwith coordinates [x1, x2, x3]\n\njulia> R = OO(Y)\nMultivariate polynomial ring in 3 variables x1, x2, x3\n  over rational field\n\njulia> (x1,x2,x3) = gens(R)\n3-element Vector{QQMPolyRingElem}:\n x1\n x2\n x3\n\njulia> X = subscheme(Y, x1)\nSpectrum\n  of quotient\n    of multivariate polynomial ring in 3 variables x1, x2, x3\n      over rational field\n    by ideal (x1)\n\njulia> f = inclusion_morphism(X, Y)\nAffine scheme morphism\n  from [x1, x2, x3]  scheme(x1)\n  to   [x1, x2, x3]  affine 3-space over QQ\ngiven by the pullback function\n  x1 -> x1\n  x2 -> x2\n  x3 -> x3\n\njulia> graph(f)\n(scheme(x1, -x1, x2 - x2, x3 - x3), Hom: scheme(x1, -x1, x2 - x2, x3 - x3) -> scheme(x1), Hom: scheme(x1, -x1, x2 - x2, x3 - x3) -> affine 3-space over QQ with coordinates [x1, x2, x3])\n\n\n\n\n\ngraph(TropC::TropicalCurve{minOrMax,false})\n\nReturn the graph of an abstract tropical curve TropC.  Same as polyhedral_complex(tc).\n\n\n\n\n\n","category":"method"},{"location":"AlgebraicGeometry/ToricVarieties/intro/","page":"Introduction","title":"Introduction","text":"CurrentModule = Oscar","category":"page"},{"location":"AlgebraicGeometry/ToricVarieties/intro/#Introduction","page":"Introduction","title":"Introduction","text":"","category":"section"},{"location":"AlgebraicGeometry/ToricVarieties/intro/#Content","page":"Introduction","title":"Content","text":"","category":"section"},{"location":"AlgebraicGeometry/ToricVarieties/intro/","page":"Introduction","title":"Introduction","text":"The toric geometry part of OSCAR comprises algorithms addressing normal toric varieties and objects from commutative algebra and polyhedral geometry derived thereof. In particular, we provide support for the following:","category":"page"},{"location":"AlgebraicGeometry/ToricVarieties/intro/","page":"Introduction","title":"Introduction","text":"torus-invariant divisor (classes),\nline bundles,\nline bundle cohomology via cohomCalg (cf. [BJRR10*1]),\nvanishing sets of line bundle cohomology (cf. Appendix B of [Bie18]),\ncohomology ring and cohomology classes,\nChow ring, algebraic cycles and intersection theory,\nelementary support for closed subvarieties.","category":"page"},{"location":"AlgebraicGeometry/ToricVarieties/intro/#Status","page":"Introduction","title":"Status","text":"","category":"section"},{"location":"AlgebraicGeometry/ToricVarieties/intro/","page":"Introduction","title":"Introduction","text":"This project is work-in-progress.","category":"page"},{"location":"AlgebraicGeometry/ToricVarieties/intro/#Tutorial","page":"Introduction","title":"Tutorial","text":"","category":"section"},{"location":"AlgebraicGeometry/ToricVarieties/intro/","page":"Introduction","title":"Introduction","text":"We provide a tutorial for toric geometry in OSCAR.","category":"page"},{"location":"AlgebraicGeometry/ToricVarieties/intro/#Long-term-goals","page":"Introduction","title":"Long term goals","text":"","category":"section"},{"location":"AlgebraicGeometry/ToricVarieties/intro/","page":"Introduction","title":"Introduction","text":"We follow [CLS11]. Our long term goals include the following:","category":"page"},{"location":"AlgebraicGeometry/ToricVarieties/intro/","page":"Introduction","title":"Introduction","text":"Ensure that one can perform all computations of Appendix B in [CLS11].\nProvide support for coherent sheaves and their sheaf cohomologies. In particular, the existing algorithms in ToricVarieties_project (based on [Bie18]) should eventually be available in OSCAR.","category":"page"},{"location":"AlgebraicGeometry/ToricVarieties/intro/#Contact","page":"Introduction","title":"Contact","text":"","category":"section"},{"location":"AlgebraicGeometry/ToricVarieties/intro/","page":"Introduction","title":"Introduction","text":"Please direct questions about this part of OSCAR to the following people:","category":"page"},{"location":"AlgebraicGeometry/ToricVarieties/intro/","page":"Introduction","title":"Introduction","text":"Martin Bies,\nLars Kastner.","category":"page"},{"location":"AlgebraicGeometry/ToricVarieties/intro/","page":"Introduction","title":"Introduction","text":"You can ask questions in the OSCAR Slack.","category":"page"},{"location":"AlgebraicGeometry/ToricVarieties/intro/","page":"Introduction","title":"Introduction","text":"Alternatively, you can raise an issue on github.","category":"page"},{"location":"AlgebraicGeometry/ToricVarieties/ToricLineBundles/","page":"Toric Line Bundles","title":"Toric Line Bundles","text":"CurrentModule = Oscar","category":"page"},{"location":"AlgebraicGeometry/ToricVarieties/ToricLineBundles/#Toric-Line-Bundles","page":"Toric Line Bundles","title":"Toric Line Bundles","text":"","category":"section"},{"location":"AlgebraicGeometry/ToricVarieties/ToricLineBundles/#Constructors","page":"Toric Line Bundles","title":"Constructors","text":"","category":"section"},{"location":"AlgebraicGeometry/ToricVarieties/ToricLineBundles/#Generic-constructors","page":"Toric Line Bundles","title":"Generic constructors","text":"","category":"section"},{"location":"AlgebraicGeometry/ToricVarieties/ToricLineBundles/","page":"Toric Line Bundles","title":"Toric Line Bundles","text":"toric_line_bundle(v::NormalToricVarietyType, picard_class::FinGenAbGroupElem)\ntoric_line_bundle(v::NormalToricVarietyType, picard_class::Vector{T}) where {T <: IntegerUnion}\ntoric_line_bundle(v::NormalToricVarietyType, d::ToricDivisor)\ntoric_line_bundle(d::ToricDivisor)\ntoric_line_bundle(v::NormalToricVarietyType, dc::ToricDivisorClass)\ntoric_line_bundle(dc::ToricDivisorClass)","category":"page"},{"location":"AlgebraicGeometry/ToricVarieties/ToricLineBundles/#toric_line_bundle-Tuple{Union{AffineNormalToricVariety, CyclicQuotientSingularity, NormalToricVariety}, FinGenAbGroupElem}","page":"Toric Line Bundles","title":"toric_line_bundle","text":"toric_line_bundle(v::NormalToricVarietyType, picard_class::FinGenAbGroupElem)\n\nConstruct the line bundle on the abstract normal toric variety with given class in the Picard group of the toric variety in question.\n\nExamples\n\njulia> P2 = projective_space(NormalToricVariety, 2)\nNormal toric variety\n\njulia> l = toric_line_bundle(P2, picard_group(P2)([1]))\nToric line bundle on a normal toric variety\n\n\n\n\n\n","category":"method"},{"location":"AlgebraicGeometry/ToricVarieties/ToricLineBundles/#toric_line_bundle-Union{Tuple{T}, Tuple{Union{AffineNormalToricVariety, CyclicQuotientSingularity, NormalToricVariety}, Vector{T}}} where T<:Union{Integer, ZZRingElem}","page":"Toric Line Bundles","title":"toric_line_bundle","text":"toric_line_bundle(v::NormalToricVarietyType, picard_class::Vector{T}) where {T <: IntegerUnion}\n\nConstruct the line bundle on the abstract normal toric variety v with class c in the Picard group of v.\n\nExamples\n\njulia> v = projective_space(NormalToricVariety, 2)\nNormal toric variety\n\njulia> l = toric_line_bundle(v, [ZZRingElem(2)])\nToric line bundle on a normal toric variety\n\n\n\n\n\n","category":"method"},{"location":"AlgebraicGeometry/ToricVarieties/ToricLineBundles/#toric_line_bundle-Tuple{Union{AffineNormalToricVariety, CyclicQuotientSingularity, NormalToricVariety}, ToricDivisor}","page":"Toric Line Bundles","title":"toric_line_bundle","text":"toric_line_bundle(v::NormalToricVarietyType, d::ToricDivisor)\n\nConstruct the toric variety associated to a (Cartier) torus-invariant divisor d on the normal toric variety v.\n\nExamples\n\njulia> v = projective_space(NormalToricVariety, 2)\nNormal toric variety\n\njulia> l = toric_line_bundle(v, toric_divisor(v, [1, 2, 3]))\nToric line bundle on a normal toric variety\n\n\n\n\n\n","category":"method"},{"location":"AlgebraicGeometry/ToricVarieties/ToricLineBundles/#toric_line_bundle-Tuple{ToricDivisor}","page":"Toric Line Bundles","title":"toric_line_bundle","text":"toric_line_bundle(d::ToricDivisor)\n\nConstruct the toric variety associated to a (Cartier) torus-invariant divisor d.\n\nExamples\n\njulia> v = projective_space(NormalToricVariety, 2)\nNormal toric variety\n\njulia> d = toric_divisor(v, [1, 2, 3]);\n\njulia> l = toric_line_bundle(d)\nToric line bundle on a normal toric variety\n\n\n\n\n\n","category":"method"},{"location":"AlgebraicGeometry/ToricVarieties/ToricLineBundles/#toric_line_bundle-Tuple{Union{AffineNormalToricVariety, CyclicQuotientSingularity, NormalToricVariety}, ToricDivisorClass}","page":"Toric Line Bundles","title":"toric_line_bundle","text":"toric_line_bundle(v::NormalToricVarietyType, dc::ToricDivisorClass)\n\nConstruct the toric variety associated to a divisor class in the class group of a toric variety.\n\nExamples\n\njulia> v = projective_space(NormalToricVariety, 2)\nNormal toric variety\n\njulia> d = toric_divisor(v, [1, 2, 3])\nTorus-invariant, non-prime divisor on a normal toric variety\n\njulia> dc = toric_divisor_class(d)\nDivisor class on a normal toric variety\n\njulia> l = toric_line_bundle(v, dc)\nToric line bundle on a normal toric variety\n\n\n\n\n\n","category":"method"},{"location":"AlgebraicGeometry/ToricVarieties/ToricLineBundles/#toric_line_bundle-Tuple{ToricDivisorClass}","page":"Toric Line Bundles","title":"toric_line_bundle","text":"toric_line_bundle(dc::ToricDivisorClass)\n\nConstruct the toric variety associated to a divisor class in the class group of a toric variety.\n\nExamples\n\njulia> v = projective_space(NormalToricVariety, 2)\nNormal toric variety\n\njulia> d = toric_divisor(v, [1, 2, 3])\nTorus-invariant, non-prime divisor on a normal toric variety\n\njulia> dc = toric_divisor_class(d)\nDivisor class on a normal toric variety\n\njulia> l = toric_line_bundle(dc)\nToric line bundle on a normal toric variety\n\n\n\n\n\n","category":"method"},{"location":"AlgebraicGeometry/ToricVarieties/ToricLineBundles/#Tensor-products","page":"Toric Line Bundles","title":"Tensor products","text":"","category":"section"},{"location":"AlgebraicGeometry/ToricVarieties/ToricLineBundles/","page":"Toric Line Bundles","title":"Toric Line Bundles","text":"Toric line bundles can be tensored via *. The n-th tensor power can be computed via ^n. In particular, ^(-1) computes the inverse of a line bundle. Alternatively, one can compute the inverse by invoking inv.","category":"page"},{"location":"AlgebraicGeometry/ToricVarieties/ToricLineBundles/#Special-line-bundles","page":"Toric Line Bundles","title":"Special line bundles","text":"","category":"section"},{"location":"AlgebraicGeometry/ToricVarieties/ToricLineBundles/","page":"Toric Line Bundles","title":"Toric Line Bundles","text":"anticanonical_bundle(v::NormalToricVarietyType)\ncanonical_bundle(v::NormalToricVarietyType)\nstructure_sheaf(v::NormalToricVarietyType)\ntrivial_line_bundle(v::NormalToricVarietyType)","category":"page"},{"location":"AlgebraicGeometry/ToricVarieties/ToricLineBundles/#anticanonical_bundle-Tuple{Union{AffineNormalToricVariety, CyclicQuotientSingularity, NormalToricVariety}}","page":"Toric Line Bundles","title":"anticanonical_bundle","text":"anticanonical_bundle(v::NormalToricVarietyType)\n\nConstruct the anticanonical bundle of a normal toric variety.\n\nExamples\n\njulia> v = projective_space(NormalToricVariety, 2)\nNormal toric variety\n\njulia> anticanonical_bundle(v)\nToric line bundle on a normal toric variety\n\n\n\n\n\n","category":"method"},{"location":"AlgebraicGeometry/ToricVarieties/ToricLineBundles/#canonical_bundle-Tuple{Union{AffineNormalToricVariety, CyclicQuotientSingularity, NormalToricVariety}}","page":"Toric Line Bundles","title":"canonical_bundle","text":"canonical_bundle(v::NormalToricVarietyType)\n\nConstruct the canonical bundle of a normal toric variety.\n\nExamples\n\njulia> v = projective_space(NormalToricVariety, 2)\nNormal toric variety\n\njulia> canonical_bundle(v)\nToric line bundle on a normal toric variety\n\n\n\n\n\n","category":"method"},{"location":"AlgebraicGeometry/ToricVarieties/ToricLineBundles/#structure_sheaf-Tuple{Union{AffineNormalToricVariety, CyclicQuotientSingularity, NormalToricVariety}}","page":"Toric Line Bundles","title":"structure_sheaf","text":"structure_sheaf(v::NormalToricVarietyType)\n\nConstruct the structure sheaf of a normal toric variety.\n\nExamples\n\njulia> v = projective_space(NormalToricVariety, 2)\nNormal toric variety\n\njulia> structure_sheaf(v)\nToric line bundle on a normal toric variety\n\n\n\n\n\n","category":"method"},{"location":"AlgebraicGeometry/ToricVarieties/ToricLineBundles/#trivial_line_bundle-Tuple{Union{AffineNormalToricVariety, CyclicQuotientSingularity, NormalToricVariety}}","page":"Toric Line Bundles","title":"trivial_line_bundle","text":"trivial_line_bundle(v::NormalToricVarietyType)\n\nConstruct the trivial line bundle on a normal toric variety.\n\nExamples\n\njulia> v = projective_space(NormalToricVariety, 2)\nNormal toric variety\n\njulia> l = trivial_line_bundle(v)\nToric line bundle on a normal toric variety\n\njulia> is_trivial(l)\ntrue\n\n\n\n\n\n","category":"method"},{"location":"AlgebraicGeometry/ToricVarieties/ToricLineBundles/#Properties","page":"Toric Line Bundles","title":"Properties","text":"","category":"section"},{"location":"AlgebraicGeometry/ToricVarieties/ToricLineBundles/","page":"Toric Line Bundles","title":"Toric Line Bundles","text":"Equality of toric line bundles can be tested via ==.","category":"page"},{"location":"AlgebraicGeometry/ToricVarieties/ToricLineBundles/","page":"Toric Line Bundles","title":"Toric Line Bundles","text":"To check if a toric line bundle is trivial, one can invoke is_trivial. Beyond this, we support the following properties of toric line bundles:","category":"page"},{"location":"AlgebraicGeometry/ToricVarieties/ToricLineBundles/","page":"Toric Line Bundles","title":"Toric Line Bundles","text":"is_ample(l::ToricLineBundle)\nis_basepoint_free(l::ToricLineBundle)\nis_immaculate(l::ToricLineBundle)\nis_very_ample(l::ToricLineBundle)","category":"page"},{"location":"AlgebraicGeometry/ToricVarieties/ToricLineBundles/#is_ample-Tuple{ToricLineBundle}","page":"Toric Line Bundles","title":"is_ample","text":"is_ample(l::ToricLineBundle)\n\nReturn true if the toric line bundle l is ample and false otherwise.\n\nExamples\n\njulia> F4 = hirzebruch_surface(NormalToricVariety, 4)\nNormal toric variety\n\njulia> is_ample(toric_line_bundle(F4, [1,0]))\nfalse\n\n\n\n\n\n","category":"method"},{"location":"AlgebraicGeometry/ToricVarieties/ToricLineBundles/#is_basepoint_free-Tuple{ToricLineBundle}","page":"Toric Line Bundles","title":"is_basepoint_free","text":"is_basepoint_free(l::ToricLineBundle)\n\nReturn true if the toric line bundle l is basepoint free and false otherwise.\n\nExamples\n\njulia> F4 = hirzebruch_surface(NormalToricVariety, 4)\nNormal toric variety\n\njulia> is_basepoint_free(toric_line_bundle(F4, [1, 0]))\ntrue\n\n\n\n\n\n","category":"method"},{"location":"AlgebraicGeometry/ToricVarieties/ToricLineBundles/#is_immaculate-Tuple{ToricLineBundle}","page":"Toric Line Bundles","title":"is_immaculate","text":"is_immaculate(l::ToricLineBundle)\n\nReturn true if all sheaf cohomologies of l are trivial and false otherwise.\n\nExamples\n\njulia> F4 = hirzebruch_surface(NormalToricVariety, 4)\nNormal toric variety\n\njulia> l = toric_line_bundle(F4, [1,0])\nToric line bundle on a normal toric variety\n\njulia> is_immaculate(toric_line_bundle(F4, [1,0]))\nfalse\n\njulia> all_cohomologies(l)\n3-element Vector{ZZRingElem}:\n 2\n 0\n 0\n\n\n\n\n\n","category":"method"},{"location":"AlgebraicGeometry/ToricVarieties/ToricLineBundles/#is_very_ample-Tuple{ToricLineBundle}","page":"Toric Line Bundles","title":"is_very_ample","text":"is_very_ample(l::ToricLineBundle)\n\nReturn true if the toric line bundle l is very ample and false otherwise.\n\nExamples\n\njulia> F4 = hirzebruch_surface(NormalToricVariety, 4)\nNormal toric variety\n\njulia> is_very_ample(toric_line_bundle(F4, [1,0]))\nfalse\n\n\n\n\n\n","category":"method"},{"location":"AlgebraicGeometry/ToricVarieties/ToricLineBundles/#Attributes","page":"Toric Line Bundles","title":"Attributes","text":"","category":"section"},{"location":"AlgebraicGeometry/ToricVarieties/ToricLineBundles/","page":"Toric Line Bundles","title":"Toric Line Bundles","text":"degree(l::ToricLineBundle)\npicard_class(l::ToricLineBundle)\ntoric_divisor(l::ToricLineBundle)\ntoric_divisor_class(l::ToricLineBundle)\ntoric_variety(l::ToricLineBundle)","category":"page"},{"location":"AlgebraicGeometry/ToricVarieties/ToricLineBundles/#degree-Tuple{ToricLineBundle}","page":"Toric Line Bundles","title":"degree","text":"degree(l::ToricLineBundle)\n\nReturn the degree of the toric line bundle l.\n\nExamples\n\njulia> v = projective_space(NormalToricVariety, 2)\nNormal toric variety\n\njulia> l = toric_line_bundle(v, [ZZRingElem(2)])\nToric line bundle on a normal toric variety\n\njulia> degree(l)\n2\n\n\n\n\n\n","category":"method"},{"location":"AlgebraicGeometry/ToricVarieties/ToricLineBundles/#picard_class-Tuple{ToricLineBundle}","page":"Toric Line Bundles","title":"picard_class","text":"picard_class(l::ToricLineBundle)\n\nReturn the class in the Picard group which defines the toric line bundle l.\n\nExamples\n\njulia> v = projective_space(NormalToricVariety, 2)\nNormal toric variety\n\njulia> l = toric_line_bundle(v, [ZZRingElem(2)])\nToric line bundle on a normal toric variety\n\njulia> picard_class(l)\nAbelian group element [2]\n\n\n\n\n\n","category":"method"},{"location":"AlgebraicGeometry/ToricVarieties/ToricLineBundles/#toric_divisor-Tuple{ToricLineBundle}","page":"Toric Line Bundles","title":"toric_divisor","text":"toric_divisor(l::ToricLineBundle)\n\nReturn a toric divisor corresponding to the toric line bundle l.\n\nExamples\n\njulia> v = projective_space(NormalToricVariety, 2)\nNormal toric variety\n\njulia> l = toric_line_bundle(v, [ZZRingElem(2)])\nToric line bundle on a normal toric variety\n\njulia> toric_divisor(l)\nTorus-invariant, cartier, non-prime divisor on a normal toric variety\n\njulia> is_cartier(toric_divisor(l))\ntrue\n\n\n\n\n\n","category":"method"},{"location":"AlgebraicGeometry/ToricVarieties/ToricLineBundles/#toric_divisor_class-Tuple{ToricLineBundle}","page":"Toric Line Bundles","title":"toric_divisor_class","text":"toric_divisor_class(l::ToricLineBundle)\n\nReturn a divisor class in the Class group corresponding to the toric line bundle l.\n\nExamples\n\njulia> v = projective_space(NormalToricVariety, 2)\nNormal toric variety\n\njulia> l = toric_line_bundle(v, [ZZRingElem(2)])\nToric line bundle on a normal toric variety\n\njulia> toric_divisor(l)\nTorus-invariant, cartier, non-prime divisor on a normal toric variety\n\njulia> is_cartier(toric_divisor(l))\ntrue\n\n\n\n\n\n","category":"method"},{"location":"AlgebraicGeometry/ToricVarieties/ToricLineBundles/#toric_variety-Tuple{ToricLineBundle}","page":"Toric Line Bundles","title":"toric_variety","text":"toric_variety(l::ToricLineBundle)\n\nReturn the toric variety over which the toric line bundle l is defined.\n\nExamples\n\njulia> v = projective_space(NormalToricVariety, 2)\nNormal toric variety\n\njulia> l = toric_line_bundle(v, [ZZRingElem(2)])\nToric line bundle on a normal toric variety\n\njulia> toric_variety(l)\nNormal toric variety without torusfactor\n\n\n\n\n\n","category":"method"},{"location":"AlgebraicGeometry/ToricVarieties/ToricLineBundles/#Methods","page":"Toric Line Bundles","title":"Methods","text":"","category":"section"},{"location":"AlgebraicGeometry/ToricVarieties/ToricLineBundles/","page":"Toric Line Bundles","title":"Toric Line Bundles","text":"basis_of_global_sections_via_rational_functions(l::ToricLineBundle)\nbasis_of_global_sections_via_homogeneous_component(l::ToricLineBundle)\ngeneric_section(l::ToricLineBundle)","category":"page"},{"location":"AlgebraicGeometry/ToricVarieties/ToricLineBundles/#basis_of_global_sections_via_rational_functions-Tuple{ToricLineBundle}","page":"Toric Line Bundles","title":"basis_of_global_sections_via_rational_functions","text":"basis_of_global_sections_via_rational_functions(l::ToricLineBundle)\n\nReturn a basis of the global sections of the toric line bundle l in terms of rational functions.\n\nExamples\n\njulia> v = projective_space(NormalToricVariety, 2)\nNormal toric variety\n\njulia> l = toric_line_bundle(v, [ZZRingElem(2)])\nToric line bundle on a normal toric variety\n\njulia> basis_of_global_sections_via_rational_functions(l)\n6-element Vector{MPolyQuoRingElem{QQMPolyRingElem}}:\n x1_^2\n x2*x1_^2\n x2^2*x1_^2\n x1_\n x2*x1_\n 1\n\n\n\n\n\n","category":"method"},{"location":"AlgebraicGeometry/ToricVarieties/ToricLineBundles/#basis_of_global_sections_via_homogeneous_component-Tuple{ToricLineBundle}","page":"Toric Line Bundles","title":"basis_of_global_sections_via_homogeneous_component","text":"basis_of_global_sections_via_homogeneous_component(l::ToricLineBundle)\n\nReturn a basis of the global sections of the toric line bundle l in terms of a homogeneous component of the Cox ring of toric_variety(l). For convenience, this method can also be called via basis_of_global_sections(l::ToricLineBundle).\n\nExamples\n\njulia> v = projective_space(NormalToricVariety, 2)\nNormal toric variety\n\njulia> l = toric_line_bundle(v, [ZZRingElem(2)])\nToric line bundle on a normal toric variety\n\njulia> basis_of_global_sections_via_homogeneous_component(l)\n6-element Vector{MPolyDecRingElem{QQFieldElem, QQMPolyRingElem}}:\n x3^2\n x2*x3\n x2^2\n x1*x3\n x1*x2\n x1^2\n\njulia> basis_of_global_sections(l)\n6-element Vector{MPolyDecRingElem{QQFieldElem, QQMPolyRingElem}}:\n x3^2\n x2*x3\n x2^2\n x1*x3\n x1*x2\n x1^2\n\n\n\n\n\n","category":"method"},{"location":"AlgebraicGeometry/ToricVarieties/ToricLineBundles/#generic_section-Tuple{ToricLineBundle}","page":"Toric Line Bundles","title":"generic_section","text":"generic_section(l::ToricLineBundle)\n\nReturn a generic section of the toric line bundle l, that is return the sum of all elements basis_of_global_sections(l), each multiplied by a random integer.\n\nThe optional keyword argument range can be used to set the range of the random integers, e.g., generic_section(l, range = -100:100)\n\nExamples\n\njulia> v = projective_space(NormalToricVariety, 2)\nNormal toric variety\n\njulia> l = toric_line_bundle(v, [ZZRingElem(2)])\nToric line bundle on a normal toric variety\n\njulia> s = generic_section(l);\n\njulia> parent(s) == cox_ring(toric_variety(l))\ntrue\n\n\n\n\n\n","category":"method"},{"location":"AlgebraicGeometry/ToricVarieties/CohomologyClasses/","page":"Cohomology Classes","title":"Cohomology Classes","text":"CurrentModule = Oscar","category":"page"},{"location":"AlgebraicGeometry/ToricVarieties/CohomologyClasses/#Cohomology-Classes","page":"Cohomology Classes","title":"Cohomology Classes","text":"","category":"section"},{"location":"AlgebraicGeometry/ToricVarieties/CohomologyClasses/#Constructors","page":"Cohomology Classes","title":"Constructors","text":"","category":"section"},{"location":"AlgebraicGeometry/ToricVarieties/CohomologyClasses/#General-constructors","page":"Cohomology Classes","title":"General constructors","text":"","category":"section"},{"location":"AlgebraicGeometry/ToricVarieties/CohomologyClasses/","page":"Cohomology Classes","title":"Cohomology Classes","text":"cohomology_class(v::NormalToricVarietyType, p::MPolyQuoRingElem)\ncohomology_class(d::ToricDivisor)\ncohomology_class(c::ToricDivisorClass)\ncohomology_class(l::ToricLineBundle)","category":"page"},{"location":"AlgebraicGeometry/ToricVarieties/CohomologyClasses/#cohomology_class-Tuple{Union{AffineNormalToricVariety, CyclicQuotientSingularity, NormalToricVariety}, MPolyQuoRingElem}","page":"Cohomology Classes","title":"cohomology_class","text":"cohomology_class(v::NormalToricVarietyType, p::MPolyQuoRingElem)\n\nConstruct the toric cohomology class on the toric variety v corresponding to the polynomial p. Note that p must reside in the cohomology ring of v.\n\nExamples\n\njulia> P2 = projective_space(NormalToricVariety, 2)\nNormal toric variety\n\njulia> c = cohomology_class(P2, gens(cohomology_ring(P2))[1])\nCohomology class on a normal toric variety given by x1\n\n\n\n\n\n","category":"method"},{"location":"AlgebraicGeometry/ToricVarieties/CohomologyClasses/#cohomology_class-Tuple{ToricDivisor}","page":"Cohomology Classes","title":"cohomology_class","text":"cohomology_class(d::ToricDivisor)\n\nConstruct the toric cohomology class corresponding to the toric divisor d.\n\nExamples\n\njulia> P2 = projective_space(NormalToricVariety, 2)\nNormal toric variety\n\njulia> d = toric_divisor(P2, [1, 2, 3])\nTorus-invariant, non-prime divisor on a normal toric variety\n\njulia> cohomology_class(d)\nCohomology class on a normal toric variety given by 6*x3\n\n\n\n\n\n","category":"method"},{"location":"AlgebraicGeometry/ToricVarieties/CohomologyClasses/#cohomology_class-Tuple{ToricDivisorClass}","page":"Cohomology Classes","title":"cohomology_class","text":"cohomology_class(c::ToricDivisorClass)\n\nConstruct the toric cohomology class corresponding to the toric divisor class c.\n\nExamples\n\njulia> P2 = projective_space(NormalToricVariety, 2)\nNormal toric variety\n\njulia> tdc = toric_divisor_class(P2, [2])\nDivisor class on a normal toric variety\n\njulia> cohomology_class(tdc)\nCohomology class on a normal toric variety given by 2*x3\n\n\n\n\n\n","category":"method"},{"location":"AlgebraicGeometry/ToricVarieties/CohomologyClasses/#cohomology_class-Tuple{ToricLineBundle}","page":"Cohomology Classes","title":"cohomology_class","text":"cohomology_class(l::ToricLineBundle)\n\nConstruct the toric cohomology class corresponding to the toric line bundle l.\n\nExamples\n\njulia> P2 = projective_space(NormalToricVariety, 2)\nNormal toric variety\n\njulia> l = toric_line_bundle(P2, [2])\nToric line bundle on a normal toric variety\n\njulia> polynomial(cohomology_class(l))\n2*x3\n\n\n\n\n\n","category":"method"},{"location":"AlgebraicGeometry/ToricVarieties/CohomologyClasses/#Addition,-subtraction-and-scalar-multiplication","page":"Cohomology Classes","title":"Addition, subtraction and scalar multiplication","text":"","category":"section"},{"location":"AlgebraicGeometry/ToricVarieties/CohomologyClasses/","page":"Cohomology Classes","title":"Cohomology Classes","text":"Cohomology classes can be added and subtracted via the usual + and - operators. Moreover, multiplication by scalars from the left is supported for scalars which are integers or of type ZZRingElem or QQFieldElem.","category":"page"},{"location":"AlgebraicGeometry/ToricVarieties/CohomologyClasses/#Wedge-product","page":"Cohomology Classes","title":"Wedge product","text":"","category":"section"},{"location":"AlgebraicGeometry/ToricVarieties/CohomologyClasses/","page":"Cohomology Classes","title":"Cohomology Classes","text":"The wedge product of cohomology classes is implemented via *,  using internally the multiplication of the corresponding polynomial  (equivalence classes) in the Cox ring.","category":"page"},{"location":"AlgebraicGeometry/ToricVarieties/CohomologyClasses/","page":"Cohomology Classes","title":"Cohomology Classes","text":"A cohomology class can be wedged n-times with itself via ^n, where n can be an integer or of type ZZRingElem.","category":"page"},{"location":"AlgebraicGeometry/ToricVarieties/CohomologyClasses/#Properties","page":"Cohomology Classes","title":"Properties","text":"","category":"section"},{"location":"AlgebraicGeometry/ToricVarieties/CohomologyClasses/","page":"Cohomology Classes","title":"Cohomology Classes","text":"One can check if a cohomology class is trivial via is_trivial.","category":"page"},{"location":"AlgebraicGeometry/ToricVarieties/CohomologyClasses/","page":"Cohomology Classes","title":"Cohomology Classes","text":"Equality of cohomology classes can be tested via ==.","category":"page"},{"location":"AlgebraicGeometry/ToricVarieties/CohomologyClasses/#Attributes","page":"Cohomology Classes","title":"Attributes","text":"","category":"section"},{"location":"AlgebraicGeometry/ToricVarieties/CohomologyClasses/","page":"Cohomology Classes","title":"Cohomology Classes","text":"toric_variety(c::CohomologyClass)\ncoefficients(c::CohomologyClass)\nexponents(c::CohomologyClass)\npolynomial(c::CohomologyClass)\npolynomial(ring::MPolyQuoRing, c::CohomologyClass)","category":"page"},{"location":"AlgebraicGeometry/ToricVarieties/CohomologyClasses/#toric_variety-Tuple{CohomologyClass}","page":"Cohomology Classes","title":"toric_variety","text":"toric_variety(c::CohomologyClass)\n\nReturn the normal toric variety of the cohomology class c.\n\nExamples\n\njulia> dP2 = del_pezzo_surface(NormalToricVariety, 2)\nNormal toric variety\n\njulia> d = toric_divisor(dP2, [1, 2, 3, 4, 5])\nTorus-invariant, non-prime divisor on a normal toric variety\n\njulia> cc = cohomology_class(d)\nCohomology class on a normal toric variety given by 6*x3 + e1 + 7*e2\n\njulia> toric_variety(cc)\nNormal, simplicial, complete toric variety\n\n\n\n\n\n","category":"method"},{"location":"AlgebraicGeometry/ToricVarieties/CohomologyClasses/#coefficients-Tuple{CohomologyClass}","page":"Cohomology Classes","title":"coefficients","text":"coefficients(c::CohomologyClass)\n\nReturn the coefficients of the cohomology class c.\n\nExamples\n\njulia> dP2 = del_pezzo_surface(NormalToricVariety, 2)\nNormal toric variety\n\njulia> d = toric_divisor(dP2, [1, 2, 3, 4, 5])\nTorus-invariant, non-prime divisor on a normal toric variety\n\njulia> cc = cohomology_class(d)\nCohomology class on a normal toric variety given by 6*x3 + e1 + 7*e2\n\njulia> coefficients(cc)\n3-element Vector{QQFieldElem}:\n 6\n 1\n 7\n\n\n\n\n\n","category":"method"},{"location":"AlgebraicGeometry/ToricVarieties/CohomologyClasses/#exponents-Tuple{CohomologyClass}","page":"Cohomology Classes","title":"exponents","text":"exponents(c::CohomologyClass)\n\nReturn the exponents of the cohomology class c.\n\nExamples\n\njulia> dP2 = del_pezzo_surface(NormalToricVariety, 2)\nNormal toric variety\n\njulia> d = toric_divisor(dP2, [1, 2, 3, 4, 5])\nTorus-invariant, non-prime divisor on a normal toric variety\n\njulia> cc = cohomology_class(d)\nCohomology class on a normal toric variety given by 6*x3 + e1 + 7*e2\n\njulia> exponents(cc)\n[0   0   1   0   0]\n[0   0   0   1   0]\n[0   0   0   0   1]\n\n\n\n\n\n","category":"method"},{"location":"AlgebraicGeometry/ToricVarieties/CohomologyClasses/#polynomial-Tuple{CohomologyClass}","page":"Cohomology Classes","title":"polynomial","text":"polynomial(c::CohomologyClass)\n\nReturn the polynomial in the cohomology ring of the normal toric variety toric_variety(c) which corresponds to c.\n\nExamples\n\njulia> dP2 = del_pezzo_surface(NormalToricVariety, 2)\nNormal toric variety\n\njulia> d = toric_divisor(dP2, [1, 2, 3, 4, 5])\nTorus-invariant, non-prime divisor on a normal toric variety\n\njulia> cc = cohomology_class(d)\nCohomology class on a normal toric variety given by 6*x3 + e1 + 7*e2\n\njulia> polynomial(cc)\n6*x3 + e1 + 7*e2\n\n\n\n\n\n","category":"method"},{"location":"AlgebraicGeometry/ToricVarieties/CohomologyClasses/#polynomial-Tuple{MPolyQuoRing, CohomologyClass}","page":"Cohomology Classes","title":"polynomial","text":"polynomial(c::CohomologyClass, ring::MPolyQuoRing)\n\nReturn the polynomial in ring corresponding to the cohomology class c.\n\nExamples\n\njulia> dP2 = del_pezzo_surface(NormalToricVariety, 2)\nNormal toric variety\n\njulia> d = toric_divisor(dP2, [1, 2, 3, 4, 5])\nTorus-invariant, non-prime divisor on a normal toric variety\n\njulia> cc = cohomology_class(d)\nCohomology class on a normal toric variety given by 6*x3 + e1 + 7*e2\n\njulia> R, _ = polynomial_ring(QQ, 5)\n(Multivariate polynomial ring in 5 variables over QQ, QQMPolyRingElem[x1, x2, x3, x4, x5])\n\njulia> (x1, x2, x3, x4, x5) = gens(R)\n5-element Vector{QQMPolyRingElem}:\n x1\n x2\n x3\n x4\n x5\n\njulia> sr_and_linear_relation_ideal = ideal([x1*x3, x1*x5, x2*x4, x2*x5, x3*x4, x1 + x2 - x5, x2 + x3 - x4 - x5])\nIdeal generated by\n  x1*x3\n  x1*x5\n  x2*x4\n  x2*x5\n  x3*x4\n  x1 + x2 - x5\n  x2 + x3 - x4 - x5\n\njulia> R_quo = quo(R, sr_and_linear_relation_ideal)[1]\nQuotient\n  of multivariate polynomial ring in 5 variables x1, x2, x3, x4, x5\n    over rational field\n  by ideal (x1*x3, x1*x5, x2*x4, x2*x5, x3*x4, x1 + x2 - x5, x2 + x3 - x4 - x5)\n\njulia> polynomial(R_quo, cc)\n6*x3 + x4 + 7*x5\n\n\n\n\n\n","category":"method"},{"location":"AlgebraicGeometry/ToricVarieties/CohomologyClasses/#Methods","page":"Cohomology Classes","title":"Methods","text":"","category":"section"},{"location":"AlgebraicGeometry/ToricVarieties/CohomologyClasses/","page":"Cohomology Classes","title":"Cohomology Classes","text":"integrate(c::CohomologyClass; check::Bool = true)","category":"page"},{"location":"AlgebraicGeometry/ToricVarieties/CohomologyClasses/#integrate-Tuple{CohomologyClass}","page":"Cohomology Classes","title":"integrate","text":"integrate(c::CohomologyClass; check::Bool = true)\n\nIntegrate the cohomolgy class c over the normal toric variety toric_variety(c).\n\nThe theory underlying this method requires that the toric variety in question is simplicial and complete. The check of completeness may take a long time to complete. If desired, this can be switched off by setting the optional argument check to the value false.\n\nExamples\n\njulia> dP3 = del_pezzo_surface(NormalToricVariety, 3)\nNormal toric variety\n\njulia> (x1, x2, x3, e1, e2, e3) = gens(cohomology_ring(dP3))\n6-element Vector{MPolyQuoRingElem{MPolyDecRingElem{QQFieldElem, QQMPolyRingElem}}}:\n x1\n x2\n x3\n e1\n e2\n e3\n\njulia> c = cohomology_class(dP3, e3*e3 + e3)\nCohomology class on a normal toric variety given by e3^2 + e3\n\njulia> integrate(c)\n-1\n\njulia> F3 = hirzebruch_surface(NormalToricVariety, 3)\nNormal toric variety\n\njulia> (x1, x2, x3, x4) = gens(cohomology_ring(F3))\n4-element Vector{MPolyQuoRingElem{MPolyDecRingElem{QQFieldElem, QQMPolyRingElem}}}:\n t1\n x1\n t2\n x2\n\njulia> c = cohomology_class(F3, x1*x2 + x3*x4)\nCohomology class on a normal toric variety given by 2//3*x2^2\n\njulia> integrate(c)\n2\n\nThe following example constructs the Fano variety 2-36 (cf. https://www.fanography.info/2-36) and verifies that the triple self-intersection number of its anticanonical bundle is 62.\n\nExamples\n\njulia> e1 = [1,0,0];\n\njulia> e2 = [0,1,0];\n\njulia> e3 = [0,0,1];\n\njulia> m = 2;\n\njulia> ray_generators = [e1, -e1, e2, e3, - e2 - e3 - m * e1];\n\njulia> max_cones = incidence_matrix([[1,3,4], [1,3,5], [1,4,5], [2,3,4], [2,3,5], [2,4,5]]);\n\njulia> X = normal_toric_variety(max_cones, ray_generators; non_redundant = true)\nNormal toric variety\n\njulia> cox_ring(X)\nMultivariate polynomial ring in 5 variables over QQ graded by\n  x1 -> [1 0]\n  x2 -> [1 2]\n  x3 -> [0 -1]\n  x4 -> [0 -1]\n  x5 -> [0 -1]\n\njulia> cohomology_ring(X)\nQuotient\n  of multivariate polynomial ring in 5 variables over QQ graded by\n    x1 -> [1]\n    x2 -> [1]\n    x3 -> [1]\n    x4 -> [1]\n    x5 -> [1]\n  by ideal (x1 - x2 - 2*x5, x3 - x5, x4 - x5, x1*x2, x3*x4*x5)\n\njulia> integrate(cohomology_class(anticanonical_divisor(X))^3)\n62\n\njulia> integrate(cohomology_class(anticanonical_divisor_class(X))^3)\n62\n\n\n\n\n\n","category":"method"},{"location":"AlgebraicGeometry/ToricVarieties/CohomologyClasses/#Special-attributes-of-toric-varieties","page":"Cohomology Classes","title":"Special attributes of toric varieties","text":"","category":"section"},{"location":"AlgebraicGeometry/ToricVarieties/CohomologyClasses/","page":"Cohomology Classes","title":"Cohomology Classes","text":"cohomology_ring(v::NormalToricVarietyType; check::Bool = true)\nvolume_form(v::NormalToricVariety)\nintersection_form(v::NormalToricVariety)\nchern_class(v::NormalToricVariety, k::Int; check::Bool = true)\nchern_classes(v::NormalToricVariety; check::Bool = true)\nbasis_of_h4(v::NormalToricVariety; check::Bool = true)","category":"page"},{"location":"AlgebraicGeometry/ToricVarieties/CohomologyClasses/#cohomology_ring-Tuple{Union{AffineNormalToricVariety, CyclicQuotientSingularity, NormalToricVariety}}","page":"Cohomology Classes","title":"cohomology_ring","text":"cohomology_ring(v::NormalToricVarietyType; check::Bool = true)\n\nReturn the cohomology ring of the simplicial and complete toric variety v.\n\nExamples\n\njulia> p2 = projective_space(NormalToricVariety, 2);\n\njulia> ngens(cohomology_ring(p2))\n3\n\n\n\n\n\n","category":"method"},{"location":"AlgebraicGeometry/ToricVarieties/CohomologyClasses/#volume_form-Tuple{NormalToricVariety}","page":"Cohomology Classes","title":"volume_form","text":"volume_form(v::NormalToricVariety)\n\nConstruct the volume form of the normal toric toric variety v.\n\nExamples\n\njulia> polynomial(volume_form(projective_space(NormalToricVariety, 2)))\nx3^2\n\njulia> polynomial(volume_form(del_pezzo_surface(NormalToricVariety, 3)))\n-e3^2\n\njulia> polynomial(volume_form(hirzebruch_surface(NormalToricVariety, 5)))\n1//5*x2^2\n\n\n\n\n\n","category":"method"},{"location":"AlgebraicGeometry/ToricVarieties/CohomologyClasses/#intersection_form-Tuple{NormalToricVariety}","page":"Cohomology Classes","title":"intersection_form","text":"intersection_form(v::NormalToricVariety)\n\nComputes the intersection numbers among the cohomology classes associated to the torusinvariant prime divisors of the normal toric toric variety v.\n\nExamples\n\njulia> F3 = hirzebruch_surface(NormalToricVariety, 3)\nNormal toric variety\n\njulia> length(intersection_form(F3))\n10\n\n\n\n\n\n","category":"method"},{"location":"AlgebraicGeometry/ToricVarieties/CohomologyClasses/#chern_class-Tuple{NormalToricVariety, Int64}","page":"Cohomology Classes","title":"chern_class","text":"chern_class(v::NormalToricVariety, k::Int; check::Bool = true)\n\nComputes the k-th Chern class of the tangent bundle of a normal toric variety that is both smooth and complete. Since these checks can be computationally very demanding, we provide an optional argument check. Once set to false, this method skips those tests.\n\nThe implemented algorithm uses proposition 13.1.2 in [CLS11].\n\nExamples\n\njulia> F3 = hirzebruch_surface(NormalToricVariety, 3)\nNormal toric variety\n\njulia> chern_class(F3, 0)\nCohomology class on a normal toric variety given by 1\n\njulia> chern_class(F3, 1, check = false)\nCohomology class on a normal toric variety given by t1 + x1 + t2 + x2\n\njulia> integrate(chern_class(F3, 2), check = false)\n4\n\n\n\n\n\n","category":"method"},{"location":"AlgebraicGeometry/ToricVarieties/CohomologyClasses/#chern_classes-Tuple{NormalToricVariety}","page":"Cohomology Classes","title":"chern_classes","text":"chern_classes(v::NormalToricVariety; check::Bool = true)\n\nComputes all Chern classes of the tangent bundle of a normal toric variety, which is smooth and complete. Since those checks can be computationally very demanding, the optional argument check can be set to false to skip those tests.\n\nExamples\n\njulia> F3 = hirzebruch_surface(NormalToricVariety, 3)\nNormal toric variety\n\njulia> cs = chern_classes(F3)\n3-element Vector{CohomologyClass}:\n Cohomology class on a normal toric variety given by 1\n Cohomology class on a normal toric variety given by t1 + x1 + t2 + x2\n Cohomology class on a normal toric variety given by 4//3*x2^2\n\njulia> integrate(cs[3])\n4\n\n\n\n\n\n","category":"method"},{"location":"AlgebraicGeometry/ToricVarieties/CohomologyClasses/#basis_of_h4-Tuple{NormalToricVariety}","page":"Cohomology Classes","title":"basis_of_h4","text":"basis_of_h4(v::NormalToricVariety; check::Bool = true)\n\nThis method computes a monomial basis of the cohomology class H^4(X mathbbQ) for a toric variety X. The algorithm employs Theorem 12.4.1 in [CLS11], i.e. truncates the cohomology ring to degree 2. By virtue of this theorem, this approach is supported only for toric varieties that are both complete and simplicial. Since it can be computationally very demanding to verify completeness, the optional argument check can be set to false to skip the tests.\n\nExamples\n\njulia> Y1 = hirzebruch_surface(NormalToricVariety, 2)\nNormal toric variety\n\njulia> Y2 = hirzebruch_surface(NormalToricVariety, 2)\nNormal toric variety\n\njulia> Y = Y1 * Y2\nNormal toric variety\n\njulia> h4_basis = basis_of_h4(Y)\n6-element Vector{CohomologyClass}:\n Cohomology class on a normal toric variety given by yx2^2\n Cohomology class on a normal toric variety given by xx2*yx2\n Cohomology class on a normal toric variety given by xx2*yt2\n Cohomology class on a normal toric variety given by xx2^2\n Cohomology class on a normal toric variety given by xt2*yx2\n Cohomology class on a normal toric variety given by xt2*yt2\n\njulia> betti_number(Y, 4) == length(h4_basis)\ntrue\n\n\n\n\n\n","category":"method"},{"location":"AbstractAlgebra/submodule/","page":"Submodules","title":"Submodules","text":"CurrentModule = AbstractAlgebra\nDocTestSetup = AbstractAlgebra.doctestsetup()","category":"page"},{"location":"AbstractAlgebra/submodule/#Submodules","page":"Submodules","title":"Submodules","text":"","category":"section"},{"location":"AbstractAlgebra/submodule/","page":"Submodules","title":"Submodules","text":"AbstractAlgebra allows the construction of submodules/subvector spaces of AbstractAlgebra modules over euclidean domains. These are given as the submodule generated by a finite list of elements in the original module.","category":"page"},{"location":"AbstractAlgebra/submodule/","page":"Submodules","title":"Submodules","text":"We define two submodules to be equal if they are (transitively) submodules of the same module M and their generators generate the same set of elements.","category":"page"},{"location":"AbstractAlgebra/submodule/#Generic-submodule-type","page":"Submodules","title":"Generic submodule type","text":"","category":"section"},{"location":"AbstractAlgebra/submodule/","page":"Submodules","title":"Submodules","text":"AbstractAlgebra implements a generic submodule type Generic.Submodule{T} where T is the element type of the base ring in src/generic/Submodule.jl. See src/generic/GenericTypes.jl for more details of the type definition.","category":"page"},{"location":"AbstractAlgebra/submodule/","page":"Submodules","title":"Submodules","text":"Elements of a generic submodule have type Generic.SubmoduleElem{T}.","category":"page"},{"location":"AbstractAlgebra/submodule/#Abstract-types","page":"Submodules","title":"Abstract types","text":"","category":"section"},{"location":"AbstractAlgebra/submodule/","page":"Submodules","title":"Submodules","text":"Submodule types belong to the abstract type FPModule{T} and their elements to FPModuleElem{T}.","category":"page"},{"location":"AbstractAlgebra/submodule/#Constructors","page":"Submodules","title":"Constructors","text":"","category":"section"},{"location":"AbstractAlgebra/submodule/","page":"Submodules","title":"Submodules","text":"sub(::FPModule{T}, ::Vector{FPModuleElem{T}}) where T <: RingElement","category":"page"},{"location":"AbstractAlgebra/submodule/#sub-Union{Tuple{T}, Tuple{AbstractAlgebra.FPModule{T}, Array{AbstractAlgebra.FPModuleElem{T}, 1}}} where T<:RingElement","page":"Submodules","title":"sub","text":"sub(m::FPModule{T}, gens::Vector{<:FPModuleElem{T}}) where T <: RingElement\n\nReturn the submodule of the module m generated by the given generators, given as elements of m.\n\n\n\n\n\n","category":"method"},{"location":"AbstractAlgebra/submodule/","page":"Submodules","title":"Submodules","text":"sub(::FPModule{T}, ::Vector{Generic.Submodule{T}}) where T <: RingElement","category":"page"},{"location":"AbstractAlgebra/submodule/#sub-Union{Tuple{T}, Tuple{AbstractAlgebra.FPModule{T}, Array{AbstractAlgebra.Generic.Submodule{T}, 1}}} where T<:RingElement","page":"Submodules","title":"sub","text":"sub(m::Module{T}, subs::Vector{<:Generic.Submodule{T}}) where T <: RingElement\n\nReturn the submodule S of the module m generated by the union of the given submodules of m, and a map which is the canonical injection from S to m.\n\n\n\n\n\n","category":"method"},{"location":"AbstractAlgebra/submodule/","page":"Submodules","title":"Submodules","text":"Note that the preimage of the canonical injection can be obtained using the preimage function described in the section on module homomorphisms. As the canonical injection is injective, this is unique.","category":"page"},{"location":"AbstractAlgebra/submodule/","page":"Submodules","title":"Submodules","text":"Examples","category":"page"},{"location":"AbstractAlgebra/submodule/","page":"Submodules","title":"Submodules","text":"julia> M = free_module(ZZ, 2)\nFree module of rank 2 over integers\n\njulia> m = M([ZZ(1), ZZ(2)])\n(1, 2)\n\njulia> n = M([ZZ(2), ZZ(-1)])\n(2, -1)\n\njulia> N, f = sub(M, [m, n])\n(Submodule over integers with 2 generators and no relations, Hom: N -> M)\n\njulia> v = N([ZZ(3), ZZ(4)])\n(3, 4)\n\njulia> v2 = f(v)\n(3, 26)\n\njulia> V = vector_space(QQ, 2)\nVector space of dimension 2 over rationals\n\njulia> m = V([QQ(1), QQ(2)])\n(1//1, 2//1)\n\njulia> n = V([QQ(2), QQ(-1)])\n(2//1, -1//1)\n\njulia> N, f = sub(V, [m, n])\n(Subspace over rationals with 2 generators and no relations, Hom: N -> V)\n","category":"page"},{"location":"AbstractAlgebra/submodule/#Functionality-for-submodules","page":"Submodules","title":"Functionality for submodules","text":"","category":"section"},{"location":"AbstractAlgebra/submodule/","page":"Submodules","title":"Submodules","text":"In addition to the Module interface, AbstractAlgebra submodules implement the following functionality.","category":"page"},{"location":"AbstractAlgebra/submodule/#Basic-manipulation","page":"Submodules","title":"Basic manipulation","text":"","category":"section"},{"location":"AbstractAlgebra/submodule/","page":"Submodules","title":"Submodules","text":"supermodule(::Generic.Submodule{T}) where T <: RingElement","category":"page"},{"location":"AbstractAlgebra/submodule/#supermodule-Union{Tuple{AbstractAlgebra.Generic.Submodule{T}}, Tuple{T}} where T<:RingElement","page":"Submodules","title":"supermodule","text":"supermodule(M::Submodule{T}) where T <: RingElement\n\nReturn the module that this module is a submodule of.\n\n\n\n\n\n","category":"method"},{"location":"AbstractAlgebra/submodule/","page":"Submodules","title":"Submodules","text":"is_submodule(::FPModule{T}, ::FPModule{T}) where T <: RingElement","category":"page"},{"location":"AbstractAlgebra/submodule/#is_submodule-Union{Tuple{T}, Tuple{AbstractAlgebra.FPModule{T}, AbstractAlgebra.FPModule{T}}} where T<:RingElement","page":"Submodules","title":"is_submodule","text":"is_submodule(M::AbstractAlgebra.FPModule{T}, N::AbstractAlgebra.FPModule{T}) where T <: RingElement\n\nReturn true if N was constructed as a submodule of M. The relation is taken transitively (i.e. subsubmodules are submodules for the purposes of this relation, etc). The module M is also considered a submodule of itself for this relation.\n\n\n\n\n\n","category":"method"},{"location":"AbstractAlgebra/submodule/","page":"Submodules","title":"Submodules","text":"is_compatible(::FPModule{T}, ::FPModule{T}) where T <: RingElement","category":"page"},{"location":"AbstractAlgebra/submodule/#is_compatible-Union{Tuple{T}, Tuple{AbstractAlgebra.FPModule{T}, AbstractAlgebra.FPModule{T}}} where T<:RingElement","page":"Submodules","title":"is_compatible","text":"is_compatible(M::AbstractAlgebra.FPModule{T}, N::AbstractAlgebra.FPModule{T}) where T <: RingElement\n\nReturn true, P if the given modules are compatible, i.e. that they are (transitively) submodules of the same module, P. Otherwise return false, M.\n\n\n\n\n\n","category":"method"},{"location":"AbstractAlgebra/submodule/","page":"Submodules","title":"Submodules","text":"dim(N::Generic.Submodule{T}) where T <: FieldElement","category":"page"},{"location":"AbstractAlgebra/submodule/#dim-Union{Tuple{AbstractAlgebra.Generic.Submodule{T}}, Tuple{T}} where T<:FieldElement","page":"Submodules","title":"dim","text":"dim(N::Submodule{T}) where T <: FieldElement\n\nReturn the dimension of the given vector subspace.\n\n\n\n\n\n","category":"method"},{"location":"AbstractAlgebra/submodule/","page":"Submodules","title":"Submodules","text":"Examples","category":"page"},{"location":"AbstractAlgebra/submodule/","page":"Submodules","title":"Submodules","text":"julia> M = free_module(ZZ, 2)\nFree module of rank 2 over integers\n\njulia> m = M([ZZ(2), ZZ(3)])\n(2, 3)\n\njulia> n = M([ZZ(1), ZZ(4)])\n(1, 4)\n\njulia> N1, = sub(M, [m, n])\n(Submodule over integers with 2 generators and no relations, Hom: N1 -> M)\n\njulia> N2, = sub(M, [m])\n(Submodule over integers with 1 generator and no relations, Hom: N2 -> M)\n\njulia> supermodule(N1) == M\ntrue\n\njulia> is_compatible(N1, N2)\n(true, Free module of rank 2 over integers)\n\njulia> is_submodule(N1, M)\nfalse\n\njulia> V = vector_space(QQ, 2)\nVector space of dimension 2 over rationals\n\njulia> m = V([QQ(2), QQ(3)])\n(2//1, 3//1)\n\njulia> N, = sub(V, [m])\n(Subspace over rationals with 1 generator and no relations, Hom: N -> V)\n\njulia> dim(V)\n2\n\njulia> dim(N)\n1","category":"page"},{"location":"AbstractAlgebra/submodule/#Intersection","page":"Submodules","title":"Intersection","text":"","category":"section"},{"location":"AbstractAlgebra/submodule/","page":"Submodules","title":"Submodules","text":"intersect(M::FPModule{T}, N::FPModule{T}) where\nT <: RingElement","category":"page"},{"location":"AbstractAlgebra/submodule/#intersect-Union{Tuple{T}, Tuple{AbstractAlgebra.FPModule{T}, AbstractAlgebra.FPModule{T}}} where T<:RingElement","page":"Submodules","title":"intersect","text":"intersect(M::FPModule{T}, N::FPModule{T}) where T <: RingElement\n\nReturn the intersection of the modules M as a submodule of M. Note that M and N must be (constructed as) submodules (transitively) of some common module P.\n\n\n\n\n\n","category":"method"},{"location":"AbstractAlgebra/submodule/","page":"Submodules","title":"Submodules","text":"Examples","category":"page"},{"location":"AbstractAlgebra/submodule/","page":"Submodules","title":"Submodules","text":"julia> M = free_module(ZZ, 2)\nFree module of rank 2 over integers\n\njulia> m = M([ZZ(2), ZZ(3)])\n(2, 3)\n\njulia> n = M([ZZ(1), ZZ(4)])\n(1, 4)\n\njulia> N1 = sub(M, [m, n])\n(Submodule over integers with 2 generators and no relations, Hom: submodule over integers with 2 generators and no relations -> M)\n\njulia> N2 = sub(M, [m])\n(Submodule over integers with 1 generator and no relations, Hom: submodule over integers with 1 generator and no relations -> M)\n\njulia> I = intersect(N1, N2)\nAny[]","category":"page"},{"location":"PolyhedralGeometry/linear_programs/","page":"Linear Programs","title":"Linear Programs","text":"CurrentModule = Oscar\nDocTestSetup = Oscar.doctestsetup()","category":"page"},{"location":"PolyhedralGeometry/linear_programs/#Linear-Programs","page":"Linear Programs","title":"Linear Programs","text":"","category":"section"},{"location":"PolyhedralGeometry/linear_programs/#Introduction","page":"Linear Programs","title":"Introduction","text":"","category":"section"},{"location":"PolyhedralGeometry/linear_programs/","page":"Linear Programs","title":"Linear Programs","text":"The purpose of a linear program is to optimize a linear function over a polyhedron.","category":"page"},{"location":"PolyhedralGeometry/linear_programs/#Constructions","page":"Linear Programs","title":"Constructions","text":"","category":"section"},{"location":"PolyhedralGeometry/linear_programs/","page":"Linear Programs","title":"Linear Programs","text":"Linear programs are constructed from a polyhedron and a linear objective function which is described by a vector and (optionally) a translation. One can select whether the optimization problem is to maximize or to minimize the objective function.","category":"page"},{"location":"PolyhedralGeometry/linear_programs/","page":"Linear Programs","title":"Linear Programs","text":"linear_program","category":"page"},{"location":"PolyhedralGeometry/linear_programs/#linear_program","page":"Linear Programs","title":"linear_program","text":"linear_program(P, c; k = 0, convention = :max)\n\nThe linear program on the feasible set P (a Polyhedron) with respect to the function x ↦ dot(c,x)+k.\n\n\n\n\n\n","category":"function"},{"location":"PolyhedralGeometry/linear_programs/#Solving-a-linear-program-an-example","page":"Linear Programs","title":"Solving a linear program - an example","text":"","category":"section"},{"location":"PolyhedralGeometry/linear_programs/","page":"Linear Programs","title":"Linear Programs","text":"Let P=-11^3 be the 3-dimensional cube in mathbbR^3, and consider the linear function ell, given by ell(xyz) = 3x-2y+4z+2. Minimizing ell over P can be done by solving the corresponding linear program. Computationally, this means first defining a linear program:","category":"page"},{"location":"PolyhedralGeometry/linear_programs/","page":"Linear Programs","title":"Linear Programs","text":"julia> P = cube(3)\nPolytope in ambient dimension 3\n\njulia> LP = linear_program(P,[3,-2,4];k=2,convention = :min)\nLinear program\n   min{c*x + k | x in P}\nwhere P is a Polyhedron{QQFieldElem} and\n   c=QQFieldElem[3, -2, 4]\n   k=2","category":"page"},{"location":"PolyhedralGeometry/linear_programs/","page":"Linear Programs","title":"Linear Programs","text":"The information about the linear program LP can be easily extracted.","category":"page"},{"location":"PolyhedralGeometry/linear_programs/","page":"Linear Programs","title":"Linear Programs","text":"julia> P = cube(3);\n\njulia> LP = linear_program(P,[3,-2,4];k=2,convention = :min);\n\njulia> c, k = objective_function(LP)\n(QQFieldElem[3, -2, 4], 2)\n\njulia> P == feasible_region(LP)\ntrue","category":"page"},{"location":"PolyhedralGeometry/linear_programs/","page":"Linear Programs","title":"Linear Programs","text":"To solve the optimization problem call solve_lp, which returns a pair m, v where the optimal value is m, and that value is attained at v.","category":"page"},{"location":"PolyhedralGeometry/linear_programs/","page":"Linear Programs","title":"Linear Programs","text":"julia> P = cube(3);\n\njulia> LP = linear_program(P,[3,-2,4];k=2,convention = :min);\n\njulia> m, v = solve_lp(LP)\n(-7, QQFieldElem[-1, 1, -1])\n\njulia> ℓ = objective_function(LP; as = :function);\n\njulia> ℓ(v) == convert(QQFieldElem, m)\ntrue","category":"page"},{"location":"PolyhedralGeometry/linear_programs/","page":"Linear Programs","title":"Linear Programs","text":"The optimal value and an optimal vertex may be obtained individually as well.","category":"page"},{"location":"PolyhedralGeometry/linear_programs/","page":"Linear Programs","title":"Linear Programs","text":"julia> P = cube(3);\n\njulia> LP = linear_program(P,[3,-2,4];k=2,convention = :min);\n\njulia> M = optimal_value(LP)\n-7\n\njulia> V = optimal_vertex(LP)\n3-element PointVector{QQFieldElem}:\n -1\n 1\n -1","category":"page"},{"location":"PolyhedralGeometry/linear_programs/#Functions","page":"Linear Programs","title":"Functions","text":"","category":"section"},{"location":"PolyhedralGeometry/linear_programs/","page":"Linear Programs","title":"Linear Programs","text":"feasible_region(lp::LinearProgram)\nambient_dim(lp::LinearProgram)\nobjective_function(lp::LinearProgram{T}; as::Symbol = :pair) where T<:scalar_types\nsolve_lp(LP::LinearProgram)\noptimal_value(lp::LinearProgram{T}) where T<:scalar_types\noptimal_vertex(lp::LinearProgram{T}) where T<:scalar_types\nload_lp(file::String)\nsave_lp(target::Union{String,IO}, lp::Union{MixedIntegerLinearProgram{QQFieldElem},LinearProgram{QQFieldElem}})\nload_mps(file::String)\nsave_mps(target::Union{String,IO}, lp::Union{MixedIntegerLinearProgram{QQFieldElem},LinearProgram{QQFieldElem}})","category":"page"},{"location":"PolyhedralGeometry/linear_programs/#feasible_region-Tuple{LinearProgram}","page":"Linear Programs","title":"feasible_region","text":"feasible_region(lp::LinearProgram)\n\nReturn the feasible region of the linear program lp, which is a Polyhedron.\n\n\n\n\n\n","category":"method"},{"location":"PolyhedralGeometry/linear_programs/#ambient_dim-Tuple{LinearProgram}","page":"Linear Programs","title":"ambient_dim","text":"ambient_dim(LP::LinearProgram)\n\nReturn the ambient dimension of the feasible reagion of LP.\n\n\n\n\n\n","category":"method"},{"location":"PolyhedralGeometry/linear_programs/#objective_function-Union{Tuple{LinearProgram{T}}, Tuple{T}} where T<:Union{Float64, FieldElem}","page":"Linear Programs","title":"objective_function","text":"objective_function(LP::LinearProgram; as = :pair)\n\nReturn the objective function x ↦ dot(c,x)+k of the linear program LP. The allowed values for as are\n\npair: Return the pair (c,k)\nfunction: Return the objective function as a function.\n\n\n\n\n\n","category":"method"},{"location":"PolyhedralGeometry/linear_programs/#solve_lp-Tuple{LinearProgram}","page":"Linear Programs","title":"solve_lp","text":"solve_lp(LP::LinearProgram)\n\nReturn a pair (m,v) where the optimal value m of the objective function of LP is attained at v (if m exists). If the optimum is not attained or the feasible region is empty, m may be infinity, -infinity, or nothing in which case v is nothing.\n\n\n\n\n\n","category":"method"},{"location":"PolyhedralGeometry/linear_programs/#optimal_value-Union{Tuple{LinearProgram{T}}, Tuple{T}} where T<:Union{Float64, FieldElem}","page":"Linear Programs","title":"optimal_value","text":"optimal_value(LP::LinearProgram)\n\nReturn, if it exists, the optimal value of the objective function of LP over the feasible region of LP. Otherwise, return -infinity or infinity depending on convention, or nothing if the feasible region is empty.\n\nExamples\n\nThe following example constructs a linear program over the three dimensional cube, and obtains the minimal value of the function (x,y,z) ↦ x+2y-3z over that cube.\n\njulia> C=cube(3)\nPolytope in ambient dimension 3\n\njulia> LP=linear_program(C,[1,2,-3]; convention = :min)\nLinear program\n   min{c*x + k | x in P}\nwhere P is a Polyhedron{QQFieldElem} and\n   c=QQFieldElem[1, 2, -3]\n   k=0\n\njulia> optimal_value(LP)\n-6\n\nOptimizing in an unbounded direction yields infinity.\n\njulia> lp = linear_program(convex_hull([0 0], [1 0; 0 1]), [1, 1])\nLinear program\n   max{c*x + k | x in P}\nwhere P is a Polyhedron{QQFieldElem} and\n   c=QQFieldElem[1, 1]\n   k=0\n\njulia> optimal_value(lp)\ninfinity\n\n\n\n\n\n","category":"method"},{"location":"PolyhedralGeometry/linear_programs/#optimal_vertex-Union{Tuple{LinearProgram{T}}, Tuple{T}} where T<:Union{Float64, FieldElem}","page":"Linear Programs","title":"optimal_vertex","text":"optimal_vertex(LP::LinearProgram)\n\nReturn either a point of the feasible region of LP which optimizes the objective function of LP, or nothing if no such point exists.\n\nExamples\n\nThe following example constructs a linear program over the three dimensional cube, and obtains the vertex of the cube which maximizes the function (x,y,z) ↦ x+2y-3z.\n\njulia> C=cube(3)\nPolytope in ambient dimension 3\n\njulia> LP=linear_program(C,[1,2,-3])\nLinear program\n   max{c*x + k | x in P}\nwhere P is a Polyhedron{QQFieldElem} and\n   c=QQFieldElem[1, 2, -3]\n   k=0\n\njulia> optimal_vertex(LP)\n3-element PointVector{QQFieldElem}:\n 1\n 1\n -1\n\n\n\n\n\n","category":"method"},{"location":"PolyhedralGeometry/linear_programs/#load_lp-Tuple{String}","page":"Linear Programs","title":"load_lp","text":"load_lp(file::String)\n\nLoad a (mixed integer) linear program from an .lp file using the LP file format.\n\n\n\n\n\n","category":"method"},{"location":"PolyhedralGeometry/linear_programs/#save_lp-Tuple{Union{IO, String}, Union{LinearProgram{QQFieldElem}, MixedIntegerLinearProgram{QQFieldElem}}}","page":"Linear Programs","title":"save_lp","text":"save_lp(target::Union{String, IO}, lp::Union{MixedIntegerLinearProgram,LinearProgram})\n\nSave a (mixed integer) linear program to an .lp file using the LP file format.\n\nExamples\n\nTake the square -1232^2 with objective 11 and one integer variable. Print the object in LP format to stdout:\n\njulia> c = cube(2, -1//2, 3//2)\nPolytope in ambient dimension 2\n\njulia> milp = mixed_integer_linear_program(c, [1,1], integer_variables=[1])\nMixed integer linear program\n\njulia> save_lp(stdout, milp)\nMAXIMIZE\n  obj: +1 x1 +1 x2\nSubject To\n  ie0: +2 x1 >= -1\n  ie1: -2 x1 >= -3\n  ie2: +2 x2 >= -1\n  ie3: -2 x2 >= -3\nBOUNDS\n  x1 free\n  x2 free\nGENERAL\n  x1\nEND\n\n\n\n\n\n","category":"method"},{"location":"PolyhedralGeometry/linear_programs/#load_mps-Tuple{String}","page":"Linear Programs","title":"load_mps","text":"load_mps(file::String)\n\nLoad a (mixed integer) linear program from an .mps file using the MPS file format.\n\n\n\n\n\n","category":"method"},{"location":"PolyhedralGeometry/linear_programs/#save_mps-Tuple{Union{IO, String}, Union{LinearProgram{QQFieldElem}, MixedIntegerLinearProgram{QQFieldElem}}}","page":"Linear Programs","title":"save_mps","text":"save_mps(target::String, lp::Union{MixedIntegerLinearProgram,LinearProgram})\n\nSave a (mixed integer) linear program to an .mps file using the MPS file format.\n\nExamples\n\nCreate the square -1232^2 with objective 11 and one integer variable. Print the object in MPS format to stdout:\n\njulia> c = cube(2, -1//2, 3//2)\nPolytope in ambient dimension 2\n\njulia> milp = mixed_integer_linear_program(c, [1,1], integer_variables=[1])\nMixed integer linear program\n\njulia> save_mps(stdout, milp)\n* Class:\tMIP\n* Rows:\t\t5\n* Columns:\t2\n* Format:\tMPS\n*\nNAME          unnamed#0\nROWS\n N  C0000000\n G  R0000000\n G  R0000001\n G  R0000002\n G  R0000003\nCOLUMNS\n    M0000000  'MARKER'                 'INTORG'\n    x1        C0000000  1                        R0000000  1\n    x1        R0000001  -1                       \n    M0000000  'MARKER'                 'INTEND'\n    x2        C0000000  1                        R0000002  1\n    x2        R0000003  -1                       \nRHS\n    B         R0000000  -0.5                     R0000001  -1.5\n    B         R0000002  -0.5                     R0000003  -1.5\nBOUNDS\n FR BND       x1  \n FR BND       x2  \nENDATA\n\n\n\n\n\n","category":"method"},{"location":"AlgebraicGeometry/intro/","page":"Introduction","title":"Introduction","text":"CurrentModule = Oscar","category":"page"},{"location":"AlgebraicGeometry/intro/#Introduction","page":"Introduction","title":"Introduction","text":"","category":"section"},{"location":"AlgebraicGeometry/intro/","page":"Introduction","title":"Introduction","text":"The algebraic geometry part of OSCAR provides functionality for dealing with","category":"page"},{"location":"AlgebraicGeometry/intro/","page":"Introduction","title":"Introduction","text":"affine algebraic sets and varieties\nprojective algebraic sets and varieties\nschemes\ntoric varieties,\ntoric schemes,","category":"page"},{"location":"AlgebraicGeometry/intro/","page":"Introduction","title":"Introduction","text":"Computations in affine and projective algebraic geometry rely on Commutative Algebra.","category":"page"},{"location":"AlgebraicGeometry/intro/","page":"Introduction","title":"Introduction","text":"Similarly, most algorithms for toric varieties and schemes are are based on Polyhedral Geometry.","category":"page"},{"location":"AlgebraicGeometry/intro/","page":"Introduction","title":"Introduction","text":"General textbooks offering details on the theory of varieties and schemes include:","category":"page"},{"location":"AlgebraicGeometry/intro/","page":"Introduction","title":"Introduction","text":"[Har77]\nThe Stacks Project","category":"page"},{"location":"AlgebraicGeometry/intro/#Conventions","page":"Introduction","title":"Conventions","text":"","category":"section"},{"location":"AlgebraicGeometry/intro/#Projectivization","page":"Introduction","title":"Projectivization","text":"","category":"section"},{"location":"AlgebraicGeometry/intro/","page":"Introduction","title":"Introduction","text":"There are two opposite conventions in common use when defining the projectivization. For details, see https://stacks.math.columbia.edu/tag/01OA (search for \"Warning\").","category":"page"},{"location":"AlgebraicGeometry/intro/","page":"Introduction","title":"Introduction","text":"For an example, look at proposition 3 in https://arxiv.org/abs/1501.04049. This proposition states that any elliptically fibred K3-surface can be described as hypersurface in the space mathbbP(mathcalO_mathbbP^1(0) oplus mathcalO_mathbbP^1(-4) oplus mathcalO_mathbbP^1(-6)). Authors, that apply the opposite convention, would say that any elliptically fibred K3-surface is a hypersurface in mathbbP(mathcalO_mathbbP^1(0) oplus mathcalO_mathbbP^1(4) oplus mathcalO_mathbbP^1(6)). Note the opposite signs.","category":"page"},{"location":"AlgebraicGeometry/intro/","page":"Introduction","title":"Introduction","text":"Irrespective of the signs used to denote the ambient space, there is always agreement on the hypersurface equation and the transformation behavior of the local coordinates. In the above example, the hypersurface equation is","category":"page"},{"location":"AlgebraicGeometry/intro/","page":"Introduction","title":"Introduction","text":"z y^2 = x^3 + alpha(st) x z^2 + beta(st) z^3  ","category":"page"},{"location":"AlgebraicGeometry/intro/","page":"Introduction","title":"Introduction","text":"where (st) are coordinates on mathbbP^1 and alpha(st), beta(st) are homogeneous polynomials in s, t of degrees 8 and 12, respectively. The projective coordinates x  y  z of the ambient space transform as sections of the bundles mathcalO_mathbbP^1(4), mathcalO_mathbbP^1(6) and mathcalO_mathbbP^1(0), respectively.","category":"page"},{"location":"PolyhedralGeometry/cones/","page":"Cones","title":"Cones","text":"CurrentModule = Oscar\nDocTestSetup = Oscar.doctestsetup()","category":"page"},{"location":"PolyhedralGeometry/cones/#Cones","page":"Cones","title":"Cones","text":"","category":"section"},{"location":"PolyhedralGeometry/cones/#Introduction","page":"Cones","title":"Introduction","text":"","category":"section"},{"location":"PolyhedralGeometry/cones/","page":"Cones","title":"Cones","text":"Let mathbbF be an ordered field; the default is that mathbbF=mathbbQ is the field of rational numbers.","category":"page"},{"location":"PolyhedralGeometry/cones/","page":"Cones","title":"Cones","text":"A set C subseteq mathbbF^n is called a (polyhedral) cone if it can be written as the set of non-negative linear combinations of finitely many vectors in mathbbF^n.  Equivalently, cones can be written as the intersection of finitely many homogeneous linear inequalities.","category":"page"},{"location":"PolyhedralGeometry/cones/","page":"Cones","title":"Cones","text":"Any cone is a special case of a polyhedron.  Conversely, intersecting a cone with a suitable affine hyperplane yields a polyhedron whose faces are in bijection with the faces of the cone.  Going back and forth between polyhedra and their homogenizations, the cones, is a frequent operation.  This is one reason for keeping cones as a distinct type.","category":"page"},{"location":"PolyhedralGeometry/cones/#Construction","page":"Cones","title":"Construction","text":"","category":"section"},{"location":"PolyhedralGeometry/cones/","page":"Cones","title":"Cones","text":"positive_hull(::Oscar.scalar_type_or_field, ::Union{Oscar.MatElem, AbstractMatrix})\ncone_from_inequalities\ncone_from_equations\nsecondary_cone(SOP::SubdivisionOfPoints{T}) where T<:scalar_types","category":"page"},{"location":"PolyhedralGeometry/cones/#positive_hull-Tuple{Union{Field, Type{<:Union{Float64, FieldElem}}}, Union{MatElem, AbstractMatrix}}","page":"Cones","title":"positive_hull","text":"positive_hull([::Union{Type{T}, Field} = QQFieldElem,] R::AbstractCollection[RayVector] [, L::AbstractCollection[RayVector]]; non_redundant::Bool = false) where T<:scalar_types\n\nA polyhedral cone, not necessarily pointed, defined by the positive hull of the rays R, with lineality given by L. The first argument either specifies the Type of its coefficients or their parent Field.\n\nR is given row-wise as representative vectors, with lineality generated by the rows of L, i.e. the cone consists of all positive linear combinations of the rows of R plus all linear combinations of the rows of L.\n\nThis is an interior description, analogous to the V-representation of a polytope.\n\nRedundant rays are allowed.\n\nExamples\n\nTo construct the positive orthant as a Cone, you can write:\n\njulia> R = [1 0; 0 1];\n\njulia> PO = positive_hull(R)\nPolyhedral cone in ambient dimension 2\n\nTo obtain the upper half-space of the plane:\n\njulia> R = [0 1];\n\njulia> L = [1 0];\n\njulia> HS = positive_hull(R, L)\nPolyhedral cone in ambient dimension 2\n\n\n\n\n\n","category":"method"},{"location":"PolyhedralGeometry/cones/#cone_from_inequalities","page":"Cones","title":"cone_from_inequalities","text":"cone_from_inequalities([::Union{Type{T}, Field} = QQFieldElem,] I::AbstractCollection[LinearHalfspace] [, E::AbstractCollection[LinearHyperplane]]; non_redundant::Bool = false)\n\nThe (convex) cone defined by\n\n x   Ix  0 Ex = 0 \n\nUse non_redundant = true if the given description contains no redundant rows to avoid unnecessary redundancy checks. The first argument either specifies the Type of its coefficients or their parent Field.\n\nExamples\n\njulia> C = cone_from_inequalities([0 -1; -1 1])\nPolyhedral cone in ambient dimension 2\n\njulia> rays(C)\n2-element SubObjectIterator{RayVector{QQFieldElem}}:\n [1, 0]\n [1, 1]\n\n\n\n\n\n","category":"function"},{"location":"PolyhedralGeometry/cones/#cone_from_equations","page":"Cones","title":"cone_from_equations","text":"cone_from_equations([::Union{Type{T}, Field} = QQFieldElem,] E::AbstractCollection[LinearHyperplane]; non_redundant::Bool = false)\n\nThe (convex) cone defined by\n\n x  Ex = 0 \n\nUse non_redundant = true if the given description contains no redundant rows to avoid unnecessary redundancy checks. The first argument either specifies the Type of its coefficients or their parent Field.\n\nExamples\n\njulia> C = cone_from_equations([1 0 0; 0 -1 1])\nPolyhedral cone in ambient dimension 3\n\njulia> lineality_space(C)\n1-element SubObjectIterator{RayVector{QQFieldElem}}:\n [0, 1, 1]\n\njulia> dim(C)\n1\n\n\n\n\n\n","category":"function"},{"location":"PolyhedralGeometry/cones/#secondary_cone-Union{Tuple{SubdivisionOfPoints{T}}, Tuple{T}} where T<:Union{Float64, FieldElem}","page":"Cones","title":"secondary_cone","text":"secondary_cone(SOP::SubdivisionOfPoints)\n\nReturn the secondary cone of a subdivision of points, the closure of all the weight vectors inducing the given subdivision of points.\n\nExamples\n\nFor a non-regular subdivision, the secondary cone can still contain non-trivial weights, but it will not be full-dimensional.\n\njulia> moaepts = [4 0 0; 0 4 0; 0 0 4; 2 1 1; 1 2 1; 1 1 2];\n\njulia> moaeimnonreg0 = incidence_matrix([[4,5,6],[1,4,2],[2,4,5],[2,3,5],[3,5,6],[1,3,6],[1,4,6]]);\n\njulia> MOAE = subdivision_of_points(moaepts, moaeimnonreg0)\nSubdivision of points in ambient dimension 3\n\njulia> C = secondary_cone(MOAE)\nPolyhedral cone in ambient dimension 6\n\njulia> dim(C)\n4\n\n\n\n\n\n","category":"method"},{"location":"PolyhedralGeometry/cones/#Auxiliary-functions","page":"Cones","title":"Auxiliary functions","text":"","category":"section"},{"location":"PolyhedralGeometry/cones/","page":"Cones","title":"Cones","text":"ambient_dim(C::Cone)\nBase.in(v::AbstractVector, C::Cone)\nBase.issubset(C0::Cone{T}, C1::Cone{T}) where T<:scalar_types\nfacet_degrees(C::Cone)\nf_vector(C::Cone)\nhilbert_basis(C::Cone{QQFieldElem})\ncodim(C::Cone)\ndim(C::Cone)\npolarize(C::Cone{T}) where T<:scalar_types\nintersect(C::Cone...)\nis_pointed(C::Cone)\nis_fulldimensional(C::Cone)\nlineality_dim(C::Cone)\nlineality_space(C::Cone{T}) where T<:scalar_types\nn_facets(C::Cone)\nn_rays(C::Cone)\nrays(C::Cone{T}) where T<:scalar_types\nrays_modulo_lineality(C::Cone{T}) where T<:scalar_types\nray_degrees(C::Cone)","category":"page"},{"location":"PolyhedralGeometry/cones/#ambient_dim-Tuple{Cone}","page":"Cones","title":"ambient_dim","text":"ambient_dim(C::Cone)\n\nReturn the ambient dimension of C.\n\nExamples\n\nThe cone C in this example is 2-dimensional within a 3-dimensional ambient space.\n\njulia> C = positive_hull([1 0 0; 1 1 0; 0 1 0]);\n\njulia> ambient_dim(C)\n3\n\n\n\n\n\n","category":"method"},{"location":"PolyhedralGeometry/cones/#in-Tuple{AbstractVector, Cone}","page":"Cones","title":"in","text":"in(v::AbstractVector, C::Cone)\n\nCheck whether the vector v is contained in the cone C.\n\nExamples\n\nThe positive orthant only contains vectors with non-negative entries:\n\njulia> C = positive_hull([1 0; 0 1]);\n\njulia> [1, 2] in C\ntrue\n\njulia> [1, -2] in C\nfalse\n\n\n\n\n\n","category":"method"},{"location":"PolyhedralGeometry/cones/#issubset-Union{Tuple{T}, Tuple{Cone{T}, Cone{T}}} where T<:Union{Float64, FieldElem}","page":"Cones","title":"issubset","text":"issubset(C0::Cone, C1::Cone)\n\nCheck whether C0 is a subset of the cone C1.\n\nExamples\n\njulia> C0 = positive_hull([1 1])\nPolyhedral cone in ambient dimension 2\n\njulia> C1 = positive_hull([1 0; 0 1])\nPolyhedral cone in ambient dimension 2\n\njulia> issubset(C0, C1)\ntrue\n\njulia> issubset(C1, C0)\nfalse\n\n\n\n\n\n","category":"method"},{"location":"PolyhedralGeometry/cones/#facet_degrees-Tuple{Cone}","page":"Cones","title":"facet_degrees","text":"facet_degrees(C::Cone)\n\nFacet degrees of the cone. The degree of a facet is the number of adjacent facets.  In particular a general 2-dimensional cone has two facets (rays) that meet at the origin. \n\nExamples\n\nProduce the facet degrees of a cone over a square and a cone over a square pyramid. \n\njulia> c = positive_hull([1 1 0; 1 -1 0; 1 0 1; 1 0 -1])\nPolyhedral cone in ambient dimension 3\n\njulia> facet_degrees(c)\n4-element Vector{Int64}:\n 2\n 2\n 2\n 2\n\njulia> c = positive_hull([1 0 1 0; 1 0 -1 0; 1 0 0 1; 1 0 0 -1; 1 1 0 0])\nPolyhedral cone in ambient dimension 4\n\njulia> facet_degrees(c)\n5-element Vector{Int64}:\n 4\n 3\n 3\n 3\n 3\n\n\n\n\n\n","category":"method"},{"location":"PolyhedralGeometry/cones/#f_vector-Tuple{Cone}","page":"Cones","title":"f_vector","text":"f_vector(C::Cone)\n\nCompute the vector (f₁f₂f_dim(C) - 1) where f_i is the number of faces of C of dimension i.\n\nExamples\n\nTake the cone over a square, then the f-vector of the cone is the same as of the square.\n\njulia> C = positive_hull([1 0 0; 1 1 0; 1 1 1; 1 0 1])\nPolyhedral cone in ambient dimension 3\n\njulia> f_vector(C)\n2-element Vector{ZZRingElem}:\n 4\n 4\n\njulia> square = cube(2)\nPolytope in ambient dimension 2\n\njulia> f_vector(square)\n2-element Vector{ZZRingElem}:\n 4\n 4\n\n\n\n\n\n","category":"method"},{"location":"PolyhedralGeometry/cones/#hilbert_basis-Tuple{Cone{QQFieldElem}}","page":"Cones","title":"hilbert_basis","text":"hilbert_basis(C::Cone{QQFieldElem})\n\nReturn the Hilbert basis of a pointed cone C as the rows of a matrix.\n\nExamples\n\nThis (non-smooth) cone in the plane has a hilbert basis with three elements.\n\njulia> C = positive_hull([1 0; 1 2])\nA polyhedral cone in ambient dimension 2\n\njulia> matrix(ZZ, hilbert_basis(C))\n[1   0]\n[1   2]\n[1   1]\n\n\n\n\n\n\n","category":"method"},{"location":"PolyhedralGeometry/cones/#codim-Tuple{Cone}","page":"Cones","title":"codim","text":"codim(C::Cone)\n\nReturn the codimension of C.\n\nExamples\n\nThe cone C in this example is 2-dimensional within a 3-dimensional ambient space.\n\njulia> C = positive_hull([1 0 0; 1 1 0; 0 1 0]);\n\njulia> codim(C)\n1\n\n\n\n\n\n","category":"method"},{"location":"PolyhedralGeometry/cones/#dim-Tuple{Cone}","page":"Cones","title":"dim","text":"dim(C::Cone)\n\nReturn the dimension of C.\n\nExamples\n\nThe cone C in this example is 2-dimensional within a 3-dimensional ambient space.\n\njulia> C = positive_hull([1 0 0; 1 1 0; 0 1 0]);\n\njulia> dim(C)\n2\n\n\n\n\n\n","category":"method"},{"location":"PolyhedralGeometry/cones/#polarize-Union{Tuple{Cone{T}}, Tuple{T}} where T<:Union{Float64, FieldElem}","page":"Cones","title":"polarize","text":"polarize(C::Cone)\n\nReturn the polar dual of C, the cone consisting of all those linear functions that evaluate positively on all of C.\n\nExamples\n\njulia> C = positive_hull([1 0; -1 2])\nPolyhedral cone in ambient dimension 2\n\njulia> Cv = polarize(C)\nPolyhedral cone in ambient dimension 2\n\njulia> rays(Cv)\n2-element SubObjectIterator{RayVector{QQFieldElem}}:\n [1, 1//2]\n [0, 1]\n\n\n\n\n\n","category":"method"},{"location":"PolyhedralGeometry/cones/#intersect-Tuple{Vararg{Cone}}","page":"Cones","title":"intersect","text":"intersect(C::Cone...)\n\nReturn the intersection bigcaplimits_c in C c.\n\nExamples\n\njulia> C0 = positive_hull([1 0])\nPolyhedral cone in ambient dimension 2\n\njulia> C1 = positive_hull([0 1])\nPolyhedral cone in ambient dimension 2\n\njulia> C01 = intersect(C0, C1)\nPolyhedral cone in ambient dimension 2\n\njulia> rays(C01)\n0-element SubObjectIterator{RayVector{QQFieldElem}}\n\njulia> dim(C01)\n0\n\n\n\n\n\n","category":"method"},{"location":"PolyhedralGeometry/cones/#is_pointed-Tuple{Cone}","page":"Cones","title":"is_pointed","text":"is_pointed(C::Cone)\n\nDetermine whether C is pointed, i.e. whether the origin is a face of C.\n\nExamples\n\nA cone with lineality is not pointed, but a cone only consisting of a single ray is.\n\njulia> C = positive_hull([1 0], [0 1]);\n\njulia> is_pointed(C)\nfalse\n\njulia> C = positive_hull([1 0]);\n\njulia> is_pointed(C)\ntrue\n\n\n\n\n\n","category":"method"},{"location":"PolyhedralGeometry/cones/#is_fulldimensional-Tuple{Cone}","page":"Cones","title":"is_fulldimensional","text":"is_fulldimensional(C::Cone)\n\nDetermine whether C is full-dimensional.\n\nExamples\n\nThe cone C in this example is 2-dimensional within a 3-dimensional ambient space.\n\njulia> C = positive_hull([1 0 0; 1 1 0; 0 1 0]);\n\njulia> is_fulldimensional(C)\nfalse\n\n\n\n\n\n","category":"method"},{"location":"PolyhedralGeometry/cones/#lineality_dim-Tuple{Cone}","page":"Cones","title":"lineality_dim","text":"lineality_dim(C::Cone)\n\nCompute the dimension of the lineality space of C, i.e. the largest linear subspace contained in C.\n\nExamples\n\nA cone is pointed if and only if the dimension of its lineality space is zero.\n\njulia> C = positive_hull([1 0 0; 1 1 0; 1 1 1; 1 0 1])\nPolyhedral cone in ambient dimension 3\n\njulia> is_pointed(C)\ntrue\n\njulia> lineality_dim(C)\n0\n\njulia> C1 = positive_hull([1 0],[0 1; 0 -1])\nPolyhedral cone in ambient dimension 2\n\njulia> is_pointed(C1)\nfalse\n\njulia> lineality_dim(C1)\n1\n\n\n\n\n\n","category":"method"},{"location":"PolyhedralGeometry/cones/#lineality_space-Union{Tuple{Cone{T}}, Tuple{T}} where T<:Union{Float64, FieldElem}","page":"Cones","title":"lineality_space","text":"lineality_space(C::Cone)\n\nReturn a basis of the lineality space of C.\n\nExamples\n\nThree rays are used here to construct the upper half-plane. Actually, two of these rays point in opposite directions. This gives us a 1-dimensional lineality.\n\njulia> UH = positive_hull([1 0; 0 1; -1 0]);\n\njulia> lineality_space(UH)\n1-element SubObjectIterator{RayVector{QQFieldElem}}:\n [1, 0]\n\n\n\n\n\n","category":"method"},{"location":"PolyhedralGeometry/cones/#n_facets-Tuple{Cone}","page":"Cones","title":"n_facets","text":"n_facets(C::Cone)\n\nReturn the number of facets of a cone C.\n\nExamples\n\nThe cone over a square at height one has four facets.\n\njulia> C = positive_hull([1 0 0; 1 1 0; 1 1 1; 1 0 1])\nPolyhedral cone in ambient dimension 3\n\njulia> n_facets(C)\n4\n\n\n\n\n\n","category":"method"},{"location":"PolyhedralGeometry/cones/#n_rays-Tuple{Cone}","page":"Cones","title":"n_rays","text":"n_rays(C::Cone)\n\nReturn the number of rays of C.\n\nExamples\n\nHere a cone is constructed from three rays. Calling number_of_rays reveals that one of these was redundant:\n\njulia> R = [1 0; 0 1; 0 2];\n\njulia> PO = positive_hull(R);\n\njulia> n_rays(PO)\n2\n\n\n\n\n\n","category":"method"},{"location":"PolyhedralGeometry/cones/#rays-Union{Tuple{Cone{T}}, Tuple{T}} where T<:Union{Float64, FieldElem}","page":"Cones","title":"rays","text":"rays([as::Type{T} = RayVector,] C::Cone)\n\nReturn the rays of C in the format defined by as. The rays are defined to be the one-dimensional faces, so if C has lineality, there are no rays.\n\nSee also rays_modulo_lineality.\n\nOptional arguments for as include\n\nRayVector.\n\nExamples\n\nHere a cone is constructed from three rays. Calling rays reveals that one of these was redundant:\n\njulia> R = [1 0; 0 1; 0 2];\n\njulia> PO = positive_hull(R);\n\njulia> rays(PO)\n2-element SubObjectIterator{RayVector{QQFieldElem}}:\n [1, 0]\n [0, 1]\n\nThe rays can also be converted to a matrix using the matrix(ring, ...) function. If ring=ZZ the primitive generators of the rays are returned.\n\njulia> R = [1 0; 2 3];\n\njulia> P = positive_hull(R);\n\njulia> rays(P)\n2-element SubObjectIterator{RayVector{QQFieldElem}}:\n [1, 0]\n [1, 3//2]\n\njulia> matrix(QQ, rays(RayVector, P))\n[1      0]\n[1   3//2]\n\njulia> matrix(ZZ, rays(P))\n[1   0]\n[2   3]\n\nA half-space has no rays:\n\njulia> UH = cone_from_inequalities([-1 0 0])\nPolyhedral cone in ambient dimension 3\n\njulia> rays(UH)\n0-element SubObjectIterator{RayVector{QQFieldElem}}\n\n\n\n\n\n","category":"method"},{"location":"PolyhedralGeometry/cones/#rays_modulo_lineality-Union{Tuple{Cone{T}}, Tuple{T}} where T<:Union{Float64, FieldElem}","page":"Cones","title":"rays_modulo_lineality","text":"rays_modulo_lineality(as, C::Cone)\n\nReturn the rays of the cone of C up to lineality as a NamedTuple with two iterators. If C has lineality L, then the iterator rays_modulo_lineality iterates over representatives of the rays of C/L. The iterator lineality_basis gives a basis of the lineality space L.\n\nSee also rays and lineality_space.\n\nExamples\n\nFor a pointed cone, with two generators, we get the usual rays:\n\njulia> C = positive_hull([1 0; 0 1])\nPolyhedral cone in ambient dimension 2\n\njulia> rays(C)\n2-element SubObjectIterator{RayVector{QQFieldElem}}:\n [1, 0]\n [0, 1]\n\njulia> RML = rays_modulo_lineality(C)\n(rays_modulo_lineality = RayVector{QQFieldElem}[[1, 0], [0, 1]], lineality_basis = RayVector{QQFieldElem}[])\n\njulia> RML.rays_modulo_lineality\n2-element SubObjectIterator{RayVector{QQFieldElem}}:\n [1, 0]\n [0, 1]\n\njulia> RML.lineality_basis\n0-element SubObjectIterator{RayVector{QQFieldElem}}\n\nIf the cone has lineality, the second iterator iterates over a basis for the space of lineality.  The following example has one generator for the positive hull plus one generator for the lineality space: \n\njulia> C = positive_hull([1 0],[0 1])\nPolyhedral cone in ambient dimension 2\n\njulia> lineality_dim(C)\n1\n\njulia> rays(C)\n0-element SubObjectIterator{RayVector{QQFieldElem}}\n\njulia> RML = rays_modulo_lineality(C)\n(rays_modulo_lineality = RayVector{QQFieldElem}[[1, 0]], lineality_basis = RayVector{QQFieldElem}[[0, 1]])\n\njulia> RML.lineality_basis\n1-element SubObjectIterator{RayVector{QQFieldElem}}:\n [0, 1]\n\n\n\n\n\n","category":"method"},{"location":"PolyhedralGeometry/cones/#ray_degrees-Tuple{Cone}","page":"Cones","title":"ray_degrees","text":"ray_degrees(C::Cone)\n\nRay degrees of the cone. If the cone has lineality, the output is empty since there are no rays that are also faces. \n\nExamples\n\njulia> c = cone_from_inequalities([-1 0 0; 0 -1 0])\nPolyhedral cone in ambient dimension 3\n\njulia> ray_degrees(c)\nInt64[]\n\njulia> c = positive_hull([1 0 1 0; 1 0 -1 0; 1 0 0 1; 1 0 0 -1; 1 1 0 0])\nPolyhedral cone in ambient dimension 4\n\njulia> ray_degrees(c) \n5-element Vector{Int64}:\n 3\n 3\n 3\n 3\n 4\n\n\n\n\n\n","category":"method"},{"location":"InvariantTheory/reductive_groups/","page":"Invariants of Linearly Reductive Groups","title":"Invariants of Linearly Reductive Groups","text":"CurrentModule = Oscar","category":"page"},{"location":"InvariantTheory/reductive_groups/#Invariants-of-Linearly-Reductive-Groups","page":"Invariants of Linearly Reductive Groups","title":"Invariants of Linearly Reductive Groups","text":"","category":"section"},{"location":"InvariantTheory/reductive_groups/","page":"Invariants of Linearly Reductive Groups","title":"Invariants of Linearly Reductive Groups","text":"In this section, with notation as in the introduction to this chapter, G will be a linearly algebraic group over an algebraically closed field K, rho G to textGL(V)cong textGL_n(K) will be a rational representation of G, and G will act on KVcong Kx_1 dots x_n by linear substitution: If rho(pi) = (a_i j), then ","category":"page"},{"location":"InvariantTheory/reductive_groups/","page":"Invariants of Linearly Reductive Groups","title":"Invariants of Linearly Reductive Groups","text":"(f      pi)  (x_1 dots x_n) = fbigl(sum_j a_1 jx_j dots sum_j a_n jx_jbigr)","category":"page"},{"location":"InvariantTheory/reductive_groups/","page":"Invariants of Linearly Reductive Groups","title":"Invariants of Linearly Reductive Groups","text":"note: Note\nThe definition of linear reductivity guarantees the existence of a Reynolds operator mathcal R KV to KV. \nBy Hilbert's celebrated finiteness theorem, KV^G is finitely generated as a K-algebra.\nBy a result of Hochster and Roberts, KV^G is Cohen-Macaulay.","category":"page"},{"location":"InvariantTheory/reductive_groups/","page":"Invariants of Linearly Reductive Groups","title":"Invariants of Linearly Reductive Groups","text":"In cases where the Reynold's operator is explicitly known, generators of invariant rings of linearly reductive groups can be found in two steps using Derksen's algorithm, see [Der99] :","category":"page"},{"location":"InvariantTheory/reductive_groups/","page":"Invariants of Linearly Reductive Groups","title":"Invariants of Linearly Reductive Groups","text":"First, compute generators of Hilbert's null-cone ideal.\nThen, apply the Reynold's operator to these generators.","category":"page"},{"location":"InvariantTheory/reductive_groups/","page":"Invariants of Linearly Reductive Groups","title":"Invariants of Linearly Reductive Groups","text":"See also [DK15] and [DJ98].","category":"page"},{"location":"InvariantTheory/reductive_groups/#Creating-Invariant-Rings","page":"Invariants of Linearly Reductive Groups","title":"Creating Invariant Rings","text":"","category":"section"},{"location":"InvariantTheory/reductive_groups/#How-Linearly-Reductive-Groups-and-Their-Representations-are-Given","page":"Invariants of Linearly Reductive Groups","title":"How Linearly Reductive Groups and Their Representations are Given","text":"","category":"section"},{"location":"InvariantTheory/reductive_groups/","page":"Invariants of Linearly Reductive Groups","title":"Invariants of Linearly Reductive Groups","text":"For the computation of invariant rings in the above setting, there is no need to deal with explicit elements of G or with its group structure. The implementation of Derksen's algorithm in OSCAR can  handle situations where both G and the representation rho are defined over an exact subfield k of K which is supported by OSCAR: ","category":"page"},{"location":"InvariantTheory/reductive_groups/","page":"Invariants of Linearly Reductive Groups","title":"Invariants of Linearly Reductive Groups","text":"G is  specified as an affine algebraic variety by polynomials with coefficients in k;\nrho G to textGL(V) cong textGL_n(K) is specified by an ntimes n matrix whose entries are polynomials in the same variables as those specifying G, with coefficients in k.","category":"page"},{"location":"InvariantTheory/reductive_groups/","page":"Invariants of Linearly Reductive Groups","title":"Invariants of Linearly Reductive Groups","text":"note: Note\nProceeding as above is not a problem: Derksen's algorithms relies on Gröbner bases techniques and means to compute Reynolds operators. It does, thus, not change the initial ground field k. That is, all computations are performed over k and computations over any extension field of k would lead to the same results.","category":"page"},{"location":"InvariantTheory/reductive_groups/","page":"Invariants of Linearly Reductive Groups","title":"Invariants of Linearly Reductive Groups","text":"In OSCAR, the basic set-up for a linearly reductive group in the context of Derksen's algorithm is provided by the  function linearly_reductive_group. At current state, this only supports rational actions of  the special linear group (in characteristic zero). For the action of this group by linear substitution on, say, n-ary forms of degree d, an explicit Reynolds operator is given by Cayley's Omega-process. We show this at work later in this section.","category":"page"},{"location":"InvariantTheory/reductive_groups/","page":"Invariants of Linearly Reductive Groups","title":"Invariants of Linearly Reductive Groups","text":"linearly_reductive_group(sym::Symbol, m::Int, K::Field)","category":"page"},{"location":"InvariantTheory/reductive_groups/#linearly_reductive_group-Tuple{Symbol, Int64, Field}","page":"Invariants of Linearly Reductive Groups","title":"linearly_reductive_group","text":"linearly_reductive_group(sym::Symbol, m::Int, K::Field)\n\nReturn the linearly reductive group indicated by sym.\n\nCurrently, the supported options for sym are:\n\n:SL, corresponding to the special linear group (of degree m over the field K).\n\nExamples\n\njulia> G = linearly_reductive_group(:SL, 2, QQ)\nReductive group SL2\n  over QQ\n\njulia> group_ideal(G)\nIdeal generated by\n  z[1, 1]*z[2, 2] - z[2, 1]*z[1, 2] - 1\n\nwarning: Experimental\nThis function is part of the experimental code in Oscar. Please read here for more details.\n\n\n\n\n\n","category":"method"},{"location":"InvariantTheory/reductive_groups/","page":"Invariants of Linearly Reductive Groups","title":"Invariants of Linearly Reductive Groups","text":"linearly_reductive_group(sym::Symbol, m::Int, R::MPolyRing)","category":"page"},{"location":"InvariantTheory/reductive_groups/#linearly_reductive_group-Tuple{Symbol, Int64, MPolyRing}","page":"Invariants of Linearly Reductive Groups","title":"linearly_reductive_group","text":"linearly_reductive_group(sym::Symbol, m::Int, R::MPolyRing)\n\nReturn the linearly reductive group indicated by sym.\n\nCurrently, the supported options for sym are:\n\n:SL, corresponding to the special linear group (of degree m over the base field K of R, where R is the polynomial ring in which the defining ideal of SL(m K) lives).\n\nExamples\n\njulia> S, z = polynomial_ring(QQ, :c=> (1:2, 1:2));\n\njulia> G = linearly_reductive_group(:SL,2,S)\nReductive group SL2\n  over QQ\n\njulia> group_ideal(G)\nIdeal generated by\n  c[1, 1]*c[2, 2] - c[2, 1]*c[1, 2] - 1\n\nwarning: Experimental\nThis function is part of the experimental code in Oscar. Please read here for more details.\n\n\n\n\n\n","category":"method"},{"location":"InvariantTheory/reductive_groups/","page":"Invariants of Linearly Reductive Groups","title":"Invariants of Linearly Reductive Groups","text":"representation_on_forms(G::LinearlyReductiveGroup, d::Int)","category":"page"},{"location":"InvariantTheory/reductive_groups/#representation_on_forms-Tuple{LinearlyReductiveGroup, Int64}","page":"Invariants of Linearly Reductive Groups","title":"representation_on_forms","text":"representation_on_forms(G::LinearlyReductiveGroup, d::Int)\n\nIf G is the special linear group acting by linear substitution on, say, n-ary forms of degree d, return the corresponding representation.\n\nnote: Note\nIn accordance with classical papers, an n-ary form of degree d in Kx_1 dots x_n is written as a K-linear combination of the K-basis with elements binomnIx^I. Here, I = (i_1 dots i_n)inmathbb Z_geq 0^n with i_1+dots +i_n =d.\n\nExamples\n\njulia> G = linearly_reductive_group(:SL, 2, QQ);\n\njulia> r = representation_on_forms(G, 2)\nRepresentation of SL2\n  on symmetric forms of degree 2\n\njulia> representation_matrix(r)\n[      z[1, 1]^2                   2*z[1, 1]*z[2, 1]         z[2, 1]^2]\n[z[1, 1]*z[1, 2]   z[1, 1]*z[2, 2] + z[2, 1]*z[1, 2]   z[2, 1]*z[2, 2]]\n[      z[1, 2]^2                   2*z[1, 2]*z[2, 2]         z[2, 2]^2]\n\nwarning: Experimental\nThis function is part of the experimental code in Oscar. Please read here for more details.\n\n\n\n\n\n","category":"method"},{"location":"InvariantTheory/reductive_groups/#Constructors-for-Invariant-Rings","page":"Invariants of Linearly Reductive Groups","title":"Constructors for Invariant Rings","text":"","category":"section"},{"location":"InvariantTheory/reductive_groups/","page":"Invariants of Linearly Reductive Groups","title":"Invariants of Linearly Reductive Groups","text":"invariant_ring(r::RepresentationLinearlyReductiveGroup)","category":"page"},{"location":"InvariantTheory/reductive_groups/#invariant_ring-Tuple{RepresentationLinearlyReductiveGroup}","page":"Invariants of Linearly Reductive Groups","title":"invariant_ring","text":"invariant_ring(r::RepresentationLinearlyReductiveGroup)\n\nReturn the invariant ring under the action defined by the representation r on an implicitly generated polynomial ring of appropriate dimension.\n\nExamples\n\njulia> G = linearly_reductive_group(:SL, 2, QQ);\n\njulia> r = representation_on_forms(G, 2);\n\njulia> RG = invariant_ring(r)\nInvariant Ring of\ngraded multivariate polynomial ring in 3 variables over QQ\n  under group action of SL2\n\nwarning: Experimental\nThis function is part of the experimental code in Oscar. Please read here for more details.\n\n\n\n\n\n","category":"method"},{"location":"InvariantTheory/reductive_groups/","page":"Invariants of Linearly Reductive Groups","title":"Invariants of Linearly Reductive Groups","text":"invariant_ring(R::MPolyDecRing, r::RepresentationLinearlyReductiveGroup)","category":"page"},{"location":"InvariantTheory/reductive_groups/#invariant_ring-Tuple{MPolyDecRing, RepresentationLinearlyReductiveGroup}","page":"Invariants of Linearly Reductive Groups","title":"invariant_ring","text":"invariant_ring(R::MPolyDecRing, r::RepresentationLinearlyReductiveGroup)\n\nReturn the invariant subring of R under the action induced by the representation of r on R.\n\nExamples\n\njulia> G = linearly_reductive_group(:SL, 3, QQ);\n\njulia> r = representation_on_forms(G, 3);\n\njulia> S, x = graded_polynomial_ring(QQ, :x => 1:10);\n\njulia> RG = invariant_ring(S, r)\nInvariant Ring of\ngraded multivariate polynomial ring in 10 variables over QQ\n  under group action of SL3\n\nwarning: Experimental\nThis function is part of the experimental code in Oscar. Please read here for more details.\n\n\n\n\n\n","category":"method"},{"location":"InvariantTheory/reductive_groups/#The-Reynolds-Operator","page":"Invariants of Linearly Reductive Groups","title":"The Reynolds Operator","text":"","category":"section"},{"location":"InvariantTheory/reductive_groups/","page":"Invariants of Linearly Reductive Groups","title":"Invariants of Linearly Reductive Groups","text":"reynolds_operator(R::RedGroupInvarRing, f::MPolyRingElem)","category":"page"},{"location":"InvariantTheory/reductive_groups/#reynolds_operator-Tuple{RedGroupInvarRing, MPolyRingElem}","page":"Invariants of Linearly Reductive Groups","title":"reynolds_operator","text":"reynolds_operator(RG::RedGroupInvarRing, f::MPolyRingElem)\n\nReturn the image of f under the Reynolds operator corresponding to RG.\n\nExamples\n\njulia> G = linearly_reductive_group(:SL, 3, QQ);\n\njulia> r = representation_on_forms(G, 3);\n\njulia> S, x = graded_polynomial_ring(QQ, :x => 1:10);\n\njulia> RG = invariant_ring(S, r);\n\njulia> 75*reynolds_operator(RG, x[5]^4)\nx[1]*x[4]*x[8]*x[10] - x[1]*x[4]*x[9]^2 - x[1]*x[5]*x[7]*x[10] + x[1]*x[5]*x[8]*x[9] + x[1]*x[6]*x[7]*x[9] - x[1]*x[6]*x[8]^2 - x[2]^2*x[8]*x[10] + x[2]^2*x[9]^2 + x[2]*x[3]*x[7]*x[10] - x[2]*x[3]*x[8]*x[9] + x[2]*x[4]*x[5]*x[10] - x[2]*x[4]*x[6]*x[9] - 2*x[2]*x[5]^2*x[9] + 3*x[2]*x[5]*x[6]*x[8] - x[2]*x[6]^2*x[7] - x[3]^2*x[7]*x[9] + x[3]^2*x[8]^2 - x[3]*x[4]^2*x[10] + 3*x[3]*x[4]*x[5]*x[9] - x[3]*x[4]*x[6]*x[8] - 2*x[3]*x[5]^2*x[8] + x[3]*x[5]*x[6]*x[7] + x[4]^2*x[6]^2 - 2*x[4]*x[5]^2*x[6] + x[5]^4\n\nwarning: Experimental\nThis function is part of the experimental code in Oscar. Please read here for more details.\n\n\n\n\n\n","category":"method"},{"location":"InvariantTheory/reductive_groups/#Fundamental-Systems-of-Invariants","page":"Invariants of Linearly Reductive Groups","title":"Fundamental Systems of Invariants","text":"","category":"section"},{"location":"InvariantTheory/reductive_groups/","page":"Invariants of Linearly Reductive Groups","title":"Invariants of Linearly Reductive Groups","text":"fundamental_invariants(RG::RedGroupInvarRing)","category":"page"},{"location":"InvariantTheory/reductive_groups/#fundamental_invariants-Tuple{RedGroupInvarRing}","page":"Invariants of Linearly Reductive Groups","title":"fundamental_invariants","text":"fundamental_invariants(RG::RedGroupInvarRing)\n\nReturn a system of fundamental invariants for RG.\n\nExamples\n\njulia> G = linearly_reductive_group(:SL, 2, QQ);\n\njulia> r = representation_on_forms(G, 2);\n\njulia> RG = invariant_ring(r);\n\njulia> fundamental_invariants(RG)\n1-element Vector{MPolyDecRingElem{QQFieldElem, QQMPolyRingElem}}:\n -X[1]*X[3] + X[2]^2\n\n\nwarning: Experimental\nThis function is part of the experimental code in Oscar. Please read here for more details.\n\n\n\n\n\n","category":"method"},{"location":"references/","page":"References","title":"References","text":"<style>\ndl {\ndisplay: grid;\ngrid-template-columns: max-content auto;\n}\ndt {\ngrid-column-start: 1;\n}\ndd {\ngrid-column-start: 2;\nmargin-bottom: 0.75em;\n}\n</style>","category":"page"},{"location":"references/","page":"References","title":"References","text":"X. Allamigeon, P. Benchimol, S. Gaubert and M. Joswig. Log-barrier interior point methods are not strongly polynomial. SIAM Journal on Applied Algebra and Geometry 2, 140–178 (2018).\n\n\n\nD. Avis, D. Bremner and R. Seidel. How good are convex hull algorithms? Comput. Geom. 7, 265–301 (1997). 11th ACM Symposium on Computational Geometry (Vancouver, BC, 1995).\n\n\n\nI. V. Arzhantsev and S. A. Gaĭfullin. Cox rings, semigroups, and automorphisms of affine varieties. Mat. Sb. 201, 3–24 (2010).\n\n\n\nB. Amrhein, O. Gloor and W. Küchlin. Walking faster. In: Design and Implementation of Symbolic Computation Systems, DISCO 1996 (Springer Berlin, Heidelberg, Heidelberg, Germany, 1996); pp. 150–161.\n\n\n\nB. Amrhein, O. Gloor and W. Küchlin. On the walk. Theoretical Computer Science 187, 179–202 (1997).\n\n\n\nK. Adiprasito, J. Huh and E. Katz. Hodge theory for combinatorial geometries. Ann. of Math. (2) 188, 381–452 (2018).\n\n\n\nW. W. Adams and P. Loustaunau. An Introduction to Gröbner Bases. Graduate studies in mathematics (American Mathematical Society, 1994).\n\n\n\nR. A. Wilson, P. Walsh, J. Tripp, I. Suleiman, R. A. Parker, S. P. Norton, S. Nickerson, S. Linton, J. Bray and R. Abbott. ATLAS of Finite Group Representations. Published electronically.\n\n\n\nN. Amenta and G. M. Ziegler. Deformed products and maximal shadows of polytopes. Contemporary Mathematics 223, 57–90 (1999).\n\n\n\nM. Bayer, A. Bruening and J. Stewart. A Combinatorial Study of Multiplexes and Ordinary Polytopes. Discrete & Computational Geometry 27, 49–63 (2002).\n\n\n\nM. Bies, M. Cvetič and M. Liu. Statistics of limit root bundles relevant for exact matter spectra of F-theory MSSMs. Phys. Rev. D 104, L061903 (2021).\n\n\n\nN. Berry, A. Dubickas, N. D. Elkies, B. Poonen and C. Smyth. The conjugate dimension of algebraic numbers. Q. J. Math. 55, 237–252 (2004).\n\n\n\nJ. Böhm, W. Decker, S. Laplagne and G. Pfister. Local to global algorithms for the Gorenstein adjoint ideal of a curve. In: Algorithmic and experimental methods in algebra, geometry, and number theory (Springer, Cham, 2017); pp. 51–96.\n\n\n\nJ. Böhm, W. Decker, S. Laplagne and G. Pfister. Computing integral bases via localization and Hensel lifting. In: MEGA 2019 - International Conference on Effective Methods in Algebraic Geometry (Madrid, Spain, 2019). HAL:hal-02912148.\n\n\n\nJ. Böhm, W. Decker, S. Laplagne, G. Pfister, A. Steenpaß and S. Steidel. Parallel algorithms for normalization. Journal of Symbolic Computation 51, 99–114 (2013). Effective Methods in Algebraic Geometry.\n\n\n\nS. Brandhorst and N. D. Elkies. Equations for a K3 Lehmer map. J. Algebraic Geom. 32, 641–675 (2023).\n\n\n\nH. U. Besche, B. Eick and E. O'Brien. SmallGrp, The GAP Small Groups Library, Version 1.5.3 (May 2023). GAP package.\n\n\n\nJ. Berthomieu, C. Eder and M. Safey El Din. Msolve: A Library for Solving Polynomial Systems. In: Proceedings of the 2021 on International Symposium on Symbolic and Algebraic Computation, ISSAC '21 (Association for Computing Machinery, New York, NY, USA, 2021); pp. 51–58.\n\n\n\nS. Backman, C. Eur and C. Simpson. Simplicial generation of Chow rings of matroids. JEMS 26, 4491–4535 (2023).\n\n\n\nJ. L. Bueso, J. Gómez-Torrecillas and A. Verschoren. Algorithmic methods in non-commutative algebra. Applications to quantum groups. Vol. 17 of Math. Model.: Theory Appl. (Dordrecht: Kluwer Academic Publishers, 2003).\n\n\n\nW. Bruns and J. Herzog. Cohen-Macaulay rings. Vol. 39 of Cambridge Studies in Advanced Mathematics (Cambridge University Press, Cambridge, 2009). 2nd edition.\n\n\n\nS. Brandhorst and T. Hofmann. Finite subgroups of automorphisms of K3 surfaces. Forum of Mathematics, Sigma 11, e54 1–57 (2023).\n\n\n\nT. Braden, J. Huh, J. P. Matherne, N. Proudfoot and B. Wang. A semi-small decomposition of the Chow ring of a matroid. Advances in Mathematics 409, 108646 (2022).\n\n\n\nW. P. Barth, K. Hulek, C. A. Peters and A. Van de Ven. Compact complex surfaces. 2nd enlarged ed. Edition, Vol. 4 of Ergeb. Math. Grenzgeb., 3. Folge (Berlin: Springer, 2004).\n\n\n\nR. Blumenhagen, B. Jurke, T. Rahn and H. Roschy. Cohomology of line bundles: A computational algorithm. Journal of Mathematical Physics 51, 103525 (2010).\n\n\n\nR. Blumenhagen, B. Jurke, T. Rahn and H. Roschy, cohomCalg package. Published electronically on GitHub (2010). High-performance line bundle cohomology computation based on BJRR10.\n\n\n\nR. Blumenhagen, B. Jurke, T. Rahn and H. Roschy. Cohomology of line bundles: Applications. Journal of Mathematical Physics 53, 012302 (2012).\n\n\n\nT. Bogart, A. N. Jensen, D. Speyer, B. Sturmfels and R. R. Thomas. Computing tropical varieties. J. Symb. Comput. 42, 54–73 (2007).\n\n\n\nJ. Böhm, S. Keicher and Y. Ren. Computing GIT-fans with symmetry and the Mori chamber decomposition of overline M_06. Math. Comp. 89, 3003–3021 (2020).\n\n\n\nL. J. Billera and C. W. Lee. A proof of the sufficiency of McMullen's conditions for f-vectors of simplicial convex                   polytopes. J. Combin. Theory Ser. A 31, 237–255 (1981).\n\n\n\nM. Baker and S. Norine. Riemann-Roch and Abel-Jacobi theory on a finite graph. Adv. Math. 215, 766–788 (2007).\n\n\n\nT. Banica and R. Speicher. Liberation of orthogonal Lie groups. Advances in Mathematics 222, 1461–1501 (2009).\n\n\n\nS. Brandhorst and M. Zach. Elliptic fibrations on Vinberg's most algebraic K3 surface (2023), arXiv:2311.11766 [math.AG].\n\n\n\nD. J. Benson. Polynomial invariants of finite groups. Vol. 190 of London Mathematical Society Lecture Note Series (Cambridge University Press, Cambridge, 1993).\n\n\n\nJ. Böhm. Parametrisierung rationaler Kurven. Diploma Thesis, Universität Bayreuth (1999).\n\n\n\nM. Bies. Cohomologies of coherent sheaves and massless spectra in F-theory. Ph.D. Thesis, Heidelberg U. (Feb 2018).\n\n\n\nM. Bies. Root bundles: Applications to F-theory Standard Models. Proc. Symp. Pure Math. 107, 17–44 (2024), arXiv:2303.08144 [hep-th].\n\n\n\nT. Bisztriczky. On a class of generalized simplices. Mathematika 43, 274–285 (1996).\n\n\n\nN. Bourbaki. Lie Groups and Lie Algebras: Chapters 4–6. Elements of Mathematics (Springer, 2002). Original French edition published with the title: Éléments de Matematique, Groupes et Algèbres de                   Lie 4, 5, e 6, 1968. Translated by Pressley.\n\n\n\nW. Burnside. Theory of groups of finite order (Dover Publications, Inc., New York, 1911); p. xxiv+512. 2d ed.\n\n\n\nJ. L. Cisneros Molina, D. T. Le and J. Seade. Handbook of Geometry and Topology of Singularities I (Springer-Verlag, Cham, 2020); p. xviii+601.\n\n\n\nJ. L. Cisneros Molina, D. T. Le and J. Seade. Handbook of Geometry and Topology of Singularities II (Springer-Verlag, Cham, 2021); p. xii+578.\n\n\n\nJ. H. Conway, R. T. Curtis, S. P. Norton, R. A. Parker and R. A. Wilson. Atlas of finite groups (Oxford University Press, Eynsham, 1985); p. xxxiv+252. Maximal subgroups and ordinary characters for simple groups, With computational assistance from J. G.                   Thackray.\n\n\n\nM. Cvetič, J. Halverson, L. Lin, M. Liu and J. Tian. Quadrillion F-Theory Compactifications with the Exact Chiral Spectrum of the Standard Model. Phys. Rev. Lett. 123, 101601 (2019), arXiv:1903.00009 [hep-th].\n\n\n\nJ. H. Conway, A. Hulpke and J. McKay. On transitive permutation groups. LMS J. Comput. Math. 1, 1–8 (1998).\n\n\n\nS. Collart, M. Kalkbrener and D. Mall. Converting Bases with the Gröbner Walk. Journal of Symbolic Computation 24, 465–469 (1997).\n\n\n\nD. A. Cox, J. Little and D. O'Shea. Using Algebraic Geometry. Vol. 185 of Graduate Texts in Mathematics (Springer-Verlag, 2005).\n\n\n\nD. A. Cox, J. B. Little and H. K. Schenck. Toric varieties. Vol. 124 of Graduate Studies in Mathematics (Providence, RI: American Mathematical Society (AMS), 2011); p. xxiv+841.\n\n\n\nB. Collins, J. A. Mingo, P. Śniady and R. Speicher. Second order freeness and fluctuations of random matrices. III: Higher order freeness and free                   cumulants. Documenta Mathematica 12, 1–70 (2007).\n\n\n\nA. M. Cohen, S. H. Murray and D. E. Taylor. Computing in groups of Lie type. Math. Comp. 73, 1477–1498 (2004).\n\n\n\nA. Collinucci and R. Savelli. On Flux Quantization in F-Theory. JHEP 02, 015 (2012), arXiv:1011.6388 [hep-th].\n\n\n\nJ. H. Conway and N. J. Sloane. Sphere packings, lattices and groups. Third Edition, Vol. 290 of Grundlehren der mathematischen Wissenschaften [Fundamental Principles of Mathematical Sciences] (Springer-Verlag, New York, 1999); p. lxxiv+703. With additional contributions by E. Bannai, R. E. Borcherds, J. Leech, S. P. Norton, A. M. Odlyzko,                   R. A. Parker, L. Queen and B. B. Venkov.\n\n\n\nC. Ceballos, F. Santos and G. M. Ziegler. Many non-equivalent realizations of the associahedron. Combinatorica 35, 513–551 (2015).\n\n\n\nG. Cébron and M. Weber. Quantum groups based on spatial partitions (2016), arXiv:1609.02321 [math.QA].\n\n\n\nP. J. Cameron. Permutation groups. Vol. 45 of London Mathematical Society Student Texts (Cambridge University Press, Cambridge, 1999); p. x+220.\n\n\n\nJ. A. Christophersen. On the components and discriminant of the versal base space of cyclic quotient singularities. In: Singularity theory and its applications, Part I (Coventry, 1988/1989), Vol. 1462 of Lecture Notes in Math. (Springer, Berlin, 1991); pp. 81–92.\n\n\n\nH. Cohen. Advanced topics in computational number theory. Vol. 193 of Graduate Texts in Mathematics (Springer-Verlag, New York, 2000); p. xvi+578.\n\n\n\nH. Cohen. A course in computational algebraic number theory. Vol. 138 of Graduate Texts in Mathematics (Springer-Verlag, Berlin, 1993); p. xii+534.\n\n\n\nD. Corey. Initial degenerations of Grassmannians. Sel. Math. New Ser. 27 (2021).\n\n\n\nS. D. Cutkosky. Resolution of singularities. Vol. 63 of Graduate Studies in Mathematics (American Mathematical Society, Providence, RI, 2004); p. viii+186.\n\n\n\nA. Della Vecchia, M. Joswig and F. Lenzen. Partial Algebraic Shifting (2024), arXiv:2410.24044 [math.CO].\n\n\n\nW. Decker and D. Eisenbud. Sheaf algorithms using the exterior algebra. In: Computations in algebraic geometry with Macaulay 2 (Berlin: Springer, 2002); pp. 215–249.\n\n\n\nW. Decker, L. Ein and F.-O. Schreyer. Construction of surfaces in mathbb P^4. J. Algebr. Geom. 2, 185–237 (1993).\n\n\n\nG. De Franceschi. Centralizers and conjugacy classes in finite classical groups (2020), arXiv:2008.12651 [math.GR].\n\n\n\nA. S. Detinko, D. L. Flannery and E. A. O'Brien. Recognizing finite matrix groups over infinite fields. J. Symbolic Comput. 50, 100–109 (2013).\n\n\n\nW. Decker, G.-M. Greuel and G. Pfister. Primary decomposition: algorithms and comparisons. In: Algorithmic algebra and number theory. Selected papers from a conference, Heidelberg, Germany,                   October 1997 (Springer, Berlin, 1999); pp. 187–220.\n\n\n\nM. Domokos and P. Hegedűs. Noether's bound for polynomial invariants of finite groups. Arch. Math. (Basel) 74, 161–167 (2000).\n\n\n\nW. Decker, A. E. Heydtmann and F.-O. Schreyer. Generating a Noetherian normalization of the invariant ring of a finite group. J. Symbolic Comput. 25, 727–731 (1998).\n\n\n\nW. Decker and T. de Jong. Gröbner bases and invariant theory. In: Gröbner bases and applications. Based on a course for young researchers, January 1998, and the                   conference \"33 years of Gröbner bases\", Linz, Austria, February 2–4, 1998, Vol. 251 of London Math. Soc. Lecture Note Ser. (Cambridge Univ. Press, Cambridge, 1998); pp. 61–89.\n\n\n\nH. Derksen and G. Kemper. Computational invariant theory. With two appendices by Vladimir L. Popov, and an addendum by Norbert                   A'Campo and Popov, 2nd enlarged edition, Invariant Theory and Algebraic Transformation Groups, VIII, enlarged Edition, Vol. 130 of Encyclopaedia of Mathematical Sciences (Springer, Heidelberg, 2015); p. xxii+366.\n\n\n\nM. Donten-Bury and S. Keicher. Computing resolutions of quotient singularities. J. Algebra 472, 546–572 (2017).\n\n\n\nW. Decker and C. Lossen. Computing in algebraic geometry. A quick start using SINGULAR. Vol. 16 of Algorithms and Computation in Mathematics (Springer-Verlag, Berlin; Hindustan Book Agency, New Delhi, 2006); p. xvi+327.\n\n\n\nJ. A. De Loera, J. Rambau and F. Santos. Triangulations. Structures for algorithms and applications. Vol. 25 of Algorithms and Computation in Mathematics (Springer-Verlag, Berlin, 2010); p. xiv+535.\n\n\n\nW. Decker and G. Pfister. A first course in computational algebraic geometry. African Institute of Mathematics (AIMS) Library Series (Cambridge University Press, Cambridge, 2013); p. viii+118.\n\n\n\nW. Decker and F.-O. Schreyer. Non-general type surfaces in mathbb P^4: Some remarks on bounds and constructions. J. Symb. Comput. 29, 545–582 (2000).\n\n\n\nM. Drton, B. Sturmfels and S. Sullivant. Lectures on algebraic statistics. Vol. 39 of Oberwolfach Semin. (Basel: Birkhäuser, 2009).\n\n\n\nH. Derksen. Computation of invariants for reductive groups. Adv. Math. 141, 366–384 (1999).\n\n\n\nD. Eisenbud, G. Fløystad and F.-O. Schreyer. Sheaf cohomology and free resolutions over exterior algebras. Trans. Am. Math. Soc. 355, 4397–4426 (2003).\n\n\n\nD. Eisenbud and J. Harris. 3264 and all that. A second course in algebraic geometry (Cambridge: Cambridge University Press, 2016).\n\n\n\nD. Eisenbud, C. Huneke and B. Ulrich. What is the Rees algebra of a module? Proc. Am. Math. Soc. 131, 701–708 (2003).\n\n\n\nD. Eisenbud, C. Huneke and W. Vasconcelos. Direct methods for primary decomposition. Invent. Math. 110, 207–235 (1992).\n\n\n\nZ. S. Eser and L. F. Matusevich. Decompositions of cellular binomial ideals. J. Lond. Math. Soc. (2) 94, 409–426 (2016).\n\n\n\nZ. S. Eser and L. F. Matusevich. Corrigendum: Decompositions of cellular binomial ideals: (J. Lond. Math. Soc. 94 (2016) 409–426). J. Lond. Math. Soc. (2) 100, 717–719 (2019).\n\n\n\nB. Eröcal, O. Motsak, F.-O. Schreyer and A. Steenpaß. Refined algorithms to compute syzygies. J. Symb. Comput. 74, 308–327 (2016).\n\n\n\nD. Eisenbud and B. Sturmfels. Binomial ideals. Duke Math. J. 84, 1–45 (1996).\n\n\n\nD. Eisenbud. Commutative algebra. With a view toward algebraic geometry. Vol. 150 (Berlin: Springer-Verlag, 1995); p. xvi + 785.\n\n\n\nD. Eisenbud. Computing cohomology. A chapter in W. Vasconcelos, Computational methods in commutative algebra and                   algebraic geometry (Berlin: Springer, 1998); pp. 209–216.\n\n\n\nJ. Faugère, P. Gianni, D. Lazard and T. Mora. Efficient Computation of Zero-dimensional Gröbner Bases by Change of Ordering. Journal of Symbolic Computation 16, 329–344 (1993).\n\n\n\nK. Fukuda, A. N. Jensen, N. Lauritzen and R. Thomas. The generic Gröbner walk. Journal of Symbolic Computation 42, 298–312 (2007).\n\n\n\nH. Fan, T. Jarvis and Y. Ruan. A mathematical theory of the gauged linear sigma model. Geometry & Topology 22, 235–303 (2017).\n\n\n\nK. Fukuda, A. N. Jensen and R. R. Thomas. Computing Groebner Fans. Math. Comp. 76, 2189–2213 (2007).\n\n\n\nW. B. Hart. Fast Library for Number Theory: An Introduction. In: Proceedings of the Third International Congress on Mathematical Software, ICMS'10 (Springer-Verlag, Berlin, Heidelberg, 2010); pp. 88–91, https://flintlib.org.\n\n\n\nA. Frühbis-Krüger, L. Ristau and B. Schober. Embedded desingularization for arithmetic surfaces—toward a parallel implementation. Math. Comp. 90, 1957–1997 (2021).\n\n\n\nE. M. Feichtner and S. Yuzvinsky. Chow rings of toric varieties defined by atomic lattices. Inventiones Mathematicae 155, 515–536 (2004).\n\n\n\nJ.-C. Faugère. A new efficient algorithm for computing Gröbner bases (F4). Journal of Pure and Applied Algebra 139, 61–88 (1999). HAL:hal-01148855.\n\n\n\nW. Fulton. Algebraic curves. An introduction to algebraic geometry. Mathematics Lecture Note Series (W. A. Benjamin, Inc., New York-Amsterdam, 1969); p. xiii+226. Notes written with the collaboration of Richard Weiss.\n\n\n\nW. Fulton. Young tableaux. Vol. 35 of London Mathematical Society Student Texts (Cambridge University Press, Cambridge, 1997); p. x+260. With applications to representation theory and geometry.\n\n\n\nW. Fulton. Intersection theory. Second Edition, Vol. 2 of Ergebnisse der Mathematik und ihrer Grenzgebiete. 3. Folge. A Series of Modern Surveys in Mathematics                   [Results in Mathematics and Related Areas. 3rd Series. A Series of Modern Surveys in Mathematics] (Springer-Verlag, Berlin, 1998); p. xiv+470.\n\n\n\nT. W. Grimm and H. Hayashi. F-theory fluxes, chirality and Chern-Simons theories. Journal of High Energy Physics 2012 (2012).\n\n\n\nE. Gawrilow, S. Hampe and M. Joswig. The polymake XML File Format. In: Mathematical Software – ICMS 2016, edited by G.-M. Greuel, T. Koch, P. Paule and A. Sommese (Springer International Publishing, Cham, 2016); pp. 403–410.\n\n\n\nW. A. de Graaf, G. Ivanyos and L. Rónyai. Computing Cartan subalgebras of Lie algebras. Appl. Algebra Eng. Commun. Comput. 7, 339–349 (1996).\n\n\n\nE. Gawrilow and M. Joswig, polymake: a Framework for Analyzing Convex Polytopes. In: Polytopes — Combinatorics and Computation, edited by G. Kalai and G. M. Ziegler (Birkhäuser, 2000); pp. 43–74, https://polymake.org.\n\n\n\nE. Gawrilow, M. Joswig, T. Rörig and N. Witte. Drawing polytopal graphs with polymake. Comput. Vis. Sci. 13, 99–110 (2010), arXiv:0711.2397.\n\n\n\nY. Giannakopoulos and E. Koutsoupias. Duality and optimality of auctions for uniform distributions. In: Proceedings of the fifteenth ACM conference on Economics and computation (Association for Computing Machinery, New York, 2014); pp. 259–276.\n\n\n\nG.-M. Greuel, C. Lossen and E. Shustin. Introduction to Singularities and Deformations. Springer Monographs in Mathematics (Springer-Verlag, Berlin, 2007); p. xii+471.\n\n\n\nG.-M. Greuel, S. Laplagne and F. Seelisch. Normalization of rings. J. Symbolic Comput. 45, 887–901 (2010).\n\n\n\nG.-M. Greuel and G. Pfister. A Singular introduction to commutative algebra. With contributions by Olaf Bachmann, Christoph Lossen                   and Hans Schönemann. 2nd extended ed. (Springer, Berlin, 2008); p. xx+689. With 1 CD-ROM (Windows, Macintosh and UNIX).\n\n\n\nD. Goldfarb and W. Y. Sit. Worst case behavior of the steepest edge simplex method. Discrete Applied Mathematics 1, 277–285 (1979).\n\n\n\nD. R. Grayson, A. Seceleanu and M. E. Stillman. Computations in intersection rings of flag bundles (2022), arXiv:1205.4190 [math.AG].\n\n\n\nP. Gianni, B. Trager and G. Zacharias. Gröbner bases and primary decomposition of polynomial ideals. In: Computational aspects of commutative algebra, Vol. 6 (Elsevier Ltd, Oxford, 1988); pp. 149–167.\n\n\n\nU. Görtz and T. Wedhorn. Algebraic Geometry I: Schemes with Examples and Exercises. 2 Edition (Springer Spektrum, 2020).\n\n\n\nA. Gathmann. Class notes „Plane Algebraic Curves” (SS 2018). Published electronically (2018).\n\n\n\nK. Gatermann. Semi-invariants, equivariants and algorithms. Appl. Algebra Engrg. Comm. Comput. 7, 105–124 (1996).\n\n\n\nW. A. de Graaf. Lie algebras: theory and algorithms. Vol. 56 of North-Holland Mathematical Library (North-Holland Publishing Co., Amsterdam, 2000); p. xii+393.\n\n\n\nD. Gromada. Compact matrix quantum groups and their representation categories, doctoralthesis, Universität des Saarlandes (2020).\n\n\n\nB. Grünbaum. Convex polytopes. Second Edition, Vol. 221 of Graduate Texts in Mathematics (Springer-Verlag, New York, 2003); p. xvi+468. Prepared and with a preface by Volker Kaibel, Victor Klee and Günter M. Ziegler.\n\n\n\nD. F. Holt, B. Eick and E. A. O'Brien. Handbook of computational group theory. Discrete Mathematics and its Applications (Boca Raton) (Chapman & Hall/CRC, Boca Raton, FL, 2005); p. xvi+514.\n\n\n\nJ. Hausen, E. Herppich and H. Süss. Multigraded factorial rings and Fano varieties with torus action. Doc. Math. 16, 71–109 (2011).\n\n\n\nG. Horrocks and D. Mumford. A rank 2 vector bundle on textP^4 with 15,000 symmetries. Topology 12, 63–81 (1973).\n\n\n\nD. F. Holt and W. Plesken. Perfect groups. Oxford Mathematical Monographs (The Clarendon Press, Oxford University Press, New York, 1989); p. xii+364. With an appendix by W. Hanrath, Oxford Science Publications.\n\n\n\nA. Hulpke, C. Roney-Dougal and C. Russell. PrimGrp, GAP Primitive Permutation Groups Library, Version 3.4.4 (Feb 2023). GAP package.\n\n\n\nJ. Halverson and J. Tian. Cost of seven-brane gauge symmetry in a quadrillion F-theory compactifications. Phys. Rev. D 95, 026005 (2017), arXiv:1610.08864 [hep-th].\n\n\n\nR. Hartshorne. Algebraic Geometry. Graduate Texts in Mathematics (Springer-Verlag, New York, 1977); p. xvi+496.\n\n\n\nH. Hasse. Noch eine Begründung der Theorie der höheren Differentialquotienten in einem algebraischen                   Funktionenkörper einer Unbestimmten. (Nach einer brieflichen Mitteilung von F. K. Schmidt in Jena). J. Reine Angew. Math. 177, 215–237 (1937).\n\n\n\nM. Hazewinkel. Hasse-Schmidt Derivations and the Hopf Algebra of Non-Commutative Symmetric Functions. Axioms 1, 149–154 (2012).\n\n\n\nA. Hulpke. The perfect groups of order up to two million. Math. Comp. 91, 1007–1017 (2022).\n\n\n\nA. Hulpke. TransGrp, Transitive Groups Library, Version 3.6.5 (Dec 2023). GAP package.\n\n\n\nJ. E. Humphreys. Introduction to Lie Algebras and Representation Theory. Vol. 9 of Graduate Texts in Mathematics (Springer-Verlag, New York, 1972); p. xii+169.\n\n\n\nB. Huppert. Endliche Gruppen. I. Vol. 134 of Die Grundlehren der mathematischen Wissenschaften (Springer-Verlag, Berlin-New York, 1967); p. xii+793.\n\n\n\nD. Huybrechts. Lectures on K3 surfaces. Vol. 158 of Cambridge Studies in Advanced Mathematics (Cambridge University Press, Cambridge, 2016); p. xi+485.\n\n\n\nY. Ito and M. Reid. The McKay correspondence for finite subgroups of mathrmSL(3mathbb C). In: Higher-dimensional complex varieties (Trento, 1994) (de Gruyter, 1996); pp. 221–240.\n\n\n\nM. Joswig, M. Klimm and S. Spitz. Generalized permutahedra and optimal auctions. SIAM Journal on Applied Algebra and Geometry 6, 711–739 (2022).\n\n\n\nM. Joswig, D. Lofano, F. H. Lutz and M. Tsuruga. Frontiers of sphere recognition in practice. J. Appl. Comput. Topol. 6, 503–527 (2022).\n\n\n\nC. Jansen, K. Lux, R. Parker and R. Wilson. An atlas of Brauer characters. Vol. 11 of London Mathematical Society Monographs. New Series (The Clarendon Press Oxford University Press, New York, 1995); p. xviii+327. Appendix 2 by T. Breuer and S. Norton, Oxford Science Publications.\n\n\n\nT. de Jong and G. Pfister. Local Analytic Geometry. Advanced Lectures in Mathematics (Vieweg+Teubner Verlag, 2000); p. xi+384.\n\n\n\nM. Joswig and T. Theobald. Polyhedral and algebraic methods in computational geometry. Universitext (Springer, London, 2013); p. x+250. Revised and updated translation of the 2008 German original.\n\n\n\nM. Joswig and G. M. Ziegler. Neighborly Cubical Polytopes. Discrete & Computational Geometry  24, 325–344 (2000).\n\n\n\nF. Johansson. Efficient implementation of the Hardy-Ramanujan-Rademacher formula. LMS J. Comput. Math. 15, 341–359 (2012).\n\n\n\nM. Joswig. Beneath-and-Beyond Revisited. In: Algebra, Geometry and Software Systems, edited by M. Joswig and N. Takayama (Springer Berlin Heidelberg, Berlin, Heidelberg, 2003); pp. 1–21.\n\n\n\nM. Joswig. Polytope propagation on graphs. In: Algebraic statistics for computational biology. (Cambridge: Cambridge University Press, 2005); pp. 181–192.\n\n\n\nM. Joswig. Essentials of tropical combinatorics. Vol. 219 of Graduate Studies in Mathematics (American Mathematical Society, Providence, RI, 2021).\n\n\n\nS.-Y. Jow. Cohomology of toric line bundles via simplicial Alexander duality. Journal of Mathematical Physics 52, 033506 (2011).\n\n\n\nT. Krick and A. Logar. An algorithm for the computation of the radical of an ideal in the ring of polynomials. In: Applied algebra, algebraic algorithms and error-correcting codes (New Orleans, LA, 1991), Vol. 539 of Lecture Notes in Comput. Sci. (Springer, Berlin, 1991); pp. 195–205.\n\n\n\nM. Kaluba, B. Lorenz and S. Timme. Polymake.jl: A New Interface to polymake. In: Mathematical Software – ICMS 2020, edited by A. M. Bigatti, J. Carette, J. H. Davenport, M. Joswig and T. de Wolff (Springer International Publishing, Cham, 2020); pp. 377–385.\n\n\n\nD. Klevers, D. K. Mayorga Pena, P.-K. Oehlmann, H. Piragua and J. Reuter. F-Theory on all Toric Hypersurface Fibrations and its Higgs Branches. JHEP 01, 142 (2015), arXiv:1408.4808 [hep-th].\n\n\n\nS. Katz, D. R. Morrison, S. Schafer-Nameki and J. Sully. Tate's algorithm and F-theory. JHEP 08, 094 (2011), arXiv:1106.3854 [hep-th].\n\n\n\nJ. Kelleher and B. O'Sullivan. Generating All Partitions: A Comparison Of Two Encodings (2014), arXiv:0909.2331 [cs.DS].\n\n\n\nM. Kreuzer and L. Robbiano. Computational commutative algebra. II (Berlin: Springer, 2005); p. x + 586.\n\n\n\nG. Kemper and A. Steel. Some algorithms in invariant theory of finite groups. In: Computational methods for representations of groups and algebras (Essen, 1997), Vol. 173 of Progr. Math. (Birkhäuser, Basel, 1999); pp. 267–285.\n\n\n\nT. Kahle. Decompositions of binomial ideals. Ann. Inst. Statist. Math. 62, 727–745 (2010).\n\n\n\nG. Kalai. Algebraic shifting. In: Computational commutative algebra and combinatorics, No. 33 of Advanced Studies in Pure Mathematics, edited by T. Hibi (Mathematical Society of Japan, 2002); pp. 121–163.\n\n\n\nG. Kemper. The calculation of radical ideals in positive characteristic. J. Symbolic Comput. 34, 229–238 (2002).\n\n\n\nG. Kemper. An algorithm to calculate optimal homogeneous systems of parameters. J. Symbolic Comput. 27, 171–184 (1999).\n\n\n\nS. King. Fast computation of secondary invariants (2007), arXiv:math/0701270 [math.AC].\n\n\n\nS. King. Minimal generating sets of non-modular invariant rings of finite groups. J. Symb. Comput. 48, 101–109 (2013).\n\n\n\nD. E. Knuth. The art of computer programming. Vol. 4A. Combinatorial algorithms. Part 1 (Addison-Wesley, Upper Saddle River, NJ, 2011); p. xv+883.\n\n\n\nD. E. Knuth. Sorting and searching. 2 Edition, Vol. 3 (Addison-Wesley, 1998).\n\n\n\nJ. Kollár. Singularities of the minimal model program. Vol. 200 of Cambridge Tracts in Mathematics (Cambridge University Press, 2013). With a collaboration of Sándor Kovács.\n\n\n\nD. Kozlov. Combinatorial algebraic topology. Vol. 21 of Algorithms and Computation in Mathematics (Springer, Berlin, 2008).\n\n\n\nR. Lidl and H. Niederreiter. Finite fields. Second Edition, Vol. 20 of Encyclopedia of Mathematics and its Applications (Cambridge University Press, Cambridge, 1997); p. xiv+755. With a foreword by P. M. Cohn.\n\n\n\nV. Levandovskyy and H. Schönemann. Plural – a computer algebra system for noncommutative polynomial algebras. In: Proceedings of the 2003 international symposium on symbolic and algebraic computation, ISSAC 2003,                   Philadelphia, PA, USA, August 3–6, 2003. (New York, NY: ACM Press, 2003); pp. 176–183.\n\n\n\nC. Lawrie and S. Schäfer-Nameki. The Tate Form on Steroids: Resolution and Higher Codimension Fibers. JHEP 04, 061 (2013), arXiv:1212.2949 [hep-th].\n\n\n\nV. Levandovskyy. Non-commutative Computer Algebra for polynomial algebras: Gröbner bases, applications and                   implementation, doctoralthesis, Technische Universität Kaiserslautern (2005).\n\n\n\nQ. Liu. Algebraic geometry and arithmetic curves. Transl. by Reinie Erné. Vol. 6 of Oxf. Grad. Texts Math. (Oxford: Oxford University Press, 2006).\n\n\n\nE. Looijenga. Isolated Singular Points on Complete Intersections. Vol. 77 of LMS Lecture Note Series (Cambridge University Press, Cambridge, 1984); p. xi+200.\n\n\n\nT. Merkwitz, L. Naughton and G. Pfeiffer. TomLib, The GAP Library of Tables of Marks, Version 1.2.11 (Jan 2024). GAP package.\n\n\n\nR. V. Moody and J. Patera. Fast recursion formula for weight multiplicities. Bull. Amer. Math. Soc. (N.S.) 7, 237–242 (1982).\n\n\n\nT. Markwig and Y. Ren. Computing tropical varieties over fields with valuation. Found. Comput. Math. 20, 783–800 (2020).\n\n\n\nE. Miller and B. Sturmfels. Combinatorial commutative algebra. Vol. 227 (New York, NY: Springer, 2005); p. xiv + 417.\n\n\n\nD. Maclagan and B. Sturmfels. Introduction to tropical geometry. Vol. 161 (Providence, RI: American Mathematical Society (AMS), 2015); p. xii + 363.\n\n\n\nM. Michałek and B. Sturmfels. Invitation to nonlinear algebra. Vol. 211 (Providence, RI: American Mathematical Society (AMS), 2021); p. xiii + 226.\n\n\n\nD. A. Marcus. Number fields. Universitext (Springer, Cham, 2018); p. xviii+203. Second edition of [MR0457396], With a foreword by Barry Mazur.\n\n\n\nV. V. Nikulin. Integer symmetric bilinear forms and some of their geometric applications. Izv. Akad. Nauk SSSR Ser. Mat. 43, 111–177, 238 (1979).\n\n\n\nOEIS Foundation Inc. The On-Line Encyclopedia of Integer Sequences. Published electronically at https://oeis.org (2024).\n\n\n\nT. Oda and K. Miyake. Lectures on Torus Embeddings and Applications. Lectures on mathematics and physics (Tata Institute of Fundamental Research, 1978).\n\n\n\nI. Ojeda Martínez de Castilla and R. P. Sánchez. Cellular binomial ideals. Primary decomposition of binomial ideals. J. Symbolic Comput. 30, 383–400 (2000).\n\n\n\nJ. Oxley. Matroid theory. Second Edition, Vol. 21 of Oxford Graduate Texts in Mathematics (Oxford University Press, Oxford, 2011); p. xiv+684.\n\n\n\nA. Postnikov and R. P. Stanley. Chains in the Bruhat order. J. Algebraic Combin. 29, 133–174 (2009).\n\n\n\nS. Pokutta and A. S. Schulz. Integer-empty polytopes in the 0/1-cube with maximal Gomory–Chvátal rank. Operations research letters 39, 457–460 (2011).\n\n\n\nG. Pfister, A. Sadiq and S. Steidel. An algorithm for primary decomposition in polynomial rings over the integers. Cent. Eur. J. Math. 9, 897–904 (2011).\n\n\n\nM. Pohst and H. Zassenhaus. Algorithmic algebraic number theory. Vol. 30 of Encyclopedia of Mathematics and its Applications (Cambridge University Press, Cambridge, 1997); p. xiv+499. Revised reprint of the 1989 original.\n\n\n\nE. Pan. SOTGrps, Constructing and identifying groups of small order type, Version 1.2 (Jun 2023). GAP package.\n\n\n\nC. Pegel. Chow Rings of Toric Varieties. Master's thesis, University of Bremen (Faculty of Mathematics, Sep 2014). Refereed by Prof. Dr. Eva Maria Feichtner and Dr. Emanuele Delucchi.\n\n\n\nG. Pólya. On picture-writing. Amer. Math. Monthly 63, 689–697 (1956).\n\n\n\nS. Popescu. On smooth surfaces of degree geq 11 in the projective fourspace, doctoralthesis, Universität des Saarlandes, Saarbrücken (1993).\n\n\n\nA. Postnikov. Permutohedra, associahedra, and beyond. International Mathematics Research Notices 2009, 1026–1106 (2009).\n\n\n\nS. Posur. Linear systems over localizations of rings. Archiv der Mathematik 111, 23–32 (2018).\n\n\n\nW. Riha and K. R. James. Algorithm 29 efficient algorithms for doubly and multiply restricted partitions. Computing 16, 163–168 (1976).\n\n\n\nH. Roschy and T. Rahn. Cohomology of line bundles: Proof of the algorithm. Journal of Mathematical Physics 51, 103520 (2010).\n\n\n\nG. Rote, F. Santos and I. Streinu. Expansive motions and the polytope of pointed pseudo-triangulations. In: Discrete and Computational Geometry (Springer, 2003); pp. 699–736.\n\n\n\nF. Rincón. Computing tropical linear spaces. J. Symb. Comput. 51, 86–98 (2013).\n\n\n\nC. Semple and M. Steel. Phylogenetics. Vol. 24 of Oxf. Lect. Ser. Math. Appl. (Oxford University Press, 2003).\n\n\n\nC. D. Savage and M. J. Schuster. Ehrhart series of lecture hall polytopes and Eulerian polynomials for inversion sequences. Journal of Combinatorial Theory, Series A 119, 850–870 (2012).\n\n\n\nM. Schütt and T. Shioda. Mordell-Weil lattices. Vol. 70 of Ergebnisse der Mathematik und ihrer Grenzgebiete. 3. Folge. A Series of Modern Surveys in Mathematics                   [Results in Mathematics and Related Areas. 3rd Series. A Series of Modern Surveys in Mathematics] (Springer, Singapore, 2019); p. xvi+431.\n\n\n\nA. J. Sommese and A. Van de Ven. On the adjunction mapping. Math. Ann. 278, 593–603 (1987).\n\n\n\nT. Shimoyama and K. Yokoyama. Localization and primary decomposition of polynomial ideals. J. Symbolic Comput. 22, 247–277 (1996).\n\n\n\nJ. Schmitt. On mathbb Q-factorial terminalizations of symplectic linear quotient singularities. Ph.D. Thesis, RPTU Kaiserslautern-Landau (2023).\n\n\n\nP. Schuchert. Matroid-Polytope und Einbettungen kombinatorischer Mannigfaltigkeiten. Ph.D. Thesis, TU Darmstadt (1995).\n\n\n\nÁ. Seress. Permutation group algorithms. Vol. 152 of Cambridge Tracts in Mathematics (Cambridge University Press, Cambridge, 2003); p. x+264.\n\n\n\nM. Sezer. Sharpening the generalized Noether bound in the invariant theory of finite groups. J. Algebra 254, 252–263 (2002).\n\n\n\nI. Shimada. An algorithm to compute automorphism groups of K3 surfaces and an application to singular K3                   surfaces. Int. Math. Res. Not. IMRN, 11961–12014 (2015).\n\n\n\nI. Shimada. Connected Components of the Moduli of Elliptic K3 Surfaces. Michigan Mathematical Journal 67, 511–559 (2018).\n\n\n\nR. P. Stanley. Invariants of finite groups and their applications to combinatorics. Bull. Amer. Math. Soc. (N.S.) 1, 475–511 (1979).\n\n\n\nThe Stacks Project Authors. Stacks Project. Published electronically.\n\n\n\nJ. R. Stembridge. Computational aspects of root systems, Coxeter groups, and Weyl characters. In: Interaction of combinatorics and representation theory, Vol. 11 of MSJ Memoirs (The Mathematical Society of Japan, 2001); pp. 1–38.\n\n\n\nJ. Stevens. On the versal deformation of cyclic quotient singularities. In: Singularity theory and its applications, Part I (Coventry, 1988/1989), Vol. 1462 of Lecture Notes in Math. (Springer, Berlin, 1991); pp. 302–319.\n\n\n\nB. Sturmfels. Algorithms in invariant theory. Texts and Monographs in Symbolic Computation (Springer-Verlag, Vienna, 1993); p. vi+197.\n\n\n\nS. Sullivant. Algebraic statistics. Vol. 194 of Grad. Stud. Math. (Providence, RI: American Mathematical Society (AMS), 2018).\n\n\n\nP. Symonds. On the Castelnuovo-Mumford regularity of rings of polynomial invariants. Ann. of Math. (2) 174, 499–517 (2011).\n\n\n\nP. Tarrago and M. Weber. The classification of tensor categories of two-colored noncrossing partitions. Journal of Combinatorial Theory, Series A 154, 464–506 (2018).\n\n\n\nD. E. Taylor. Pairs of Generators for Matrix Groups. I. The Cayley Bulletin 3, 76–85 (1987), arXiv:2201.09155 [math.GR].\n\n\n\nQ.-N. Tran. A Fast Algorithm for Gröbner Basis Conversion and its Applications. Journal of Symbolic Computation 30, 451–467 (2000).\n\n\n\nQ.-N. Tran. Efficient Groebner walk conversion for implicitization of geometric objects. Computer Aided Geometric Design 21, 837–857 (2004).\n\n\n\nI. Turkalj. Reflective Lorentzian lattices of signature (5, 1). Journal of Algebra 513, 516–544 (2018).\n\n\n\nM. Vaughan-Lee and B. Eick. SglPPow, Database of groups of prime-power order for some prime-powers, Version 2.3 (Nov 2022). GAP package.\n\n\n\nE. B. Vinberg. Some arithmetical discrete groups in Lobacevsky spaces. In: Discrete subgroups of Lie groups and applications to moduli (Internat. Colloq., Bombay, 1973), No. 7 of Tata Inst. Fundam. Res. Stud. Math. (Published for the Tata Institute of Fundamental Research, Bombay by Oxford University Press, Bombay, 1975); pp. 323–348.\n\n\n\nS. Volz. Design and implementation of efficient algorithms for operations on partitions of sets. Bachelor's Thesis, Universität des Saarlandes (2023).\n\n\n\nL. C. Washington. Elliptic curves. Second Edition, Discrete Mathematics and its Applications (Boca Raton) (Chapman & Hall/CRC, Boca Raton, FL, 2008); p. xviii+513. Number theory and cryptography.\n\n\n\nT. Weigand. Lectures on F-theory compactifications and model building. Class. Quant. Grav. 27, 214004 (2010), arXiv:1009.3497 [hep-th].\n\n\n\nT. Weigand. TASI Lectures on F-theory. PoS TASI2017, 016 (2018), arXiv:1806.01854 [hep-th].\n\n\n\nJ. B. Wilson. Optimal algorithms of Gram-Schmidt type. Linear Algebra Appl. 438, 4573–4583 (2013).\n\n\n\nE. Witten. Topological Sigma Models. Commun. Math. Phys. 118, 411 (1988).\n\n\n\nE. Witten. On flux quantization in M theory and the effective action. J. Geom. Phys. 22, 1–13 (1997), arXiv:hep-th/9609122.\n\n\n\nR. Yamagishi. On smoothness of minimal models of quotient singularities by finite subgroups of                   mathrmSL_n(mathbb C). Glasg. Math. J. 60, 603–634 (2018).\n\n\n\nA. Zoghbi and I. Stojmenovic. Fast algorithms for generating integer partitions. Int. J. Comput. Math. 70, 319–332 (1998).\n\n\n\nG. M. Ziegler. Lectures on polytopes. Vol. 152 of Graduate Texts in Mathematics (Springer-Verlag, New York, 1995); p. x+370.\n\n\n\n","category":"page"},{"location":"CommutativeAlgebra/FrameWorks/module_localizations/","page":"Localizations of modules over computable rings","title":"Localizations of modules over computable rings","text":"CurrentModule = Oscar","category":"page"},{"location":"CommutativeAlgebra/FrameWorks/module_localizations/#Localizations-of-modules-over-computable-rings","page":"Localizations of modules over computable rings","title":"Localizations of modules over computable rings","text":"","category":"section"},{"location":"CommutativeAlgebra/FrameWorks/module_localizations/","page":"Localizations of modules over computable rings","title":"Localizations of modules over computable rings","text":"For localizations of modules, there exists a generic implementation of  the common methods such as membership tests, kernel computations, etc.  based on the work of Barakat, Posur, et. al; see [Pos18].","category":"page"},{"location":"CommutativeAlgebra/FrameWorks/module_localizations/","page":"Localizations of modules over computable rings","title":"Localizations of modules over computable rings","text":"Let R be a ring of type <:Ring, U subset R a multiplicative set of type <:AbsMultSet  and S = RU^-1 the localization of R at U. Recall that R  is computable if one can compute syzygies and lifts over R.  The results from [Pos18], Theorem 3.9, assert that then also the localization S is  computable, provided that there exists a solution to the localization problem  (Definition 3.8, [Pos18] and below). ","category":"page"},{"location":"CommutativeAlgebra/FrameWorks/module_localizations/","page":"Localizations of modules over computable rings","title":"Localizations of modules over computable rings","text":"The user who wishes to use the generic code for  localizations therefore has to make sure the following two  requirements are met: ","category":"page"},{"location":"CommutativeAlgebra/FrameWorks/module_localizations/","page":"Localizations of modules over computable rings","title":"Localizations of modules over computable rings","text":"The code for finitely generated modules and ideals must be functional over R, including the computation of coordinates and kernel. \nThe user has to solve the localization problem by implementing has_nonempty_intersection(U::MultSetType, I::IdealType) for the type MultSetType of multiplicative sets and the type IdealType of ideals in R that they would like to consider.","category":"page"},{"location":"CommutativeAlgebra/FrameWorks/module_localizations/","page":"Localizations of modules over computable rings","title":"Localizations of modules over computable rings","text":"has_nonempty_intersection(U::AbsMultSet, I::Ideal)","category":"page"},{"location":"CommutativeAlgebra/FrameWorks/module_localizations/#has_nonempty_intersection-Tuple{AbsMultSet, Ideal}","page":"Localizations of modules over computable rings","title":"has_nonempty_intersection","text":"has_nonempty_intersection(U::AbsMultSet, I::Ideal)\n\nFor a finitely generated ideal I  R and a multiplicative  set U  R, this checks whether the intersection U  I  is nonempty and returns a triple \n\n(success, f, a).\n\nIn the affirmative case, success is true, f  U  I is  some element in the intersection and a  R¹ˣᵏ is a  Vector{elem_type(R)} such that f = ᵢ aᵢgᵢ where gᵢ are the elements in gens(I).\n\nWhen the intersection is empty, this returns (false, f, a) with meaningless values for f and a.\n\nNote: When implementing methods of this function, it is  recommended to choose f to be the 'least complex' in  an appropriate sense for R.\n\n\n\n\n\n","category":"method"},{"location":"CommutativeAlgebra/FrameWorks/module_localizations/","page":"Localizations of modules over computable rings","title":"Localizations of modules over computable rings","text":"Note: In order to clear denominators of row vectors, the generic code uses the method lcm(v::Vector{T}) where T = elem_type(R).  If no such method already exists, this has to also be provided; in the worst case by simply returning the product of the denominators. ","category":"page"},{"location":"CommutativeAlgebra/FrameWorks/module_localizations/","page":"Localizations of modules over computable rings","title":"Localizations of modules over computable rings","text":"As soon as the above requirements are met, the methods ","category":"page"},{"location":"CommutativeAlgebra/FrameWorks/module_localizations/","page":"Localizations of modules over computable rings","title":"Localizations of modules over computable rings","text":"   represents_element(u::FreeModElem{T}, M::SubquoModule{T}) where {T<:AbsLocalizedRingElem}\n   coordinates(u::FreeModElem{T}, M::SubquoModule{T}) where {T<:AbsLocalizedRingElem}\n   kernel(f::FreeModuleHom{DomType, CodType, Nothing}) where {T, DomType<:FreeMod{T}, CodType<:SubquoModule{T}}\n   kernel(f::SubQuoHom{DomType, CodType, Nothing}) where {T, DomType<:FreeMod{T}, CodType<:SubquoModule{T}}\n   iszero(a::SubquoModuleElem{T}) where {T<:AbsLocalizedRingElem}","category":"page"},{"location":"CommutativeAlgebra/FrameWorks/module_localizations/","page":"Localizations of modules over computable rings","title":"Localizations of modules over computable rings","text":"will be available for modules over S, i.e. for T = elem_type(S).  As can easily be seen, having the first three of these methods is already equivalent to S = RU^-1 being computable; hence all higher methods can be derived  from these basic ones. ","category":"page"},{"location":"CommutativeAlgebra/FrameWorks/module_localizations/","page":"Localizations of modules over computable rings","title":"Localizations of modules over computable rings","text":"The generic code makes use of a simple caching mechanism for the SubquoModules as follows.  For a module M = (G + N)N with submodules G N subset R^n of some free module,  the localization MU^-1 over S = RU^-1 has an associated saturated module over R:","category":"page"},{"location":"CommutativeAlgebra/FrameWorks/module_localizations/","page":"Localizations of modules over computable rings","title":"Localizations of modules over computable rings","text":"   M = (G + N)N quad\n   G =  a in R^n  exists u in U  u cdot a in G + Nquad\n   N =  b in R^n  exists u in U  u cdot b in N","category":"page"},{"location":"CommutativeAlgebra/FrameWorks/module_localizations/","page":"Localizations of modules over computable rings","title":"Localizations of modules over computable rings","text":"While it might be difficult to compute such saturations, we have a generic algorithm to check  membership for elements in M (via represents_element for MU^-1).  It is assumed that such membership tests are cheaper for modules over R compared to  modules over S. For instance in the case where R is a multivariate polynomial ring,  once a (relative) groebner basis has been computed for M, membership test for M  is merely a reduction while for the localization MU^-1 it triggers  another groebner basis computation a priori. ","category":"page"},{"location":"CommutativeAlgebra/FrameWorks/module_localizations/","page":"Localizations of modules over computable rings","title":"Localizations of modules over computable rings","text":"But for every element a in R^n that has  already been shown to represent an element in the saturation M, we can cache  the results of the computation in an intermediate pre-saturated module  M subset tilde M subset M by adding the necessary generators to G and N  for a representation of a. Then, checking membership for a a second time will  fall back to a membership test in tilde M. For the latter, we assume some caching  to already be implemented as, for instance, for the use of groebner bases in the polynomial  case.","category":"page"},{"location":"CommutativeAlgebra/FrameWorks/module_localizations/","page":"Localizations of modules over computable rings","title":"Localizations of modules over computable rings","text":"A sample implementation for various localizations of multivariate polynomial rings  can be found in src/Modules/mpoly-localizations.jl. A modified version for localizations  of affine algebras which also overwrites some of the generic methods, is in  src/Modules/mpolyquo-localizations.jl.","category":"page"},{"location":"General/faq/","page":"Frequently Asked Questions","title":"Frequently Asked Questions","text":"CurrentModule = Oscar\nDocTestSetup = Oscar.doctestsetup()","category":"page"},{"location":"General/faq/#Frequently-Asked-Questions","page":"Frequently Asked Questions","title":"Frequently Asked Questions","text":"","category":"section"},{"location":"General/faq/#General-questions","page":"Frequently Asked Questions","title":"General questions","text":"","category":"section"},{"location":"General/faq/","page":"Frequently Asked Questions","title":"Frequently Asked Questions","text":"Q: How do I install OSCAR?","category":"page"},{"location":"General/faq/","page":"Frequently Asked Questions","title":"Frequently Asked Questions","text":"You can find our installation instructions here.","category":"page"},{"location":"General/faq/","page":"Frequently Asked Questions","title":"Frequently Asked Questions","text":"","category":"page"},{"location":"General/faq/","page":"Frequently Asked Questions","title":"Frequently Asked Questions","text":"Q: Can I find all methods that apply to a given object?","category":"page"},{"location":"General/faq/","page":"Frequently Asked Questions","title":"Frequently Asked Questions","text":"Yes, Julia provides the function methodswith for this very purpose.","category":"page"},{"location":"General/faq/","page":"Frequently Asked Questions","title":"Frequently Asked Questions","text":"For your convenience, let us give an example here. To this end, we first create a projective space in OSCAR:","category":"page"},{"location":"General/faq/","page":"Frequently Asked Questions","title":"Frequently Asked Questions","text":"julia> v = projective_space(NormalToricVariety,2)\nNormal toric variety\n\njulia> typeof(v)\nNormalToricVariety","category":"page"},{"location":"General/faq/","page":"Frequently Asked Questions","title":"Frequently Asked Questions","text":"Suppose that we now want to find all methods that accept a NormalToricVariety as one of their arguments. This can be achieved as follows:","category":"page"},{"location":"General/faq/","page":"Frequently Asked Questions","title":"Frequently Asked Questions","text":"julia> methodswith(typeof(v))\n[1] intersection_form(v::NormalToricVariety) in Oscar at /datadisk/Computer/Mathematics_software/PackagesForJulia/Oscar.jl/src/ToricVarieties/CohomologyClasses/special_attributes.jl:101\n[2] mori_cone(v::NormalToricVariety) in Oscar at /datadisk/Computer/Mathematics_software/PackagesForJulia/Oscar.jl/src/ToricVarieties/NormalToricVarieties/attributes.jl:976\n[3] nef_cone(v::NormalToricVariety) in Oscar at /datadisk/Computer/Mathematics_software/PackagesForJulia/Oscar.jl/src/ToricVarieties/NormalToricVarieties/attributes.jl:953\n[4] toric_ideal(ntv::NormalToricVariety) in Oscar at /datadisk/Computer/Mathematics_software/PackagesForJulia/Oscar.jl/src/ToricVarieties/NormalToricVarieties/attributes.jl:510\n[5] volume_form(v::NormalToricVariety) in Oscar at /datadisk/Computer/Mathematics_software/PackagesForJulia/Oscar.jl/src/ToricVarieties/CohomologyClasses/special_attributes.jl:50","category":"page"},{"location":"General/faq/","page":"Frequently Asked Questions","title":"Frequently Asked Questions","text":"Often it can be beneficial to also include supertypes in the search:","category":"page"},{"location":"General/faq/","page":"Frequently Asked Questions","title":"Frequently Asked Questions","text":"julia> methodswith(typeof(v), supertypes = true)","category":"page"},{"location":"General/faq/","page":"Frequently Asked Questions","title":"Frequently Asked Questions","text":"As of December 2022, this results in a list of 101 functions.","category":"page"},{"location":"General/faq/","page":"Frequently Asked Questions","title":"Frequently Asked Questions","text":"Note that we can also find the constructors, i.e. functions that return an object of type NormalToricVariety. This is possible with the Julia function methods:","category":"page"},{"location":"General/faq/","page":"Frequently Asked Questions","title":"Frequently Asked Questions","text":"julia> methods(typeof(v))\n# 5 methods for type constructor:\n[1] NormalToricVariety(P::Polyhedron) in Oscar at /datadisk/Computer/Mathematics_software/PackagesForJulia/Oscar.jl/src/ToricVarieties/NormalToricVarieties/constructors.jl:183\n[2] NormalToricVariety(PF::PolyhedralFan) in Oscar at /datadisk/Computer/Mathematics_software/PackagesForJulia/Oscar.jl/src/ToricVarieties/NormalToricVarieties/constructors.jl:155\n[3] NormalToricVariety(rays::Vector{Vector{Int64}}, max_cones::Vector{Vector{Int64}}; non_redundant) in Oscar at /datadisk/Computer/Mathematics_software/PackagesForJulia/Oscar.jl/src/ToricVarieties/NormalToricVarieties/constructors.jl:131\n[4] NormalToricVariety(C::Cone) in Oscar at /datadisk/Computer/Mathematics_software/PackagesForJulia/Oscar.jl/src/ToricVarieties/NormalToricVarieties/constructors.jl:79\n[5] NormalToricVariety(polymakeNTV::Polymake.BigObject) in Oscar at /datadisk/Computer/Mathematics_software/PackagesForJulia/Oscar.jl/src/ToricVarieties/NormalToricVarieties/constructors.jl:8","category":"page"},{"location":"General/faq/","page":"Frequently Asked Questions","title":"Frequently Asked Questions","text":"","category":"page"},{"location":"General/faq/","page":"Frequently Asked Questions","title":"Frequently Asked Questions","text":"Q: Why do you have your own matrix types, and why do they not support the exact same commands as Julia matrices?","category":"page"},{"location":"General/faq/","page":"Frequently Asked Questions","title":"Frequently Asked Questions","text":"Unfortunately, Julia's matrices and linear algebra cannot be made to work in our context due to two independent problems:","category":"page"},{"location":"General/faq/","page":"Frequently Asked Questions","title":"Frequently Asked Questions","text":"In empty matrices (0 rows or columns) all that is known is the type of the matrix entries, however for the complex types used in OSCAR, this information is not sufficient to create elements, hence zero(T) or friends cannot work.\nMany functions (e.g. det) assume that all types used embed into the real or complex numbers, in Julia det(ones(Int, (1,1))) == 1.0, so the fact that this is exactly the integer 1  is lost. Furthermore, more general rings cannot be embedded into the reals at all.","category":"page"},{"location":"General/faq/","page":"Frequently Asked Questions","title":"Frequently Asked Questions","text":"","category":"page"},{"location":"General/faq/","page":"Frequently Asked Questions","title":"Frequently Asked Questions","text":"Q: Why can zero(T) for a type T not work?","category":"page"},{"location":"General/faq/","page":"Frequently Asked Questions","title":"Frequently Asked Questions","text":"At least two reasons:","category":"page"},{"location":"General/faq/","page":"Frequently Asked Questions","title":"Frequently Asked Questions","text":"The type depends on data that is not a bit-type.\nEven if it could, it is not desirable. Typical example: computations in mathbb Znmathbb Z, so modular arithmetic. If n is small, then it is tempting to define a type T depending on n. We actually did this, and tried to use this. It did not work well, for various reasons. E.g.:\nA generic algorithmic pattern for problems over the integers is to solve them by solving them modulo n for many n, e.g. chosen as prime numbers, and then to combine them. If the type depends on n, then for every prime the code gets compiled, thus negating any advantages from the use of modular techniqes.","category":"page"},{"location":"General/faq/","page":"Frequently Asked Questions","title":"Frequently Asked Questions","text":"Of course, one could make the n an additional parameter to all functions needing it, but then e.g. addition of matrices would have to be implemented specifically for this case, negating the advantages of generic implementations.","category":"page"},{"location":"General/faq/","page":"Frequently Asked Questions","title":"Frequently Asked Questions","text":"In OSCAR, the role of the type is split between the actual Julia type and the parent.","category":"page"},{"location":"General/faq/","page":"Frequently Asked Questions","title":"Frequently Asked Questions","text":"","category":"page"},{"location":"General/faq/","page":"Frequently Asked Questions","title":"Frequently Asked Questions","text":"Q: What is a parent?","category":"page"},{"location":"General/faq/","page":"Frequently Asked Questions","title":"Frequently Asked Questions","text":"Almost all element-like objects in OSCAR have a parent, i.e., they belong to some larger structure. For example algebraic numbers belong to a number field, modular integers belong to a ring mathbb Znmathbb Z, permutations are elements of permutation groups and so on. The data common to all such elements is out-sourced to the parent. For a number field for example, the parent contains the polynomial used to define the field (plus other information).","category":"page"},{"location":"General/faq/","page":"Frequently Asked Questions","title":"Frequently Asked Questions","text":"Given that a type alone is not large enough to contain the data, the parent is used. Roughly, outside a function signature, a parent replaces the role of the type. For example, for a ring element elm in OSCAR zero(parent(elm)) works, even if zero(typeof(elm)) may not.","category":"page"},{"location":"General/faq/","page":"Frequently Asked Questions","title":"Frequently Asked Questions","text":"","category":"page"},{"location":"General/faq/","page":"Frequently Asked Questions","title":"Frequently Asked Questions","text":"Q: How can I access or install custom GAP packages (e.g. unpublished ones)?","category":"page"},{"location":"General/faq/","page":"Frequently Asked Questions","title":"Frequently Asked Questions","text":"An already locally installed GAP package can be loaded into the OSCAR session via GAP.Packages.load, where the first argument is the local path to the package directory (the one that contains the PackageInfo.g file). This works only if no other version of this package has been loaded already.","category":"page"},{"location":"General/faq/","page":"Frequently Asked Questions","title":"Frequently Asked Questions","text":"If Oscar loads the package in question already on startup but you want a different version of this package to be loaded, you can force this by storing the desired version in the pkg subdirectory of the user's root directory (GAPInfo.UserGapRoot in GAP).","category":"page"},{"location":"General/faq/","page":"Frequently Asked Questions","title":"Frequently Asked Questions","text":"Installing a new GAP package for which you know the URL of a package archive can be done via GAP.Packages.install, where the first argument is this URL.","category":"page"},{"location":"General/faq/","page":"Frequently Asked Questions","title":"Frequently Asked Questions","text":"","category":"page"},{"location":"General/faq/","page":"Frequently Asked Questions","title":"Frequently Asked Questions","text":"Q: Why does my program not terminate?","category":"page"},{"location":"General/faq/","page":"Frequently Asked Questions","title":"Frequently Asked Questions","text":"Many of the algorithms implemented in OSCAR have a very high complexity. Even if not calling one of these algorithms directly, you may be using it in the background. Please read our page on Complex Algorithms in OSCAR.","category":"page"},{"location":"General/faq/","page":"Frequently Asked Questions","title":"Frequently Asked Questions","text":"","category":"page"},{"location":"General/faq/","page":"Frequently Asked Questions","title":"Frequently Asked Questions","text":"Q: How do I cite OSCAR?","category":"page"},{"location":"General/faq/","page":"Frequently Asked Questions","title":"Frequently Asked Questions","text":"Please see here.","category":"page"},{"location":"General/faq/","page":"Frequently Asked Questions","title":"Frequently Asked Questions","text":"","category":"page"},{"location":"General/faq/#Windows-specific","page":"Frequently Asked Questions","title":"Windows specific","text":"","category":"section"},{"location":"General/faq/","page":"Frequently Asked Questions","title":"Frequently Asked Questions","text":"Q: How can I install OSCAR on Windows?","category":"page"},{"location":"General/faq/","page":"Frequently Asked Questions","title":"Frequently Asked Questions","text":"Please follow the install instructions on our website.","category":"page"},{"location":"General/faq/","page":"Frequently Asked Questions","title":"Frequently Asked Questions","text":"","category":"page"},{"location":"General/faq/","page":"Frequently Asked Questions","title":"Frequently Asked Questions","text":"Q: Why does OSCAR require WSL on Windows?","category":"page"},{"location":"General/faq/","page":"Frequently Asked Questions","title":"Frequently Asked Questions","text":"Several of the OSCAR corner stones originate from Unix-like operating systems and have no or only limited native support for Windows.","category":"page"},{"location":"General/faq/","page":"Frequently Asked Questions","title":"Frequently Asked Questions","text":"","category":"page"},{"location":"General/faq/","page":"Frequently Asked Questions","title":"Frequently Asked Questions","text":"Q: How can I access Linux files from the Explorer?","category":"page"},{"location":"General/faq/","page":"Frequently Asked Questions","title":"Frequently Asked Questions","text":"Type \\\\wsl$ into the Explorer address bar, then press the Enter key.","category":"page"},{"location":"General/faq/","page":"Frequently Asked Questions","title":"Frequently Asked Questions","text":"","category":"page"},{"location":"General/faq/#Linux-specific","page":"Frequently Asked Questions","title":"Linux specific","text":"","category":"section"},{"location":"General/faq/","page":"Frequently Asked Questions","title":"Frequently Asked Questions","text":"Q: Why can't I install OSCAR using the Julia version installed by my package manager?","category":"page"},{"location":"General/faq/","page":"Frequently Asked Questions","title":"Frequently Asked Questions","text":"Some Linux distributions unfortunately ship crippled versions of Julia by default, which prevent OSCAR from working. For example the Debian and Ubuntu Julia packages are missing some files required by OSCAR. In this case, this can be resolved by also installing the libjulia-dev package.","category":"page"},{"location":"General/faq/","page":"Frequently Asked Questions","title":"Frequently Asked Questions","text":"For this reason, we recommend always using the official Julia binaries available form the Julia website.","category":"page"},{"location":"General/faq/","page":"Frequently Asked Questions","title":"Frequently Asked Questions","text":"","category":"page"},{"location":"General/faq/","page":"Frequently Asked Questions","title":"Frequently Asked Questions","text":"Q: What to do if I get an error similar to libstdc++.so.6: version `GLIBCXX_3.4.26'?","category":"page"},{"location":"General/faq/","page":"Frequently Asked Questions","title":"Frequently Asked Questions","text":"Sometimes installing or updating OSCAR gives the error libstdc++.so.6: version `GLIBCXX_3.4.26' or a similar one.","category":"page"},{"location":"General/faq/","page":"Frequently Asked Questions","title":"Frequently Asked Questions","text":"This typically happens when manually installing Julia using the official Julia binaries from their website. These bundle their own copy of the C++ standard library, which can lead to trouble if its version differs from the system's C++ library.","category":"page"},{"location":"General/faq/","page":"Frequently Asked Questions","title":"Frequently Asked Questions","text":"As a workaround, you can rename the copy of the C++ library bundled with Julia, so that the system copy is used. This can be achieved by executing the following Julia code:","category":"page"},{"location":"General/faq/","page":"Frequently Asked Questions","title":"Frequently Asked Questions","text":"  path = Libdl.dlpath(\"libstdc++\")\n  mv(path,\"$path.bak\")","category":"page"},{"location":"General/faq/","page":"Frequently Asked Questions","title":"Frequently Asked Questions","text":"If for some reason you need to restore the C++ library bundled with Julia, you can simply rename it back.","category":"page"},{"location":"General/faq/","page":"Frequently Asked Questions","title":"Frequently Asked Questions","text":"Q: Why does OSCAR fail to precompile when using it with GNU parallel?","category":"page"},{"location":"General/faq/","page":"Frequently Asked Questions","title":"Frequently Asked Questions","text":"You get errors like the following when trying to run some script using OSCAR with GNU parallel:","category":"page"},{"location":"General/faq/","page":"Frequently Asked Questions","title":"Frequently Asked Questions","text":"  ERROR: LoadError: InitError: ArgumentError: '.../deps/<something>_jll' exists. `force=true` is required to remove '...' before copying.","category":"page"},{"location":"General/faq/","page":"Frequently Asked Questions","title":"Frequently Asked Questions","text":"There was a bug in julia versions before 1.8 that ignored the parent argument for the tempname function when the TMPDIR environment variable is set and GNU parallel by default sets TMPDIR to /tmp.","category":"page"},{"location":"General/faq/","page":"Frequently Asked Questions","title":"Frequently Asked Questions","text":"Either upgrade to Julia 1.8 or later, or add delete!(ENV, \"TMPDIR\"); to the beginning of your julia code (before importing / using Oscar).","category":"page"},{"location":"DeveloperDocumentation/AbstractCollection/#AbstractCollection","page":"AbstractCollection","title":"AbstractCollection","text":"","category":"section"},{"location":"DeveloperDocumentation/AbstractCollection/","page":"AbstractCollection","title":"AbstractCollection","text":"Allowing the user to pass input using several formats usually is handled within julia by defining specialized methods for each function and argument type(s). This can prove to be inefficient when the amount possible combinations of these increases. AbstractCollection is a Dict meant to enable the user to profit from a fixed interpretation describing different collections of mathematical objects, while also simplifying the life of the developer, also resulting in less code duplication.","category":"page"},{"location":"DeveloperDocumentation/AbstractCollection/#Idea","page":"AbstractCollection","title":"Idea","text":"","category":"section"},{"location":"DeveloperDocumentation/AbstractCollection/","page":"AbstractCollection","title":"AbstractCollection","text":"Commonly the same kind of information, e.g. an amount of PointVectors, is accepted as argument for many different functions. The user can chose from different types (coming with an interpretation of their content) to use when calling one of these functions to describe the data. This data is then converted to a type and format Polymake.jl (and thus indirectly the polymake kernel) supports.","category":"page"},{"location":"DeveloperDocumentation/AbstractCollection/#Example","page":"AbstractCollection","title":"Example","text":"","category":"section"},{"location":"DeveloperDocumentation/AbstractCollection/","page":"AbstractCollection","title":"AbstractCollection","text":"Usually in polymake, a collection of points is displayed as a matrix of row-vectors. Such a matrix is always created from the input information. When writing a new function accepting an object x of type AbstractCollection[PointVector] (note that, with AbstractCollection being a Dict, its entries are accessed using square brackets; the keys are the Oscar types of the elements of the collection), the necessary conversion can (and should) be called at the beginning. These conversion functions already exist and support all of the types stated in Type compatibility. In this case the function is homogenized_matrix(x, 1).","category":"page"},{"location":"DeveloperDocumentation/AbstractCollection/","page":"AbstractCollection","title":"AbstractCollection","text":"RayVectors and their collections work about the same; the main difference for the programmer is that homogenized_matrix(x, 0) is called.","category":"page"},{"location":"DeveloperDocumentation/AbstractCollection/","page":"AbstractCollection","title":"AbstractCollection","text":"When looking at the beginning of the convex_hull method, the corresponding conversions of the three arguments V, R and L can be seen:","category":"page"},{"location":"DeveloperDocumentation/AbstractCollection/","page":"AbstractCollection","title":"AbstractCollection","text":"function convex_hull(::Type{T}, V::AbstractCollection[PointVector], R::Union{AbstractCollection[RayVector], Nothing} = nothing, L::Union{AbstractCollection[RayVector], Nothing} = nothing; non_redundant::Bool = false) where T<:scalar_types\n    # Rays and Points are homogenized and combined and\n    # Lineality is homogenized\n    points = stack(homogenized_matrix(V, 1), homogenized_matrix(R, 0))\n    lineality = isnothing(L) || isempty(L) ? zero_matrix(QQ, 0, size(points,2)) : homogenized_matrix(L, 0)\n\n    ...\nend","category":"page"},{"location":"DeveloperDocumentation/AbstractCollection/#Conversion-functions","page":"AbstractCollection","title":"Conversion functions","text":"","category":"section"},{"location":"DeveloperDocumentation/AbstractCollection/","page":"AbstractCollection","title":"AbstractCollection","text":"So effectively supporting AbstractCollections only requires to know when to apply which conversion function. The following table explains this for AbstractCollection[T]:","category":"page"},{"location":"DeveloperDocumentation/AbstractCollection/","page":"AbstractCollection","title":"AbstractCollection","text":"T Target format Conversion function\nPointVector matrix of row-vectors homogenized_matrix(*, 1)\nRayVector matrix of row-vectors (linear setting) unhomogenized_matrix(*)\nRayVector matrix of row-vectors (affine setting) homogenized_matrix(*, 0)\nLinearHalfspace/LinearHyperplane inequality/equation matrix (linear setting) linear_matrix_for_polymake(*)\nAffineHalfspace/AffineHyperplane inequality/equation matrix (affine setting) affine_matrix_for_polymake(*)","category":"page"},{"location":"AlgebraicGeometry/ToricVarieties/Subvarieties/","page":"Subvarieties","title":"Subvarieties","text":"CurrentModule = Oscar","category":"page"},{"location":"AlgebraicGeometry/ToricVarieties/Subvarieties/#Subvarieties","page":"Subvarieties","title":"Subvarieties","text":"","category":"section"},{"location":"AlgebraicGeometry/ToricVarieties/Subvarieties/#Introduction","page":"Subvarieties","title":"Introduction","text":"","category":"section"},{"location":"AlgebraicGeometry/ToricVarieties/Subvarieties/","page":"Subvarieties","title":"Subvarieties","text":"We focus on simplicial toric varieties. Then, any closed subvariety is given as the vanishing set of a homogeneous ideal in the Cox ring of the toric variety in question (cf. proposition 5.2.4 in [CLS11]). As of now, we provide elementary support for closed subvarieties of simplicial toric varieties.","category":"page"},{"location":"AlgebraicGeometry/ToricVarieties/Subvarieties/#Constructors","page":"Subvarieties","title":"Constructors","text":"","category":"section"},{"location":"AlgebraicGeometry/ToricVarieties/Subvarieties/#General-constructors","page":"Subvarieties","title":"General constructors","text":"","category":"section"},{"location":"AlgebraicGeometry/ToricVarieties/Subvarieties/","page":"Subvarieties","title":"Subvarieties","text":"closed_subvariety_of_toric_variety(toric_variety::NormalToricVarietyType, defining_polynomials::Vector{MPolyDecRingElem{QQFieldElem, QQMPolyRingElem}})\nclosed_subvariety_of_toric_variety(toric_variety::NormalToricVarietyType, defining_ideal::MPolyIdeal)","category":"page"},{"location":"AlgebraicGeometry/ToricVarieties/Subvarieties/#closed_subvariety_of_toric_variety-Tuple{Union{AffineNormalToricVariety, CyclicQuotientSingularity, NormalToricVariety}, Vector{MPolyDecRingElem{QQFieldElem, QQMPolyRingElem}}}","page":"Subvarieties","title":"closed_subvariety_of_toric_variety","text":"closed_subvariety_of_toric_variety(toric_variety::NormalToricVarietyType, defining_polynomials::Vector{MPolyDecRingElem{QQFieldElem, QQMPolyRingElem}})\n\nConstruct the closed subvariety of a simplicial normal toric variety. The defining data for the closed subvariety is a list of homogeneous polynomials, all of which must be elements of the Cox ring of the toric variety in question. The common vanishing locus of these polynomials defines the closed subvariety in question. By proposition 5.2.4 in [CLS11] every closed subvariety of a simplicial toric variety arises in this way.\n\nExamples\n\njulia> f2 = hirzebruch_surface(NormalToricVariety, 2);\n\njulia> (t1, x1, t2, x2) = gens(cox_ring(f2));\n\njulia> closed_subvariety_of_toric_variety(f2, [t1])\nClosed subvariety of a normal toric variety\n\n\n\n\n\n","category":"method"},{"location":"AlgebraicGeometry/ToricVarieties/Subvarieties/#closed_subvariety_of_toric_variety-Tuple{Union{AffineNormalToricVariety, CyclicQuotientSingularity, NormalToricVariety}, MPolyIdeal}","page":"Subvarieties","title":"closed_subvariety_of_toric_variety","text":"closed_subvariety_of_toric_variety(toric_variety::NormalToricVarietyType, defining_ideal::MPolyIdeal)\n\nConstruct the closed subvariety of a simplicial normal toric variety. The defining data for the closed subvariety is an ideal of the Cox ring of the toric variety in question. By proposition 5.2.4 in [CLS11] every closed subvariety of a simplicial toric variety arises in this way.\n\nExamples\n\njulia> f2 = hirzebruch_surface(NormalToricVariety, 2);\n\njulia> (t1, x1, t2, x2) = gens(cox_ring(f2));\n\njulia> closed_subvariety_of_toric_variety(f2, ideal([t1]))\nClosed subvariety of a normal toric variety\n\n\n\n\n\n","category":"method"},{"location":"AlgebraicGeometry/ToricVarieties/Subvarieties/#Properties","page":"Subvarieties","title":"Properties","text":"","category":"section"},{"location":"AlgebraicGeometry/ToricVarieties/Subvarieties/","page":"Subvarieties","title":"Subvarieties","text":"is_empty(c::ClosedSubvarietyOfToricVariety)","category":"page"},{"location":"AlgebraicGeometry/ToricVarieties/Subvarieties/#is_empty-Tuple{ClosedSubvarietyOfToricVariety}","page":"Subvarieties","title":"is_empty","text":"is_empty(c::ClosedSubvarietyOfToricVariety)\n\nChecks if a closed subvariety of a toric variety is empty. This check uses proposition 5.2.6 in [CLS11].\n\nExamples\n\njulia> f2 = hirzebruch_surface(NormalToricVariety, 2);\n\njulia> (t1, x1, t2, x2) = gens(cox_ring(f2));\n\njulia> c = closed_subvariety_of_toric_variety(f2, [t1])\nClosed subvariety of a normal toric variety\n\njulia> is_empty(c)\nfalse\n\njulia> c2 = closed_subvariety_of_toric_variety(f2, [x1,x2])\nClosed subvariety of a normal toric variety\n\njulia> is_empty(c2)\ntrue\n\n\n\n\n\n","category":"method"},{"location":"AlgebraicGeometry/ToricVarieties/Subvarieties/#Attributes","page":"Subvarieties","title":"Attributes","text":"","category":"section"},{"location":"AlgebraicGeometry/ToricVarieties/Subvarieties/","page":"Subvarieties","title":"Subvarieties","text":"toric_variety(c::ClosedSubvarietyOfToricVariety)\ndefining_ideal(c::ClosedSubvarietyOfToricVariety)\nradical(c::ClosedSubvarietyOfToricVariety)","category":"page"},{"location":"AlgebraicGeometry/ToricVarieties/Subvarieties/#toric_variety-Tuple{ClosedSubvarietyOfToricVariety}","page":"Subvarieties","title":"toric_variety","text":"toric_variety(c::ClosedSubvarietyOfToricVariety)\n\nWhen constructing a closed subvariety, a toric variety must be provided in which the closed subvariety is contained. This method returns this initially provided toric supervariety.\n\nNote however that perse, a closed subvariety can be contained in different non-isomorphic toric varieties.\n\nExamples\n\njulia> f2 = hirzebruch_surface(NormalToricVariety, 2);\n\njulia> (t1, x1, t2, x2) = gens(cox_ring(f2));\n\njulia> c = closed_subvariety_of_toric_variety(f2, [t1])\nClosed subvariety of a normal toric variety\n\njulia> toric_variety(c) == f2\ntrue\n\n\n\n\n\n","category":"method"},{"location":"AlgebraicGeometry/ToricVarieties/Subvarieties/#defining_ideal-Tuple{ClosedSubvarietyOfToricVariety}","page":"Subvarieties","title":"defining_ideal","text":"defining_ideal(c::ClosedSubvarietyOfToricVariety)\n\nWhen constructing a closed subvariety, an ideal in the Cox ring of a normal toric variety must be provided. This method returns this initially provided ideal.\n\nExamples\n\njulia> f2 = hirzebruch_surface(NormalToricVariety, 2);\n\njulia> (t1, x1, t2, x2) = gens(cox_ring(f2));\n\njulia> c = closed_subvariety_of_toric_variety(f2, [t1])\nClosed subvariety of a normal toric variety\n\njulia> defining_ideal(c) == ideal([t1])\ntrue\n\n\n\n\n\n","category":"method"},{"location":"AlgebraicGeometry/ToricVarieties/Subvarieties/#radical-Tuple{ClosedSubvarietyOfToricVariety}","page":"Subvarieties","title":"radical","text":"radical(c::ClosedSubvarietyOfToricVariety)\n\nWhen constructing a closed subvariety, an ideal in the Cox ring of a normal toric variety must be provided. This method returns the radical of this initially provided ideal.\n\nExamples\n\njulia> f2 = hirzebruch_surface(NormalToricVariety, 2);\n\njulia> (t1, x1, t2, x2) = gens(cox_ring(f2));\n\njulia> c = closed_subvariety_of_toric_variety(f2, [t1])\nClosed subvariety of a normal toric variety\n\njulia> radical(c) == ideal([t1])\ntrue\n\n\n\n\n\n","category":"method"},{"location":"DeveloperDocumentation/gap_integration/#GAP-Integration","page":"GAP Integration","title":"GAP Integration","text":"","category":"section"},{"location":"DeveloperDocumentation/gap_integration/","page":"GAP Integration","title":"GAP Integration","text":"This section explains how Oscar interacts with GAP.","category":"page"},{"location":"DeveloperDocumentation/gap_integration/#The-Julia-package-[GAP.jl](https://github.com/oscar-system/GAP.jl)","page":"GAP Integration","title":"The Julia package GAP.jl","text":"","category":"section"},{"location":"DeveloperDocumentation/gap_integration/","page":"GAP Integration","title":"GAP Integration","text":"This package provides a bidirectional interface between GAP and Julia. Its documentation describes how to call GAP functions in Julia code and vice versa, and how low level Julia objects can be converted to GAP objects and vice versa.","category":"page"},{"location":"DeveloperDocumentation/gap_integration/","page":"GAP Integration","title":"GAP Integration","text":"When one works interactively in an Oscar session, calling GAP.prompt() opens a GAP session which has access to the variables in the Julia session, in particular to all Oscar functions and objects; one can return to the Julia prompt by entering quit; in the GAP session.","category":"page"},{"location":"DeveloperDocumentation/gap_integration/#Interface-functionalities-beyond-GAP.jl","page":"GAP Integration","title":"Interface functionalities beyond GAP.jl","text":"","category":"section"},{"location":"DeveloperDocumentation/gap_integration/","page":"GAP Integration","title":"GAP Integration","text":"For code involving Julia types that are defined in Oscar, GAP.jl cannot provide utility functions such as conversions to and from GAP.","category":"page"},{"location":"DeveloperDocumentation/gap_integration/","page":"GAP Integration","title":"GAP Integration","text":"The GAP package OscarInterface (at gap/OscarInterface) is intended to contain the GAP code in question, for example the declarations of new filters and the installation of new methods.\nNote that such code must be loaded at runtime into the GAP session that is started by Julia, and the OscarInterface package gets loaded in Oscar's __init__ function.\nThe files in the directory src/GAP are intended to contain the Julia code in question, for example conversions from GAP to ZZRingElem, QQFieldElem, FinFieldElem, etc., and the construction of isomorphisms between algebraic structures such as rings and fields in GAP and Oscar, via Oscar.iso_oscar_gap and Oscar.iso_gap_oscar.\nIn Oscar code, global GAP variables can be accessed as members of GAP.Globals, but for the case of GAP functions, it is more efficient to use Oscar.GAPWrap instead.\nFor example, if one wants to call GAP's IsFinite then it is recommended to replace the call GAP.Globals.IsFinite(x)::Bool, for some GAP object x (a group or a ring or a list, etc.), by Oscar.GAPWrap.IsFinite(x). This works only if the method in question gets defined in src/GAP/wrappers.jl, thus methods with the required signatures should be added to this file when they turn out to be needed.\n(The reason why we collect the GAP.@wrap lines in an Oscar file and not inside GAP.jl is that we can extend the list without waiting for releases of GAP.jl.)\nIn GAP code, global Julia variables can be accessed as members of Julia, relative to its Main module. For example, one can call Julia.sqrt and Julia.typeof (or Julia.Base.sqrt and Julia.Core.typeof) in GAP code.\nIn order to access variables from the Oscar module, it is not safe to use Julia.Oscar because the module Oscar is not always defined in Main. Instead, there is the global GAP variable Oscar.","category":"page"},{"location":"DeveloperDocumentation/gap_integration/","page":"GAP Integration","title":"GAP Integration","text":"Oscar.iso_oscar_gap\nOscar.iso_gap_oscar","category":"page"},{"location":"DeveloperDocumentation/gap_integration/#iso_oscar_gap","page":"GAP Integration","title":"iso_oscar_gap","text":"Oscar.iso_oscar_gap(R::T) -> Map{T, GapObj}\n\nReturn an isomorphism f with domain R and codomain a GAP object S.\n\nElements x of R are mapped to S via f(x), and elements y of S are mapped to R via preimage(f, y).\n\nMatrices m over R are mapped to matrices over S via map_entries(f, m), and matrices n over S are mapped to matrices over R via Oscar.preimage_matrix(f, n).\n\nAdmissible values of R and the corresponding S are currently as follows.\n\nR S (in GAP.Globals)\nZZ Integers\nQQ Rationals\nresidue_ring(ZZ, n)[1] mod(Integers, n)\nfinite_field(p, d)[1] GF(p, d)\ncyclotomic_field(n)[1] CF(n)\nnumber_field(f::QQPolyRingElem)[1] AlgebraicExtension(Rationals, g)\nabelian_closure(QQ)[1] Cyclotomics\npolynomial_ring(F)[1] PolynomialRing(G)\npolynomial_ring(F, n)[1] PolynomialRing(G, n)\n\n(Here g is the polynomial over GAP.Globals.Rationals that corresponds to f, and G is equal to Oscar.iso_oscar_gap(F).)\n\nExamples\n\njulia> f = Oscar.iso_oscar_gap(ZZ);\n\njulia> x = ZZ(2)^100;  y = f(x)\nGAP: 1267650600228229401496703205376\n\njulia> preimage(f, y) == x\ntrue\n\njulia> m = matrix(ZZ, 2, 3, [1, 2, 3, 4, 5, 6]);\n\njulia> n = map_entries(f, m)\nGAP: [ [ 1, 2, 3 ], [ 4, 5, 6 ] ]\n\njulia> Oscar.preimage_matrix(f, n) == m\ntrue\n\njulia> R, x = polynomial_ring(QQ);\n\njulia> f = Oscar.iso_oscar_gap(R);\n\njulia> pol = x^2 + x - 1;\n\njulia> y = f(pol)\nGAP: x_1^2+x_1-1\n\njulia> preimage(f, y) == pol\ntrue\n\nwarning: Warning\nThe functions Oscar.iso_oscar_gap and Oscar.iso_gap_oscar are not injective. Due to caching, it may happen that S stores an attribute value of Oscar.iso_gap_oscar(S), but that the codomain of this map is not identical with or even not equal to the given R.Note also that R and S may differ w.r.t. some structural properties because GAP does not support all kinds of constructions that are possible in Oscar. For example, if R is a non-simple number field then S will be a simple extension because GAP knows only simple field extensions. Thus using Oscar.iso_oscar_gap(R) for objects R whose recursive structure is not fully supported in GAP will likely cause overhead at runtime.\n\n\n\n\n\n","category":"function"},{"location":"DeveloperDocumentation/gap_integration/#iso_gap_oscar","page":"GAP Integration","title":"iso_gap_oscar","text":"Oscar.iso_gap_oscar(R) -> Map{GapObj, T}\n\nReturn an isomorphism f with domain the GAP object R and codomain an Oscar object S.\n\nElements x of R are mapped to S via f(x), and elements y of S are mapped to R via preimage(f, y).\n\nMatrices m over R are mapped to matrices over S via map_entries(f, m), and matrices n over S are mapped to matrices over R via Oscar.preimage_matrix(f, n).\n\nAdmissible values of R and the corresponding S are currently as follows.\n\nS (in GAP.Globals) R\nIntegers ZZ\nRationals QQ\nmod(Integers, n) residue_ring(ZZ, n)[1]\nGF(p, d) finite_field(p, d)[1]\nCF(n) cyclotomic_field(n)[1]\nAlgebraicExtension(Rationals, f) number_field(g)[1]\nCyclotomics abelian_closure(QQ)[1]\nPolynomialRing(F) polynomial_ring(G)[1]\nPolynomialRing(F, n) polynomial_ring(G, n)[1]\n\n(Here g is the polynomial over QQ that corresponds to the polynomial f, and G is equal to Oscar.iso_gap_oscar(F).)\n\nExamples\n\njulia> f = Oscar.iso_gap_oscar(GAP.Globals.Integers);\n\njulia> x = ZZ(2)^100;  y = preimage(f, x)\nGAP: 1267650600228229401496703205376\n\njulia> f(y) == x\ntrue\n\njulia> m = matrix(ZZ, 2, 3, [1, 2, 3, 4, 5, 6]);\n\njulia> n = Oscar.preimage_matrix(f, m)\nGAP: [ [ 1, 2, 3 ], [ 4, 5, 6 ] ]\n\njulia> map_entries(f, n) == m\ntrue\n\njulia> R = GAP.Globals.PolynomialRing(GAP.Globals.Rationals);\n\njulia> f = Oscar.iso_gap_oscar(R);\n\njulia> x = gen(codomain(f));\n\njulia> pol = x^2 + x + 1;\n\njulia> y = preimage(f, pol)\nGAP: x_1^2+x_1+1\n\njulia> f(y) == pol\ntrue\n\nwarning: Warning\nThe functions Oscar.iso_gap_oscar and Oscar.iso_oscar_gap are not injective. Due to caching, it may happen that S stores an attribute value of Oscar.iso_oscar_gap(S), but that the codomain of this map is not identical with or even not equal to the given R.\n\n\n\n\n\n","category":"function"},{"location":"AlgebraicGeometry/AlgebraicVarieties/AffineVariety/","page":"Affine Varieties","title":"Affine Varieties","text":"CurrentModule = Oscar\nDocTestSetup = Oscar.doctestsetup()","category":"page"},{"location":"AlgebraicGeometry/AlgebraicVarieties/AffineVariety/#Affine-Varieties","page":"Affine Varieties","title":"Affine Varieties","text":"","category":"section"},{"location":"AlgebraicGeometry/AlgebraicVarieties/AffineVariety/","page":"Affine Varieties","title":"Affine Varieties","text":"An affine variety is an algebraic set such that X(K) is irreducible for k subseteq K an algebraic closure. See Affine Algebraic Sets.","category":"page"},{"location":"AlgebraicGeometry/AlgebraicVarieties/AffineVariety/","page":"Affine Varieties","title":"Affine Varieties","text":"In Oscar varieties are implemented as special instances of Affine schemes and more formally defined as follows.","category":"page"},{"location":"AlgebraicGeometry/AlgebraicVarieties/AffineVariety/","page":"Affine Varieties","title":"Affine Varieties","text":"AbsAffineVariety","category":"page"},{"location":"AlgebraicGeometry/AlgebraicVarieties/AffineVariety/#AbsAffineVariety","page":"Affine Varieties","title":"AbsAffineVariety","text":"AbsAffineVariety <: AbsAffineAlgebraicSet\n\nAn affine, geometrically integral subscheme of an affine space over a field.\n\n\n\n\n\n","category":"type"},{"location":"AlgebraicGeometry/AlgebraicVarieties/AffineVariety/","page":"Affine Varieties","title":"Affine Varieties","text":"Functionality which is not (yet) provided by a variety-specific implementation, falls back to the appropriate functionality of schemes.","category":"page"},{"location":"AlgebraicGeometry/AlgebraicVarieties/AffineVariety/#Constructors","page":"Affine Varieties","title":"Constructors","text":"","category":"section"},{"location":"AlgebraicGeometry/AlgebraicVarieties/AffineVariety/","page":"Affine Varieties","title":"Affine Varieties","text":"variety(I::MPolyIdeal; check=true)\nvariety(X::AbsAffineScheme{<:Field}; is_reduced=false, check::Bool=true)\nvariety(R::MPolyAnyRing; check=true)","category":"page"},{"location":"AlgebraicGeometry/AlgebraicVarieties/AffineVariety/#variety-Tuple{MPolyIdeal}","page":"Affine Varieties","title":"variety","text":"variety(I::MPolyIdeal; check=true) -> AffineVariety\n\nReturn the affine variety defined by the ideal I.\n\nBy our convention, varieties are absolutely irreducible. Hence we check that the radical of I is prime and stays prime when viewed over the algebraic closure. This is an expensive check that can be disabled.\n\njulia> R, (x,y) = QQ[:x,:y]\n(Multivariate polynomial ring in 2 variables over QQ, QQMPolyRingElem[x, y])\n\njulia> variety(ideal([x,y]))\nAffine variety\n  in affine 2-space over QQ with coordinates [x, y]\ndefined by ideal (x, y)\n\n\nOver fields different from QQ, currently, we cannot check for irreducibility over the algebraic closure. But if you know that the ideal in question defines a variety, you can construct it by disabling the check.\n\njulia> R, (x,y) = GF(2)[:x,:y];\n\njulia> variety(x^3+y+1, check=false)\nAffine variety\n  in affine 2-space over GF(2) with coordinates [x, y]\ndefined by ideal (x^3 + y + 1)\n\n\n\n\n\n\n","category":"method"},{"location":"AlgebraicGeometry/AlgebraicVarieties/AffineVariety/#variety-Tuple{AbsAffineScheme{<:Field}}","page":"Affine Varieties","title":"variety","text":"variety(X::AbsAffineScheme; is_reduced::false, check::Bool=true) -> AffineVariety\n\nConvert X to an affine variety.\n\nIf is_reduced is set, assume that X is already reduced.\n\n\n\n\n\n","category":"method"},{"location":"AlgebraicGeometry/AlgebraicVarieties/AffineVariety/#variety-Tuple{Union{MPolyRing, Oscar.MPolyLocRing, Oscar.MPolyQuoLocRing, MPolyQuoRing}}","page":"Affine Varieties","title":"variety","text":"variety(R::Ring; check=true)\n\nReturn the affine variety with coordinate ring R.\n\nWe require that R is a finitely generated algebra over a field k and moreover that the base change of R to the algebraic closure bar k is an integral domain.\n\njulia> R, (x,y) = QQ[:x,:y];\n\njulia> Q,_ = quo(R,ideal([x,y]));\n\njulia> variety(Q)\nAffine variety\n  in affine 2-space over QQ with coordinates [x, y]\ndefined by ideal (x, y)\n\n\n\n\n\n\n","category":"method"},{"location":"AlgebraicGeometry/AlgebraicVarieties/AffineVariety/#Attributes","page":"Affine Varieties","title":"Attributes","text":"","category":"section"},{"location":"AlgebraicGeometry/AlgebraicVarieties/AffineVariety/","page":"Affine Varieties","title":"Affine Varieties","text":"So far all are inherited from Affine Algebraic Sets and Affine schemes.","category":"page"},{"location":"AlgebraicGeometry/AlgebraicVarieties/AffineVariety/#Properties","page":"Affine Varieties","title":"Properties","text":"","category":"section"},{"location":"AlgebraicGeometry/AlgebraicVarieties/AffineVariety/","page":"Affine Varieties","title":"Affine Varieties","text":"So far all are inherited from Affine Algebraic Sets and Affine schemes.","category":"page"},{"location":"AlgebraicGeometry/AlgebraicVarieties/AffineVariety/#Methods","page":"Affine Varieties","title":"Methods","text":"","category":"section"},{"location":"AlgebraicGeometry/AlgebraicVarieties/AffineVariety/","page":"Affine Varieties","title":"Affine Varieties","text":"So far all are inherited from Affine Algebraic Sets and Affine schemes.","category":"page"},{"location":"Hecke/manual/misc/sparse/#Sparse-linear-algebra","page":"Sparse linear algebra","title":"Sparse linear algebra","text":"","category":"section"},{"location":"Hecke/manual/misc/sparse/","page":"Sparse linear algebra","title":"Sparse linear algebra","text":"CurrentModule = Hecke","category":"page"},{"location":"Hecke/manual/misc/sparse/#Introduction","page":"Sparse linear algebra","title":"Introduction","text":"","category":"section"},{"location":"Hecke/manual/misc/sparse/","page":"Sparse linear algebra","title":"Sparse linear algebra","text":"This chapter deals with sparse linear algebra over commutative rings and fields.","category":"page"},{"location":"Hecke/manual/misc/sparse/","page":"Sparse linear algebra","title":"Sparse linear algebra","text":"Sparse linear algebra, that is, linear algebra with sparse matrices, plays an important role in various algorithms in algebraic number theory. For example, it is one of the key ingredients in the computation of class groups and discrete logarithms using index calculus methods.","category":"page"},{"location":"Hecke/manual/misc/sparse/#Sparse-rows","page":"Sparse linear algebra","title":"Sparse rows","text":"","category":"section"},{"location":"Hecke/manual/misc/sparse/","page":"Sparse linear algebra","title":"Sparse linear algebra","text":"Building blocks for sparse matrices are sparse rows, which are modelled by objects of type SRow. More precisely, the type is of parametrized form SRow{T}, where T is the element type of the base ring R. For example, SRow{ZZRingElem} is the type for sparse rows over the integers.","category":"page"},{"location":"Hecke/manual/misc/sparse/","page":"Sparse linear algebra","title":"Sparse linear algebra","text":"It is important to note that sparse rows do not have a fixed number of columns, that is, they represent elements of  (x_i)_i in R^mathbbN mid x_i = 0 text for almost all i. In particular any two sparse rows over the same base ring can be added.","category":"page"},{"location":"Hecke/manual/misc/sparse/#Creation","page":"Sparse linear algebra","title":"Creation","text":"","category":"section"},{"location":"Hecke/manual/misc/sparse/","page":"Sparse linear algebra","title":"Sparse linear algebra","text":"sparse_row(::NCRing, ::Vector{Tuple{Int, T}}) where T\nsparse_row(::NCRing, ::Vector{Tuple{Int, Int}})\nsparse_row(::NCRing, ::Vector{Int}, ::Vector{T}) where T","category":"page"},{"location":"Hecke/manual/misc/sparse/#sparse_row-Union{Tuple{T}, Tuple{NCRing, Array{Tuple{Int64, T}, 1}}} where T","page":"Sparse linear algebra","title":"sparse_row","text":"sparse_row(R::Ring, J::Vector{Tuple{Int, T}}) -> SRow{T}\n\nConstructs the sparse row (a_i)_i with a_i_j = x_j, where J = (i_j x_j)_j. The elements x_i must belong to the ring R.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/misc/sparse/#sparse_row-Tuple{NCRing, Vector{Tuple{Int64, Int64}}}","page":"Sparse linear algebra","title":"sparse_row","text":"sparse_row(R::Ring, J::Vector{Tuple{Int, Int}}) -> SRow\n\nConstructs the sparse row (a_i)_i over R with a_i_j = x_j, where J = (i_j x_j)_j.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/misc/sparse/#sparse_row-Union{Tuple{T}, Tuple{NCRing, Vector{Int64}, Vector{T}}} where T","page":"Sparse linear algebra","title":"sparse_row","text":"sparse_row(R::NCRing, J::Vector{Int}, V::Vector{T}) -> SRow{T}\n\nConstructs the sparse row (a_i)_i over R with a_i_j = x_j, where J = (i_j)_j and V = (x_j)_j.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/misc/sparse/#Basic-operations","page":"Sparse linear algebra","title":"Basic operations","text":"","category":"section"},{"location":"Hecke/manual/misc/sparse/","page":"Sparse linear algebra","title":"Sparse linear algebra","text":"Rows support the usual operations:","category":"page"},{"location":"Hecke/manual/misc/sparse/","page":"Sparse linear algebra","title":"Sparse linear algebra","text":"+, -, ==\nmultiplication by scalars\ndiv, divexact","category":"page"},{"location":"Hecke/manual/misc/sparse/","page":"Sparse linear algebra","title":"Sparse linear algebra","text":"getindex(::SRow{ZZRingElem}, ::Int)\nadd_scaled_row(::SRow{ZZRingElem}, ::SRow{ZZRingElem}, ::ZZRingElem)\nadd_scaled_row(::SRow{T}, ::SRow{T}, ::T) where {T}\ntransform_row(::SRow{T}, ::SRow{T}, ::T, ::T, ::T, ::T) where {T}\nlength(::SRow)","category":"page"},{"location":"Hecke/manual/misc/sparse/#getindex-Tuple{SRow{ZZRingElem}, Int64}","page":"Sparse linear algebra","title":"getindex","text":"getindex(A::SRow, j::Int) -> RingElem\n\nGiven a sparse row (a_i)_i and an index j return a_j.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/misc/sparse/#add_scaled_row-Tuple{SRow{ZZRingElem}, SRow{ZZRingElem}, ZZRingElem}","page":"Sparse linear algebra","title":"add_scaled_row","text":"add_scaled_row(A::SRow{T}, B::SRow{T}, c::T) -> SRow{T}\n\nReturns the row c A + B.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/misc/sparse/#add_scaled_row-Union{Tuple{T}, Tuple{SRow{T}, SRow{T}, T}} where T","page":"Sparse linear algebra","title":"add_scaled_row","text":"add_scaled_row(A::SRow{T}, B::SRow{T}, c::T) -> SRow{T}\n\nReturns the row c A + B.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/misc/sparse/#transform_row-Union{Tuple{T}, Tuple{SRow{T}, SRow{T}, Vararg{T, 4}}} where T","page":"Sparse linear algebra","title":"transform_row","text":"transform_row(A::SRow{T}, B::SRow{T}, i::Int, j::Int, a::T, b::T, c::T, d::T)\n\nReturns the tuple (aA + bB cA + dB).\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/misc/sparse/#length-Tuple{SRow}","page":"Sparse linear algebra","title":"length","text":"length(A::SRow)\n\nReturns the number of nonzero entries of A.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/misc/sparse/#Change-of-base-ring","page":"Sparse linear algebra","title":"Change of base ring","text":"","category":"section"},{"location":"Hecke/manual/misc/sparse/","page":"Sparse linear algebra","title":"Sparse linear algebra","text":"change_base_ring(::ZZRing, ::SRow{ZZRingElem})","category":"page"},{"location":"Hecke/manual/misc/sparse/#change_base_ring-Tuple{ZZRing, SRow{ZZRingElem}}","page":"Sparse linear algebra","title":"change_base_ring","text":"change_base_ring(R::Ring, A::SRow) -> SRow\n\nCreate a new sparse row by coercing all elements into the ring R.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/misc/sparse/#Maximum,-minimum-and-2-norm","page":"Sparse linear algebra","title":"Maximum, minimum and 2-norm","text":"","category":"section"},{"location":"Hecke/manual/misc/sparse/","page":"Sparse linear algebra","title":"Sparse linear algebra","text":"maximum(::SRow)\nmaximum(::SRow{ZZRingElem})\nminimum(::SRow{ZZRingElem})\nminimum(::SRow)\nnorm2(::SRow{ZZRingElem})","category":"page"},{"location":"Hecke/manual/misc/sparse/#maximum-Tuple{SRow}","page":"Sparse linear algebra","title":"maximum","text":"maximum(A::SRow{T}) -> T\n\nReturns the largest entry of A.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/misc/sparse/#maximum-Tuple{SRow{ZZRingElem}}","page":"Sparse linear algebra","title":"maximum","text":"maximum(A::SRow{T}) -> T\n\nReturns the largest entry of A.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/misc/sparse/#minimum-Tuple{SRow{ZZRingElem}}","page":"Sparse linear algebra","title":"minimum","text":"minimum(A::SRow{T}) -> T\n\nReturns the smallest entry of A.\n\n\n\n\n\n  minimum(A::RelNumFieldOrderIdeal) -> AbsNumFieldOrderIdeal{AbsSimpleNumField, AbsSimpleNumFieldElem}\n  minimum(A::RelNumFieldOrderIdeal) -> RelNumFieldOrderIdeal\n\nReturns the ideal A cap O where O is the maximal order of the coefficient ideals of A.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/misc/sparse/#minimum-Tuple{SRow}","page":"Sparse linear algebra","title":"minimum","text":"minimum(A::SRow{T}) -> T\n\nReturns the smallest entry of A.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/misc/sparse/#norm2-Tuple{SRow{ZZRingElem}}","page":"Sparse linear algebra","title":"norm2","text":"norm2(A::SRow{T} -> T\n\nReturns A cdot A^t.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/misc/sparse/#Functionality-for-integral-sparse-rows","page":"Sparse linear algebra","title":"Functionality for integral sparse rows","text":"","category":"section"},{"location":"Hecke/manual/misc/sparse/","page":"Sparse linear algebra","title":"Sparse linear algebra","text":"lift(::SRow{zzModRingElem})\nmod!(::SRow{ZZRingElem}, ::ZZRingElem)\nmod_sym!(::SRow{ZZRingElem}, ::ZZRingElem)\nmod_sym!(::SRow{ZZRingElem}, ::Integer)\nmaximum(::typeof(abs), ::SRow{ZZRingElem})","category":"page"},{"location":"Hecke/manual/misc/sparse/#lift-Tuple{SRow{zzModRingElem}}","page":"Sparse linear algebra","title":"lift","text":"lift(A::SRow{zzModRingElem}) -> SRow{ZZRingElem}\n\nReturn the sparse row obtained by lifting all entries in A.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/misc/sparse/#mod!-Tuple{SRow{ZZRingElem}, ZZRingElem}","page":"Sparse linear algebra","title":"mod!","text":"mod!(A::SRow{ZZRingElem}, n::ZZRingElem) -> SRow{ZZRingElem}\n\nInplace reduction of all entries of A modulo n to the positive residue system.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/misc/sparse/#mod_sym!-Tuple{SRow{ZZRingElem}, ZZRingElem}","page":"Sparse linear algebra","title":"mod_sym!","text":"mod_sym!(A::SRow{ZZRingElem}, n::ZZRingElem) -> SRow{ZZRingElem}\n\nInplace reduction of all entries of A modulo n to the symmetric residue system.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/misc/sparse/#mod_sym!-Tuple{SRow{ZZRingElem}, Integer}","page":"Sparse linear algebra","title":"mod_sym!","text":"mod_sym!(A::SRow{ZZRingElem}, n::Integer) -> SRow{ZZRingElem}\n\nInplace reduction of all entries of A modulo n to the symmetric residue system.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/misc/sparse/#maximum-Tuple{typeof(abs), SRow{ZZRingElem}}","page":"Sparse linear algebra","title":"maximum","text":"maximum(abs, A::SRow{ZZRingElem}) -> ZZRingElem\n\nReturns the largest, in absolute value, entry of A.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/misc/sparse/#Conversion-to/from-julia-and-AbstractAlgebra-types","page":"Sparse linear algebra","title":"Conversion to/from julia and AbstractAlgebra types","text":"","category":"section"},{"location":"Hecke/manual/misc/sparse/","page":"Sparse linear algebra","title":"Sparse linear algebra","text":"Vector(r::SRow, n::Int)\nsparse_row(A::MatElem)\ndense_row(r::SRow, n::Int)","category":"page"},{"location":"Hecke/manual/misc/sparse/#Vector-Tuple{SRow, Int64}","page":"Sparse linear algebra","title":"Vector","text":"Vector(a::SMat{T}, n::Int) -> Vector{T}\n\nThe first n entries of a, as a julia vector.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/misc/sparse/#sparse_row-Tuple{MatElem}","page":"Sparse linear algebra","title":"sparse_row","text":"sparse_row(A::MatElem)\n\nConvert A to a sparse row. nrows(A) == 1 must hold.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/misc/sparse/#dense_row-Tuple{SRow, Int64}","page":"Sparse linear algebra","title":"dense_row","text":"dense_row(r::SRow, n::Int)\n\nConvert r[1:n] to a dense row, that is an AbstractAlgebra matrix.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/misc/sparse/#Sparse-matrices","page":"Sparse linear algebra","title":"Sparse matrices","text":"","category":"section"},{"location":"Hecke/manual/misc/sparse/","page":"Sparse linear algebra","title":"Sparse linear algebra","text":"Let R be a commutative ring. Sparse matrices with base ring R are modelled by objects of type SMat. More precisely, the type is of parametrized form SRow{T}, where T is the element type of the base ring. For example, SMat{ZZRingElem} is the type for sparse matrices over the integers.","category":"page"},{"location":"Hecke/manual/misc/sparse/","page":"Sparse linear algebra","title":"Sparse linear algebra","text":"In contrast to sparse rows, sparse matrices have a fixed number of rows and columns, that is, they represent elements of the matrices space mathrmMat_ntimes m(R). Internally, sparse matrices are implemented as an array of sparse rows. As a consequence, unlike their dense counterparts, sparse matrices have a mutable number of rows and it is very performant to add additional rows.","category":"page"},{"location":"Hecke/manual/misc/sparse/#Construction","page":"Sparse linear algebra","title":"Construction","text":"","category":"section"},{"location":"Hecke/manual/misc/sparse/","page":"Sparse linear algebra","title":"Sparse linear algebra","text":"sparse_matrix(::Ring)\nsparse_matrix(::Ring, ::Int, ::Int)","category":"page"},{"location":"Hecke/manual/misc/sparse/#sparse_matrix-Tuple{Ring}","page":"Sparse linear algebra","title":"sparse_matrix","text":"sparse_matrix(R::Ring) -> SMat\n\nReturn an empty sparse matrix with base ring R.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/misc/sparse/#sparse_matrix-Tuple{Ring, Int64, Int64}","page":"Sparse linear algebra","title":"sparse_matrix","text":"sparse_matrix(R::Ring, n::Int, m::Int) -> SMat\n\nReturn a sparse n times m zero matrix over R.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/misc/sparse/","page":"Sparse linear algebra","title":"Sparse linear algebra","text":"Sparse matrices can also be created from dense matrices as well as from julia arrays:","category":"page"},{"location":"Hecke/manual/misc/sparse/","page":"Sparse linear algebra","title":"Sparse linear algebra","text":"sparse_matrix(::MatElem; keepzrows)\nsparse_matrix(::Matrix{T}) where {T}\nsparse_matrix(::Ring, ::Matrix{T}) where {T}","category":"page"},{"location":"Hecke/manual/misc/sparse/#sparse_matrix-Tuple{MatElem}","page":"Sparse linear algebra","title":"sparse_matrix","text":"sparse_matrix(A::MatElem; keepzrows::Bool = true)\n\nConstructs the sparse matrix corresponding to the dense matrix A. If keepzrows is false, then the constructor will drop any zero row of A.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/misc/sparse/#sparse_matrix-Union{Tuple{Matrix{T}}, Tuple{T}} where T","page":"Sparse linear algebra","title":"sparse_matrix","text":"sparse_matrix(R::Ring, A::Matrix{T}) -> SMat\n\nConstructs the sparse matrix over R corresponding to A.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/misc/sparse/#sparse_matrix-Union{Tuple{T}, Tuple{Ring, Matrix{T}}} where T","page":"Sparse linear algebra","title":"sparse_matrix","text":"sparse_matrix(R::Ring, A::Matrix{T}) -> SMat\n\nConstructs the sparse matrix over R corresponding to A.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/misc/sparse/","page":"Sparse linear algebra","title":"Sparse linear algebra","text":"The normal way however, is to add rows:","category":"page"},{"location":"Hecke/manual/misc/sparse/","page":"Sparse linear algebra","title":"Sparse linear algebra","text":"push!(::SMat{T}, ::SRow{T}) where {T}","category":"page"},{"location":"Hecke/manual/misc/sparse/#push!-Union{Tuple{T}, Tuple{SMat{T}, SRow{T}}} where T","page":"Sparse linear algebra","title":"push!","text":"push!(A::SMat{T}, B::SRow{T}) where T\n\nAppends the sparse row B to A.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/misc/sparse/","page":"Sparse linear algebra","title":"Sparse linear algebra","text":"Sparse matrices can also be concatenated to form larger ones:","category":"page"},{"location":"Hecke/manual/misc/sparse/","page":"Sparse linear algebra","title":"Sparse linear algebra","text":"vcat!(::SMat{T}, ::SMat{T}) where {T}\nvcat(::SMat{T}, ::SMat{T}) where {T}\nhcat!(::SMat{T}, ::SMat{T}) where {T}\nhcat(::SMat{T}, ::SMat{T}) where {T}","category":"page"},{"location":"Hecke/manual/misc/sparse/#vcat!-Union{Tuple{T}, Tuple{SMat{T}, SMat{T}}} where T","page":"Sparse linear algebra","title":"vcat!","text":"vcat!(A::SMat, B::SMat) -> SMat\n\nVertically joins A and B inplace, that is, the rows of B are appended to A.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/misc/sparse/#vcat-Union{Tuple{T}, Tuple{SMat{T}, SMat{T}}} where T","page":"Sparse linear algebra","title":"vcat","text":"vcat(A::SMat, B::SMat) -> SMat\n\nVertically joins A and B.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/misc/sparse/#hcat!-Union{Tuple{T}, Tuple{SMat{T}, SMat{T}}} where T","page":"Sparse linear algebra","title":"hcat!","text":"hcat!(A::SMat, B::SMat) -> SMat\n\nHorizontally concatenates A and B, inplace, changing A.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/misc/sparse/#hcat-Union{Tuple{T}, Tuple{SMat{T}, SMat{T}}} where T","page":"Sparse linear algebra","title":"hcat","text":"hcat(A::SMat, B::SMat) -> SMat\n\nHorizontally concatenates A and B.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/misc/sparse/","page":"Sparse linear algebra","title":"Sparse linear algebra","text":"(Normal julia cat is also supported)","category":"page"},{"location":"Hecke/manual/misc/sparse/","page":"Sparse linear algebra","title":"Sparse linear algebra","text":"There are special constructors:","category":"page"},{"location":"Hecke/manual/misc/sparse/","page":"Sparse linear algebra","title":"Sparse linear algebra","text":"identity_matrix(::Type{SMat}, ::Ring, ::Int)\nzero_matrix(::Type{SMat}, ::Ring, ::Int)\nzero_matrix(::Type{SMat}, ::Ring, ::Int, ::Int)\nblock_diagonal_matrix(xs::Vector{<:SMat{T}}) where {T}","category":"page"},{"location":"Hecke/manual/misc/sparse/#identity_matrix-Tuple{Type{SMat}, Ring, Int64}","page":"Sparse linear algebra","title":"identity_matrix","text":"identity_matrix(::Type{SMat}, R::Ring, n::Int)\n\nReturn a sparse n times n identity matrix over R.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/misc/sparse/#zero_matrix-Tuple{Type{SMat}, Ring, Int64}","page":"Sparse linear algebra","title":"zero_matrix","text":"zero_matrix(::Type{SMat}, R::Ring, n::Int)\n\nReturn a sparse n times n zero matrix over R.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/misc/sparse/#zero_matrix-Tuple{Type{SMat}, Ring, Int64, Int64}","page":"Sparse linear algebra","title":"zero_matrix","text":"zero_matrix(::Type{SMat}, R::Ring, n::Int, m::Int)\n\nReturn a sparse n times m zero matrix over R.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/misc/sparse/#block_diagonal_matrix-Union{Tuple{Vector{<:SMat{T}}}, Tuple{T}} where T","page":"Sparse linear algebra","title":"block_diagonal_matrix","text":"block_diagonal_matrix(xs::Vector{SMat})\n\nReturn the block diagonal matrix with the matrices in xs on the diagonal. Requires all blocks to have the same base ring.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/misc/sparse/","page":"Sparse linear algebra","title":"Sparse linear algebra","text":"Slices:","category":"page"},{"location":"Hecke/manual/misc/sparse/","page":"Sparse linear algebra","title":"Sparse linear algebra","text":"sub(::SMat{T}, ::AbstractUnitRange, ::AbstractUnitRange) where {T}","category":"page"},{"location":"Hecke/manual/misc/sparse/#sub-Union{Tuple{T}, Tuple{SMat{T}, AbstractUnitRange, AbstractUnitRange}} where T","page":"Sparse linear algebra","title":"sub","text":"sub(A::SMat, r::AbstractUnitRange, c::AbstractUnitRange) -> SMat\n\nReturn the submatrix of A, where the rows correspond to r and the columns correspond to c.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/misc/sparse/","page":"Sparse linear algebra","title":"Sparse linear algebra","text":"Transpose:","category":"page"},{"location":"Hecke/manual/misc/sparse/","page":"Sparse linear algebra","title":"Sparse linear algebra","text":"transpose(A::SMat)","category":"page"},{"location":"Hecke/manual/misc/sparse/#transpose-Tuple{SMat}","page":"Sparse linear algebra","title":"transpose","text":"transpose(A::SMat) -> SMat\n\nReturns the transpose of A.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/misc/sparse/#Elementary-Properties","page":"Sparse linear algebra","title":"Elementary Properties","text":"","category":"section"},{"location":"Hecke/manual/misc/sparse/","page":"Sparse linear algebra","title":"Sparse linear algebra","text":"sparsity(::SMat)\ndensity(::SMat)\nnnz(::SMat)\nnumber_of_rows(::SMat)\nnumber_of_columns(::SMat)\nisone(::SMat)\niszero(::SMat)\nis_upper_triangular(::SMat)\nmaximum(::SMat)\nminimum(::SMat)\nmaximum(::typeof(abs), ::SMat{ZZRingElem})\nelementary_divisors(::SMat{ZZRingElem})\nHecke.solve_dixon_sf(::SMat{ZZRingElem}, ::SRow{ZZRingElem})\nHecke.hadamard_bound2(::SMat)\nHecke.echelon_with_transform(::SMat{zzModRingElem})\nHecke.reduce_full(::SMat{ZZRingElem}, ::SRow{ZZRingElem})\nhnf!(::SMat{ZZRingElem})\nhnf(::SMat{ZZRingElem})\nsnf(::SMat{ZZRingElem})\nhnf_extend!(::SMat{ZZRingElem}, ::SMat{ZZRingElem})\nis_diagonal(::SMat)\ndet(::SMat{ZZRingElem})\ndet_mc(::SMat{ZZRingElem})\nvalence_mc(::SMat)\nsaturate(::SMat{ZZRingElem})\nHecke.hnf_kannan_bachem(::SMat{ZZRingElem})\ndiagonal_form(::SMat{ZZRingElem})","category":"page"},{"location":"Hecke/manual/misc/sparse/#sparsity-Tuple{SMat}","page":"Sparse linear algebra","title":"sparsity","text":"sparsity(A::SMat) -> Float64\n\nReturn the sparsity of A, that is, the number of zero-valued elements divided by the number of all elements.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/misc/sparse/#density-Tuple{SMat}","page":"Sparse linear algebra","title":"density","text":"density(A::SMat) -> Float64\n\nReturn the density of A, that is, the number of nonzero-valued elements divided by the number of all elements.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/misc/sparse/#nnz-Tuple{SMat}","page":"Sparse linear algebra","title":"nnz","text":"nnz(A::SMat) -> Int\n\nReturn the number of non-zero entries of A.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/misc/sparse/#number_of_rows-Tuple{SMat}","page":"Sparse linear algebra","title":"number_of_rows","text":"number_of_rows(A::SMat) -> Int\n\nReturn the number of rows of A.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/misc/sparse/#number_of_columns-Tuple{SMat}","page":"Sparse linear algebra","title":"number_of_columns","text":"number_of_columns(A::SMat) -> Int\n\nReturn the number of columns of A.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/misc/sparse/#isone-Tuple{SMat}","page":"Sparse linear algebra","title":"isone","text":"isone(A::SMat)\n\nTests if A is an identity matrix.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/misc/sparse/#iszero-Tuple{SMat}","page":"Sparse linear algebra","title":"iszero","text":"iszero(A::SMat)\n\nTests if A is a zero matrix.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/misc/sparse/#is_upper_triangular-Tuple{SMat}","page":"Sparse linear algebra","title":"is_upper_triangular","text":"is_upper_triangular(A::SMat)\n\nReturns true if and only if A is upper (right) triangular.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/misc/sparse/#maximum-Tuple{SMat}","page":"Sparse linear algebra","title":"maximum","text":"maximum(A::SMat{T}) -> T\n\nFinds the largest entry of A.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/misc/sparse/#minimum-Tuple{SMat}","page":"Sparse linear algebra","title":"minimum","text":"minimum(A::SMat{T}) -> T\n\nFinds the smallest entry of A.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/misc/sparse/#maximum-Tuple{typeof(abs), SMat{ZZRingElem}}","page":"Sparse linear algebra","title":"maximum","text":"maximum(abs, A::SMat{ZZRingElem}) -> ZZRingElem\n\nFinds the largest, in absolute value, entry of A.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/misc/sparse/#elementary_divisors-Tuple{SMat{ZZRingElem}}","page":"Sparse linear algebra","title":"elementary_divisors","text":"elementary_divisors(A::SMat{ZZRingElem}) -> Vector{ZZRingElem}\n\nThe elementary divisors of A, i.e. the diagonal elements of the Smith normal form of A.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/misc/sparse/#solve_dixon_sf-Tuple{SMat{ZZRingElem}, SRow{ZZRingElem}}","page":"Sparse linear algebra","title":"solve_dixon_sf","text":"solve_dixon_sf(A::SMat{ZZRingElem}, b::SRow{ZZRingElem}, is_int::Bool = false) -> SRow{ZZRingElem}, ZZRingElem\nsolve_dixon_sf(A::SMat{ZZRingElem}, B::SMat{ZZRingElem}, is_int::Bool = false) -> SMat{ZZRingElem}, ZZRingElem\n\nFor a sparse square matrix A of full rank and a sparse matrix (row), find a sparse matrix (row) x and an integer d s.th. x A = bd holds. The algorithm is a Dixon-based linear p-adic lifting method. If \\code{is_int} is given, then d is assumed to be 1. In this case rational reconstruction is avoided.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/misc/sparse/#hadamard_bound2-Tuple{SMat}","page":"Sparse linear algebra","title":"hadamard_bound2","text":"hadamard_bound2(A::SMat{T}) -> T\n\nThe square of the product of the norms of the rows of A.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/misc/sparse/#echelon_with_transform-Tuple{SMat{zzModRingElem}}","page":"Sparse linear algebra","title":"echelon_with_transform","text":"echelon_with_transform(A::SMat{zzModRingElem}) -> SMat, SMat\n\nFind a unimodular matrix T and an upper-triangular E s.th. TA = E holds.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/misc/sparse/#reduce_full-Tuple{SMat{ZZRingElem}, SRow{ZZRingElem}}","page":"Sparse linear algebra","title":"reduce_full","text":"reduce_full(A::SMat{ZZRingElem}, g::SRow{ZZRingElem},\n                      with_transform = Val(false)) -> SRow{ZZRingElem}, Vector{Int}\n\nReduces g modulo A and assumes that A is upper triangular.\n\nThe second return value is the array of pivot elements of A that changed.\n\nIf with_transform is set to Val(true), then additionally an array of transformations is returned.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/misc/sparse/#hnf!-Tuple{SMat{ZZRingElem}}","page":"Sparse linear algebra","title":"hnf!","text":"hnf!(A::SMat{ZZRingElem})\n\nInplace transform of A into upper right Hermite normal form.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/misc/sparse/#hnf-Tuple{SMat{ZZRingElem}}","page":"Sparse linear algebra","title":"hnf","text":"hnf(A::SMat{ZZRingElem}) -> SMat{ZZRingElem}\n\nReturn the upper right Hermite normal form of A.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/misc/sparse/#snf-Tuple{SMat{ZZRingElem}}","page":"Sparse linear algebra","title":"snf","text":"snf(A::SMat{ZZRingElem})\n\nThe Smith normal form (snf) of A.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/misc/sparse/#hnf_extend!-Tuple{SMat{ZZRingElem}, SMat{ZZRingElem}}","page":"Sparse linear algebra","title":"hnf_extend!","text":"hnf_extend!(A::SMat{ZZRingElem}, b::SMat{ZZRingElem}, offset::Int = 0) -> SMat{ZZRingElem}\n\nGiven a matrix A in HNF, extend this to get the HNF of the concatenation with b.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/misc/sparse/#is_diagonal-Tuple{SMat}","page":"Sparse linear algebra","title":"is_diagonal","text":"is_diagonal(A::SMat) -> Bool\n\nTrue iff only the i-th entry in the i-th row is non-zero.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/misc/sparse/#det-Tuple{SMat{ZZRingElem}}","page":"Sparse linear algebra","title":"det","text":"det(A::SMat{ZZRingElem})\n\nThe determinant of A using a modular algorithm. Uses the dense (zzModMatrix) determinant on A for various primes p.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/misc/sparse/#det_mc-Tuple{SMat{ZZRingElem}}","page":"Sparse linear algebra","title":"det_mc","text":"det_mc(A::SMat{ZZRingElem})\n\nComputes the determinant of A using a LasVegas style algorithm, i.e. the result is not proven to be correct. Uses the dense (zzModMatrix) determinant on A for various primes p.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/misc/sparse/#valence_mc-Tuple{SMat}","page":"Sparse linear algebra","title":"valence_mc","text":"valence_mc{T}(A::SMat{T}; extra_prime = 2, trans = Vector{SMatSLP_add_row{T}}()) -> T\n\nUses a Monte-Carlo algorithm to compute the valence of A. The valence is the valence of the minimal polynomial f of transpose(A)*A, thus the last non-zero coefficient, typically f(0).\n\nThe valence is computed modulo various primes until the computation stabilises for extra_prime many.\n\ntrans, if given, is  a SLP (straight-line-program) in GL(n, Z). Then the valence of trans * A  is computed instead.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/misc/sparse/#saturate-Tuple{SMat{ZZRingElem}}","page":"Sparse linear algebra","title":"saturate","text":"saturate(A::SMat{ZZRingElem}) -> SMat{ZZRingElem}\n\nComputes the saturation of A, that is, a basis for mathbfQotimes M cap mathbfZ^n, where M is the row span of A and n the number of rows of A.\n\nEquivalently, return TA for an invertible rational matrix T, such that TA is integral and the elementary divisors of TA are all trivial.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/misc/sparse/#hnf_kannan_bachem-Tuple{SMat{ZZRingElem}}","page":"Sparse linear algebra","title":"hnf_kannan_bachem","text":"hnf_kannan_bachem(A::SMat{ZZRingElem}) -> SMat{ZZRingElem}\n\nCompute the Hermite normal form of A using the Kannan-Bachem algorithm.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/misc/sparse/#diagonal_form-Tuple{SMat{ZZRingElem}}","page":"Sparse linear algebra","title":"diagonal_form","text":"diagonal_form(A::SMat{ZZRingElem}) -> SMat{ZZRingElem}\n\nA matrix D that is diagonal and obtained via unimodular row and column operations. Like a snf without the divisibility condition.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/misc/sparse/#Manipulation/-Access","page":"Sparse linear algebra","title":"Manipulation/ Access","text":"","category":"section"},{"location":"Hecke/manual/misc/sparse/","page":"Sparse linear algebra","title":"Sparse linear algebra","text":"getindex(::SMat{T}, ::Int, ::Int) where {T}\ngetindex(::SMat{T}, ::Int) where {T}\nsetindex!(::SMat{T}, ::SRow{T}, ::Int) where {T}\nswap_rows!(::SMat, ::Int, I::Int)\nswap_cols!(::SMat, ::Int, I::Int)\nscale_row!(::SMat{T}, ::Int, ::T) where {T}\nadd_scaled_col!(::SMat{T}, ::Int, ::Int, ::T) where {T}\nadd_scaled_row!(::SMat{T}, ::Int, ::Int, ::T) where {T}\ntransform_row!(::SMat{T}, ::Int, ::Int, ::T, ::T, ::T, ::T) where {T}\ndiagonal(::SMat)\nreverse_rows!(::SMat)\nmod_sym!(::SMat{ZZRingElem}, ::ZZRingElem)\nfind_row_starting_with(::SMat, ::Int)\nreduce(::SMat{ZZRingElem}, ::SRow{ZZRingElem}, ::ZZRingElem)\nreduce(::SMat{ZZRingElem}, ::SRow{ZZRingElem})\nreduce(::SMat{T}, ::SRow{T}) where {T <: FieldElement}\nrand_row(::SMat{T}) where {T}","category":"page"},{"location":"Hecke/manual/misc/sparse/#getindex-Union{Tuple{T}, Tuple{SMat{T}, Int64, Int64}} where T","page":"Sparse linear algebra","title":"getindex","text":"getindex(A::SMat, i::Int, j::Int)\n\nGiven a sparse matrix A = (a_ij)_i j, return the entry a_ij.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/misc/sparse/#getindex-Union{Tuple{T}, Tuple{SMat{T}, Int64}} where T","page":"Sparse linear algebra","title":"getindex","text":"getindex(A::SMat, i::Int) -> SRow\n\nGiven a sparse matrix A and an index i, return the i-th row of A.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/misc/sparse/#setindex!-Union{Tuple{T}, Tuple{SMat{T}, SRow{T}, Int64}} where T","page":"Sparse linear algebra","title":"setindex!","text":"setindex!(A::SMat, b::SRow, i::Int)\n\nGiven a sparse matrix A, a sparse row b and an index i, set the i-th row of A equal to b.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/misc/sparse/#swap_rows!-Tuple{SMat, Int64, Int64}","page":"Sparse linear algebra","title":"swap_rows!","text":"swap_rows!(A::SMat{T}, i::Int, j::Int)\n\nSwap the i-th and j-th row of A inplace.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/misc/sparse/#swap_cols!-Tuple{SMat, Int64, Int64}","page":"Sparse linear algebra","title":"swap_cols!","text":"swap_cols!(A::SMat, i::Int, j::Int)\n\nSwap the i-th and j-th column of A inplace.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/misc/sparse/#scale_row!-Union{Tuple{T}, Tuple{SMat{T}, Int64, T}} where T","page":"Sparse linear algebra","title":"scale_row!","text":"scale_row!(A::SMat{T}, i::Int, c::T)\n\nMultiply the i-th row of A by c inplace.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/misc/sparse/#add_scaled_col!-Union{Tuple{T}, Tuple{SMat{T}, Int64, Int64, T}} where T","page":"Sparse linear algebra","title":"add_scaled_col!","text":"add_scaled_col!(A::SMat{T}, i::Int, j::Int, c::T)\n\nAdd c times the i-th column to the j-th column of A inplace, that is, A_j rightarrow A_j + c cdot A_i, where (A_i)_i denote the columns of A.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/misc/sparse/#add_scaled_row!-Union{Tuple{T}, Tuple{SMat{T}, Int64, Int64, T}} where T","page":"Sparse linear algebra","title":"add_scaled_row!","text":"add_scaled_row!(A::SMat{T}, i::Int, j::Int, c::T)\n\nAdd c times the i-th row to the j-th row of A inplace, that is, A_j rightarrow A_j + c cdot A_i, where (A_i)_i denote the rows of A.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/misc/sparse/#transform_row!-Union{Tuple{T}, Tuple{SMat{T}, Int64, Int64, Vararg{T, 4}}} where T","page":"Sparse linear algebra","title":"transform_row!","text":"transform_row!(A::SMat{T}, i::Int, j::Int, a::T, b::T, c::T, d::T)\n\nApplies the transformation (A_i A_j) rightarrow (aA_i + bA_j cA_i + dA_j) to A, where (A_i)_i are the rows of A.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/misc/sparse/#diagonal-Tuple{SMat}","page":"Sparse linear algebra","title":"diagonal","text":"diagonal(A::SMat) -> ZZRingElem[]\n\nThe diagonal elements of A in an array.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/misc/sparse/#reverse_rows!-Tuple{SMat}","page":"Sparse linear algebra","title":"reverse_rows!","text":"reverse_rows!(A::SMat)\n\nInplace inversion of the rows of A.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/misc/sparse/#mod_sym!-Tuple{SMat{ZZRingElem}, ZZRingElem}","page":"Sparse linear algebra","title":"mod_sym!","text":"mod_sym!(A::SMat{ZZRingElem}, n::ZZRingElem)\n\nInplace reduction of all entries of A modulo n to the symmetric residue system.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/misc/sparse/#find_row_starting_with-Tuple{SMat, Int64}","page":"Sparse linear algebra","title":"find_row_starting_with","text":"find_row_starting_with(A::SMat, p::Int) -> Int\n\nTries to find the index i such that A_ip neq 0 and A_i p-j = 0 for all j  1. It is assumed that A is upper triangular. If such an index does not exist, find the smallest index larger.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/misc/sparse/#reduce-Tuple{SMat{ZZRingElem}, SRow{ZZRingElem}, ZZRingElem}","page":"Sparse linear algebra","title":"reduce","text":"reduce(A::SMat{ZZRingElem}, g::SRow{ZZRingElem}, m::ZZRingElem) -> SRow{ZZRingElem}\n\nGiven an upper triangular matrix A over the integers, a sparse row g and an integer m, this function reduces g modulo A and returns g modulo m with respect to the symmetric residue system.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/misc/sparse/#reduce-Tuple{SMat{ZZRingElem}, SRow{ZZRingElem}}","page":"Sparse linear algebra","title":"reduce","text":"reduce(A::SMat{ZZRingElem}, g::SRow{ZZRingElem}) -> SRow{ZZRingElem}\n\nGiven an upper triangular matrix A over a field and a sparse row g, this function reduces g modulo A.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/misc/sparse/#reduce-Union{Tuple{T}, Tuple{SMat{T}, SRow{T}}} where T<:FieldElement","page":"Sparse linear algebra","title":"reduce","text":"reduce(A::SMat{T}, g::SRow{T}) -> SRow{T}\n\nGiven an upper triangular matrix A over a field and a sparse row g, this function reduces g modulo A.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/misc/sparse/#rand_row-Union{Tuple{SMat{T}}, Tuple{T}} where T","page":"Sparse linear algebra","title":"rand_row","text":"rand_row(A::SMat) -> SRow\n\nReturn a random row of the sparse matrix A.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/misc/sparse/","page":"Sparse linear algebra","title":"Sparse linear algebra","text":"Changing of the ring:","category":"page"},{"location":"Hecke/manual/misc/sparse/","page":"Sparse linear algebra","title":"Sparse linear algebra","text":"map_entries(f, ::SMat)\nchange_base_ring(::Ring, ::SMat)","category":"page"},{"location":"Hecke/manual/misc/sparse/#map_entries-Tuple{Any, SMat}","page":"Sparse linear algebra","title":"map_entries","text":"map_entries(f, A::SMat) -> SMat\n\nGiven a sparse matrix A and a callable object f, this function will construct a new sparse matrix by applying f to all elements of A.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/misc/sparse/#change_base_ring-Tuple{Ring, SMat}","page":"Sparse linear algebra","title":"change_base_ring","text":"change_base_ring(R::Ring, A::SMat)\n\nCreate a new sparse matrix by coercing all elements into the ring R.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/misc/sparse/#Arithmetic","page":"Sparse linear algebra","title":"Arithmetic","text":"","category":"section"},{"location":"Hecke/manual/misc/sparse/","page":"Sparse linear algebra","title":"Sparse linear algebra","text":"Matrices support the usual operations as well","category":"page"},{"location":"Hecke/manual/misc/sparse/","page":"Sparse linear algebra","title":"Sparse linear algebra","text":"+, -, ==\ndiv, divexact by scalars\nmultiplication by scalars","category":"page"},{"location":"Hecke/manual/misc/sparse/","page":"Sparse linear algebra","title":"Sparse linear algebra","text":"Various products:","category":"page"},{"location":"Hecke/manual/misc/sparse/","page":"Sparse linear algebra","title":"Sparse linear algebra","text":"*(::SMat{T}, ::AbstractVector{T}) where {T}\n*(::SMat{T}, ::AbstractMatrix{T})  where {T}\n*(::SMat{T}, ::MatElem{T}) where {T}\n*(::SRow{T}, ::SMat{T}) where {T}","category":"page"},{"location":"Hecke/manual/misc/sparse/#*-Union{Tuple{T}, Tuple{SMat{T}, AbstractVector{T}}} where T","page":"Sparse linear algebra","title":"*","text":"*(A::SMat{T}, b::AbstractVector{T}) -> Vector{T}\n\nReturn the product A cdot b as a dense vector.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/misc/sparse/#*-Union{Tuple{T}, Tuple{SMat{T}, AbstractMatrix{T}}} where T","page":"Sparse linear algebra","title":"*","text":"*(A::SMat{T}, b::AbstractMatrix{T}) -> Matrix{T}\n\nReturn the product A cdot b as a dense array.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/misc/sparse/#*-Union{Tuple{T}, Tuple{SMat{T}, MatElem{T}}} where T","page":"Sparse linear algebra","title":"*","text":"*(A::SMat{T}, b::MatElem{T}) -> MatElem\n\nReturn the product A cdot b as a dense matrix.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/misc/sparse/#*-Union{Tuple{T}, Tuple{SRow{T}, SMat{T}}} where T","page":"Sparse linear algebra","title":"*","text":"*(A::SRow, B::SMat) -> SRow\n\nReturn the product Acdot B as a sparse row.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/misc/sparse/","page":"Sparse linear algebra","title":"Sparse linear algebra","text":"dot(::SRow{T}, ::SMat{T}, ::SRow{T}) where T\ndot(::MatrixElem{T}, ::SMat{T}, ::MatrixElem{T}) where T\ndot(::AbstractVector{T}, ::SMat{T}, ::AbstractVector{T}) where T","category":"page"},{"location":"Hecke/manual/misc/sparse/#dot-Union{Tuple{T}, Tuple{SRow{T}, SMat{T}, SRow{T}}} where T","page":"Sparse linear algebra","title":"dot","text":"dot(x::SRow{T}, A::SMat{T}, y::SRow{T}) where T -> T\n\nReturn the generalized dot product dot(x, A*y).\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/misc/sparse/#dot-Union{Tuple{T}, Tuple{MatrixElem{T}, SMat{T}, MatrixElem{T}}} where T","page":"Sparse linear algebra","title":"dot","text":"dot(x::MatrixElem{T}, A::SMat{T}, y::MatrixElem{T}) where T -> T\n\nReturn the generalized dot product dot(x, A*y).\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/misc/sparse/#dot-Union{Tuple{T}, Tuple{AbstractVector{T}, SMat{T}, AbstractVector{T}}} where T","page":"Sparse linear algebra","title":"dot","text":"dot(x::AbstractVector{T}, A::SMat{T}, y::AbstractVector{T}) where T -> T\n\nReturn the generalized dot product dot(x, A*y).\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/misc/sparse/","page":"Sparse linear algebra","title":"Sparse linear algebra","text":"Other:","category":"page"},{"location":"Hecke/manual/misc/sparse/","page":"Sparse linear algebra","title":"Sparse linear algebra","text":"sparse(::SMat)\nZZMatrix(::SMat{ZZRingElem})\nZZMatrix(::SMat{T}) where {T <: Integer}\nMatrix(::SMat)\nArray(::SMat)","category":"page"},{"location":"Hecke/manual/misc/sparse/#sparse-Tuple{SMat}","page":"Sparse linear algebra","title":"sparse","text":"sparse(A::SMat) -> SparseMatrixCSC\n\nThe same matrix, but as a sparse matrix of julia type SparseMatrixCSC.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/misc/sparse/#ZZMatrix-Tuple{SMat{ZZRingElem}}","page":"Sparse linear algebra","title":"ZZMatrix","text":"ZZMatrix(A::SMat{ZZRingElem})\n\nThe same matrix A, but as an ZZMatrix.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/misc/sparse/#ZZMatrix-Union{Tuple{SMat{T}}, Tuple{T}} where T<:Integer","page":"Sparse linear algebra","title":"ZZMatrix","text":"ZZMatrix(A::SMat{T}) where {T <: Integer}\n\nThe same matrix A, but as an ZZMatrix. Requires a conversion from the base ring of A to mathbb ZZ.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/misc/sparse/#Matrix-Tuple{SMat}","page":"Sparse linear algebra","title":"Matrix","text":"Matrix(A::SMat{T}) -> Matrix{T}\n\nThe same matrix, but as a julia matrix.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/misc/sparse/#Array-Tuple{SMat}","page":"Sparse linear algebra","title":"Array","text":"Array(A::SMat{T}) -> Matrix{T}\n\nThe same matrix, but as a two-dimensional julia array.\n\n\n\n\n\n","category":"method"},{"location":"AlgebraicGeometry/Curves/ParametrizationPlaneCurves/","page":"Rational Parametrizations of Rational Plane Curves","title":"Rational Parametrizations of Rational Plane Curves","text":"CurrentModule = Oscar","category":"page"},{"location":"AlgebraicGeometry/Curves/ParametrizationPlaneCurves/#Rational-Parametrizations-of-Rational-Plane-Curves","page":"Rational Parametrizations of Rational Plane Curves","title":"Rational Parametrizations of Rational Plane Curves","text":"","category":"section"},{"location":"AlgebraicGeometry/Curves/ParametrizationPlaneCurves/","page":"Rational Parametrizations of Rational Plane Curves","title":"Rational Parametrizations of Rational Plane Curves","text":"note: Note\nIn this section, C will denote a complex projective plane curve, defined by an absolutely irreducible, homogeneous polynomial in three variables, with coefficients in mathbb Q. Moreover, we will write n = deg C.","category":"page"},{"location":"AlgebraicGeometry/Curves/ParametrizationPlaneCurves/","page":"Rational Parametrizations of Rational Plane Curves","title":"Rational Parametrizations of Rational Plane Curves","text":"Recall that the curve C is rational if it is birationally equivalent to the projective line mathbb P^1(mathbb C). In other words, there exists a rational parametrization of C, that is, a birational map mathbb P^1(mathbb C)dashrightarrow C. Note that such a parametrization is given by three homogeneous polynomials of the same degree in the homogeneous coordinates on mathbb P^1(mathbb C).","category":"page"},{"location":"AlgebraicGeometry/Curves/ParametrizationPlaneCurves/","page":"Rational Parametrizations of Rational Plane Curves","title":"Rational Parametrizations of Rational Plane Curves","text":"note: Note\nThe curve C is rational iff its geometric genus is zero.","category":"page"},{"location":"AlgebraicGeometry/Curves/ParametrizationPlaneCurves/","page":"Rational Parametrizations of Rational Plane Curves","title":"Rational Parametrizations of Rational Plane Curves","text":"Based on work of Max Noether on adjoint curves, Hilbert und Hurwitz showed that if C is rational, then there is a birational map C dashrightarrow D defined over mathbb Q such that D = mathbb P^1(mathbb C) if n is odd, and Dsubsetmathbb P^2(mathbb C) is a conic if n is even.","category":"page"},{"location":"AlgebraicGeometry/Curves/ParametrizationPlaneCurves/","page":"Rational Parametrizations of Rational Plane Curves","title":"Rational Parametrizations of Rational Plane Curves","text":"note: Note\nIf a conic D contains a rational point, then there exists a parametrization of D defined over mathbb Q; otherwise, there exists a parametrization of D defined over a quadratic field extension of mathbb Q.","category":"page"},{"location":"AlgebraicGeometry/Curves/ParametrizationPlaneCurves/","page":"Rational Parametrizations of Rational Plane Curves","title":"Rational Parametrizations of Rational Plane Curves","text":"The approach of Hilbert und Hurwitz is constructive and allows one, in principle, to find rational parametrizations. The resulting algorithm is not very practical, however, as the approach asks to compute adjoint curves repeatedly, at each of a number of reduction steps.","category":"page"},{"location":"AlgebraicGeometry/Curves/ParametrizationPlaneCurves/","page":"Rational Parametrizations of Rational Plane Curves","title":"Rational Parametrizations of Rational Plane Curves","text":"The algorithm implemented in OSCAR relies on reduction steps of a different type and requires the computation of adjoint curves only once. Its individual steps are interesting in their own right:","category":"page"},{"location":"AlgebraicGeometry/Curves/ParametrizationPlaneCurves/","page":"Rational Parametrizations of Rational Plane Curves","title":"Rational Parametrizations of Rational Plane Curves","text":"Assure that the curve  C is rational by checking that its geometric genus is zero;\ncompute a basis of the adjoint curves of C of degree n-2; each such basis defines a birational map C dashrightarrow C_n-2  where C_n-2 is a rational normal curve in mathbb P^n-2(mathbb C);\nthe anticanonical linear system on C_n-2 defines a birational map C_n-2dashrightarrow C_n-4, where C_n-4 is a rational normal curve in in mathbb P^n-4(mathbb C);\niterate the previous step to obtain a birational map  C_n-2 dashrightarrow dots dashrightarrow D,  where D = mathbb P^1(mathbb C) if n is odd, and Dsubsetmathbb P^2(mathbb C) is a conic if n is even;\ninvert the birational map  C dashrightarrow C_n-2 dashrightarrow dots dashrightarrow D; \nif n is even, compute a parametrization of the conic D and compose it with the inverted map above.","category":"page"},{"location":"AlgebraicGeometry/Curves/ParametrizationPlaneCurves/","page":"Rational Parametrizations of Rational Plane Curves","title":"Rational Parametrizations of Rational Plane Curves","text":"note: Note\nThe defining property of an adjoint curve is that it passes with “sufficiently high” multiplicity through the singularities of C. There are several concepts of making this precise. For each such concept, there is a corresponding  adjoint ideal of C, namely the homogeneous ideal formed by the defining polynomials of the adjoint curves. In OSCAR, we follow the concept of Gorenstein which leads to the largest possible adjoint ideal.","category":"page"},{"location":"AlgebraicGeometry/Curves/ParametrizationPlaneCurves/","page":"Rational Parametrizations of Rational Plane Curves","title":"Rational Parametrizations of Rational Plane Curves","text":"See [Bhm99] and [BDLP17] for details and further references.","category":"page"},{"location":"AlgebraicGeometry/Curves/ParametrizationPlaneCurves/#Adjoint-Ideals-of-Plane-Curves","page":"Rational Parametrizations of Rational Plane Curves","title":"Adjoint Ideals of Plane Curves","text":"","category":"section"},{"location":"AlgebraicGeometry/Curves/ParametrizationPlaneCurves/","page":"Rational Parametrizations of Rational Plane Curves","title":"Rational Parametrizations of Rational Plane Curves","text":"adjoint_ideal(C::ProjectivePlaneCurve{QQField})","category":"page"},{"location":"AlgebraicGeometry/Curves/ParametrizationPlaneCurves/#adjoint_ideal-Tuple{ProjectivePlaneCurve{QQField}}","page":"Rational Parametrizations of Rational Plane Curves","title":"adjoint_ideal","text":"adjoint_ideal(C::ProjectivePlaneCurve{QQField})\n\nReturn the Gorenstein adjoint ideal of C. \n\nExamples\n\njulia> R, (x,y,z) = graded_polynomial_ring(QQ, [:x, :y, :z]);\n\njulia> C = ProjectivePlaneCurve(y^4-2*x^3*z+3*x^2*z^2-2*y^2*z^2)\nProjective plane curve\n  defined by 0 = 2*x^3*z - 3*x^2*z^2 - y^4 + 2*y^2*z^2\n\njulia> I = adjoint_ideal(C)\nIdeal generated by\n  -x*z + y^2\n  x*y - y*z\n  x^2 - x*z\n\n\n\n\n\n\n","category":"method"},{"location":"AlgebraicGeometry/Curves/ParametrizationPlaneCurves/#Rational-Points-on-Conics","page":"Rational Parametrizations of Rational Plane Curves","title":"Rational Points on Conics","text":"","category":"section"},{"location":"AlgebraicGeometry/Curves/ParametrizationPlaneCurves/","page":"Rational Parametrizations of Rational Plane Curves","title":"Rational Parametrizations of Rational Plane Curves","text":"rational_point_conic(D::ProjectivePlaneCurve{QQField})","category":"page"},{"location":"AlgebraicGeometry/Curves/ParametrizationPlaneCurves/#rational_point_conic-Tuple{ProjectivePlaneCurve{QQField}}","page":"Rational Parametrizations of Rational Plane Curves","title":"rational_point_conic","text":"rational_point_conic(D::ProjectivePlaneCurve{QQField})\n\nIf the plane conic D contains a rational point, return the homogeneous coordinates of such a point. If no such point exists, return a point on D defined over a quadratic field extension of mathbb Q.\n\nExamples\n\njulia> R, (x,y,z) = graded_polynomial_ring(QQ, [:x, :y, :z]);\n\njulia> C = ProjectivePlaneCurve(y^4-2*x^3*z+3*x^2*z^2-2*y^2*z^2)\nProjective plane curve\n  defined by 0 = 2*x^3*z - 3*x^2*z^2 - y^4 + 2*y^2*z^2\n\njulia> I = adjoint_ideal(C)\nIdeal generated by\n  -x*z + y^2\n  x*y - y*z\n  x^2 - x*z\n\njulia> R, (x,y,z) = graded_polynomial_ring(QQ, [:x, :y, :z]);\n\njulia> D = ProjectivePlaneCurve(x^2 + 2*y^2 + 5*z^2 - 4*x*y + 3*x*z + 17*y*z);\n\njulia> P = rational_point_conic(D)\n3-element Vector{AbstractAlgebra.Generic.MPoly{AbsSimpleNumFieldElem}}:\n -1//4*a\n -1//4*a + 1//4\n 0\n\njulia> S = parent(P[1])\nMultivariate polynomial ring in 3 variables x, y, z\n  over number field of degree 2 over QQ\n\njulia> NF = base_ring(S)\nNumber field with defining polynomial t^2 - 2\n  over rational field\n\njulia> a = gen(NF)\na\n\njulia> minpoly(a)\nt^2 - 2\n\n\n\n\n\n\n","category":"method"},{"location":"AlgebraicGeometry/Curves/ParametrizationPlaneCurves/#Parametrizing-Rational-Plane-Curves","page":"Rational Parametrizations of Rational Plane Curves","title":"Parametrizing Rational Plane Curves","text":"","category":"section"},{"location":"AlgebraicGeometry/Curves/ParametrizationPlaneCurves/","page":"Rational Parametrizations of Rational Plane Curves","title":"Rational Parametrizations of Rational Plane Curves","text":"parametrization(C::ProjectivePlaneCurve{QQField})","category":"page"},{"location":"AlgebraicGeometry/Curves/ParametrizationPlaneCurves/#parametrization-Tuple{ProjectivePlaneCurve{QQField}}","page":"Rational Parametrizations of Rational Plane Curves","title":"parametrization","text":"parametrization(C::ProjectivePlaneCurve{QQField})\n\nReturn a rational parametrization of  C. \n\nExamples\n\njulia> R, (x,y,z) = graded_polynomial_ring(QQ, [:x, :y, :z]);\n\njulia> C = ProjectivePlaneCurve(y^4-2*x^3*z+3*x^2*z^2-2*y^2*z^2)\nProjective plane curve\n  defined by 0 = 2*x^3*z - 3*x^2*z^2 - y^4 + 2*y^2*z^2\n\njulia> parametrization(C)\n3-element Vector{QQMPolyRingElem}:\n 12*s^4 - 8*s^2*t^2 + t^4\n -12*s^3*t + 2*s*t^3\n 8*s^4\n\n\n\n\n\n\n","category":"method"},{"location":"AlgebraicGeometry/Curves/ParametrizationPlaneCurves/#Contact","page":"Rational Parametrizations of Rational Plane Curves","title":"Contact","text":"","category":"section"},{"location":"AlgebraicGeometry/Curves/ParametrizationPlaneCurves/","page":"Rational Parametrizations of Rational Plane Curves","title":"Rational Parametrizations of Rational Plane Curves","text":"Please direct questions about this part of OSCAR to the following people:","category":"page"},{"location":"AlgebraicGeometry/Curves/ParametrizationPlaneCurves/","page":"Rational Parametrizations of Rational Plane Curves","title":"Rational Parametrizations of Rational Plane Curves","text":"Janko Böhm,\nWolfram Decker.","category":"page"},{"location":"AlgebraicGeometry/Curves/ParametrizationPlaneCurves/","page":"Rational Parametrizations of Rational Plane Curves","title":"Rational Parametrizations of Rational Plane Curves","text":"You can ask questions in the OSCAR Slack.","category":"page"},{"location":"AlgebraicGeometry/Curves/ParametrizationPlaneCurves/","page":"Rational Parametrizations of Rational Plane Curves","title":"Rational Parametrizations of Rational Plane Curves","text":"Alternatively, you can raise an issue on github.","category":"page"},{"location":"AbstractAlgebra/fraction/","page":"Generic fraction fields","title":"Generic fraction fields","text":"CurrentModule = AbstractAlgebra\nDocTestSetup = AbstractAlgebra.doctestsetup()","category":"page"},{"location":"AbstractAlgebra/fraction/#Generic-fraction-fields","page":"Generic fraction fields","title":"Generic fraction fields","text":"","category":"section"},{"location":"AbstractAlgebra/fraction/","page":"Generic fraction fields","title":"Generic fraction fields","text":"AbstractAlgebra.jl provides a module, implemented in src/Fraction.jl for fraction fields over any gcd domain belonging to the AbstractAlgebra.jl abstract type hierarchy.","category":"page"},{"location":"AbstractAlgebra/fraction/#Generic-fraction-types","page":"Generic fraction fields","title":"Generic fraction types","text":"","category":"section"},{"location":"AbstractAlgebra/fraction/","page":"Generic fraction fields","title":"Generic fraction fields","text":"AbstractAlgebra.jl implements a generic fraction type Generic.FracFieldElem{T} where T is the type of elements of the base ring. See the file src/generic/GenericTypes.jl for details.","category":"page"},{"location":"AbstractAlgebra/fraction/","page":"Generic fraction fields","title":"Generic fraction fields","text":"Parent objects of such fraction elements have type Generic.FracField{T}.","category":"page"},{"location":"AbstractAlgebra/fraction/#Factored-fraction-types","page":"Generic fraction fields","title":"Factored fraction types","text":"","category":"section"},{"location":"AbstractAlgebra/fraction/","page":"Generic fraction fields","title":"Generic fraction fields","text":"AbstractAlgebra.jl also implements a fraction type Generic.FactoredFracFieldElem{T} with parent objects of such fractions having type Generic.FactoredFracField{T}. As opposed to the fractions of type Generic.FracFieldElem{T}, which are just a numerator and denominator, these fractions are maintained in factored form as much as possible.","category":"page"},{"location":"AbstractAlgebra/fraction/#Abstract-types","page":"Generic fraction fields","title":"Abstract types","text":"","category":"section"},{"location":"AbstractAlgebra/fraction/","page":"Generic fraction fields","title":"Generic fraction fields","text":"All fraction element types belong to the abstract type FracElem{T} and the fraction field types belong to the abstract type FracField{T}. This enables one to write generic functions that can accept any AbstractAlgebra fraction type.","category":"page"},{"location":"AbstractAlgebra/fraction/","page":"Generic fraction fields","title":"Generic fraction fields","text":"note: Note\nBoth the generic fraction field type Generic.FracField{T} and the abstract type it belongs to, FracField{T} are both called FracField. The former is a (parameterised) concrete type for a fraction field over a given base ring whose elements have type T. The latter is an abstract type representing all fraction field types in AbstractAlgebra.jl, whether generic or very specialised (e.g. supplied by a C library).","category":"page"},{"location":"AbstractAlgebra/fraction/#Fraction-field-constructors","page":"Generic fraction fields","title":"Fraction field constructors","text":"","category":"section"},{"location":"AbstractAlgebra/fraction/","page":"Generic fraction fields","title":"Generic fraction fields","text":"In order to construct fractions in AbstractAlgebra.jl, one can first construct the fraction field itself. This is accomplished with the following constructor.","category":"page"},{"location":"AbstractAlgebra/fraction/","page":"Generic fraction fields","title":"Generic fraction fields","text":"fraction_field(R::Ring; cached::Bool = true)","category":"page"},{"location":"AbstractAlgebra/fraction/","page":"Generic fraction fields","title":"Generic fraction fields","text":"Given a base ring R return the parent object of the fraction field of R. By default the parent object S will depend only on R and will be cached. Setting the optional argument cached to false will prevent the parent object S from being cached.","category":"page"},{"location":"AbstractAlgebra/fraction/","page":"Generic fraction fields","title":"Generic fraction fields","text":"Here are some examples of creating fraction fields and making use of the resulting parent objects to coerce various elements into the fraction field.","category":"page"},{"location":"AbstractAlgebra/fraction/","page":"Generic fraction fields","title":"Generic fraction fields","text":"Examples","category":"page"},{"location":"AbstractAlgebra/fraction/","page":"Generic fraction fields","title":"Generic fraction fields","text":"julia> R, x = polynomial_ring(ZZ, :x)\n(Univariate polynomial ring in x over integers, x)\n\njulia> S = fraction_field(R)\nFraction field\n  of univariate polynomial ring in x over integers\n\njulia> f = S()\n0\n\njulia> g = S(123)\n123\n\njulia> h = S(BigInt(1234))\n1234\n\njulia> k = S(x + 1)\nx + 1","category":"page"},{"location":"AbstractAlgebra/fraction/#Factored-Fraction-field-constructors","page":"Generic fraction fields","title":"Factored Fraction field constructors","text":"","category":"section"},{"location":"AbstractAlgebra/fraction/","page":"Generic fraction fields","title":"Generic fraction fields","text":"The corresponding factored field uses the following constructor.","category":"page"},{"location":"AbstractAlgebra/fraction/","page":"Generic fraction fields","title":"Generic fraction fields","text":"FactoredFractionField(R::Ring; cached::Bool = true)","category":"page"},{"location":"AbstractAlgebra/fraction/","page":"Generic fraction fields","title":"Generic fraction fields","text":"Examples","category":"page"},{"location":"AbstractAlgebra/fraction/","page":"Generic fraction fields","title":"Generic fraction fields","text":"julia> R, (x, y) = polynomial_ring(ZZ, [:x, :y])\n(Multivariate polynomial ring in 2 variables over integers, AbstractAlgebra.Generic.MPoly{BigInt}[x, y])\n\njulia> S = FactoredFractionField(R)\nFactored fraction field of Multivariate polynomial ring in 2 variables over integers\n\njulia> (X, Y) = (S(x), S(y))\n(x, y)\n\njulia> f = X^6*(X+Y)^2*(X^2+Y)^3*(X+2*Y)^-3*(X+3*Y)^-4\nx^6*(x + y)^2*(x^2 + y)^3/((x + 2*y)^3*(x + 3*y)^4)\n\njulia> numerator(f)\nx^14 + 2*x^13*y + x^12*y^2 + 3*x^12*y + 6*x^11*y^2 + 3*x^10*y^3 + 3*x^10*y^2 + 6*x^9*y^3 + 3*x^8*y^4 + x^8*y^3 + 2*x^7*y^4 + x^6*y^5\n\njulia> denominator(f)\nx^7 + 18*x^6*y + 138*x^5*y^2 + 584*x^4*y^3 + 1473*x^3*y^4 + 2214*x^2*y^5 + 1836*x*y^6 + 648*y^7\n\njulia> derivative(f, x)\nx^5*(x + y)*(x^2 + y)^2*(7*x^5 + 58*x^4*y + 127*x^3*y^2 + x^3*y + 72*x^2*y^3 + 22*x^2*y^2 + 61*x*y^3 + 36*y^4)/((x + 2*y)^4*(x + 3*y)^5)","category":"page"},{"location":"AbstractAlgebra/fraction/#Fraction-constructors","page":"Generic fraction fields","title":"Fraction constructors","text":"","category":"section"},{"location":"AbstractAlgebra/fraction/","page":"Generic fraction fields","title":"Generic fraction fields","text":"One can construct fractions using the fraction field parent object, as for any ring or field.","category":"page"},{"location":"AbstractAlgebra/fraction/","page":"Generic fraction fields","title":"Generic fraction fields","text":"(R::FracField)() # constructs zero\n(R::FracField)(c::Integer)\n(R::FracField)(c::elem_type(R))\n(R::FracField{T})(a::T) where T <: RingElement","category":"page"},{"location":"AbstractAlgebra/fraction/","page":"Generic fraction fields","title":"Generic fraction fields","text":"One may also use the Julia double slash operator to construct elements of the fraction field without constructing the fraction field parent first.","category":"page"},{"location":"AbstractAlgebra/fraction/","page":"Generic fraction fields","title":"Generic fraction fields","text":"//(x::T, y::T) where T <: RingElement","category":"page"},{"location":"AbstractAlgebra/fraction/","page":"Generic fraction fields","title":"Generic fraction fields","text":"Examples","category":"page"},{"location":"AbstractAlgebra/fraction/","page":"Generic fraction fields","title":"Generic fraction fields","text":"julia> R, x = polynomial_ring(QQ, :x)\n(Univariate polynomial ring in x over rationals, x)\n\njulia> S = fraction_field(R)\nFraction field\n  of univariate polynomial ring in x over rationals\n\njulia> f = S(x + 1)\nx + 1\n\njulia> g = (x^2 + x + 1)//(x^3 + 3x + 1)\n(x^2 + x + 1)//(x^3 + 3*x + 1)\n\njulia> x//f\nx//(x + 1)\n\njulia> f//x\n(x + 1)//x","category":"page"},{"location":"AbstractAlgebra/fraction/#Functions-for-types-and-parents-of-fraction-fields","page":"Generic fraction fields","title":"Functions for types and parents of fraction fields","text":"","category":"section"},{"location":"AbstractAlgebra/fraction/","page":"Generic fraction fields","title":"Generic fraction fields","text":"Fraction fields in AbstractAlgebra.jl implement the Ring interface.","category":"page"},{"location":"AbstractAlgebra/fraction/","page":"Generic fraction fields","title":"Generic fraction fields","text":"base_ring(R::FracField)\nbase_ring(a::FracElem)","category":"page"},{"location":"AbstractAlgebra/fraction/","page":"Generic fraction fields","title":"Generic fraction fields","text":"Return the base ring of which the fraction field was constructed.","category":"page"},{"location":"AbstractAlgebra/fraction/","page":"Generic fraction fields","title":"Generic fraction fields","text":"parent(a::FracElem)","category":"page"},{"location":"AbstractAlgebra/fraction/","page":"Generic fraction fields","title":"Generic fraction fields","text":"Return the fraction field of the given fraction.","category":"page"},{"location":"AbstractAlgebra/fraction/","page":"Generic fraction fields","title":"Generic fraction fields","text":"characteristic(R::FracField)","category":"page"},{"location":"AbstractAlgebra/fraction/","page":"Generic fraction fields","title":"Generic fraction fields","text":"Return the characteristic of the base ring of the fraction field. If the characteristic is not known an exception is raised.","category":"page"},{"location":"AbstractAlgebra/fraction/","page":"Generic fraction fields","title":"Generic fraction fields","text":"Examples","category":"page"},{"location":"AbstractAlgebra/fraction/","page":"Generic fraction fields","title":"Generic fraction fields","text":"julia> R, x = polynomial_ring(QQ, :x)\n(Univariate polynomial ring in x over rationals, x)\n\njulia> S = fraction_field(R)\nFraction field\n  of univariate polynomial ring in x over rationals\n\njulia> f = S(x + 1)\nx + 1\n\njulia> U = base_ring(S)\nUnivariate polynomial ring in x over rationals\n\njulia> V = base_ring(f)\nUnivariate polynomial ring in x over rationals\n\njulia> T = parent(f)\nFraction field\n  of univariate polynomial ring in x over rationals\n\njulia> m = characteristic(S)\n0","category":"page"},{"location":"AbstractAlgebra/fraction/#Fraction-field-functions","page":"Generic fraction fields","title":"Fraction field functions","text":"","category":"section"},{"location":"AbstractAlgebra/fraction/#Basic-functions","page":"Generic fraction fields","title":"Basic functions","text":"","category":"section"},{"location":"AbstractAlgebra/fraction/","page":"Generic fraction fields","title":"Generic fraction fields","text":"Fraction fields implement the Ring interface.","category":"page"},{"location":"AbstractAlgebra/fraction/","page":"Generic fraction fields","title":"Generic fraction fields","text":"zero(R::FracField)\none(R::FracField)\niszero(a::FracElem)\nisone(a::FracElem)","category":"page"},{"location":"AbstractAlgebra/fraction/","page":"Generic fraction fields","title":"Generic fraction fields","text":"inv(a::T) where T <: FracElem","category":"page"},{"location":"AbstractAlgebra/fraction/","page":"Generic fraction fields","title":"Generic fraction fields","text":"They also implement the field interface.","category":"page"},{"location":"AbstractAlgebra/fraction/","page":"Generic fraction fields","title":"Generic fraction fields","text":"is_unit(f::FracElem)","category":"page"},{"location":"AbstractAlgebra/fraction/","page":"Generic fraction fields","title":"Generic fraction fields","text":"And they implement the fraction field interface.","category":"page"},{"location":"AbstractAlgebra/fraction/","page":"Generic fraction fields","title":"Generic fraction fields","text":"numerator(a::FracElem)\ndenominator(a::FracElem)","category":"page"},{"location":"AbstractAlgebra/fraction/","page":"Generic fraction fields","title":"Generic fraction fields","text":"Examples","category":"page"},{"location":"AbstractAlgebra/fraction/","page":"Generic fraction fields","title":"Generic fraction fields","text":"julia> R, x = polynomial_ring(QQ, :x)\n(Univariate polynomial ring in x over rationals, x)\n\njulia> S = fraction_field(R)\nFraction field\n  of univariate polynomial ring in x over rationals\n\njulia> f = S(x + 1)\nx + 1\n\njulia> g = (x^2 + x + 1)//(x^3 + 3x + 1)\n(x^2 + x + 1)//(x^3 + 3*x + 1)\n\njulia> h = zero(S)\n0\n\njulia> k = one(S)\n1\n\njulia> isone(k)\ntrue\n\njulia> iszero(f)\nfalse\n\njulia> r = deepcopy(f)\nx + 1\n\njulia> n = numerator(g)\nx^2 + x + 1\n\njulia> d = denominator(g)\nx^3 + 3*x + 1","category":"page"},{"location":"AbstractAlgebra/fraction/#Greatest-common-divisor","page":"Generic fraction fields","title":"Greatest common divisor","text":"","category":"section"},{"location":"AbstractAlgebra/fraction/","page":"Generic fraction fields","title":"Generic fraction fields","text":"gcd{T <: RingElem}(::FracElem{T}, ::FracElem{T})","category":"page"},{"location":"AbstractAlgebra/fraction/#gcd-Union{Tuple{T}, Tuple{FracElem{T}, FracElem{T}}} where T<:RingElem","page":"Generic fraction fields","title":"gcd","text":"gcd(a::FracElem{T}, b::FracElem{T}) where {T <: RingElem}\n\nReturn a greatest common divisor of a and b if one exists. N.B: we define the GCD of ab and cd to be gcd(ad bc)bd, reduced to lowest terms. This requires the existence of a greatest common divisor function for the base ring.\n\n\n\n\n\n","category":"method"},{"location":"AbstractAlgebra/fraction/","page":"Generic fraction fields","title":"Generic fraction fields","text":"Examples","category":"page"},{"location":"AbstractAlgebra/fraction/","page":"Generic fraction fields","title":"Generic fraction fields","text":"julia> R, x = polynomial_ring(QQ, :x)\n(Univariate polynomial ring in x over rationals, x)\n\njulia> f = (x + 1)//(x^3 + 3x + 1)\n(x + 1)//(x^3 + 3*x + 1)\n\njulia> g = (x^2 + 2x + 1)//(x^2 + x + 1)\n(x^2 + 2*x + 1)//(x^2 + x + 1)\n\njulia> h = gcd(f, g)\n(x + 1)//(x^5 + x^4 + 4*x^3 + 4*x^2 + 4*x + 1)\n","category":"page"},{"location":"AbstractAlgebra/fraction/#Square-root","page":"Generic fraction fields","title":"Square root","text":"","category":"section"},{"location":"AbstractAlgebra/fraction/","page":"Generic fraction fields","title":"Generic fraction fields","text":"is_square{T <: RingElem}(::FracElem{T})","category":"page"},{"location":"AbstractAlgebra/fraction/#is_square-Union{Tuple{FracElem{T}}, Tuple{T}} where T<:RingElem","page":"Generic fraction fields","title":"is_square","text":"is_square(a::FracElem{T}) where T <: RingElem\n\nReturn true if a is a square.\n\n\n\n\n\n","category":"method"},{"location":"AbstractAlgebra/fraction/","page":"Generic fraction fields","title":"Generic fraction fields","text":"Base.sqrt(::FracElem{T}) where {T <: RingElem}","category":"page"},{"location":"AbstractAlgebra/fraction/#sqrt-Union{Tuple{FracElem{T}}, Tuple{T}} where T<:RingElem","page":"Generic fraction fields","title":"sqrt","text":"Base.sqrt(a::FracElem{T}; check::Bool=true) where T <: RingElem\n\nReturn the square root of a. By default the function will throw an exception if the input is not square. If check=false this test is omitted.\n\n\n\n\n\n","category":"method"},{"location":"AbstractAlgebra/fraction/","page":"Generic fraction fields","title":"Generic fraction fields","text":"Examples","category":"page"},{"location":"AbstractAlgebra/fraction/","page":"Generic fraction fields","title":"Generic fraction fields","text":"julia> R, x = polynomial_ring(QQ, :x)\n(Univariate polynomial ring in x over rationals, x)\n\njulia> S = fraction_field(R)\nFraction field\n  of univariate polynomial ring in x over rationals\n\njulia> a = (21//4*x^6 - 15*x^5 + 27//14*x^4 + 9//20*x^3 + 3//7*x + 9//10)//(x + 3)\n(21//4*x^6 - 15*x^5 + 27//14*x^4 + 9//20*x^3 + 3//7*x + 9//10)//(x + 3)\n\njulia> sqrt(a^2)\n(21//4*x^6 - 15*x^5 + 27//14*x^4 + 9//20*x^3 + 3//7*x + 9//10)//(x + 3)\n\njulia> is_square(a^2)\ntrue","category":"page"},{"location":"AbstractAlgebra/fraction/#Remove-and-valuation","page":"Generic fraction fields","title":"Remove and valuation","text":"","category":"section"},{"location":"AbstractAlgebra/fraction/","page":"Generic fraction fields","title":"Generic fraction fields","text":"When working over a Euclidean domain, it is convenient to extend valuations to the fraction field. To facilitate this, we define the following functions.","category":"page"},{"location":"AbstractAlgebra/fraction/","page":"Generic fraction fields","title":"Generic fraction fields","text":"remove{T <: RingElem}(::FracElem{T}, ::T)","category":"page"},{"location":"AbstractAlgebra/fraction/#remove-Union{Tuple{T}, Tuple{FracElem{T}, T}} where T<:RingElem","page":"Generic fraction fields","title":"remove","text":"remove(z::FracElem{T}, p::T) where {T <: RingElem}\n\nReturn the tuple n x such that z = p^nx where x has valuation 0 at p.\n\n\n\n\n\n","category":"method"},{"location":"AbstractAlgebra/fraction/","page":"Generic fraction fields","title":"Generic fraction fields","text":"valuation{T <: RingElem}(::FracElem{T}, ::T)","category":"page"},{"location":"AbstractAlgebra/fraction/#valuation-Union{Tuple{T}, Tuple{FracElem{T}, T}} where T<:RingElem","page":"Generic fraction fields","title":"valuation","text":"valuation(z::FracElem{T}, p::T) where {T <: RingElem}\n\nReturn the valuation of z at p.\n\n\n\n\n\n","category":"method"},{"location":"AbstractAlgebra/fraction/","page":"Generic fraction fields","title":"Generic fraction fields","text":"Examples","category":"page"},{"location":"AbstractAlgebra/fraction/","page":"Generic fraction fields","title":"Generic fraction fields","text":"julia> R, x = polynomial_ring(ZZ, :x)\n(Univariate polynomial ring in x over integers, x)\n\njulia> f = (x + 1)//(x^3 + 3x + 1)\n(x + 1)//(x^3 + 3*x + 1)\n\njulia> g = (x^2 + 1)//(x^2 + x + 1)\n(x^2 + 1)//(x^2 + x + 1)\n\njulia> v, q = remove(f^3*g, x + 1)\n(3, (x^2 + 1)//(x^11 + x^10 + 10*x^9 + 12*x^8 + 39*x^7 + 48*x^6 + 75*x^5 + 75*x^4 + 66*x^3 + 37*x^2 + 10*x + 1))\n\njulia> v = valuation(f^3*g, x + 1)\n3\n","category":"page"},{"location":"AbstractAlgebra/fraction/#Random-generation","page":"Generic fraction fields","title":"Random generation","text":"","category":"section"},{"location":"AbstractAlgebra/fraction/","page":"Generic fraction fields","title":"Generic fraction fields","text":"Random fractions can be generated using rand. The parameters passed after the fraction field tell rand how to generate random elements of the base ring.","category":"page"},{"location":"AbstractAlgebra/fraction/","page":"Generic fraction fields","title":"Generic fraction fields","text":"rand(R::FracField, v...)","category":"page"},{"location":"AbstractAlgebra/fraction/","page":"Generic fraction fields","title":"Generic fraction fields","text":"Examples","category":"page"},{"location":"AbstractAlgebra/fraction/","page":"Generic fraction fields","title":"Generic fraction fields","text":"julia> K = fraction_field(ZZ)\nRationals\n\njulia> f = rand(K, -10:10)\n-1//3\n\njulia> R, x = polynomial_ring(ZZ, :x)\n(Univariate polynomial ring in x over integers, x)\n\njulia> S = fraction_field(R)\nFraction field\n  of univariate polynomial ring in x over integers\n\njulia> g = rand(S, -1:3, -10:10)\n(-4*x - 4)//(4*x^2 + x - 4)","category":"page"},{"location":"AbstractAlgebra/fraction/#Extra-functionality-for-factored-fractions","page":"Generic fraction fields","title":"Extra functionality for factored fractions","text":"","category":"section"},{"location":"AbstractAlgebra/fraction/","page":"Generic fraction fields","title":"Generic fraction fields","text":"The Generic.FactoredFracFieldElem{T} type implements an interface similar to that of the Fac{T} type for iterating over the terms in the factorisation. There is also the function push_term!(a, b, e) for efficiently performing a *= b^e, and the function normalise returns relatively prime terms.","category":"page"},{"location":"AbstractAlgebra/fraction/","page":"Generic fraction fields","title":"Generic fraction fields","text":"Examples","category":"page"},{"location":"AbstractAlgebra/fraction/","page":"Generic fraction fields","title":"Generic fraction fields","text":"julia> F = FactoredFractionField(ZZ)\nFactored fraction field of Integers\n\njulia> f = F(-1)\n-1\n\njulia> push_term!(f, 10, 10)\n-10^10\n\njulia> push_term!(f, 42, -8)\n-10^10/42^8\n\njulia> normalise(f)\n-5^10*2^2/21^8\n\njulia> unit(f)\n-1\n\njulia> collect(f)\n2-element Vector{Tuple{BigInt, Int64}}:\n (10, 10)\n (42, -8)","category":"page"},{"location":"Hecke/manual/quad_forms/lattices/#Lattices","page":"Lattices","title":"Lattices","text":"","category":"section"},{"location":"Hecke/manual/quad_forms/lattices/","page":"Lattices","title":"Lattices","text":"CurrentModule = Hecke\nDocTestSetup = quote\n    using Hecke\n  end","category":"page"},{"location":"Hecke/manual/quad_forms/lattices/#Creation-of-lattices","page":"Lattices","title":"Creation of lattices","text":"","category":"section"},{"location":"Hecke/manual/quad_forms/lattices/#Inside-a-given-ambient-space","page":"Lattices","title":"Inside a given ambient space","text":"","category":"section"},{"location":"Hecke/manual/quad_forms/lattices/","page":"Lattices","title":"Lattices","text":"lattice(::AbstractSpace)\nlattice(::AbstractSpace, ::PMat)\nlattice(::AbstractSpace, ::MatElem)\nlattice(::AbstractSpace, ::Vector)","category":"page"},{"location":"Hecke/manual/quad_forms/lattices/#lattice-Tuple{AbstractSpace}","page":"Lattices","title":"lattice","text":"lattice(V::AbstractSpace) -> AbstractLat\n\nGiven an ambient space V, return the lattice with the standard basis matrix. If V is hermitian (resp. quadratic) then the output is a hermitian (resp. quadratic) lattice.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/quad_forms/lattices/#lattice-Tuple{AbstractSpace, Hecke.PMat}","page":"Lattices","title":"lattice","text":"lattice(V::AbstractSpace, B::PMat ; check::Bool = true) -> AbstractLat\n\nGiven an ambient space V and a pseudo-matrix B, return the lattice spanned by the pseudo-matrix B inside V. If V is hermitian (resp. quadratic) then the output is a hermitian (resp. quadratic) lattice.\n\nBy default, B is checked to be of full rank. This test can be disabled by setting check to false.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/quad_forms/lattices/#lattice-Tuple{AbstractSpace, MatElem}","page":"Lattices","title":"lattice","text":"lattice(V::AbstractSpace, basis::MatElem ; check::Bool = true) -> AbstractLat\n\nGiven an ambient space V and a matrix basis, return the lattice spanned by the rows of basis inside V. If V is hermitian (resp. quadratic) then the output is a hermitian (resp. quadratic) lattice.\n\nBy default, basis is checked to be of full rank. This test can be disabled by setting check to false.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/quad_forms/lattices/#lattice-Tuple{AbstractSpace, Vector}","page":"Lattices","title":"lattice","text":"lattice(V::AbstractSpace, gens::Vector) -> AbstractLat\n\nGiven an ambient space V and a list of generators gens, return the lattice spanned by gens in V. If V is hermitian (resp. quadratic) then the output is a hermitian (resp. quadratic) lattice.\n\nIf gens is empty, the function returns the zero lattice in V.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/quad_forms/lattices/#Quadratic-lattice-over-a-number-field","page":"Lattices","title":"Quadratic lattice over a number field","text":"","category":"section"},{"location":"Hecke/manual/quad_forms/lattices/","page":"Lattices","title":"Lattices","text":"quadratic_lattice(::Field)\nquadratic_lattice(::Field, ::PMat)\nquadratic_lattice(::Field, ::MatElem)\nquadratic_lattice(::Field, ::Vector)","category":"page"},{"location":"Hecke/manual/quad_forms/lattices/#quadratic_lattice-Tuple{Field}","page":"Lattices","title":"quadratic_lattice","text":"quadratic_lattice(K::Field ; gram::MatElem) -> Union{ZZLat, QuadLat}\n\nGiven a matrix gram and a field K, return the free quadratic lattice inside the quadratic space over K with Gram matrix gram.\n\nIf K = mathbbQ, then the output lattice is of type ZZLat, seen as a lattice over the ring mathbbZ.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/quad_forms/lattices/#quadratic_lattice-Tuple{Field, Hecke.PMat}","page":"Lattices","title":"quadratic_lattice","text":"quadratic_lattice(K::Field, B::PMat ; gram = nothing,\n                                      check:::Bool = true) -> QuadLat\n\nGiven a pseudo-matrix B with entries in a field K return the quadratic lattice spanned by the pseudo-matrix B inside the quadratic space over K with Gram matrix gram.\n\nIf gram is not supplied, the Gram matrix of the ambient space will be the identity matrix over K of size the number of columns of B.\n\nBy default, B is checked to be of full rank. This test can be disabled by setting check to false.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/quad_forms/lattices/#quadratic_lattice-Tuple{Field, MatElem}","page":"Lattices","title":"quadratic_lattice","text":"quadratic_lattice(K::Field, basis::MatElem ; gram = nothing,\n                                             check::Bool = true)\n                                                      -> Union{ZZLat, QuadLat}\n\nGiven a matrix basis and a field K, return the quadratic lattice spanned by the rows of basis inside the quadratic space over K with Gram matrix gram.\n\nIf gram is not supplied, the Gram matrix of the ambient space will be the identity matrix over K of size the number of columns of basis.\n\nBy default, basis is checked to be of full rank. This test can be disabled by setting check to false.\n\nIf K = mathbbQ, then the output lattice is of type ZZLat, seen as a lattice over the ring mathbbZ.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/quad_forms/lattices/#quadratic_lattice-Tuple{Field, Vector}","page":"Lattices","title":"quadratic_lattice","text":"quadratic_lattice(K::Field, gens::Vector ; gram = nothing) -> Union{ZZLat, QuadLat}\n\nGiven a list of vectors gens and a field K, return the quadratic lattice spanned by the elements of gens inside the quadratic space over K with Gram matrix gram.\n\nIf gram is not supplied, the Gram matrix of the ambient space will be the identity matrix over K of size the length of the elements of gens.\n\nIf gens is empty, gram must be supplied and the function returns the zero lattice in the quadratic space over K with gram matrix gram.\n\nIf K = mathbbQ, then the output lattice is of type ZZLat, seen as a lattice over the ring mathbbZ.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/quad_forms/lattices/#Hermitian-lattice-over-a-degree-2-extension","page":"Lattices","title":"Hermitian lattice over a degree 2 extension","text":"","category":"section"},{"location":"Hecke/manual/quad_forms/lattices/","page":"Lattices","title":"Lattices","text":"hermitian_lattice(::NumField)\nhermitian_lattice(::NumField, ::PMat)\nhermitian_lattice(::NumField, ::MatElem)\nhermitian_lattice(::NumField, ::Vector)","category":"page"},{"location":"Hecke/manual/quad_forms/lattices/#hermitian_lattice-Tuple{NumField}","page":"Lattices","title":"hermitian_lattice","text":"hermitian_lattice(E::NumField; gram::MatElem) -> HermLat\n\nGiven a matrix gram and a number field E of degree 2, return the free hermitian lattice inside the hermitian space over E with Gram matrix gram.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/quad_forms/lattices/#hermitian_lattice-Tuple{NumField, Hecke.PMat}","page":"Lattices","title":"hermitian_lattice","text":"hermitian_lattice(E::NumField, B::PMat; gram = nothing,\n\t\t\t             check::Bool = true) -> HermLat\n\nGiven a pseudo-matrix B with entries in a number field E of degree 2, return the hermitian lattice spanned by the pseudo-matrix B inside the hermitian space over E with Gram matrix gram.\n\nIf gram is not supplied, the Gram matrix of the ambient space will be the identity matrix over E of size the number of columns of B.\n\nBy default, B is checked to be of full rank. This test can be disabled by setting check to false.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/quad_forms/lattices/#hermitian_lattice-Tuple{NumField, MatElem}","page":"Lattices","title":"hermitian_lattice","text":"hermitian_lattice(E::NumField, basis::MatElem; gram = nothing,\n\t\t\t                    check::Bool = true) -> HermLat\n\nGiven a matrix basis and a number field E of degree 2, return the hermitian lattice spanned by the rows of basis inside the hermitian space over E with Gram matrix gram.\n\nIf gram is not supplied, the Gram matrix of the ambient space will be the identity matrix over E of size the number of columns of basis.\n\nBy default, basis is checked to be of full rank. This test can be disabled by setting check to false.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/quad_forms/lattices/#hermitian_lattice-Tuple{NumField, Vector}","page":"Lattices","title":"hermitian_lattice","text":"hermitian_lattice(E::NumField, gens::Vector ; gram = nothing) -> HermLat\n\nGiven a list of vectors gens and a number field E of degree 2, return the hermitian lattice spanned by the elements of gens inside the hermitian space over E with Gram matrix gram.\n\nIf gram is not supplied, the Gram matrix of the ambient space will be the identity matrix over E of size the length of the elements of gens.\n\nIf gens is empty, gram must be supplied and the function returns the zero lattice in the hermitan space over E with Gram matrix gram.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/quad_forms/lattices/#Examples","page":"Lattices","title":"Examples","text":"","category":"section"},{"location":"Hecke/manual/quad_forms/lattices/","page":"Lattices","title":"Lattices","text":"The two following examples will be used all along this section:","category":"page"},{"location":"Hecke/manual/quad_forms/lattices/","page":"Lattices","title":"Lattices","text":"using Hecke # hide\nK, a = rationals_as_number_field();\nKt, t = K[\"t\"];\ng = t^2 + 7;\nE, b = number_field(g, \"b\");\nD = matrix(K, 3, 3, [2, 0, 0, 0, 2, 0, 0, 0, 2]);\ngens = Vector{AbsSimpleNumFieldElem}[map(K, [1, 1, 0]), map(K, [1, 0, 1]), map(K, [2, 0, 0])];\nLquad = quadratic_lattice(K, gens, gram = D)\nD = matrix(E, 4, 4, [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]);\ngens = Vector{Hecke.RelSimpleNumFieldElem{AbsSimpleNumFieldElem}}[map(E, [2, -1, 0, 0]), map(E, [-3, 0, -1, 0]), map(E, [0, 0, 0, -1]), map(E, [b, 0, 0, 0])];\nLherm = hermitian_lattice(E, gens, gram = D)","category":"page"},{"location":"Hecke/manual/quad_forms/lattices/","page":"Lattices","title":"Lattices","text":"Note that the format used here is the one given by the internal function Hecke.to_hecke() which prints REPL commands to get back the input lattice.","category":"page"},{"location":"Hecke/manual/quad_forms/lattices/","page":"Lattices","title":"Lattices","text":"using Hecke # hide\nK, a = rationals_as_number_field();\nKt, t = K[\"t\"];\ng = t^2 + 7;\nE, b = number_field(g, \"b\");\nD = matrix(E, 4, 4, [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]);\ngens = Vector{Hecke.RelSimpleNumFieldElem{AbsSimpleNumFieldElem}}[map(E, [2, -1, 0, 0]), map(E, [-3, 0, -1, 0]), map(E, [0, 0, 0, -1]), map(E, [b, 0, 0, 0])];\nLherm = hermitian_lattice(E, gens, gram = D);\nHecke.to_hecke(Lherm)","category":"page"},{"location":"Hecke/manual/quad_forms/lattices/","page":"Lattices","title":"Lattices","text":"Finally, one can access some databases in which are stored several quadratic and hermitian lattices. Up to now, these are not automatically available while running Hecke. It can nonethelss be used in the following way:","category":"page"},{"location":"Hecke/manual/quad_forms/lattices/","page":"Lattices","title":"Lattices","text":"using Hecke # hide\nqld = Hecke.quadratic_lattice_database()\nlattice(qld, 1)\nhlb = Hecke.hermitian_lattice_database()\nlattice(hlb, 426)","category":"page"},{"location":"Hecke/manual/quad_forms/lattices/","page":"Lattices","title":"Lattices","text":"","category":"page"},{"location":"Hecke/manual/quad_forms/lattices/#Ambient-space-and-rational-span","page":"Lattices","title":"Ambient space and rational span","text":"","category":"section"},{"location":"Hecke/manual/quad_forms/lattices/","page":"Lattices","title":"Lattices","text":"ambient_space(::AbstractLat)\nrational_span(::AbstractLat)\nbasis_matrix_of_rational_span(::AbstractLat)\ngram_matrix_of_rational_span(::AbstractLat)\ndiagonal_of_rational_span(::AbstractLat)","category":"page"},{"location":"Hecke/manual/quad_forms/lattices/#ambient_space-Tuple{AbstractLat}","page":"Lattices","title":"ambient_space","text":"ambient_space(L::AbstractLat) -> AbstractSpace\n\nReturn the ambient space of the lattice L. If the ambient space is not known, an error is raised.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/quad_forms/lattices/#rational_span-Tuple{AbstractLat}","page":"Lattices","title":"rational_span","text":"rational_span(L::AbstractLat) -> AbstractSpace\n\nReturn the rational span of the lattice L.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/quad_forms/lattices/#basis_matrix_of_rational_span-Tuple{AbstractLat}","page":"Lattices","title":"basis_matrix_of_rational_span","text":"basis_matrix_of_rational_span(L::AbstractLat) -> MatElem\n\nReturn a basis matrix of the rational span of the lattice L.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/quad_forms/lattices/#gram_matrix_of_rational_span-Tuple{AbstractLat}","page":"Lattices","title":"gram_matrix_of_rational_span","text":"gram_matrix_of_rational_span(L::AbstractLat) -> MatElem\n\nReturn the Gram matrix of the rational span of the lattice L.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/quad_forms/lattices/#diagonal_of_rational_span-Tuple{AbstractLat}","page":"Lattices","title":"diagonal_of_rational_span","text":"diagonal_of_rational_span(L::AbstractLat) -> Vector\n\nReturn the diagonal of the rational span of the lattice L.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/quad_forms/lattices/#Examples-2","page":"Lattices","title":"Examples","text":"","category":"section"},{"location":"Hecke/manual/quad_forms/lattices/","page":"Lattices","title":"Lattices","text":"using Hecke # hide\nK, a = rationals_as_number_field();\nKt, t = K[\"t\"];\ng = t^2 + 7;\nE, b = number_field(g, \"b\");\nD = matrix(K, 3, 3, [2, 0, 0, 0, 2, 0, 0, 0, 2]);\ngens = Vector{AbsSimpleNumFieldElem}[map(K, [1, 1, 0]), map(K, [1, 0, 1]), map(K, [2, 0, 0])];\nLquad = quadratic_lattice(K, gens, gram = D);\nD = matrix(E, 4, 4, [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]);\ngens = Vector{Hecke.RelSimpleNumFieldElem{AbsSimpleNumFieldElem}}[map(E, [2, -1, 0, 0]), map(E, [-3, 0, -1, 0]), map(E, [0, 0, 0, -1]), map(E, [b, 0, 0, 0])];\nLherm = hermitian_lattice(E, gens, gram = D);\nambient_space(Lherm)\nrational_span(Lquad)\nbasis_matrix_of_rational_span(Lherm)\ngram_matrix_of_rational_span(Lherm)\ndiagonal_of_rational_span(Lquad)","category":"page"},{"location":"Hecke/manual/quad_forms/lattices/","page":"Lattices","title":"Lattices","text":"","category":"page"},{"location":"Hecke/manual/quad_forms/lattices/#Rational-equivalence","page":"Lattices","title":"Rational equivalence","text":"","category":"section"},{"location":"Hecke/manual/quad_forms/lattices/","page":"Lattices","title":"Lattices","text":"hasse_invariant(L::QuadLat, p)\nwitt_invariant(L::QuadLat, p)\nis_rationally_isometric(::AbstractLat, ::AbstractLat, ::AbsNumFieldOrderIdeal)\nis_rationally_isometric(L::AbstractLat, M::AbstractLat)","category":"page"},{"location":"Hecke/manual/quad_forms/lattices/#hasse_invariant-Tuple{QuadLat, Any}","page":"Lattices","title":"hasse_invariant","text":"hasse_invariant(L::AbstractLat, p::Union{InfPlc, AbsNumFieldOrderIdeal{AbsSimpleNumField, AbsSimpleNumFieldElem}}) -> Int\n\nReturn the Hasse invariant of the rational span of the lattice L at the place p. The lattice must be quadratic.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/quad_forms/lattices/#witt_invariant-Tuple{QuadLat, Any}","page":"Lattices","title":"witt_invariant","text":"witt_invariant(L::AbstractLat, p::Union{InfPlc, AbsNumFieldOrderIdeal{AbsSimpleNumField, AbsSimpleNumFieldElem}}) -> Int\n\nReturn the Witt invariant of the rational span of the lattice L at the place p. The lattice must be quadratic.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/quad_forms/lattices/#is_rationally_isometric-Tuple{AbstractLat, AbstractLat, AbsNumFieldOrderIdeal}","page":"Lattices","title":"is_rationally_isometric","text":"is_rationally_isometric(L::AbstractLat, M::AbstractLat, p::Union{InfPlc, AbsNumFieldOrderIdeal})\n                                                                     -> Bool\n\nReturn whether the rational spans of the lattices L and M are isometric over the completion at the place p.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/quad_forms/lattices/#is_rationally_isometric-Tuple{AbstractLat, AbstractLat}","page":"Lattices","title":"is_rationally_isometric","text":"is_rationally_isometric(L::AbstractLat, M::AbstractLat) -> Bool\n\nReturn whether the rational spans of the lattices L and M are isometric.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/quad_forms/lattices/#Examples-3","page":"Lattices","title":"Examples","text":"","category":"section"},{"location":"Hecke/manual/quad_forms/lattices/","page":"Lattices","title":"Lattices","text":"For now and for the rest of this section, the examples will include the new lattice Lquad2 which is quadratic. Moreover, all the completions are going to be done at the prime ideal p = 7*mathcal O_K.","category":"page"},{"location":"Hecke/manual/quad_forms/lattices/","page":"Lattices","title":"Lattices","text":"using Hecke # hide\nK, a = rationals_as_number_field();\nD = matrix(K, 3, 3, [2, 0, 0, 0, 2, 0, 0, 0, 2]);\ngens = Vector{AbsSimpleNumFieldElem}[map(K, [1, 1, 0]), map(K, [1, 0, 1]), map(K, [2, 0, 0])];\nLquad = quadratic_lattice(K, gens, gram = D);\nD = matrix(K, 3, 3, [2, 0, 0, 0, 2, 0, 0, 0, 2]);\ngens = Vector{AbsSimpleNumFieldElem}[map(K, [-35, 25, 0]), map(K, [30, 40, -20]), map(K, [5, 10, -5])];\nLquad2 = quadratic_lattice(K, gens, gram = D)\nOK = maximal_order(K);\np = prime_decomposition(OK, 7)[1][1]\nhasse_invariant(Lquad, p), witt_invariant(Lquad, p)\nis_rationally_isometric(Lquad, Lquad2, p)\nis_rationally_isometric(Lquad, Lquad2)","category":"page"},{"location":"Hecke/manual/quad_forms/lattices/","page":"Lattices","title":"Lattices","text":"","category":"page"},{"location":"Hecke/manual/quad_forms/lattices/#Attributes","page":"Lattices","title":"Attributes","text":"","category":"section"},{"location":"Hecke/manual/quad_forms/lattices/","page":"Lattices","title":"Lattices","text":"Let L be a lattice over EK. We call a pseudo-basis of L any sequence of pairs (mathfrak A_i x_i)_1 leq i leq n where the mathfrak A_i's are fractional (left) ideals of mathcal O_E and (x_i)_1 leq i leq n is a basis of the rational span of L, and such that","category":"page"},{"location":"Hecke/manual/quad_forms/lattices/","page":"Lattices","title":"Lattices","text":"   L = bigoplus_i = 1^n mathfrak A_ix_i","category":"page"},{"location":"Hecke/manual/quad_forms/lattices/","page":"Lattices","title":"Lattices","text":"Note that a pseudo-basis is not unique. Given a pseudo-basis (mathfrak A_i x_i)_1 leq i leq n of L, we define the corresponding pseudo-matrix of L to be the datum consisting of a list of  coefficient ideals corresponding to the ideals mathfrak A_i's and a matrix whose rows are the coordinates of the x_i's in the canonical basis of the ambient space of L (conversely, given any such pseudo-matrix, one can define the corresponding pseudo-basis).","category":"page"},{"location":"Hecke/manual/quad_forms/lattices/","page":"Lattices","title":"Lattices","text":"rank(L::AbstractLat)\ndegree(L::AbstractLat)\ndiscriminant(::AbstractLat)\nbase_field(::AbstractLat)\nbase_ring(::AbstractLat)\nfixed_field(::AbstractLat)\nfixed_ring(::AbstractLat)\ninvolution(::AbstractLat)\npseudo_matrix(::AbstractLat)\npseudo_basis(::AbstractLat)\ncoefficient_ideals(::AbstractLat)\nabsolute_basis_matrix(::AbstractLat)\nabsolute_basis(::AbstractLat)\ngenerators(L::AbstractLat; minimal::Bool = false)\ngram_matrix_of_generators(::AbstractLat; minimal::Bool = false)","category":"page"},{"location":"Hecke/manual/quad_forms/lattices/#rank-Tuple{AbstractLat}","page":"Lattices","title":"rank","text":"rank(L::AbstractLat) -> Int\n\nReturn the rank of the underlying module of the lattice L.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/quad_forms/lattices/#degree-Tuple{AbstractLat}","page":"Lattices","title":"degree","text":"degree(L::AbstractLat) -> Int\n\nReturn the dimension of the ambient space of the lattice L.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/quad_forms/lattices/#discriminant-Tuple{AbstractLat}","page":"Lattices","title":"discriminant","text":"discriminant(L::AbstractLat) -> AbsSimpleNumFieldOrderFractionalIdeal\n\nReturn the discriminant of the lattice L, that is, the generalized index ideal L^  L.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/quad_forms/lattices/#base_field-Tuple{AbstractLat}","page":"Lattices","title":"base_field","text":"base_field(L::AbstractLat) -> Field\n\nReturn the algebra over which the rational span of the lattice L is defined.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/quad_forms/lattices/#base_ring-Tuple{AbstractLat}","page":"Lattices","title":"base_ring","text":"base_ring(L::AbstractLat) -> Ring\n\nReturn the order over which the lattice L is defined.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/quad_forms/lattices/#fixed_field-Tuple{AbstractLat}","page":"Lattices","title":"fixed_field","text":"fixed_field(L::AbstractLat) -> Field\n\nReturns the fixed field of the involution of the lattice L.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/quad_forms/lattices/#fixed_ring-Tuple{AbstractLat}","page":"Lattices","title":"fixed_ring","text":"fixed_ring(L::AbstractLat) -> Ring\n\nReturn the maximal order in the fixed field of the lattice L.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/quad_forms/lattices/#involution-Tuple{AbstractLat}","page":"Lattices","title":"involution","text":"involution(L::AbstractLat) -> Map\n\nReturn the involution of the rational span of the lattice L.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/quad_forms/lattices/#pseudo_matrix-Tuple{AbstractLat}","page":"Lattices","title":"pseudo_matrix","text":"pseudo_matrix(L::AbstractLat) -> PMat\n\nReturn a basis pseudo-matrix of the lattice L.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/quad_forms/lattices/#pseudo_basis-Tuple{AbstractLat}","page":"Lattices","title":"pseudo_basis","text":"pseudo_basis(L::AbstractLat) -> Vector{Tuple{Vector, Ideal}}\n\nReturn a pseudo-basis of the lattice L.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/quad_forms/lattices/#coefficient_ideals-Tuple{AbstractLat}","page":"Lattices","title":"coefficient_ideals","text":"coefficient_ideals(L::AbstractLat) -> Vector{AbsNumFieldOrderIdeal{AbsSimpleNumField, AbsSimpleNumFieldElem}}\n\nReturn the coefficient ideals of a pseudo-basis of the lattice L.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/quad_forms/lattices/#absolute_basis_matrix-Tuple{AbstractLat}","page":"Lattices","title":"absolute_basis_matrix","text":"absolute_basis_matrix(L::AbstractLat) -> MatElem\n\nReturn a mathbfZ-basis matrix of the lattice L.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/quad_forms/lattices/#absolute_basis-Tuple{AbstractLat}","page":"Lattices","title":"absolute_basis","text":"absolute_basis(L::AbstractLat) -> Vector\n\nReturn a mathbfZ-basis of the lattice L.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/quad_forms/lattices/#generators-Tuple{AbstractLat}","page":"Lattices","title":"generators","text":"generators(L::AbstractLat; minimal = false) -> Vector{Vector}\n\nReturn a set of generators of the lattice L over the base ring of L.\n\nIf minimal == true, the number of generators is minimal. Note that computing minimal generators is expensive.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/quad_forms/lattices/#gram_matrix_of_generators-Tuple{AbstractLat}","page":"Lattices","title":"gram_matrix_of_generators","text":"gram_matrix_of_generators(L::AbstractLat; minimal::Bool = false) -> MatElem\n\nReturn the Gram matrix of a generating set of the lattice L.\n\nIf minimal == true, then a minimal generating set is used. Note that computing minimal generators is expensive.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/quad_forms/lattices/#Examples-4","page":"Lattices","title":"Examples","text":"","category":"section"},{"location":"Hecke/manual/quad_forms/lattices/","page":"Lattices","title":"Lattices","text":"using Hecke # hide\nK, a = rationals_as_number_field();\nKt, t = K[\"t\"];\ng = t^2 + 7;\nE, b = number_field(g, \"b\");\nD = matrix(E, 4, 4, [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]);\ngens = Vector{Hecke.RelSimpleNumFieldElem{AbsSimpleNumFieldElem}}[map(E, [2, -1, 0, 0]), map(E, [-3, 0, -1, 0]), map(E, [0, 0, 0, -1]), map(E, [b, 0, 0, 0])];\nLherm = hermitian_lattice(E, gens, gram = D);\nrank(Lherm), degree(Lherm)\ndiscriminant(Lherm)\nbase_field(Lherm)\nbase_ring(Lherm)\nfixed_field(Lherm)\nfixed_ring(Lherm)\ninvolution(Lherm)\npseudo_matrix(Lherm)\npseudo_basis(Lherm)\ncoefficient_ideals(Lherm)\nabsolute_basis_matrix(Lherm)\nabsolute_basis(Lherm)\ngenerators(Lherm)\ngram_matrix_of_generators(Lherm)","category":"page"},{"location":"Hecke/manual/quad_forms/lattices/","page":"Lattices","title":"Lattices","text":"","category":"page"},{"location":"Hecke/manual/quad_forms/lattices/#Module-operations","page":"Lattices","title":"Module operations","text":"","category":"section"},{"location":"Hecke/manual/quad_forms/lattices/","page":"Lattices","title":"Lattices","text":"Let L be a lattice over EK inside the space (V Phi). The dual lattice of L is defined to be the following lattice over EK in (V Phi):","category":"page"},{"location":"Hecke/manual/quad_forms/lattices/","page":"Lattices","title":"Lattices","text":"   L^ = left x in V mid Phi(xL) subseteq mathcal O_E right","category":"page"},{"location":"Hecke/manual/quad_forms/lattices/","page":"Lattices","title":"Lattices","text":"For any fractional (left) ideal mathfrak a of mathcal O_E, one can define the lattice mathfrak aL to be the lattice over EK, in the same space (V Phi), obtained by rescaling the coefficient ideals of a pseudo-basis of L by mathfrak a. In another flavour, for any non-zero element a in K, one defines the rescaled lattice L^a to be the lattice over EK with the same underlying module as L (i.e. the same pseudo-bases) but in space (V aPhi).","category":"page"},{"location":"Hecke/manual/quad_forms/lattices/","page":"Lattices","title":"Lattices","text":"Base.:(+)(::AbstractLat, ::AbstractLat)\nBase.:(*)(::NumFieldElem, ::AbstractLat)\nBase.:(*)(::NumFieldOrderIdeal, ::AbstractLat)\nBase.:(*)(::NumFieldOrderFractionalIdeal, ::AbstractLat)\nrescale(::AbstractLat, ::NumFieldElem)\ndual(::AbstractLat)\nintersect(::AbstractLat, ::AbstractLat)\nprimitive_closure(::AbstractLat, ::AbstractLat)\northogonal_submodule(::AbstractLat, ::AbstractLat)","category":"page"},{"location":"Hecke/manual/quad_forms/lattices/#+-Tuple{AbstractLat, AbstractLat}","page":"Lattices","title":"+","text":"+(L::AbstractLat, M::AbstractLat) -> AbstractLat\n\nReturn the sum of the lattices L and M.\n\nThe lattices L and M must have the same ambient space.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/quad_forms/lattices/#*-Tuple{NumFieldElem, AbstractLat}","page":"Lattices","title":"*","text":"*(a::NumFieldElem, L::AbstractLat) -> AbstractLat\n\nReturn the lattice aL inside the ambient space of the lattice L.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/quad_forms/lattices/#*-Tuple{NumFieldOrderIdeal, AbstractLat}","page":"Lattices","title":"*","text":"*(a::NumFieldOrderIdeal, L::AbstractLat) -> AbstractLat\n\nReturn the lattice aL inside the ambient space of the lattice L.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/quad_forms/lattices/#*-Tuple{NumFieldOrderFractionalIdeal, AbstractLat}","page":"Lattices","title":"*","text":"*(a::NumFieldOrderFractionalIdeal, L::AbstractLat) -> AbstractLat\n\nReturn the lattice aL inside the ambient space of the lattice L.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/quad_forms/lattices/#rescale-Tuple{AbstractLat, NumFieldElem}","page":"Lattices","title":"rescale","text":"rescale(L::AbstractLat, a::NumFieldElem) -> AbstractLat\n\nReturn the rescaled lattice L^a. Note that this has a different ambient space than the lattice L.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/quad_forms/lattices/#dual-Tuple{AbstractLat}","page":"Lattices","title":"dual","text":"dual(L::AbstractLat) -> AbstractLat\n\nReturn the dual lattice of the lattice L.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/quad_forms/lattices/#intersect-Tuple{AbstractLat, AbstractLat}","page":"Lattices","title":"intersect","text":"intersect(L::AbstractLat, M::AbstractLat) -> AbstractLat\n\nReturn the intersection of the lattices L and M.\n\nThe lattices L and M must have the same ambient space.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/quad_forms/lattices/#primitive_closure-Tuple{AbstractLat, AbstractLat}","page":"Lattices","title":"primitive_closure","text":"primitive_closure(M::AbstractLat, N::AbstractLat) -> AbstractLat\n\nGiven two lattices M and N defined over a number field E, with N subseteq Eotimes M, return the primitive closure M cap Eotimes N of N in M.\n\nOne can also use the alias saturate(L, M).\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/quad_forms/lattices/#orthogonal_submodule-Tuple{AbstractLat, AbstractLat}","page":"Lattices","title":"orthogonal_submodule","text":"orthogonal_submodule(L::AbstractLat, M::AbstractLat) -> AbstractLat\n\nReturn the largest submodule of L orthogonal to M.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/quad_forms/lattices/#Examples-5","page":"Lattices","title":"Examples","text":"","category":"section"},{"location":"Hecke/manual/quad_forms/lattices/","page":"Lattices","title":"Lattices","text":"using Hecke # hide\nK, a = rationals_as_number_field();\nD = matrix(K, 3, 3, [2, 0, 0, 0, 2, 0, 0, 0, 2]);\ngens = Vector{AbsSimpleNumFieldElem}[map(K, [1, 1, 0]), map(K, [1, 0, 1]), map(K, [2, 0, 0])];\nLquad = quadratic_lattice(K, gens, gram = D);\nD = matrix(K, 3, 3, [2, 0, 0, 0, 2, 0, 0, 0, 2]);\ngens = Vector{AbsSimpleNumFieldElem}[map(K, [-35, 25, 0]), map(K, [30, 40, -20]), map(K, [5, 10, -5])];\nLquad2 = quadratic_lattice(K, gens, gram = D);\nOK = maximal_order(K);\np = prime_decomposition(OK, 7)[1][1];\npseudo_matrix(Lquad + Lquad2)\npseudo_matrix(intersect(Lquad, Lquad2))\npseudo_matrix(p*Lquad)\nambient_space(rescale(Lquad,3*a))\npseudo_matrix(Lquad)","category":"page"},{"location":"Hecke/manual/quad_forms/lattices/#Categorical-constructions","page":"Lattices","title":"Categorical constructions","text":"","category":"section"},{"location":"Hecke/manual/quad_forms/lattices/","page":"Lattices","title":"Lattices","text":"Given finite collections of lattices, one can construct their direct sums, which are also direct products in this context. They are also sometimes called biproducts. Depending on the user usage, it is possible to call one of the following functions.","category":"page"},{"location":"Hecke/manual/quad_forms/lattices/","page":"Lattices","title":"Lattices","text":"direct_sum(::Vector{AbstractLat})\ndirect_product(::Vector{AbstractLat})\nbiproduct(::Vector{AbstractLat})","category":"page"},{"location":"Hecke/manual/quad_forms/lattices/#direct_sum-Tuple{Vector{AbstractLat}}","page":"Lattices","title":"direct_sum","text":"direct_sum(x::Vararg{T}) where T <: AbstractLat -> T, Vector{AbstractSpaceMor}\ndirect_sum(x::Vector{T}) where T <: AbstractLat -> T, Vector{AbstractSpaceMor}\n\nGiven a collection of quadratic or hermitian lattices L_1 ldots L_n, return their direct sum L = L_1 oplus ldots oplus L_n, together with the injections L_i to L (seen as maps between the corresponding ambient spaces).\n\nFor objects of type AbstractLat, finite direct sums and finite direct products agree and they are therefore called biproducts. If one wants to obtain L as a direct product with the projections L to L_i, one should call direct_product(x). If one wants to obtain L as a biproduct with the injections L_i to L and the projections L to L_i, one should call biproduct(x).\n\n\n\n\n\ndirect_sum(g1::QuadSpaceCls, g2::QuadSpaceCls) -> QuadSpaceCls\n\nReturn the isometry class of the direct sum of two representatives.\n\n\n\n\n\ndirect_sum(M::ModuleFP{T}...; task::Symbol = :sum) where T\n\nGiven modules M_1dots M_n, say, return the direct sum bigoplus_i=1^n M_i.  \n\nAdditionally, return \n\na vector containing the canonical injections  M_itobigoplus_i=1^n M_i if task = :sum (default),\na vector containing the canonical projections  bigoplus_i=1^n M_ito M_i if task = :prod,\ntwo vectors containing the canonical injections and projections, respectively, if task = :both,\nnone of the above maps if task = :none.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/quad_forms/lattices/#direct_product-Tuple{Vector{AbstractLat}}","page":"Lattices","title":"direct_product","text":"direct_product(algebras::StructureConstantAlgebra...; task::Symbol = :sum)\n  -> StructureConstantAlgebra, Vector{AbsAlgAssMor}, Vector{AbsAlgAssMor}\ndirect_product(algebras::Vector{StructureConstantAlgebra}; task::Symbol = :sum)\n  -> StructureConstantAlgebra, Vector{AbsAlgAssMor}, Vector{AbsAlgAssMor}\n\nReturns the algebra A = A_1 times cdots times A_k. task can be \":sum\", \":prod\", \":both\" or \":none\" and determines which canonical maps are computed as well: \":sum\" for the injections, \":prod\" for the projections.\n\n\n\n\n\ndirect_product(x::Vararg{T}) where T <: AbstractLat -> T, Vector{AbstractSpaceMor}\ndirect_product(x::Vector{T}) where T <: AbstractLat -> T, Vector{AbstractSpaceMor}\n\nGiven a collection of quadratic or hermitian lattices L_1 ldots L_n, return their direct product L = L_1 times ldots times L_n, together with the projections L to L_i (seen as maps between the corresponding ambient spaces).\n\nFor objects of type AbstractLat, finite direct sums and finite direct products agree and they are therefore called biproducts. If one wants to obtain L as a direct sum with the injections L_i to L, one should call direct_sum(x). If one wants to obtain L as a biproduct with the injections L_i to L and the projections L to L_i, one should call biproduct(x).\n\n\n\n\n\ndirect_product(F::FreeMod{T}...; task::Symbol = :prod) where T\n\nGiven free modules F_1dots F_n, say, return the direct product prod_i=1^n F_i.\n\nAdditionally, return\n\na vector containing the canonical projections  prod_i=1^n F_ito F_i if task = :prod (default),\na vector containing the canonical injections  F_itoprod_i=1^n F_i if task = :sum,\ntwo vectors containing the canonical projections and injections, respectively, if task = :both,\nnone of the above maps if task = :none.\n\n\n\n\n\ndirect_product(M::ModuleFP{T}...; task::Symbol = :prod) where T\n\nGiven modules M_1dots M_n, say, return the direct product prod_i=1^n M_i.\n\nAdditionally, return\n\na vector containing the canonical projections  prod_i=1^n M_ito M_i if task = :prod (default),\na vector containing the canonical injections  M_itoprod_i=1^n M_i if task = :sum,\ntwo vectors containing the canonical projections and injections, respectively, if task = :both,\nnone of the above maps if task = :none.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/quad_forms/lattices/#biproduct-Tuple{Vector{AbstractLat}}","page":"Lattices","title":"biproduct","text":"biproduct(x::Vararg{T}) where T <: AbstractLat -> T, Vector{AbstractSpaceMor}, Vector{AbstractSpaceMor}\nbiproduct(x::Vector{T}) where T <: AbstractLat -> T, Vector{AbstractSpaceMor}, Vector{AbstractSpaceMor}\n\nGiven a collection of quadratic or hermitian lattices L_1 ldots L_n, return their biproduct L = L_1 oplus ldots oplus L_n, together with the injections L_i to L and the projections L to L_i (seen as maps between the corresponding ambient spaces).\n\nFor objects of type AbstractLat, finite direct sums and finite direct products agree and they are therefore called biproducts. If one wants to obtain L as a direct sum with the injections L_i to L, one should call direct_sum(x). If one wants to obtain L as a direct product with the projections L to L_i, one should call direct_product(x).\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/quad_forms/lattices/","page":"Lattices","title":"Lattices","text":"","category":"page"},{"location":"Hecke/manual/quad_forms/lattices/#Invariants","page":"Lattices","title":"Invariants","text":"","category":"section"},{"location":"Hecke/manual/quad_forms/lattices/","page":"Lattices","title":"Lattices","text":"Let L be a lattice over EK, in the space (V Phi). We define:","category":"page"},{"location":"Hecke/manual/quad_forms/lattices/","page":"Lattices","title":"Lattices","text":"the norm mathfrak n(L) of L to be the ideal of mathcal O_K generated by the squares leftPhi(xx) mid x in L right;\nthe scale mathfrak s(L) of L to be the set Phi(LL) = leftPhi(xy) mid xy in L right;\nthe volume mathfrak v(L) of L to be the index ideal","category":"page"},{"location":"Hecke/manual/quad_forms/lattices/","page":"Lattices","title":"Lattices","text":"   lbrack L^ colon L rbrack_mathcal O_E = langle left sigma mid sigma in textHom_mathcal O_E(L^ L) right rangle_mathcal O_E","category":"page"},{"location":"Hecke/manual/quad_forms/lattices/","page":"Lattices","title":"Lattices","text":"norm(::AbstractLat)\nscale(L::AbstractLat)\nvolume(L::AbstractLat)","category":"page"},{"location":"Hecke/manual/quad_forms/lattices/#norm-Tuple{AbstractLat}","page":"Lattices","title":"norm","text":"norm(L::AbstractLat) -> AbsNumFieldOrderFractionalIdeal\n\nReturn the norm of the lattice L. This is a fractional ideal of the fixed field of L.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/quad_forms/lattices/#scale-Tuple{AbstractLat}","page":"Lattices","title":"scale","text":"scale(L::AbstractLat) -> AbsSimpleNumFieldOrderFractionalIdeal\n\nReturn the scale of the lattice L.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/quad_forms/lattices/#volume-Tuple{AbstractLat}","page":"Lattices","title":"volume","text":"volume(L::AbstractLat) -> AbsSimpleNumFieldOrderFractionalIdeal\n\nReturn the volume of the lattice L.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/quad_forms/lattices/#Examples-6","page":"Lattices","title":"Examples","text":"","category":"section"},{"location":"Hecke/manual/quad_forms/lattices/","page":"Lattices","title":"Lattices","text":"using Hecke # hide\nK, a = rationals_as_number_field();\nKt, t = K[\"t\"];\ng = t^2 + 7;\nE, b = number_field(g, \"b\");\nD = matrix(E, 4, 4, [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]);\ngens = Vector{Hecke.RelSimpleNumFieldElem{AbsSimpleNumFieldElem}}[map(E, [2, -1, 0, 0]), map(E, [-3, 0, -1, 0]), map(E, [0, 0, 0, -1]), map(E, [b, 0, 0, 0])];\nLherm = hermitian_lattice(E, gens, gram = D);\nnorm(Lherm)\nscale(Lherm)\nvolume(Lherm)","category":"page"},{"location":"Hecke/manual/quad_forms/lattices/","page":"Lattices","title":"Lattices","text":"","category":"page"},{"location":"Hecke/manual/quad_forms/lattices/#Predicates","page":"Lattices","title":"Predicates","text":"","category":"section"},{"location":"Hecke/manual/quad_forms/lattices/","page":"Lattices","title":"Lattices","text":"Let L be a lattice over EK. It is said to be integral if its scale is an integral ideal, i.e. it is contained in mathcal O_E. Moreover, if mathfrak p is a prime ideal in mathcal O_K, then L is said to be modular (resp. locally modular at mathfrak p) if there exists a fractional ideal mathfrak a of mathcal O_E (resp. an integer v) such that mathfrak aL^ = L (resp. mathfrak p^vL_mathfrak p^ = L_mathfrak p).","category":"page"},{"location":"Hecke/manual/quad_forms/lattices/","page":"Lattices","title":"Lattices","text":"is_integral(::AbstractLat)\nis_modular(::AbstractLat)\nis_modular(::AbstractLat, p)\nis_positive_definite(L::AbstractLat)\nis_negative_definite(L::AbstractLat)\nis_definite(L::AbstractLat)\ncan_scale_totally_positive(L::AbstractLat)","category":"page"},{"location":"Hecke/manual/quad_forms/lattices/#is_integral-Tuple{AbstractLat}","page":"Lattices","title":"is_integral","text":"is_integral(L::AbstractLat) -> Bool\n\nReturn whether the lattice L is integral.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/quad_forms/lattices/#is_modular-Tuple{AbstractLat}","page":"Lattices","title":"is_modular","text":"is_modular(L::AbstractLat) -> Bool, AbsSimpleNumFieldOrderFractionalIdeal\n\nReturn whether the lattice L is modular. In this case, the second returned value is a fractional ideal mathfrak a of the base algebra of L such that mathfrak a L^ = L, where L^ is the dual of L.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/quad_forms/lattices/#is_modular-Tuple{AbstractLat, Any}","page":"Lattices","title":"is_modular","text":"is_modular(L::AbstractLat, p) -> Bool, Int\n\nReturn whether the completion L_p of the lattice L at the prime ideal or integer p is modular. If it is the case the second returned value is an integer v such that L_p is p^v-modular.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/quad_forms/lattices/#is_positive_definite-Tuple{AbstractLat}","page":"Lattices","title":"is_positive_definite","text":"is_positive_definite(L::AbstractLat) -> Bool\n\nReturn whether the rational span of the lattice L is positive definite.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/quad_forms/lattices/#is_negative_definite-Tuple{AbstractLat}","page":"Lattices","title":"is_negative_definite","text":"is_negative_definite(L::AbstractLat) -> Bool\n\nReturn whether the rational span of the lattice L is negative definite.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/quad_forms/lattices/#is_definite-Tuple{AbstractLat}","page":"Lattices","title":"is_definite","text":"is_definite(L::AbstractLat) -> Bool\n\nReturn whether the rational span of the lattice L is definite.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/quad_forms/lattices/#can_scale_totally_positive-Tuple{AbstractLat}","page":"Lattices","title":"can_scale_totally_positive","text":"can_scale_totally_positive(L::AbstractLat) -> Bool, NumFieldElem\n\nReturn whether there is a totally positive rescaled lattice of the lattice L. If so, the second returned value is an element a such that L^a is totally positive.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/quad_forms/lattices/#Examples-7","page":"Lattices","title":"Examples","text":"","category":"section"},{"location":"Hecke/manual/quad_forms/lattices/","page":"Lattices","title":"Lattices","text":"using Hecke # hide\nK, a = rationals_as_number_field();\nKt, t = K[\"t\"];\ng = t^2 + 7;\nE, b = number_field(g, \"b\");\nD = matrix(E, 4, 4, [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]);\ngens = Vector{Hecke.RelSimpleNumFieldElem{AbsSimpleNumFieldElem}}[map(E, [2, -1, 0, 0]), map(E, [-3, 0, -1, 0]), map(E, [0, 0, 0, -1]), map(E, [b, 0, 0, 0])];\nLherm = hermitian_lattice(E, gens, gram = D);\nOK = maximal_order(K);\nis_integral(Lherm)\nis_modular(Lherm)[1]\np = prime_decomposition(OK, 7)[1][1];\nis_modular(Lherm, p)\nis_positive_definite(Lherm)\ncan_scale_totally_positive(Lherm)","category":"page"},{"location":"Hecke/manual/quad_forms/lattices/","page":"Lattices","title":"Lattices","text":"","category":"page"},{"location":"Hecke/manual/quad_forms/lattices/#Local-properties","page":"Lattices","title":"Local properties","text":"","category":"section"},{"location":"Hecke/manual/quad_forms/lattices/","page":"Lattices","title":"Lattices","text":"local_basis_matrix(L::AbstractLat, p; type::Symbol = :any)\njordan_decomposition(L::AbstractLat, p::AbsNumFieldOrderIdeal{AbsSimpleNumField, AbsSimpleNumFieldElem})\nis_isotropic(::AbstractLat, p)","category":"page"},{"location":"Hecke/manual/quad_forms/lattices/#local_basis_matrix-Tuple{AbstractLat, Any}","page":"Lattices","title":"local_basis_matrix","text":"local_basis_matrix(L::AbstractLat, p::AbsNumFieldOrderIdeal{AbsSimpleNumField, AbsSimpleNumFieldElem}; type = :any) -> MatElem\n\nGiven a prime ideal p and a lattice L, return a basis matrix of a lattice M such that M_p = L_p. Note that if p is an ideal in the base ring of L, the completions are taken at the minimum of p (which is an ideal in the base ring of the order of p).\n\nIf type == :submodule, the lattice M will be a sublattice of L.\nIf type == :supermodule, the lattice M will be a superlattice of L.\nIf type == :any, there may not be any containment relation between M and L.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/quad_forms/lattices/#jordan_decomposition-Tuple{AbstractLat, AbsSimpleNumFieldOrderIdeal}","page":"Lattices","title":"jordan_decomposition","text":"jordan_decomposition(L::AbstractLat, p::AbsNumFieldOrderIdeal{AbsSimpleNumField, AbsSimpleNumFieldElem})\n                            -> Vector{MatElem}, Vector{MatElem}, Vector{Int}\n\nReturn a Jordan decomposition of the completion of the lattice L at a prime ideal p.\n\nThe returned value consists of three lists (M_i)_i, (G_i)_i and (s_i)_i of the same length r. The completions of the row spans of the matrices M_i yield a Jordan decomposition of L_p into modular sublattices L_i with Gram matrices G_i and scale of p-adic valuation s_i.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/quad_forms/lattices/#is_isotropic-Tuple{AbstractLat, Any}","page":"Lattices","title":"is_isotropic","text":"is_isotropic(L::AbstractLat, p::Union{AbsNumFieldOrderIdeal{AbsSimpleNumField, AbsSimpleNumFieldElem}, InfPlc}) -> Bool\n\nReturn whether the completion of the lattice L at the place p is isotropic.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/quad_forms/lattices/#Examples-8","page":"Lattices","title":"Examples","text":"","category":"section"},{"location":"Hecke/manual/quad_forms/lattices/","page":"Lattices","title":"Lattices","text":"using Hecke # hide\nK, a = rationals_as_number_field();\nD = matrix(K, 3, 3, [2, 0, 0, 0, 2, 0, 0, 0, 2]);\ngens = Vector{AbsSimpleNumFieldElem}[map(K, [1, 1, 0]), map(K, [1, 0, 1]), map(K, [2, 0, 0])];\nLquad = quadratic_lattice(K, gens, gram = D);\nOK = maximal_order(K);\np = prime_decomposition(OK, 7)[1][1];\nlocal_basis_matrix(Lquad, p)\njordan_decomposition(Lquad, p)\nis_isotropic(Lquad, p)","category":"page"},{"location":"Hecke/manual/quad_forms/lattices/","page":"Lattices","title":"Lattices","text":"","category":"page"},{"location":"Hecke/manual/quad_forms/lattices/#Automorphisms-for-definite-lattices","page":"Lattices","title":"Automorphisms for definite lattices","text":"","category":"section"},{"location":"Hecke/manual/quad_forms/lattices/","page":"Lattices","title":"Lattices","text":"Let L and L be two lattices over the same extension EK, inside their respective ambient spaces (V Phi) and (V Phi). Similarly to homomorphisms of spaces, we define a homomorphism of lattices from L to L to be an mathcalO_E-module$ homomorphism f colon L to L such that for all xy in L, one has","category":"page"},{"location":"Hecke/manual/quad_forms/lattices/","page":"Lattices","title":"Lattices","text":"   Phi(f(x) f(y)) = Phi(xy)","category":"page"},{"location":"Hecke/manual/quad_forms/lattices/","page":"Lattices","title":"Lattices","text":"Again, any automorphism of lattices is called an isometry and any monomorphism is called an embedding. We refer to the set of isometries from a lattice L to itself as the automorphism group of L.","category":"page"},{"location":"Hecke/manual/quad_forms/lattices/","page":"Lattices","title":"Lattices","text":"automorphism_group_order(::AbstractLat)\nautomorphism_group_generators(::AbstractLat)","category":"page"},{"location":"Hecke/manual/quad_forms/lattices/#automorphism_group_order-Tuple{AbstractLat}","page":"Lattices","title":"automorphism_group_order","text":"automorphism_group_order(L::AbstractLat; depth::Int = -1, bacher_depth::Int = 0) -> Int\n\nGiven a definite lattice L, return the order of the automorphism group of L.\n\nSetting the parameters depth and bacher_depth to a positive value may improve performance. If set to -1 (default), the used value of depth is chosen heuristically depending on the rank of L. By default, bacher_depth is set to 0.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/quad_forms/lattices/#automorphism_group_generators-Tuple{AbstractLat}","page":"Lattices","title":"automorphism_group_generators","text":"automorphism_group_generators(L::AbstractLat; ambient_representation::Bool = true,\n                                              depth::Int = -1, bacher_depth::Int = 0)\n                                                      -> Vector{MatElem}\n\nGiven a definite lattice L, return generators for the automorphism group of L. If ambient_representation == true (the default), the transformations are represented with respect to the ambient space of L. Otherwise, the transformations are represented with respect to the (pseudo-)basis of L.\n\nSetting the parameters depth and bacher_depth to a positive value may improve performance. If set to -1 (default), the used value of depth is chosen heuristically depending on the rank of L. By default, bacher_depth is set to 0.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/quad_forms/lattices/#Examples-9","page":"Lattices","title":"Examples","text":"","category":"section"},{"location":"Hecke/manual/quad_forms/lattices/","page":"Lattices","title":"Lattices","text":"using Hecke # hide\nK, a = rationals_as_number_field();\nKt, t = K[\"t\"];\ng = t^2 + 7;\nE, b = number_field(g, \"b\");\nD = matrix(K, 3, 3, [2, 0, 0, 0, 2, 0, 0, 0, 2]);\ngens = Vector{AbsSimpleNumFieldElem}[map(K, [1, 1, 0]), map(K, [1, 0, 1]), map(K, [2, 0, 0])];\nLquad = quadratic_lattice(K, gens, gram = D);\nis_definite(Lquad)\nautomorphism_group_order(Lquad)\nautomorphism_group_generators(Lquad)","category":"page"},{"location":"Hecke/manual/quad_forms/lattices/","page":"Lattices","title":"Lattices","text":"","category":"page"},{"location":"Hecke/manual/quad_forms/lattices/#Isometry","page":"Lattices","title":"Isometry","text":"","category":"section"},{"location":"Hecke/manual/quad_forms/lattices/","page":"Lattices","title":"Lattices","text":"is_isometric(::AbstractLat, ::AbstractLat)\nis_isometric_with_isometry(::AbstractLat, ::AbstractLat)\nis_locally_isometric(::AbstractLat, ::AbstractLat, p::AbsNumFieldOrderIdeal{AbsSimpleNumField, AbsSimpleNumFieldElem})","category":"page"},{"location":"Hecke/manual/quad_forms/lattices/#is_isometric-Tuple{AbstractLat, AbstractLat}","page":"Lattices","title":"is_isometric","text":"is_isometric(L::AbstractLat, M::AbstractLat; depth::Int = -1, bacher_depth::Int = 0) -> Bool\n\nReturn whether the lattices L and M are isometric.\n\nSetting the parameters depth and bacher_depth to a positive value may improve performance. If set to -1 (default), the used value of depth is chosen heuristically depending on the rank of L. By default, bacher_depth is set to 0.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/quad_forms/lattices/#is_isometric_with_isometry-Tuple{AbstractLat, AbstractLat}","page":"Lattices","title":"is_isometric_with_isometry","text":"is_isometric_with_isometry(L::AbstractLat, M::AbstractLat; ambient_representation::Bool = true\n                                                           depth::Int = -1, bacher_depth::Int = 0)\n                                                          -> (Bool, MatElem)\n\nReturn whether the lattices L and M are isometric. If this is the case, the second returned value is an isometry T from L to M.\n\nBy default, that isometry is represented with respect to the bases of the ambient spaces, that is, T V_M T^t = V_L where V_L and V_M are the Gram matrices of the ambient spaces of L and M respectively. If ambient_representation == false, then the isometry is represented with respect to the (pseudo-)bases of L and M, that is, T G_M T^t = G_L where G_M and G_L are the Gram matrices of the (pseudo-)bases of L and M respectively.\n\nSetting the parameters depth and bacher_depth to a positive value may improve performance. If set to -1 (default), the used value of depth is chosen heuristically depending on the rank of L. By default, bacher_depth is set to 0.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/quad_forms/lattices/#is_locally_isometric-Tuple{AbstractLat, AbstractLat, AbsSimpleNumFieldOrderIdeal}","page":"Lattices","title":"is_locally_isometric","text":"is_locally_isometric(L::AbstractLat, M::AbstractLat, p::AbsNumFieldOrderIdeal{AbsSimpleNumField, AbsSimpleNumFieldElem}) -> Bool\n\nReturn whether the completions of the lattices L and M at the prime ideal p are isometric.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/quad_forms/lattices/#Examples-10","page":"Lattices","title":"Examples","text":"","category":"section"},{"location":"Hecke/manual/quad_forms/lattices/","page":"Lattices","title":"Lattices","text":"using Hecke # hide\nK, a = rationals_as_number_field();\nD = matrix(K, 3, 3, [2, 0, 0, 0, 2, 0, 0, 0, 2]);\ngens = Vector{AbsSimpleNumFieldElem}[map(K, [1, 1, 0]), map(K, [1, 0, 1]), map(K, [2, 0, 0])];\nLquad = quadratic_lattice(K, gens, gram = D);\nD = matrix(K, 3, 3, [2, 0, 0, 0, 2, 0, 0, 0, 2]);\ngens = Vector{AbsSimpleNumFieldElem}[map(K, [-35, 25, 0]), map(K, [30, 40, -20]), map(K, [5, 10, -5])];\nLquad2 = quadratic_lattice(K, gens, gram = D);\nOK = maximal_order(K);\np = prime_decomposition(OK, 7)[1][1];\nis_isometric(Lquad, Lquad2)\nis_locally_isometric(Lquad, Lquad2, p)","category":"page"},{"location":"Hecke/manual/quad_forms/lattices/","page":"Lattices","title":"Lattices","text":"","category":"page"},{"location":"Hecke/manual/quad_forms/lattices/#Maximal-integral-lattices","page":"Lattices","title":"Maximal integral lattices","text":"","category":"section"},{"location":"Hecke/manual/quad_forms/lattices/","page":"Lattices","title":"Lattices","text":"is_maximal_integral(::AbstractLat, p)\nis_maximal_integral(::AbstractLat)\nis_maximal(::AbstractLat, p)\nmaximal_integral_lattice(::AbstractLat, p)\nmaximal_integral_lattice(::AbstractLat)\nmaximal_integral_lattice(::AbstractSpace)","category":"page"},{"location":"Hecke/manual/quad_forms/lattices/#is_maximal_integral-Tuple{AbstractLat, Any}","page":"Lattices","title":"is_maximal_integral","text":"is_maximal_integral(L::AbstractLat, p::AbsNumFieldOrderIdeal{AbsSimpleNumField, AbsSimpleNumFieldElem}) -> Bool, AbstractLat\n\nGiven a lattice L and a prime ideal p of the fixed ring mathcal O_K of L, return whether the completion of L at p has integral norm and that L has no proper overlattice satisfying this property.\n\nIf the norm of L is not integral at p, the second output is L by default. Otherwise, either L is maximal at p and the second output is L, or the second output is a lattice M in the ambient space of L whose completion at p is a minimal overlattice of L_p with integral norm.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/quad_forms/lattices/#is_maximal_integral-Tuple{AbstractLat}","page":"Lattices","title":"is_maximal_integral","text":"is_maximal_integral(L::AbstractLat) -> Bool, AbstractLat\n\nGiven a lattice L, return whether L has integral norm and has no proper overlattice satisfying this property.\n\nIf the norm of L is not integral, the second output is L by default. Otherwise, either L is maximal and the second output is L, or the second output is a minimal overlattice M of L with integral norm.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/quad_forms/lattices/#is_maximal-Tuple{AbstractLat, Any}","page":"Lattices","title":"is_maximal","text":"is_maximal(L::AbstractLat, p::AbsNumFieldOrderIdeal{AbsSimpleNumField, AbsSimpleNumFieldElem}) -> Bool, AbstractLat\n\nGiven a lattice L and a prime ideal p in the fixed ring mathcal O_K of L such that the norm of L_p is integral, return whether L is maximal integral at p.\n\nIf L is locally maximal at p, the second output is L, otherwise it is a lattice M in the same ambient space of L whose completion at p has integral norm and is a proper overlattice of L_p.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/quad_forms/lattices/#maximal_integral_lattice-Tuple{AbstractLat, Any}","page":"Lattices","title":"maximal_integral_lattice","text":"maximal_integral_lattice(L::AbstractLat, p::AbsNumFieldOrderIdeal{AbsSimpleNumField, AbsSimpleNumFieldElem}) -> AbstractLat\n\nGiven a lattice L and a prime ideal p of the fixed ring mathcal O_K of L such that the norm of L_p is integral, return a lattice M in the ambient space of L which is maximal integral at p and which agrees with L locally at all the places different from p.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/quad_forms/lattices/#maximal_integral_lattice-Tuple{AbstractLat}","page":"Lattices","title":"maximal_integral_lattice","text":"maximal_integral_lattice(L::AbstractLat) -> AbstractLat\n\nGiven a lattice L with integral norm, return a maximal integral overlattice M of L.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/quad_forms/lattices/#maximal_integral_lattice-Tuple{AbstractSpace}","page":"Lattices","title":"maximal_integral_lattice","text":"maximal_integral_lattice(V::AbstractSpace) -> AbstractLat\n\nGiven a space V, return a lattice in V with integral norm and which is maximal in V satisfying this property.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/quad_forms/lattices/#Examples-11","page":"Lattices","title":"Examples","text":"","category":"section"},{"location":"Hecke/manual/quad_forms/lattices/","page":"Lattices","title":"Lattices","text":"using Hecke # hide\nK, a = rationals_as_number_field();\nKt, t = K[\"t\"];\ng = t^2 + 7;\nE, b = number_field(g, \"b\");\nD = matrix(E, 4, 4, [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]);\ngens = Vector{Hecke.RelSimpleNumFieldElem{AbsSimpleNumFieldElem}}[map(E, [2, -1, 0, 0]), map(E, [-3, 0, -1, 0]), map(E, [0, 0, 0, -1]), map(E, [b, 0, 0, 0])];\nLherm = hermitian_lattice(E, gens, gram = D);\nOK = maximal_order(K);\np = prime_decomposition(OK, 7)[1][1];\nis_maximal_integral(Lherm, p)\nis_maximal_integral(Lherm)\nis_maximal(Lherm, p)\npseudo_basis(maximal_integral_lattice(Lherm, p))\npseudo_basis(maximal_integral_lattice(Lherm))\npseudo_basis(maximal_integral_lattice(ambient_space(Lherm)))","category":"page"},{"location":"CommutativeAlgebra/GroebnerBases/groebner_bases_integers/","page":"Gröbner/Standard Bases Over mathbb Z","title":"Gröbner/Standard Bases Over mathbb Z","text":"CurrentModule = Oscar\nDocTestSetup = Oscar.doctestsetup()","category":"page"},{"location":"CommutativeAlgebra/GroebnerBases/groebner_bases_integers/#Gröbner/Standard-Bases-Over-\\mathbb-Z","page":"Gröbner/Standard Bases Over mathbb Z","title":"Gröbner/Standard Bases Over mathbb Z","text":"","category":"section"},{"location":"CommutativeAlgebra/GroebnerBases/groebner_bases_integers/","page":"Gröbner/Standard Bases Over mathbb Z","title":"Gröbner/Standard Bases Over mathbb Z","text":"In this section, we consider a polynomial ring mathbb Zx = mathbb Zx_1 dots x_n over the integers. As in the previous section on Gröbner/standard bases over fields, let  be a monomial ordering on textMon_n(x). With respect to this ordering, the localization mathbb Zx_ and, given a nonzero element f in mathbb Zx_, the notions leading term, leading monomial, leading exponent, leading coefficient, and tail  of f are defined as before.","category":"page"},{"location":"CommutativeAlgebra/GroebnerBases/groebner_bases_integers/","page":"Gröbner/Standard Bases Over mathbb Z","title":"Gröbner/Standard Bases Over mathbb Z","text":"note: Note\nOver mathbb Z, the basic idea of multivariate polynomial division with remainder in OSCAR is as follows: If ax^alpha is the leading term of the intermediate dividend, f_i is some divisor whose leading monomial equals x^alpha, say textLT(f_i) = bx^alpha, and r is the remainder of a on division by b in mathbb Z, then ax^alpha is replaced by rx^alpha.","category":"page"},{"location":"CommutativeAlgebra/GroebnerBases/groebner_bases_integers/#Examples","page":"Gröbner/Standard Bases Over mathbb Z","title":"Examples","text":"","category":"section"},{"location":"CommutativeAlgebra/GroebnerBases/groebner_bases_integers/","page":"Gröbner/Standard Bases Over mathbb Z","title":"Gröbner/Standard Bases Over mathbb Z","text":"julia> R, (x, y) = polynomial_ring(ZZ, [:x, :y]);\n\njulia> reduce(3*x, [2*x])\nx\n\njulia> reduce(6*x, [5*x, 2*x])\n0","category":"page"},{"location":"CommutativeAlgebra/GroebnerBases/groebner_bases_integers/","page":"Gröbner/Standard Bases Over mathbb Z","title":"Gröbner/Standard Bases Over mathbb Z","text":"The notion of leading ideals  as formulated in the previous section and the definitions of standard bases (Gröbner bases) carry over: A standard basis for an ideal Isubset Kx_ with respect to  is a finite subset G of I such that textL_(G) = textL_(I) (a standard basis with respect to a global monomial ordering is also called a Gröbner basis).","category":"page"},{"location":"CommutativeAlgebra/GroebnerBases/groebner_bases_integers/","page":"Gröbner/Standard Bases Over mathbb Z","title":"Gröbner/Standard Bases Over mathbb Z","text":"There is, however, a sublety: Over a field, the defining condition of a standard basis as stated above is equivalent to saying that the textLT_(g), gin Gsetminus0 generate textL_(I). Over mathbb Z, the latter condition implies the former one, but not vice versa. Consequently, over mathbb Z, a finite subset G of I satisfying the latter condition is called a strong standard basis for I (with respect to ).","category":"page"},{"location":"CommutativeAlgebra/GroebnerBases/groebner_bases_integers/","page":"Gröbner/Standard Bases Over mathbb Z","title":"Gröbner/Standard Bases Over mathbb Z","text":"We refer to the  textbook [AL94] for more on this.","category":"page"},{"location":"CommutativeAlgebra/GroebnerBases/groebner_bases_integers/","page":"Gröbner/Standard Bases Over mathbb Z","title":"Gröbner/Standard Bases Over mathbb Z","text":"note: Note\nOver mathbb Z, the standard bases returned by OSCAR are strong in the sense above.","category":"page"},{"location":"CommutativeAlgebra/GroebnerBases/groebner_bases_integers/#Examples-2","page":"Gröbner/Standard Bases Over mathbb Z","title":"Examples","text":"","category":"section"},{"location":"CommutativeAlgebra/GroebnerBases/groebner_bases_integers/","page":"Gröbner/Standard Bases Over mathbb Z","title":"Gröbner/Standard Bases Over mathbb Z","text":"julia> R, (x,y) = polynomial_ring(ZZ, [:x,:y])\n(Multivariate polynomial ring in 2 variables over ZZ, ZZMPolyRingElem[x, y])\n\njulia> I = ideal(R, [3*x^2*y+7*y, 4*x*y^2-5*x])\nIdeal generated by\n  3*x^2*y + 7*y\n  4*x*y^2 - 5*x\n\njulia> G = groebner_basis(I, ordering = lex(R))\nGröbner basis with elements\n  1: 28*y^3 - 35*y\n  2: 4*x*y^2 - 5*x\n  3: 15*x^2 + 28*y^2\n  4: 3*x^2*y + 7*y\n  5: x^2*y^2 - 5*x^2 - 7*y^2\nwith respect to the ordering\n  lex([x, y])","category":"page"},{"location":"AlgebraicGeometry/Surfaces/AdjunctionProcess/","page":"Adjunction Process for Surfaces","title":"Adjunction Process for Surfaces","text":"CurrentModule = Oscar","category":"page"},{"location":"AlgebraicGeometry/Surfaces/AdjunctionProcess/#Adjunction-Process-for-Surfaces","page":"Adjunction Process for Surfaces","title":"Adjunction Process for Surfaces","text":"","category":"section"},{"location":"AlgebraicGeometry/Surfaces/AdjunctionProcess/","page":"Adjunction Process for Surfaces","title":"Adjunction Process for Surfaces","text":"A surface in this section is a smooth projective surface over mathbb C.","category":"page"},{"location":"AlgebraicGeometry/Surfaces/AdjunctionProcess/","page":"Adjunction Process for Surfaces","title":"Adjunction Process for Surfaces","text":"Blowing up a surface in a point means to replace the point by an exceptional curve. Each such curve E is a smooth, rational curve with self-intersection number E^2=-1. We speak of  a (-1)-curve. A surface is minimal if it contains no (-1)-curves. That is, the surface cannot be obtained by blowing up a point on another surface. A surface X_textmin is called a minimal model of a surface X if X_textmin is minimal and X can be obtained from X_textmin by repeatedly blowing up a point. Each surface X has a minimal model which is unique if X has non-negative Kodaira dimension. The Enriques-Kodaira classification classifies surfaces according to their minimal models. See [BHPV-D-V04] for more on this.","category":"page"},{"location":"AlgebraicGeometry/Surfaces/AdjunctionProcess/","page":"Adjunction Process for Surfaces","title":"Adjunction Process for Surfaces","text":"Given a surface, we may apply the adjunction process of Van de Ven and Sommese [SV-D-V87] to discover a minimal model. To describe this process, consider a surface X subset mathbb P^n of codimension c. Let S and S_X denote the homogeneous coordinate rings of mathbb P^n and X, respectively. Consider omega_X=textExt^c_S(S_XS(-n-1)) the graded dualizing module of S_X. A basis of the graded piece (omega_X)_1 corresponds to the linear system K_X +H, where K_X is a canonical divisor on X and H is the hyperplane class. Except for some exceptional cases, this linear system defines a birational morphism varphi_K_X+Hcolon X to X onto another smooth projective surface X such that  varphi_K_X+H blows down precisely all (-1)-lines on X. As shown by Van de Ven and Sommese, in the exceptional cases,","category":"page"},{"location":"AlgebraicGeometry/Surfaces/AdjunctionProcess/","page":"Adjunction Process for Surfaces","title":"Adjunction Process for Surfaces","text":"X is a linearly or quadratically embedded $ \\mathbb P^{2}$ or X is ruled by lines, in which case K_X+H = emptyset,\nX is an anti-canonically embedded del Pezzo surface, in which case varphi_K_X+H maps X to a point,\nX is a conic bundle, in which case  varphi_K_X+Hcolon X to B maps X to a curve B such that the fibers of varphi_K_X+H are the conics, or\nX is a surface in one of four explicit families identified by Sommese and Van de Ven, and varphi_K_X+Hcolon X to X is not birational, but finite to one.","category":"page"},{"location":"AlgebraicGeometry/Surfaces/AdjunctionProcess/","page":"Adjunction Process for Surfaces","title":"Adjunction Process for Surfaces","text":"If we are not in one of these cases, a (-1)-conic C in X is mapped to a (-1)-line in X since (K_X+H)  C=-1+2=1. Thus, the adjunction process, which  consists of applying the adjunction maps varphi_K_X+H, varphi_K_X+H and so on, yields finitely many surfaces X rightarrow X^prime rightarrow X^primeprime rightarrow dots which are called the adjoint surfaces of X. The last adjoint surface is either minimal or belongs to one of the exceptional cases. In particular, if  X has non-negative Kodaira dimension, the adjunction process yields the uniquely determined minimal model of X.","category":"page"},{"location":"AlgebraicGeometry/Surfaces/AdjunctionProcess/","page":"Adjunction Process for Surfaces","title":"Adjunction Process for Surfaces","text":"note: Note\nIf X is rational, the last adjoint surface is either mathbb P^2, the Veronese surface, a Hirzebruch surface, a Del Pezzo surface, a conic bundle, or one of the four explicit families identified by Sommese and Van de Ven.","category":"page"},{"location":"AlgebraicGeometry/Surfaces/AdjunctionProcess/","page":"Adjunction Process for Surfaces","title":"Adjunction Process for Surfaces","text":"note: Note\nIn explicit computations, we consider surfaces which are defined by polynomial equations with coefficients in a subfield of mathbb C which can be handled by OSCAR.","category":"page"},{"location":"AlgebraicGeometry/Surfaces/AdjunctionProcess/","page":"Adjunction Process for Surfaces","title":"Adjunction Process for Surfaces","text":"note: Note\nThe surfaces in the examples below are taken from the OSCAR data base of nongeneral type surfaces in mathbb P^4. To ease subsequent computations, the surfaces in the data base where constructed over finite fields. Note, however, that the recipes used in the constructions also work in characteristic zero. So all computations can be confirmed in characteristic zero, although this may be time consuming.","category":"page"},{"location":"AlgebraicGeometry/Surfaces/AdjunctionProcess/#Adjunction-Process","page":"Adjunction Process for Surfaces","title":"Adjunction Process","text":"","category":"section"},{"location":"AlgebraicGeometry/Surfaces/AdjunctionProcess/","page":"Adjunction Process for Surfaces","title":"Adjunction Process for Surfaces","text":"What we describe here goes back to joint work of Wolfram Decker and Frank-Olaf Schreyer. See [DES93],  [DS00].","category":"page"},{"location":"AlgebraicGeometry/Surfaces/AdjunctionProcess/","page":"Adjunction Process for Surfaces","title":"Adjunction Process for Surfaces","text":"adjunction_process(X::AbsProjectiveVariety, steps::Int=0)","category":"page"},{"location":"AlgebraicGeometry/Surfaces/AdjunctionProcess/#adjunction_process","page":"Adjunction Process for Surfaces","title":"adjunction_process","text":"adjunction_process(X::AbsProjectiveVariety, steps::Int=0)\n\nGiven a smooth surface X and a non-negative integer steps, return data which describes the adjunction process for X:  If steps == 0, carry out the complete process. Otherwise, carry out the indicated number of steps only.\n\nMore precisely, if X^(0) = X rightarrow X^(1)rightarrow dots rightarrow X^(r) is the sequence of successive adjunction maps and  adjoint surfaces in the completed adjunction process, return a quadruple L, say, where: \n\nL[1] is a vector of tuples of numerical data: For each step X^(i)rightarrow X^(i+1), return the tuple (n^(i) d^(i) pi^(i) s^(i))  where n^(i) is the dimension of the ambient projective space of X^(i), d^(i) is the degree of X^(i), pi^(i) is the sectional genus of X^(i),  and s^(i) is the number of exceptional (-1)-lines on X^(i) which are blown down to points in $ X^{(i+1)}$.\n\nL[2] is a vector of adjoint matrices: For each step X^(i)rightarrow X^(i+1), return a presentation matrix of S_X^(i)(1) considered  as a module over S_X^(i+1), where the S_X^(i) are the homogeneous coordinate rings of the X^(i). If X is rational, these matrices can be used to compute a rational parametrization of X.\n\nL[3] is a vector of zero-dimensional projective algebraic sets: For each step X^(i)rightarrow X^(i+1), return the union of points in $ X^{(i+1)}$ which are obtained by blowing down the exceptional (-1)-lines on X^(i).\n\nL[4] is a projective variety: Return the last adjoint surface X^(r). \n\nnote: Note\nThe function does not check whether X is smooth. If you are uncertain, enter is_smooth(X) first.\n\nwarning: Warning\nAt current state, the adjunction process is only implemented for rational and Enriques surfaces which are linearly normal in the given embedding. The function does not check whether X is rational or an Enriques surface. In fact, at current state, OSCAR does not offer direct checks for this. Note, however, that the adjunction process will give an answer to this question a posteriori in cases where it terminates with a surface which is known to be rational or an Enriques surface.\n\nExamples\n\njulia> X = bordiga()\nProjective variety\n  in projective 4-space over GF(31991) with coordinates [x, y, z, u, v]\ndefined by ideal with 4 generators\n\n\njulia> dim(X)\n2\n\njulia> codim(X)\n2\n\njulia> L = adjunction_process(X);\n\njulia> L[1]\n2-element Vector{NTuple{4, ZZRingElem}}:\n (4, 6, 3, 0)\n (2, 1, 0, 10)\n\njulia> L[4]\nProjective variety\n  in projective 2-space over GF(31991) with coordinates [z[1], z[2], z[3]]\ndefined by ideal (0)\n\njulia> L[3][1]\nProjective algebraic set\n  in projective 2-space over GF(31991) with coordinates [z[1], z[2], z[3]]\ndefined by ideal with 5 generators\n\njulia> dim(L[3][1])\n0\n\njulia> degree(L[3][1])\n10\n\njulia> X = rational_d9_pi7();\n\njulia> L = adjunction_process(X);\n\njulia> L[1]\n3-element Vector{NTuple{4, ZZRingElem}}:\n (4, 9, 7, 0)\n (6, 9, 4, 6)\n (3, 3, 1, 3)\n\nnote: Note\nInspecting the  returned numerical data in the first example above, we see that the Bordiga surface is the blow-up of the projective plane in 10 points, embedded into projective 4-space by the linear system H = 4L -sum_i=1^10 E_i. Here, L is the preimage of a line and the E_i are the exceptional divisors. In the second example, we see from the output that the terminal object of the adjunction process is a Del Pezzo surface in projective 3-space, that is, the blow-up of the projective plane in 6 points. In sum, we see that X is the blow-up of the projective plane in 15 points, embedded into projective 4-space by the linear system H = 9L - sum_i=1^6 3E_i - sum_i=7^9 2E_i - sum_i=10^15 E_i. \n\n\n\n\n\n","category":"function"},{"location":"AlgebraicGeometry/Surfaces/AdjunctionProcess/#Contact","page":"Adjunction Process for Surfaces","title":"Contact","text":"","category":"section"},{"location":"AlgebraicGeometry/Surfaces/AdjunctionProcess/","page":"Adjunction Process for Surfaces","title":"Adjunction Process for Surfaces","text":"Please direct questions about this part of OSCAR to the following people:","category":"page"},{"location":"AlgebraicGeometry/Surfaces/AdjunctionProcess/","page":"Adjunction Process for Surfaces","title":"Adjunction Process for Surfaces","text":"Wolfram Decker.","category":"page"},{"location":"AlgebraicGeometry/Surfaces/AdjunctionProcess/","page":"Adjunction Process for Surfaces","title":"Adjunction Process for Surfaces","text":"You can ask questions in the OSCAR Slack.","category":"page"},{"location":"AlgebraicGeometry/Surfaces/AdjunctionProcess/","page":"Adjunction Process for Surfaces","title":"Adjunction Process for Surfaces","text":"Alternatively, you can raise an issue on github.","category":"page"},{"location":"AlgebraicGeometry/AlgebraicVarieties/ProjectiveVariety/","page":"Projective Varieties","title":"Projective Varieties","text":"CurrentModule = Oscar\nDocTestSetup = Oscar.doctestsetup()","category":"page"},{"location":"AlgebraicGeometry/AlgebraicVarieties/ProjectiveVariety/#Projective-Varieties","page":"Projective Varieties","title":"Projective Varieties","text":"","category":"section"},{"location":"AlgebraicGeometry/AlgebraicVarieties/ProjectiveVariety/","page":"Projective Varieties","title":"Projective Varieties","text":"A projective variety over an algebraically closed field is an irreducible projective algebraic set. See Projective Algebraic Sets.","category":"page"},{"location":"AlgebraicGeometry/AlgebraicVarieties/ProjectiveVariety/","page":"Projective Varieties","title":"Projective Varieties","text":"In practice we work over non-closed fields. To be called a variety an algebraic set V must stay irreducible when viewed over the algebraic closure.","category":"page"},{"location":"AlgebraicGeometry/AlgebraicVarieties/ProjectiveVariety/","page":"Projective Varieties","title":"Projective Varieties","text":"In Oscar projective varieties are Projective schemes and more formally defined as follows.","category":"page"},{"location":"AlgebraicGeometry/AlgebraicVarieties/ProjectiveVariety/","page":"Projective Varieties","title":"Projective Varieties","text":"AbsProjectiveVariety","category":"page"},{"location":"AlgebraicGeometry/AlgebraicVarieties/ProjectiveVariety/#AbsProjectiveVariety","page":"Projective Varieties","title":"AbsProjectiveVariety","text":"AbsProjectiveVariety <: AbsProjectiveAlgebraicSet\n\nA geometrically integral subscheme of a projective space over a field.\n\n\n\n\n\n","category":"type"},{"location":"AlgebraicGeometry/AlgebraicVarieties/ProjectiveVariety/#Constructors","page":"Projective Varieties","title":"Constructors","text":"","category":"section"},{"location":"AlgebraicGeometry/AlgebraicVarieties/ProjectiveVariety/","page":"Projective Varieties","title":"Projective Varieties","text":"variety(I::MPolyIdeal{<:MPolyDecRingElem}; check::Bool=true)\nvariety(X::AbsProjectiveScheme{<:Field}; check::Bool=true)\nvariety(R::Ring; check::Bool=true)\nvariety(f::MPolyDecRingElem; check=true)","category":"page"},{"location":"AlgebraicGeometry/AlgebraicVarieties/ProjectiveVariety/#variety-Tuple{MPolyIdeal{<:MPolyDecRingElem}}","page":"Projective Varieties","title":"variety","text":"variety(I::MPolyIdeal{<:MPolyDecRingElem}; check::Bool=true, is_radical::Bool=false) -> ProjectiveVariety\n\nReturn the projective variety defined by the homogeneous prime ideal I.\n\nSince in our terminology varieties are irreducible over the algebraic closure, we check that I stays prime when viewed over the algebraic closure. This is an expensive check that can be disabled. Note that the ideal I must live in a standard graded ring.\n\njulia> P3 = projective_space(QQ,3)\nProjective space of dimension 3\n  over rational field\nwith homogeneous coordinates [s0, s1, s2, s3]\n\njulia> (s0,s1,s2,s3) = homogeneous_coordinates(P3);\n\njulia> X = variety(s0^3 + s1^3 + s2^3 + s3^3)\nProjective variety\n  in projective 3-space over QQ with coordinates [s0, s1, s2, s3]\ndefined by ideal (s0^3 + s1^3 + s2^3 + s3^3)\n\njulia> dim(X)\n2\n\njulia> Y = variety(ideal([s0^3 + s1^3 + s2^3 + s3^3, s0]))\nProjective variety\n  in projective 3-space over QQ with coordinates [s0, s1, s2, s3]\ndefined by ideal (s0^3 + s1^3 + s2^3 + s3^3, s0)\n\njulia> dim(Y)\n1\n\n\n\n\n\n","category":"method"},{"location":"AlgebraicGeometry/AlgebraicVarieties/ProjectiveVariety/#variety-Tuple{AbsProjectiveScheme{<:Field}}","page":"Projective Varieties","title":"variety","text":"variety(X::AbsProjectiveScheme; is_reduced::Bool=false, check::Bool=true) -> ProjectiveVariety\n\nConvert X to a projective variety by considering its reduced structure\n\n\n\n\n\n","category":"method"},{"location":"AlgebraicGeometry/AlgebraicVarieties/ProjectiveVariety/#variety-Tuple{Ring}","page":"Projective Varieties","title":"variety","text":"variety(R::GradedRing; check::Bool=true)\n\nReturn the projective variety defined by the mathbbZ standard graded ring R.\n\nWe require that R is a finitely generated algebra over a field k and moreover that the base change of R to the algebraic closure bar k is an integral domain.\n\n\n\n\n\n","category":"method"},{"location":"AlgebraicGeometry/AlgebraicVarieties/ProjectiveVariety/#variety-Tuple{MPolyDecRingElem}","page":"Projective Varieties","title":"variety","text":"variety(f::MPolyDecRingElem; check=true)\n\nReturn the projective variety defined by the homogeneous polynomial f.\n\nThis checks that f is absolutely irreducible.\n\n\n\n\n\n","category":"method"},{"location":"AlgebraicGeometry/AlgebraicVarieties/ProjectiveVariety/#Attributes","page":"Projective Varieties","title":"Attributes","text":"","category":"section"},{"location":"AlgebraicGeometry/AlgebraicVarieties/ProjectiveVariety/","page":"Projective Varieties","title":"Projective Varieties","text":"In addition to what is inherited from Projective Algebraic Sets and Projective schemes, we currently have:","category":"page"},{"location":"AlgebraicGeometry/AlgebraicVarieties/ProjectiveVariety/","page":"Projective Varieties","title":"Projective Varieties","text":"sectional_genus(X::AbsProjectiveVariety)","category":"page"},{"location":"AlgebraicGeometry/AlgebraicVarieties/ProjectiveVariety/#sectional_genus-Tuple{AbsProjectiveVariety}","page":"Projective Varieties","title":"sectional_genus","text":"sectional_genus(X::AbsProjectiveVariety)\n\nGiven a subvariety X of some mathbb P^n, return the arithmetic genus of the intersection of X with a general linear subspace of mathbb P^n of dimension c+1.\n\nExamples\n\njulia> X = bordiga()\nProjective variety\n  in projective 4-space over GF(31991) with coordinates [x, y, z, u, v]\ndefined by ideal with 4 generators\n\njulia> dim(X)\n2\n\njulia> codim(X)\n2\n\njulia> degree(X)\n6\n\njulia> sectional_genus(X)\n3\n\n\n\n\n\n","category":"method"},{"location":"AlgebraicGeometry/AlgebraicVarieties/ProjectiveVariety/#Properties","page":"Projective Varieties","title":"Properties","text":"","category":"section"},{"location":"AlgebraicGeometry/AlgebraicVarieties/ProjectiveVariety/","page":"Projective Varieties","title":"Projective Varieties","text":"In addition to what is inherited from Projective Algebraic Sets and Projective schemes, we currently have:","category":"page"},{"location":"AlgebraicGeometry/AlgebraicVarieties/ProjectiveVariety/","page":"Projective Varieties","title":"Projective Varieties","text":"is_linearly_normal(X::AbsProjectiveVariety)","category":"page"},{"location":"AlgebraicGeometry/AlgebraicVarieties/ProjectiveVariety/#is_linearly_normal-Tuple{AbsProjectiveVariety}","page":"Projective Varieties","title":"is_linearly_normal","text":"is_linearly_normal(X::AbsProjectiveVariety)\n\nReturn true if X is linearly normal, and false otherwise.\n\nExamples\n\njulia> X = bordiga()\nProjective variety\n  in projective 4-space over GF(31991) with coordinates [x, y, z, u, v]\ndefined by ideal with 4 generators\n\njulia> dim(X)\n2\n\njulia> codim(X)\n2\n\njulia> is_linearly_normal(X)\ntrue\n\n\n\n\n\n","category":"method"},{"location":"AlgebraicGeometry/AlgebraicVarieties/ProjectiveVariety/#Methods","page":"Projective Varieties","title":"Methods","text":"","category":"section"},{"location":"AlgebraicGeometry/AlgebraicVarieties/ProjectiveVariety/","page":"Projective Varieties","title":"Projective Varieties","text":"In addition to what is inherited from Projective Algebraic Sets and Projective schemes, we currently have:","category":"page"},{"location":"AlgebraicGeometry/AlgebraicVarieties/ProjectiveVariety/","page":"Projective Varieties","title":"Projective Varieties","text":"canonical_bundle(X::AbsProjectiveVariety)","category":"page"},{"location":"AlgebraicGeometry/AlgebraicVarieties/ProjectiveVariety/#canonical_bundle-Tuple{AbsProjectiveVariety}","page":"Projective Varieties","title":"canonical_bundle","text":"canonical_bundle(X::AbsProjectiveVariety)\n\nGiven a smooth projective variety X, return a module whose sheafification is the canonical bundle of X.\n\nnote: Note\nThe function does not check smoothness. If you are uncertain, enter is_smooth(X) first.\n\nExamples\n\njulia> R, x = graded_polynomial_ring(QQ, :x => (1:6));\n\njulia> I = ideal(R, [x[1]*x[6] - x[2]*x[5] + x[3]*x[4]]);\n\njulia> GRASSMANNIAN = variety(I);\n\njulia> Omega = canonical_bundle(GRASSMANNIAN)\nGraded submodule of R^1 with 1 generator\n  1: e[1]\nrepresented as subquotient with no relations\n\njulia> degrees_of_generators(Omega)\n1-element Vector{FinGenAbGroupElem}:\n [4]\n\njulia> R, (x, y, z) = graded_polynomial_ring(QQ,[:x, :y, :z]);\n\njulia> I = ideal(R, [y^2*z + x*y*z - x^3 - x*z^2 - z^3]);\n\njulia> ELLCurve = variety(I);\n\njulia> Omega = canonical_bundle(ELLCurve)\nGraded submodule of R^1 with 1 generator\n  1: e[1]\nrepresented as subquotient with no relations\n\njulia> degrees_of_generators(Omega)\n1-element Vector{FinGenAbGroupElem}:\n [0]\n\njulia> X = bordiga()\nProjective variety\n  in projective 4-space over GF(31991) with coordinates [x, y, z, u, v]\ndefined by ideal with 4 generators\n\njulia> dim(X)\n2\n\njulia> codim(X)\n2\n\njulia> Omega = canonical_bundle(X);\n\njulia> typeof(Omega)\nSubquoModule{MPolyDecRingElem{fpFieldElem, fpMPolyRingElem}}\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/number_fields/elements/","page":"Element operations","title":"Element operations","text":"CurrentModule = Hecke\nDocTestSetup = quote\n    using Hecke\n  end","category":"page"},{"location":"Hecke/manual/number_fields/elements/#Element-operations","page":"Element operations","title":"Element operations","text":"","category":"section"},{"location":"Hecke/manual/number_fields/elements/#Creation","page":"Element operations","title":"Creation","text":"","category":"section"},{"location":"Hecke/manual/number_fields/elements/","page":"Element operations","title":"Element operations","text":"gen(::SimpleNumField)\ngens(::NonSimpleNumField)","category":"page"},{"location":"Hecke/manual/number_fields/elements/#gen-Tuple{SimpleNumField}","page":"Element operations","title":"gen","text":"gen(L::SimpleNumField) -> NumFieldElem\n\nGiven a simple number field L = Kx(f) over K, this functions returns the class of x, which is the canonical primitive element of L over K.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/number_fields/elements/#gens-Tuple{NonSimpleNumField}","page":"Element operations","title":"gens","text":"gens(L::NonSimpleNumField) -> Vector{NumFieldElem}\n\nGiven a non-simple number field L = Kx_1dotscx_n(f_1dotscf_n) over K, this functions returns the list bar x_1dotscbar x_n.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/number_fields/elements/","page":"Element operations","title":"Element operations","text":"Elements can also be created by specifying the coordinates with respect to the basis of the number field:","category":"page"},{"location":"Hecke/manual/number_fields/elements/","page":"Element operations","title":"Element operations","text":"    (L::number_field)(c::Vector{NumFieldElem}) -> NumFieldElem","category":"page"},{"location":"Hecke/manual/number_fields/elements/","page":"Element operations","title":"Element operations","text":"Given a number field LK of degree d and a vector c length d, this constructs the element a with coordinates(a) == c.","category":"page"},{"location":"Hecke/manual/number_fields/elements/","page":"Element operations","title":"Element operations","text":"julia> Qx, x = QQ[\"x\"];\n\njulia> K, a = number_field(x^2 - 2, \"a\");\n\njulia> K([1, 2])\n2*a + 1\n\njulia> L, b = radical_extension(3, a, \"b\")\n(Relative number field of degree 3 over number field, b)\n\njulia> L([a, 1, 1//2])\n1//2*b^2 + b + a","category":"page"},{"location":"Hecke/manual/number_fields/elements/","page":"Element operations","title":"Element operations","text":"quadratic_defect(a::NumFieldElem, p)\nhilbert_symbol(a::AbsSimpleNumFieldElem, b::AbsSimpleNumFieldElem, p::Union{AbsNumFieldOrderIdeal, RelNumFieldOrderIdeal})\nrepresentation_matrix(::NumFieldElem)\nbasis_matrix(::Vector{AbsSimpleNumFieldElem})\ncoefficients(::SimpleNumFieldElem)\ncoordinates(::NumFieldElem)\nabsolute_coordinates(::NumFieldElem)\ncoeff(::SimpleNumFieldElem, ::Int)\nvaluation(::NumFieldElem, ::Any)\ntorsion_unit_order(::AbsSimpleNumFieldElem, ::Int)\ntr(::NumFieldElem)\nabsolute_tr(::NumFieldElem)\nalgebraic_split(::AbsSimpleNumFieldElem)","category":"page"},{"location":"Hecke/manual/number_fields/elements/#quadratic_defect-Tuple{NumFieldElem, Any}","page":"Element operations","title":"quadratic_defect","text":"quadratic_defect(a::Union{NumFieldElem,Rational,QQFieldElem}, p) -> Union{Inf, PosInf}\n\nReturns the valuation of the quadratic defect of the element a at p, which can either be prime object or an infinite place of the parent of a.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/number_fields/elements/#hilbert_symbol-Tuple{AbsSimpleNumFieldElem, AbsSimpleNumFieldElem, Union{AbsNumFieldOrderIdeal, Hecke.RelNumFieldOrderIdeal}}","page":"Element operations","title":"hilbert_symbol","text":"hilbert_symbol(a::NumFieldElem, b::NumFieldElem, p::AbsNumFieldOrderIdeal{AbsSimpleNumField, AbsSimpleNumFieldElem}) -> Int\n\nReturns the local Hilbert symbol (ab)_p.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/number_fields/elements/#representation_matrix-Tuple{NumFieldElem}","page":"Element operations","title":"representation_matrix","text":"representation_matrix(a::NumFieldElem) -> MatElem\n\nReturns the representation matrix of a, that is, the matrix representing multiplication with a with respect to the canonical basis of the parent of a.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/number_fields/elements/#basis_matrix-Tuple{Vector{AbsSimpleNumFieldElem}}","page":"Element operations","title":"basis_matrix","text":"basis_matrix(v::Vector{NumFieldElem}) -> Mat\n\nGiven a vector v of n elements of a number field K of degree d, this function returns an n times d matrix with entries in the base field of K, where row i contains the coefficients of vi with respect of the canonical basis of K.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/number_fields/elements/#coefficients-Tuple{SimpleNumFieldElem}","page":"Element operations","title":"coefficients","text":"coefficients(a::SimpleNumFieldElem, i::Int) -> Vector{FieldElem}\n\nGiven a number field element a of a simple number field extension L/K, this function returns the coefficients of a, when expanded in the canonical power basis of L.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/number_fields/elements/#coordinates-Tuple{NumFieldElem}","page":"Element operations","title":"coordinates","text":"coordinates(x::NumFieldElem{T}) -> Vector{T}\n\nGiven an element x in a number field K, this function returns the coordinates of x with respect to the basis of K (the output of the 'basis' function).\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/number_fields/elements/#absolute_coordinates-Tuple{NumFieldElem}","page":"Element operations","title":"absolute_coordinates","text":"absolute_coordinates(x::NumFieldElem{T}) -> Vector{T}\n\nGiven an element x in a number field K, this function returns the coordinates of x with respect to the basis of K over the rationals (the output of the absolute_basis function).\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/number_fields/elements/#coeff-Tuple{SimpleNumFieldElem, Int64}","page":"Element operations","title":"coeff","text":"coeff(a::SimpleNumFieldElem, i::Int) -> FieldElem\n\nGiven a number field element a of a simple number field extension L/K, this function returns the i-th coefficient of a, when expanded in the canonical power basis of L. The result is an element of K.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/number_fields/elements/#valuation-Tuple{NumFieldElem, Any}","page":"Element operations","title":"valuation","text":"valuation(a::NumFieldElem, p::AbsNumFieldOrderIdeal{AbsSimpleNumField, AbsSimpleNumFieldElem}) -> ZZRingElem\n\nComputes the mathfrak p-adic valuation of a, that is, the largest i such that a is contained in mathfrak p^i.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/number_fields/elements/#torsion_unit_order-Tuple{AbsSimpleNumFieldElem, Int64}","page":"Element operations","title":"torsion_unit_order","text":"torsion_unit_order(x::AbsSimpleNumFieldElem, n::Int)\n\nGiven a torsion unit x together with a multiple n of its order, compute the order of x, that is, the smallest k in mathbb Z_geq 1 such that x^k = 1.\n\nIt is not checked whether x is a torsion unit.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/number_fields/elements/#tr-Tuple{NumFieldElem}","page":"Element operations","title":"tr","text":"tr(a::NumFieldElem) -> NumFieldElem\n\nReturns the trace of an element a of a number field extension LK. This will be an element of K.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/number_fields/elements/#absolute_tr-Tuple{NumFieldElem}","page":"Element operations","title":"absolute_tr","text":"absolute_tr(a::NumFieldElem) -> QQFieldElem\n\nGiven a number field element a, returns the absolute trace of a.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/number_fields/elements/#algebraic_split-Tuple{AbsSimpleNumFieldElem}","page":"Element operations","title":"algebraic_split","text":"algebraic_split(a::AbsSimpleNumFieldElem) -> AbsSimpleNumFieldElem, AbsSimpleNumFieldElem\n\nWrites the input as a quotient of two \"small\" algebraic integers.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/number_fields/elements/#Conjugates","page":"Element operations","title":"Conjugates","text":"","category":"section"},{"location":"Hecke/manual/number_fields/elements/","page":"Element operations","title":"Element operations","text":"conjugates(::NumFieldElem, ::AcbField)\nconjugates(::NumFieldElem)\nconjugates_log(::AbsSimpleNumFieldElem, ::Int)\nconjugates_real(::AbsSimpleNumFieldElem)\nconjugates_complex(::AbsSimpleNumFieldElem)\nconjugates_arb_log_normalise(::AbsSimpleNumFieldElem)\nminkowski_map(::AbsSimpleNumFieldElem)","category":"page"},{"location":"Hecke/manual/number_fields/elements/#conjugates-Tuple{NumFieldElem, AcbField}","page":"Element operations","title":"conjugates","text":"conjugates(x::AbsSimpleNumFieldElem, C::AcbField) -> Vector{AcbFieldElem}\n\nCompute the conjugates of x as elements of type AcbFieldElem. Recall that we order the complex conjugates sigma_r+1(x)sigma_r+2s(x) such that sigma_i(x) = overlinesigma_i + s(x) for r + 1 leq i leq r + s.\n\nLet p be the precision of C, then every entry y of the vector returned satisfies radius(real(y)) < 2^-p and radius(imag(y)) < 2^-p respectively.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/number_fields/elements/#conjugates-Tuple{NumFieldElem}","page":"Element operations","title":"conjugates","text":"conjugates(x::AbsSimpleNumFieldElem, abs_tol::Int) -> Vector{AcbFieldElem}\n\nCompute the conjugates of x as elements of type AcbFieldElem. Recall that we order the complex conjugates sigma_r+1(x)sigma_r+2s(x) such that sigma_i(x) = overlinesigma_i + s(x) for r + 1 leq i leq r + s.\n\nEvery entry y of the vector returned satisfies radius(real(y)) < 2^-abs_tol and radius(imag(y)) < 2^-abs_tol respectively.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/number_fields/elements/#conjugates_log-Tuple{AbsSimpleNumFieldElem, Int64}","page":"Element operations","title":"conjugates_log","text":"conjugates_arb_log(x::AbsSimpleNumFieldElem, abs_tol::Int) -> Vector{ArbFieldElem}\n\nReturns the elements (log(lvert sigma_1(x) rvert)dotsclog(lvertsigma_r(x) rvert) dotsc2log(lvert sigma_r+1(x) rvert)dotsc 2log(lvert sigma_r+s(x)rvert)) as elements of type ArbFieldElem with radius less then 2^-abs_tol.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/number_fields/elements/#conjugates_real-Tuple{AbsSimpleNumFieldElem}","page":"Element operations","title":"conjugates_real","text":"conjugates_arb_real(x::AbsSimpleNumFieldElem, abs_tol::Int) -> Vector{ArbFieldElem}\n\nCompute the real conjugates of x as elements of type ArbFieldElem.\n\nEvery entry y of the array returned satisfies radius(y) < 2^-abs_tol.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/number_fields/elements/#conjugates_complex-Tuple{AbsSimpleNumFieldElem}","page":"Element operations","title":"conjugates_complex","text":"conjugates_complex(x::AbsSimpleNumFieldElem, abs_tol::Int) -> Vector{AcbFieldElem}\n\nCompute the complex conjugates of x as elements of type AcbFieldElem. Recall that we order the complex conjugates sigma_r+1(x)sigma_r+2s(x) such that sigma_i(x) = overlinesigma_i + s(x) for r + 1 leq i leq r + s.\n\nEvery entry y of the array returned satisfies radius(real(y)) < 2^-abs_tol and radius(imag(y)) < 2^-abs_tol.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/number_fields/elements/#conjugates_arb_log_normalise-Tuple{AbsSimpleNumFieldElem}","page":"Element operations","title":"conjugates_arb_log_normalise","text":"conjugates_arb_log_normalise(x::AbsSimpleNumFieldElem, p::Int = 10)\nconjugates_arb_log_normalise(x::FacElem{AbsSimpleNumFieldElem, AbsSimpleNumField}, p::Int = 10)\n\nThe \"normalised\" logarithms, i.e. the array c_ilog x^(i) - 1nlogN(x), so the (weighted) sum adds up to zero.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/number_fields/elements/#minkowski_map-Tuple{AbsSimpleNumFieldElem}","page":"Element operations","title":"minkowski_map","text":"minkowski_map(a::AbsSimpleNumFieldElem, abs_tol::Int) -> Vector{ArbFieldElem}\n\nReturns the image of a under the Minkowski embedding. Every entry of the array returned is of type ArbFieldElem with radius less then 2^(-abs_tol).\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/number_fields/elements/#Predicates","page":"Element operations","title":"Predicates","text":"","category":"section"},{"location":"Hecke/manual/number_fields/elements/","page":"Element operations","title":"Element operations","text":"is_integral(::NumFieldElem)\nis_torsion_unit(::AbsSimpleNumFieldElem)\nis_local_norm(::NumField, ::NumFieldElem, ::Any)\nis_norm_divisible(::AbsSimpleNumFieldElem, ::ZZRingElem)\nis_norm(::AbsSimpleNumField, ::ZZRingElem)","category":"page"},{"location":"Hecke/manual/number_fields/elements/#is_integral-Tuple{NumFieldElem}","page":"Element operations","title":"is_integral","text":"is_integral(a::NumFieldElem) -> Bool\n\nReturns whether a is integral, that is, whether the minimal polynomial of a has integral coefficients.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/number_fields/elements/#is_torsion_unit-Tuple{AbsSimpleNumFieldElem}","page":"Element operations","title":"is_torsion_unit","text":"is_torsion_unit(x::AbsSimpleNumFieldElem, checkisunit::Bool = false) -> Bool\n\nReturns whether x is a torsion unit, that is, whether there exists n such that x^n = 1.\n\nIf checkisunit is true, it is first checked whether x is a unit of the maximal order of the number field x is lying in.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/number_fields/elements/#is_local_norm-Tuple{NumField, NumFieldElem, Any}","page":"Element operations","title":"is_local_norm","text":"is_local_norm(L::NumField, a::NumFieldElem, P)\n\nGiven a number field LK, an element a in K and a prime ideal P of K, returns whether a is a local norm at P.\n\nThe number field LK must be a simple extension of degree 2.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/number_fields/elements/#is_norm_divisible-Tuple{AbsSimpleNumFieldElem, ZZRingElem}","page":"Element operations","title":"is_norm_divisible","text":"is_norm_divisible(a::AbsSimpleNumFieldElem, n::ZZRingElem) -> Bool\n\nChecks if the norm of a is divisible by n, assuming that the norm of a is an integer.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/number_fields/elements/#is_norm-Tuple{AbsSimpleNumField, ZZRingElem}","page":"Element operations","title":"is_norm","text":"is_norm(K::AbsSimpleNumField, a::ZZRingElem; extra::Vector{ZZRingElem}) -> Bool, AbsSimpleNumFieldElem\n\nFor a ZZRingElem a, try to find T in K s.th. N(T) = a holds. If successful, return true and T, otherwise false and some element. In \\testtt{extra} one can pass in additional prime numbers that are allowed to occur in the solution. This will then be supplemented. The element will be returned in factored form.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/number_fields/elements/#Invariants","page":"Element operations","title":"Invariants","text":"","category":"section"},{"location":"Hecke/manual/number_fields/elements/","page":"Element operations","title":"Element operations","text":"norm(::NumFieldElem)\nabsolute_norm(::NumFieldElem)\nminpoly(::NumFieldElem)\nabsolute_minpoly(::NumFieldElem)\ncharpoly(::NumFieldElem)\nabsolute_charpoly(::NumFieldElem)\nnorm(::NumFieldElem, ::NumField)","category":"page"},{"location":"Hecke/manual/number_fields/elements/#norm-Tuple{NumFieldElem}","page":"Element operations","title":"norm","text":"norm(a::NumFieldElem) -> NumFieldElem\n\nReturns the norm of an element a of a number field extension LK. This will be an element of K.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/number_fields/elements/#absolute_norm-Tuple{NumFieldElem}","page":"Element operations","title":"absolute_norm","text":"absolute_norm(a::NumFieldElem) -> QQFieldElem\n\nGiven a number field element a, returns the absolute norm of a.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/number_fields/elements/#minpoly-Tuple{NumFieldElem}","page":"Element operations","title":"minpoly","text":"minpoly(a::NumFieldElem) -> PolyRingElem\n\nGiven a number field element a of a number field K, this function returns the minimal polynomial of a over the base field of K.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/number_fields/elements/#absolute_minpoly-Tuple{NumFieldElem}","page":"Element operations","title":"absolute_minpoly","text":"absolute_minpoly(a::NumFieldElem) -> PolyRingElem\n\nGiven a number field element a of a number field K, this function returns the minimal polynomial of a over the rationals mathbfQ.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/number_fields/elements/#charpoly-Tuple{NumFieldElem}","page":"Element operations","title":"charpoly","text":"charpoly(a::NumFieldElem) -> PolyRingElem\n\nGiven a number field element a of a number field K, this function returns the characteristic polynomial of a over the base field of K.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/number_fields/elements/#absolute_charpoly-Tuple{NumFieldElem}","page":"Element operations","title":"absolute_charpoly","text":"absolute_charpoly(a::NumFieldElem) -> PolyRingElem\n\nGiven a number field element a of a number field K, this function returns the characteristic polynomial of a over the rationals mathbfQ.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/number_fields/elements/#norm-Tuple{NumFieldElem, NumField}","page":"Element operations","title":"norm","text":"norm(a::NumFieldElem, k::NumField) -> NumFieldElem\n\nReturns the norm of an element a of a number field L with respect to a subfield k of L. This will be an element of k.\n\n\n\n\n\n","category":"method"},{"location":"Groups/action/","page":"Group actions","title":"Group actions","text":"CurrentModule = Oscar\nDocTestSetup = Oscar.doctestsetup()","category":"page"},{"location":"Groups/action/#Group-actions","page":"Group actions","title":"Group actions","text":"","category":"section"},{"location":"Groups/action/","page":"Group actions","title":"Group actions","text":"A group action of a group G on a set Omega (from the right) is defined by a map muOmegatimes Gto Omega that satisfies the compatibility conditions mu(mu(xg)h) = mu(x gh) and mu(x 1_G) = x for all xinOmega.","category":"page"},{"location":"Groups/action/","page":"Group actions","title":"Group actions","text":"The maps mu are implemented as functions that take two arguments, an element x of Omega and a group element g, and return the image of x under g.","category":"page"},{"location":"Groups/action/","page":"Group actions","title":"Group actions","text":"In many cases, a natural action is given by the types of the elements in Omega and in G. For example permutation groups act on positive integers by just applying the permutations. In such situations, the function ^ can be used as action function, and ^ is taken as the default whenever no other function is prescribed.","category":"page"},{"location":"Groups/action/","page":"Group actions","title":"Group actions","text":"However, the action is not always determined by the types of the involved objects. For example, permutations can act on vectors of positive integers by applying the permutations pointwise, or by permuting the entries; matrices can act on vectors by multiplying the vector with the matrix, or by multiplying the inverse of the matrix with the vector; and of course one can construct new custom actions in situations where default actions are already available.","category":"page"},{"location":"Groups/action/","page":"Group actions","title":"Group actions","text":"Thus it is in general necessary to specify the action function explicitly, see the following sections.","category":"page"},{"location":"Groups/action/#Common-actions-of-group-elements","page":"Group actions","title":"Common actions of group elements","text":"","category":"section"},{"location":"Groups/action/","page":"Group actions","title":"Group actions","text":"on_tuples\non_sets\npermuted\non_indeterminates\non_lines\non_echelon_form_mats\non_subgroups","category":"page"},{"location":"Groups/action/#on_tuples","page":"Group actions","title":"on_tuples","text":"on_tuples(tuple::GapObj, x::GAPGroupElem)\non_tuples(tuple::Vector, x::GAPGroupElem)\non_tuples(tuple::T, x::GAPGroupElem) where T <: Tuple\n\nReturn the image of tuple under x, where the action is given by applying ^ to the entries of tuple.\n\nFor Vector and Tuple objects, one can also call ^ instead of on_tuples.\n\nExamples\n\njulia> g = symmetric_group(3);  g[1]\n(1,2,3)\n\njulia> l = GapObj([1, 2, 4])\nGAP: [ 1, 2, 4 ]\n\njulia> on_tuples(l, g[1])\nGAP: [ 2, 3, 4 ]\n\njulia> on_tuples([1, 2, 4], g[1])\n3-element Vector{Int64}:\n 2\n 3\n 4\n\njulia> on_tuples((1, 2, 4), g[1])\n(2, 3, 4)\n\njulia> (1, 2, 4)^g[1]\n(2, 3, 4)\n\n\n\n\n\n","category":"function"},{"location":"Groups/action/#on_sets","page":"Group actions","title":"on_sets","text":"on_sets(set::GapObj, x::GAPGroupElem)\non_sets(set::Vector, x::GAPGroupElem)\non_sets(set::Tuple, x::GAPGroupElem)\non_sets(set::AbstractSet, x::GAPGroupElem)\n\nReturn the image of set under x, where the action is given by applying ^ to the entries of set, and then turning the result into a sorted vector/tuple or a set, respectively.\n\nFor Set objects, one can also call ^ instead of on_sets.\n\nExamples\n\njulia> g = symmetric_group(3);  g[1]\n(1,2,3)\n\njulia> l = GapObj([1, 3])\nGAP: [ 1, 3 ]\n\njulia> on_sets(l, g[1])\nGAP: [ 1, 2 ]\n\njulia> on_sets([1, 3], g[1])\n2-element Vector{Int64}:\n 1\n 2\n\njulia> on_sets((1, 3), g[1])\n(1, 2)\n\njulia> on_sets(Set([1, 3]), g[1])\nSet{Int64} with 2 elements:\n  2\n  1\n\njulia> BitSet([1, 3])^g[1]\nBitSet with 2 elements:\n  1\n  2\n\n\n\n\n\n","category":"function"},{"location":"Groups/action/#permuted","page":"Group actions","title":"permuted","text":"permuted(pnt::GapObj, x::PermGroupElem)\npermuted(pnt::Vector, x::PermGroupElem)\npermuted(pnt::Tuple, x::PermGroupElem)\n\nReturn the image of pnt under x, where the action is given by permuting the entries of pnt with x.\n\nExamples\n\njulia> g = symmetric_group(3);  g[1]\n(1,2,3)\n\njulia> a = [\"a\", \"b\", \"c\"]\n3-element Vector{String}:\n \"a\"\n \"b\"\n \"c\"\n\njulia> permuted(a, g[1])\n3-element Vector{String}:\n \"c\"\n \"a\"\n \"b\"\n\njulia> permuted((\"a\", \"b\", \"c\"), g[1])\n(\"c\", \"a\", \"b\")\n\njulia> l = GapObj(a; recursive = true)\nGAP: [ \"a\", \"b\", \"c\" ]\n\njulia> permuted(l, g[1])\nGAP: [ \"c\", \"a\", \"b\" ]\n\n\n\n\n\n","category":"function"},{"location":"Groups/action/#on_indeterminates","page":"Group actions","title":"on_indeterminates","text":"on_indeterminates(f::GapObj, p::PermGroupElem)\non_indeterminates(f::MPolyRingElem, p::PermGroupElem)\non_indeterminates(f::FreeAssociativeAlgebraElem, p::PermGroupElem)\non_indeterminates(f::MPolyIdeal, p::PermGroupElem)\n\nReturn the image of f under p where p acts via permuting the indeterminates.\n\nFor MPolyRingElem, FreeAssociativeAlgebraElem, and MPolyIdeal objects, one can also call ^ instead of on_indeterminates.\n\nExamples\n\njulia> g = symmetric_group(3);  p = g[1]\n(1,2,3)\n\njulia> R, x = polynomial_ring(QQ, [:x1, :x2, :x3]);\n\njulia> f = x[1]*x[2] + x[2]*x[3]\nx1*x2 + x2*x3\n\njulia> f^p\nx1*x3 + x2*x3\n\njulia> x = [GAP.Globals.X(GAP.Globals.Rationals, i) for i in 1:3];\n\njulia> f = x[1]*x[2] + x[2]*x[3]\nGAP: x_1*x_2+x_2*x_3\n\njulia> on_indeterminates(f, p)\nGAP: x_1*x_3+x_2*x_3\n\n\n\n\n\non_indeterminates(f::GapObj, p::MatrixGroupElem)\non_indeterminates(f::MPolyRingElem{T}, p::MatrixGroupElem{T}) where T\non_indeterminates(f::MPolyIdeal, p::MatrixGroupElem)\n\nReturn the image of f under p where p acts via evaluating f at the vector obtained by multiplying p with the (column) vector of indeterminates. This corresponds to considering the variables of the polynomial ring containing f as the basis of a vector space on which p acts by multiplication from the right.\n\nFor MPolyRingElem and MPolyIdeal objects, one can also call ^ instead of on_indeterminates.\n\nExamples\n\njulia> g = general_linear_group(2, 5);  m = g[2]\n[4   1]\n[4   0]\n\njulia> R, x = polynomial_ring(base_ring(g), degree(g));\n\njulia> f = x[1]*x[2] + x[1]\nx1*x2 + x1\n\njulia> f^m\nx1^2 + 4*x1*x2 + 4*x1 + x2\n\n\n\n\n\n","category":"function"},{"location":"Groups/action/#on_lines","page":"Group actions","title":"on_lines","text":"on_lines(line::GapObj, x::GAPGroupElem)\non_lines(line::AbstractAlgebra.Generic.FreeModuleElem, x::GAPGroupElem)\n\nReturn the image of the nonzero vector line under x, where the action is given by first computing line * x and then normalizing the result by scalar multiplication from the left such that the first nonzero entry is the one of the base_ring of line.\n\nExamples\n\njulia> n = 2;  F = GF(5);  g = general_linear_group(n, F);\n\njulia> v = gen(free_module(F, n), 1)\n(1, 0)\n\njulia> m = gen(g, 2)\n[4   1]\n[4   0]\n\njulia> v * m\n(4, 1)\n\njulia> on_lines(v, m)\n(1, 4)\n\n\n\n\n\n","category":"function"},{"location":"Groups/action/#on_echelon_form_mats","page":"Group actions","title":"on_echelon_form_mats","text":"on_echelon_form_mats(m::MatElem{T}, x::MatrixGroupElem) where T <: FinFieldElem\n\nReturn the image of m under x, where the action is given by first computing the product m * x and then normalizing the result by computing its reduced row echelon form with echelon_form.\n\nIdentifying m with the subspace of the natural module for the group of x that is generated by the rows of m, on_echelon_form_mats describes the action on subspaces of this natural module. Note that for computing the orbit and stabilizer of m w.r.t. on_echelon_form_mats, m must be in reduced row echelon form.\n\nExamples\n\njulia> n = 3;  q = 2;  F = GF(q);  V = free_module(F, n);\n\njulia> G = GL(n, F);\n\njulia> W, embW = sub(V, [gen(V,1), gen(V,3)])\n(Subspace over F with 2 generators and no relations, Hom: W -> V)\n\njulia> m = matrix(embW)\n[1   0   0]\n[0   0   1]\n\njulia> S, _ = stabilizer(G, m, on_echelon_form_mats);  order(S)\n24\n\njulia> orb = orbit(G, on_echelon_form_mats, m);  length(orb)\n7\n\n\n\n\n\n","category":"function"},{"location":"Groups/action/#on_subgroups","page":"Group actions","title":"on_subgroups","text":"on_subgroups(x::GapObj, g::GAPGroupElem) -> GapObj\non_subgroups(x::T, g::GAPGroupElem) where T <: GAPGroup -> T\n\nReturn the image of the group x under g. Note that x must be a subgroup of the domain of g.\n\nExamples\n\njulia> C = cyclic_group(20)\nPc group of order 20\n\njulia> S = automorphism_group(C)\nAut( <pc group of size 20 with 3 generators> )\n\njulia> H, _ = sub(C, [gens(C)[1]^4])\n(Sub-pc group of order 5, Hom: H -> C)\n\njulia> all(g -> on_subgroups(H, g) == H, S)\ntrue\n\n\n\n\n\n","category":"function"},{"location":"Groups/action/#G-Sets","page":"Group actions","title":"G-Sets","text":"","category":"section"},{"location":"Groups/action/","page":"Group actions","title":"Group actions","text":"The idea behind G-sets is to have objects that encode the permutation action induced by a group (that need not be a permutation group) on a given set. A G-set provides an explicit bijection between the elements of the set and the corresponding set of positive integers on which the induced permutation group acts, see action_homomorphism(Omega::GSetByElements{T}) where T<:GAPGroup. Note that the explicit elements of a G-set Omega can be obtained using collect(Omega).","category":"page"},{"location":"Groups/action/","page":"Group actions","title":"Group actions","text":"gset(G::Union{GAPGroup, FinGenAbGroup}, fun::Function, Omega)\npermutation\nacting_group(Omega::GSetByElements)\naction_function(Omega::GSetByElements)\naction_homomorphism(Omega::GSetByElements{T}) where T<:GAPGroup\nis_conjugate(Omega::GSet, omega1, omega2)\nis_conjugate_with_data(Omega::GSet, omega1, omega2)\norbit(Omega::GSetByElements{<:GAPGroup, S}, omega::S) where S\norbit(G::PermGroup, omega)\norbits(Omega::T) where T <: GSetByElements{TG} where TG <: GAPGroup","category":"page"},{"location":"Groups/action/#gset-Tuple{Union{FinGenAbGroup, Oscar.GAPGroup}, Function, Any}","page":"Group actions","title":"gset","text":"gset(G::Union{GAPGroup, FinGenAbGroup}[, fun::Function], seeds, closed::Bool = false, check::Bool = true)\n\nReturn the G-set Omega that consists of the closure of the seeds seeds under the action of G defined by fun.\n\nThis means that Omega contains all elements fun(omega, g) for omega in seeds and g in G.\n\nfun can be omitted if the element type of seeds implies a reasonable default, for example, if G is a PermGroup and seeds is a Vector{T} where T is one of Int, Set{Int}, Vector{Int}.\n\nIf check is set to false then it is not checked whether the entries of seeds are valid as the first argument of fun.\n\nIf closed is set to true then seeds is assumed to be closed under the action of G. In this case, collect(Omega) is guaranteed to be equal to collect(seeds); in particular, the ordering of points in seeds (if applicable) is kept. Note that the indexing of points in Omega is used by action_homomorphism.\n\nExamples\n\njulia> G = symmetric_group(4);\n\njulia> length(gset(G, [1]))  # natural action\n4\n\njulia> length(gset(G, [[1, 2]]))  # action on ordered pairs\n12\n\njulia> length(gset(G, on_sets, [[1, 2]]))  # action on unordered pairs\n6\n\n\n\n\n\n","category":"method"},{"location":"Groups/action/#permutation","page":"Group actions","title":"permutation","text":"permutation(Omega::GSetByElements{T}, g::BasicGAPGroupElem{T}) where T<:GAPGroup\n\nReturn the element of the permutation group that describes the action of g on Omega, where g is an element of acting_group(Omega).\n\nExamples\n\njulia> G = symmetric_group(4);\n\njulia> Omega = gset(G, [[1, 2]]);\n\njulia> x = gen(G, 1)\n(1,2,3,4)\n\njulia> permutation(Omega, x)\n(1,2,4,7)(3,6,9,12)(5,8,10,11)\n\n\n\n\n\n","category":"function"},{"location":"Groups/action/#acting_group-Tuple{Oscar.GSetByElements}","page":"Group actions","title":"acting_group","text":"acting_group(Omega::GSetByElements)\n\nReturn the group G acting on Omega.\n\nExamples\n\njulia> G = symmetric_group(4);\n\njulia> acting_group(gset(G, [1])) == G\ntrue\n\n\n\n\n\n","category":"method"},{"location":"Groups/action/#action_function-Tuple{Oscar.GSetByElements}","page":"Group actions","title":"action_function","text":"action_function(Omega::GSetByElements)\n\nReturn the function f Omega times G to Omega that defines the G-set.\n\nExamples\n\njulia> G = symmetric_group(4);\n\njulia> action_function(gset(G, [1])) == ^\ntrue\n\njulia> action_function(gset(G, [[1, 2]])) == on_tuples\ntrue\n\njulia> action_function(gset(G, on_sets, [[1, 2]])) == on_sets\ntrue\n\n\n\n\n\n","category":"method"},{"location":"Groups/action/#action_homomorphism-Union{Tuple{Oscar.GSetByElements{T}}, Tuple{T}} where T<:Oscar.GAPGroup","page":"Group actions","title":"action_homomorphism","text":"action_homomorphism(Omega::GSetByElements{T}) where T<:GAPGroup\n\nReturn the group homomorphism act with domain G = acting_group(Omega) and codomain symmetric_group(n) that describes the permutation action of G on Omega, where Omega has n elements.\n\nThis means that if an element g in G maps collect(Omega)[i] to collect(Omega)[j] then act(g) maps i to j.\n\nExamples\n\njulia> G = symmetric_group(6);\n\njulia> Omega = gset(G, [Set([1, 2])]);  # action on unordered pairs\n\njulia> acthom = action_homomorphism(Omega)\nGroup homomorphism\n  from Sym(6)\n  to Sym(15)\n\njulia> g = gen(G, 1)\n(1,2,3,4,5,6)\n\njulia> elms = collect(Omega);\n\njulia> actg = acthom(g)\n(1,2,3,5,7,10)(4,6,8,11,14,13)(9,12,15)\n\njulia> elms[1]^g == elms[2]\ntrue\n\njulia> 1^actg == 2\ntrue\n\n\n\n\n\n","category":"method"},{"location":"Groups/action/#is_conjugate-Tuple{GSet, Any, Any}","page":"Group actions","title":"is_conjugate","text":"is_conjugate(Omega::GSet, omega1, omega2)\n\nReturn true if omega1, omega2 are in the same orbit of Omega, and false otherwise. To also obtain a conjugating element use is_conjugate_with_data.\n\nExamples\n\njulia> G = sylow_subgroup(symmetric_group(6), 2)[1]\nPermutation group of degree 6 and order 16\n\njulia> Omega = gset(G);\n\njulia> is_conjugate(Omega, 1, 2)\ntrue\n\njulia> is_conjugate(Omega, 1, 5)\nfalse\n\n\n\n\n\n","category":"method"},{"location":"Groups/action/#is_conjugate_with_data-Tuple{GSet, Any, Any}","page":"Group actions","title":"is_conjugate_with_data","text":"is_conjugate_with_data(Omega::GSet, omega1, omega2)\n\nDetermine whether omega1, omega2 are in the same orbit of Omega. If yes, return (true, g) where g is an element in the group G of Omega that maps omega1 to omega2. If not, return (false, nothing). If the conjugating element g is not needed, use is_conjugate.\n\nExamples\n\njulia> G = sylow_subgroup(symmetric_group(6), 2)[1]\nPermutation group of degree 6 and order 16\n\njulia> Omega = gset(G);\n\njulia> is_conjugate_with_data(Omega, 1, 2)\n(true, (1,2))\n\njulia> is_conjugate_with_data(Omega, 1, 5)\n(false, ())\n\n\n\n\n\n","category":"method"},{"location":"Groups/action/#orbit-Union{Tuple{S}, Tuple{Oscar.GSetByElements{<:Oscar.GAPGroup, S}, S}} where S","page":"Group actions","title":"orbit","text":"orbit(Omega::GSet, omega)\n\nReturn the G-set that consists of the elements fun(omega, g) where g is in the group of Omega and fun is the underlying action of Omega.\n\nExamples\n\njulia> G = sylow_subgroup(symmetric_group(6), 2)[1]\nPermutation group of degree 6 and order 16\n\njulia> Omega = gset(G, [1, 5]);\n\njulia> length(orbit(Omega, 1))\n4\n\n\n\n\n\n","category":"method"},{"location":"Groups/action/#orbit-Tuple{PermGroup, Any}","page":"Group actions","title":"orbit","text":"orbit(G::Union{GAPGroup, FinGenAbGroup}[, fun::Function], omega)\n\nReturn the G-set that consists of the images of omega under the action of G defined by fun.\n\nThis means that the result contains all elements fun(omega, g) for g in G.\n\nfun can be omitted if the type of Omega implies a reasonable default, for example, if G is a PermGroup and omega is one of Int, Set{Int}, Vector{Int}.\n\nExamples\n\njulia> G = symmetric_group(4);\n\njulia> length(orbit(G, 1))\n4\n\njulia> length(orbit(G, [1, 2]))\n12\n\njulia> length(orbit(G, on_sets, [1, 2]))\n6\n\n\n\n\n\n","category":"method"},{"location":"Groups/action/#orbits-Union{Tuple{T}, Tuple{TG}} where {TG<:Oscar.GAPGroup, T<:(Oscar.GSetByElements{TG})}","page":"Group actions","title":"orbits","text":"orbits(Omega::GSet)\n\nReturn the vector of transitive G-sets in Omega.\n\nExamples\n\njulia> G = sylow_subgroup(symmetric_group(6), 2)[1]\nPermutation group of degree 6 and order 16\n\njulia> orbs = orbits(gset(G));\n\njulia> map(collect, orbs)\n2-element Vector{Vector{Int64}}:\n [1, 2, 3, 4]\n [5, 6]\n\n\n\n\n\n","category":"method"},{"location":"Groups/action/#Stabilizers","page":"Group actions","title":"Stabilizers","text":"","category":"section"},{"location":"Groups/action/","page":"Group actions","title":"Group actions","text":"stabilizer(G::GAPGroup, pnt::Any, actfun::Function)\nstabilizer(Omega::GSet)","category":"page"},{"location":"Groups/action/#stabilizer-Tuple{Oscar.GAPGroup, Any, Function}","page":"Group actions","title":"stabilizer","text":"stabilizer(G::GAPGroup, pnt::Any[, actfun::Function])\n\nReturn S, emb where S is the subgroup of G that consists of all those elements g that fix pnt under the action given by actfun, that is, actfun(pnt, g) == pnt holds, and emb is the embedding of S into G.\n\nThe default for actfun depends on the types of G and pnt: If G is a PermGroup then the default actions on integers, Vectors of  integers, and Sets of integers are given by ^, on_tuples, and on_sets, respectively. If G is a MatrixGroup then the default actions on FreeModuleElems, Vectors of them, and Sets of them are given by *, on_tuples, and on_sets, respectively.\n\nExamples\n\njulia> G = symmetric_group(5);\n\njulia> S = stabilizer(G, 1);  order(S[1])\n24\n\njulia> S = stabilizer(G, [1, 2]);  order(S[1])\n6\n\njulia> S = stabilizer(G, Set([1, 2]));  order(S[1])\n12\n\njulia> S = stabilizer(G, [1, 1, 2, 2, 3], permuted);  order(S[1])\n4\n\n\n\n\n\n","category":"method"},{"location":"Groups/action/#stabilizer-Tuple{GSet}","page":"Group actions","title":"stabilizer","text":"stabilizer(Omega::GSet{T,S})\nstabilizer(Omega::GSet{T,S}, omega::S = representative(Omega); check::Bool = true) where {T,S}\nstabilizer(Omega::GSet{T,S}, omega::Set{S}; check::Bool = true) where {T,S}\nstabilizer(Omega::GSet{T,S}, omega::Vector{S}; check::Bool = true) where {T,S}\nstabilizer(Omega::GSet{T,S}, omega::Tuple{S,Vararg{S}}; check::Bool = true) where {T,S}\n\nReturn the subgroup of G = acting_group(Omega) that fixes omega, together with the embedding of this subgroup into G.\n\nIf omega is a Set of points in Omega then stabilizer means the setwise stabilizer of the entries in omega. If omega is a Vector or a Tuple of points in Omega then stabilizer means the pointwise stabilizer of the entries in omega.\n\nIf check is false then it is not checked whether omega is in Omega.\n\nExamples\n\njulia> Omega = gset(symmetric_group(4));\n\njulia> stabilizer(Omega)\n(Permutation group of degree 4 and order 6, Hom: permutation group -> Sym(4))\n\njulia> stabilizer(Omega, [1, 2])\n(Permutation group of degree 4 and order 2, Hom: permutation group -> Sym(4))\n\n\n\n\n\n","category":"method"},{"location":"CommutativeAlgebra/ModulesOverMultivariateRings/free_modules/","page":"Free Modules","title":"Free Modules","text":"CurrentModule = Oscar\nDocTestSetup = Oscar.doctestsetup()","category":"page"},{"location":"CommutativeAlgebra/ModulesOverMultivariateRings/free_modules/#free_modules","page":"Free Modules","title":"Free Modules","text":"","category":"section"},{"location":"CommutativeAlgebra/ModulesOverMultivariateRings/free_modules/","page":"Free Modules","title":"Free Modules","text":"In this section, the expression free module  refers to a free module of finite rank over a ring of type MPolyRing, MPolyQuoRing, MPolyLocRing, or MPolyQuoLocRing. More concretely, given a ring R of one of these types, the free R-modules considered are of type R^p, where we think of R^p as a free module with a given basis, namely the basis of standard unit vectors. Accordingly, elements of free modules are represented by coordinate vectors, and homomorphisms between free modules by matrices.","category":"page"},{"location":"CommutativeAlgebra/ModulesOverMultivariateRings/free_modules/","page":"Free Modules","title":"Free Modules","text":"note: Note\nBy convention, vectors are row vectors, and matrices operate by multiplication on the right.","category":"page"},{"location":"CommutativeAlgebra/ModulesOverMultivariateRings/free_modules/#Types","page":"Free Modules","title":"Types","text":"","category":"section"},{"location":"CommutativeAlgebra/ModulesOverMultivariateRings/free_modules/","page":"Free Modules","title":"Free Modules","text":"All OSCAR types for the modules considered here belong to the abstract type ModuleFP{T}, where T is the element type of the underlying ring. Graded or not, the free modules belong to the abstract subtype AbstractFreeMod{T} <: ModuleFP{T}, they are modeled as objects of the concrete type FreeMod{T} <: AbstractFreeMod{T}.","category":"page"},{"location":"CommutativeAlgebra/ModulesOverMultivariateRings/free_modules/","page":"Free Modules","title":"Free Modules","text":"note: Note\nCanonical maps such us the canonical projection onto a quotient module arise in many  constructions in commutative algebra. The FreeMod type is designed so that it allows for the caching of such maps when executing functions. The direct_sum function discussed in this section provides an example.","category":"page"},{"location":"CommutativeAlgebra/ModulesOverMultivariateRings/free_modules/#Constructors","page":"Free Modules","title":"Constructors","text":"","category":"section"},{"location":"CommutativeAlgebra/ModulesOverMultivariateRings/free_modules/","page":"Free Modules","title":"Free Modules","text":"free_module(R::MPolyRing, n::Int, name::VarName = :e; cached::Bool = false)","category":"page"},{"location":"CommutativeAlgebra/ModulesOverMultivariateRings/free_modules/#free_module","page":"Free Modules","title":"free_module","text":"free_module(R::MPolyRing, p::Int, name::VarName = :e; cached::Bool = false)\nfree_module(R::MPolyQuoRing, p::Int, name::VarName = :e; cached::Bool = false)\nfree_module(R::MPolyLocRing, p::Int, name::VarName = :e; cached::Bool = false)\nfree_module(R::MPolyQuoLocRing, p::Int, name::VarName = :e; cached::Bool = false)\n\nReturn the free R-module R^p, created with its basis of standard unit vectors.\n\nThe string name specifies how the basis vectors are printed. \n\nExamples\n\njulia> R, (x, y, z) = polynomial_ring(QQ, [:x, :y, :z]);\n\njulia> FR = free_module(R, 2)\nFree module of rank 2 over R\n\njulia> x*FR[1]\nx*e[1]\n\njulia> P = ideal(R, [x, y, z]);\n\njulia> U = complement_of_prime_ideal(P);\n\njulia> RL, _ = localization(R, U);\n\njulia> FRL = free_module(RL, 2, \"f\")\nFree module of rank 2 over localization of R at complement of prime ideal (x, y, z)\n\njulia> RL(x)*FRL[1]\nx*f[1]\n\njulia> RQ, _ = quo(R, ideal(R, [2*x^2-y^3, 2*x^2-y^5]));\n\njulia> FRQ =  free_module(RQ, 2, \"g\")\nFree module of rank 2 over RQ\n\njulia> RQ(x)*FRQ[1]\nx*g[1]\n\njulia> RQL, _ = localization(RQ, U);\n\njulia> FRQL =  free_module(RQL, 2, \"h\")\nFree module of rank 2 over localization of RQ at complement of prime ideal\n\njulia> RQL(x)*FRQL[1]\nx*h[1]\n\n\n\n\n\n","category":"function"},{"location":"CommutativeAlgebra/ModulesOverMultivariateRings/free_modules/","page":"Free Modules","title":"Free Modules","text":"Over graded multivariate polynomial rings and their quotients,  there are two basic ways of creating graded free modules: While the grade function allows one to create a graded free module by assigning a grading to a free module already constructed, the graded_free_module function is meant to create a graded free module all at once.","category":"page"},{"location":"CommutativeAlgebra/ModulesOverMultivariateRings/free_modules/","page":"Free Modules","title":"Free Modules","text":"grade(F::FreeMod, W::Vector{FinGenAbGroupElem})","category":"page"},{"location":"CommutativeAlgebra/ModulesOverMultivariateRings/free_modules/#grade-Tuple{FreeMod, Vector{FinGenAbGroupElem}}","page":"Free Modules","title":"grade","text":"grade(F::FreeMod, W::Vector{FinGenAbGroupElem})\n\nGiven a free module F over a graded ring with grading group G, say, and given a vector W of ngens(F) elements of G, create a G-graded free module by assigning the entries of W as weights to the generators of F. Return the new module. \n\ngrade(F::FreeMod)\n\nAs above, with all weights set to zero(G).\n\nnote: Note\nThe function applies to free modules over both graded multivariate polynomial rings and their quotients.\n\nExamples\n\njulia> R, x, y = polynomial_ring(QQ, :x => 1:2, :y => 1:3);\n\njulia> G = abelian_group([0, 0])\nZ^2\n\njulia> g = gens(G)\n2-element Vector{FinGenAbGroupElem}:\n [1, 0]\n [0, 1]\n\njulia> W = [g[1], g[1], g[2], g[2], g[2]];\n\njulia> S, _ = grade(R, W)\n(Graded multivariate polynomial ring in 5 variables over QQ, MPolyDecRingElem{QQFieldElem, QQMPolyRingElem}[x[1], x[2], y[1], y[2], y[3]])\n\njulia> F = free_module(S, 3)\nFree module of rank 3 over S\n\njulia> FF = grade(F)\nGraded free module S^3([0, 0]) of rank 3 over S\n\njulia> F\nFree module of rank 3 over S\n\n\n\n\n\n","category":"method"},{"location":"CommutativeAlgebra/ModulesOverMultivariateRings/free_modules/","page":"Free Modules","title":"Free Modules","text":"grade(F::FreeMod, W::Vector{<:Vector{<:IntegerUnion}})","category":"page"},{"location":"CommutativeAlgebra/ModulesOverMultivariateRings/free_modules/#grade-Tuple{FreeMod, Vector{<:Vector{<:Union{Integer, ZZRingElem}}}}","page":"Free Modules","title":"grade","text":"grade(F::FreeMod, W::Vector{<:Vector{<:IntegerUnion}})\n\nGiven a free module F over a graded ring with grading group G = mathbb Z^m, and given a vector W of ngens(F) integer vectors of the same size m, say, define a G-grading on F  by converting the vectors in W to elements of G, and assigning these elements as weights to  the variables. Return the new module.\n\ngrade(F::FreeMod, W::Union{ZZMatrix, Matrix{<:IntegerUnion}})\n\nAs above, converting the columns of W.\n\ngrade(F::FreeMod, W::Vector{<:IntegerUnion})\n\nGiven a free module F over a graded ring with grading group G = mathbb Z, and given a vector W of ngens(F) integers, define a G-grading on F converting the entries  of W to elements of G, and assigning these elements as weights to the variables.  Return the new module.\n\nnote: Note\nThe function applies to free modules over both graded multivariate polynomial  rings and their quotients.\n\nExamples\n\njulia> R, (x, y, z) = graded_polynomial_ring(QQ, [:x, :y, :z],  [1 0 1; 0 1 1])\n(Graded multivariate polynomial ring in 3 variables over QQ, MPolyDecRingElem{QQFieldElem, QQMPolyRingElem}[x, y, z])\n\njulia> F = free_module(R, 2)\nFree module of rank 2 over R\n\njulia> FF = grade(F,  [[1, 0], [0, 1]])\nGraded free module R^1([-1 0]) + R^1([0 -1]) of rank 2 over R\n\njulia> FFF = grade(F,  [1 0; 0 1])\nGraded free module R^1([-1 0]) + R^1([0 -1]) of rank 2 over R\n\njulia> R, (x, y) = graded_polynomial_ring(QQ, [:x, :y])\n(Graded multivariate polynomial ring in 2 variables over QQ, MPolyDecRingElem{QQFieldElem, QQMPolyRingElem}[x, y])\n\njulia> S, _ = quo(R, [x*y])\n(Quotient of multivariate polynomial ring by ideal (x*y), Map: R -> S)\n\njulia> F = free_module(S, 2)\nFree module of rank 2 over S\n\njulia> FF = grade(F, [1, 2])\nGraded free module S^1([-1]) + S^1([-2]) of rank 2 over S\n\n\n\n\n\n","category":"method"},{"location":"CommutativeAlgebra/ModulesOverMultivariateRings/free_modules/","page":"Free Modules","title":"Free Modules","text":"graded_free_module(R::Ring, p::Int, W::Vector{FinGenAbGroupElem}=[grading_group(R)[0] for i in 1:p], name::String=\"e\")","category":"page"},{"location":"CommutativeAlgebra/ModulesOverMultivariateRings/free_modules/#graded_free_module","page":"Free Modules","title":"graded_free_module","text":"graded_free_module(R::AdmissibleModuleFPRing, p::Int, W::Vector{FinGenAbGroupElem}=[grading_group(R)[0] for i in 1:p], name::String=\"e\")\n\nGiven a graded ring R with grading group G, say, and given a vector W with p elements of G, create the free module R^p  equipped with its basis of standard unit vectors, and assign weights to these  vectors according to the entries of W. Return the resulting graded free module.\n\ngraded_free_module(R::AdmissibleModuleFPRing, W::Vector{FinGenAbGroupElem}, name::String=\"e\")\n\nAs above, with p = length(W).\n\nnote: Note\nThe function applies to graded multivariate polynomial rings and their quotients.\n\nThe string name specifies how the basis vectors are printed. \n\nExamples\n\njulia> R, (x,y) = graded_polynomial_ring(QQ, [:x, :y])\n(Graded multivariate polynomial ring in 2 variables over QQ, MPolyDecRingElem{QQFieldElem, QQMPolyRingElem}[x, y])\n\njulia> graded_free_module(R,3)\nGraded free module R^3([0]) of rank 3 over R\n\njulia> G = grading_group(R)\nZ\n\njulia> graded_free_module(R, [G[1], 2*G[1]])\nGraded free module R^1([-1]) + R^1([-2]) of rank 2 over R\n\n\n\n\n\n","category":"function"},{"location":"CommutativeAlgebra/ModulesOverMultivariateRings/free_modules/","page":"Free Modules","title":"Free Modules","text":"graded_free_module(R::Ring, W::Vector{<:Vector{<:IntegerUnion}}, name::String=\"e\")","category":"page"},{"location":"CommutativeAlgebra/ModulesOverMultivariateRings/free_modules/#graded_free_module-2","page":"Free Modules","title":"graded_free_module","text":"graded_free_module(R::AdmissibleModuleFPRing, W::Vector{<:Vector{<:IntegerUnion}}, name::String=\"e\")\n\nGiven a graded ring R with grading group G = mathbb Z^m,  and given a vector W of integer vectors of the same size p, say, create the free  module R^p equipped with its basis of standard unit vectors, and assign weights to these  vectors according to the entries of W, converted to elements of G. Return the  resulting graded free module.\n\ngraded_free_module(R::AdmissibleModuleFPRing, W::Union{ZZMatrix, Matrix{<:IntegerUnion}}, name::String=\"e\")\n\nAs above, converting the columns of W.\n\ngraded_free_module(R::AdmissibleModuleFPRing, W::Vector{<:IntegerUnion}, name::String=\"e\")\n\nGiven a graded ring R with grading group G = mathbb Z,  and given a vector W of integers, set p = length(W), create the free module R^p  equipped with its basis of standard unit vectors, and assign weights to these  vectors according to the entries of W, converted to elements of G. Return  the resulting graded free module.\n\nThe string name specifies how the basis vectors are printed. \n\nnote: Note\nThe function applies to graded multivariate polynomial rings and their quotients.\n\nExamples\n\njulia> R, (x,y) = graded_polynomial_ring(QQ, [:x, :y]);\n\njulia> F = graded_free_module(R, [1, 2])\nGraded free module R^1([-1]) + R^1([-2]) of rank 2 over R\n\njulia> S, (x, y, z) = graded_polynomial_ring(QQ, [:x, :y, :z], [1 0 1; 0 1 1]);\n\njulia> FF = graded_free_module(S, [[1, 2], [-1, 3]])\nGraded free module S^1([-1 -2]) + S^1([1 -3]) of rank 2 over S\n\njulia> FFF = graded_free_module(S, [1 -1; 2 3])\nGraded free module S^1([-1 -2]) + S^1([1 -3]) of rank 2 over S\n\njulia> FF == FFF\ntrue\n\n\n\n\n\n","category":"function"},{"location":"CommutativeAlgebra/ModulesOverMultivariateRings/free_modules/#Data-Associated-to-Free-Modules","page":"Free Modules","title":"Data Associated to Free Modules","text":"","category":"section"},{"location":"CommutativeAlgebra/ModulesOverMultivariateRings/free_modules/","page":"Free Modules","title":"Free Modules","text":"If F is a free R-module, then","category":"page"},{"location":"CommutativeAlgebra/ModulesOverMultivariateRings/free_modules/","page":"Free Modules","title":"Free Modules","text":"base_ring(F) refers to R,\nbasis(F), gens(F) to the basis vectors of F, \nrank(F), number_of_generators(F) / ngens(F), dim(F) to the number of these vectors, and\nF[i], basis(F, i), gen(F, i) to the i-th such vector.","category":"page"},{"location":"CommutativeAlgebra/ModulesOverMultivariateRings/free_modules/#Examples","page":"Free Modules","title":"Examples","text":"","category":"section"},{"location":"CommutativeAlgebra/ModulesOverMultivariateRings/free_modules/","page":"Free Modules","title":"Free Modules","text":"julia> R, (x, y) = polynomial_ring(QQ, [:x, :y]);\n\njulia> F = free_module(R, 3);\n\njulia> basis(F)\n3-element Vector{FreeModElem{QQMPolyRingElem}}:\n e[1]\n e[2]\n e[3]\n\njulia> rank(F)\n3","category":"page"},{"location":"CommutativeAlgebra/ModulesOverMultivariateRings/free_modules/","page":"Free Modules","title":"Free Modules","text":"In the graded case, we also have:","category":"page"},{"location":"CommutativeAlgebra/ModulesOverMultivariateRings/free_modules/","page":"Free Modules","title":"Free Modules","text":" grading_group(F::FreeMod)","category":"page"},{"location":"CommutativeAlgebra/ModulesOverMultivariateRings/free_modules/#grading_group-Tuple{FreeMod}","page":"Free Modules","title":"grading_group","text":"grading_group(F::FreeMod)\n\nReturn the grading group of base_ring(F).\n\nExamples\n\njulia> R, (x,y) = graded_polynomial_ring(QQ, [:x, :y]);\n\njulia> F = graded_free_module(R, 3)\nGraded free module R^3([0]) of rank 3 over R\n\njulia> grading_group(F)\nZ\n\n\n\n\n\n","category":"method"},{"location":"CommutativeAlgebra/ModulesOverMultivariateRings/free_modules/","page":"Free Modules","title":"Free Modules","text":"degrees_of_generators(F::FreeMod)","category":"page"},{"location":"CommutativeAlgebra/ModulesOverMultivariateRings/free_modules/#degrees_of_generators-Tuple{FreeMod}","page":"Free Modules","title":"degrees_of_generators","text":"degrees_of_generators(F::FreeMod)\n\nReturn the degrees of the generators of F.\n\nExamples\n\njulia> R, (x, y, z) = graded_polynomial_ring(QQ, [:x, :y, :z]);\n\njulia> F = graded_free_module(R, 2)\nGraded free module R^2([0]) of rank 2 over R\n\njulia> degrees_of_generators(F)\n2-element Vector{FinGenAbGroupElem}:\n [0]\n [0]\n\n\n\n\n\n","category":"method"},{"location":"CommutativeAlgebra/ModulesOverMultivariateRings/free_modules/#Elements-of-Free-Modules","page":"Free Modules","title":"Elements of Free Modules","text":"","category":"section"},{"location":"CommutativeAlgebra/ModulesOverMultivariateRings/free_modules/","page":"Free Modules","title":"Free Modules","text":"All OSCAR types for elements of the modules considered here belong to the abstract type ModuleElemFP{T}, where T is the element type of the underlying ring. The free modules belong to the abstract subtype AbstractFreeModElem{T} <: ModuleFPElem{T}. They are modeled as objects of the concrete type FreeModElem{T} <: AbstractFreeModElem{T} which implements an element f of a free module F as a sparse row, that is, as an object of type SRow{T}. This object specifies the coordinates of f with respect to the basis of standard unit vectors of F. To create an element, enter its coordinates as a sparse row or a vector: ","category":"page"},{"location":"CommutativeAlgebra/ModulesOverMultivariateRings/free_modules/","page":"Free Modules","title":"Free Modules","text":"(F::FreeMod{T})(c::SRow{T}) where T","category":"page"},{"location":"CommutativeAlgebra/ModulesOverMultivariateRings/free_modules/","page":"Free Modules","title":"Free Modules","text":"(F::FreeMod{T})(c::Vector{T}) where T","category":"page"},{"location":"CommutativeAlgebra/ModulesOverMultivariateRings/free_modules/","page":"Free Modules","title":"Free Modules","text":"Alternatively, directly write the element as a linear combination of basis vectors of F:","category":"page"},{"location":"CommutativeAlgebra/ModulesOverMultivariateRings/free_modules/#Examples-2","page":"Free Modules","title":"Examples","text":"","category":"section"},{"location":"CommutativeAlgebra/ModulesOverMultivariateRings/free_modules/","page":"Free Modules","title":"Free Modules","text":"julia> R, (x, y) = polynomial_ring(QQ, [:x, :y]);\n\njulia> F = free_module(R, 3);\n\njulia> f = F(sparse_row(R, [(1,x),(3,y)]))\nx*e[1] + y*e[3]\n\njulia> g = F([x, zero(R), y])\nx*e[1] + y*e[3]\n\njulia> h = x*F[1] + y*F[3]\nx*e[1] + y*e[3]\n\njulia> f == g == h\ntrue","category":"page"},{"location":"CommutativeAlgebra/ModulesOverMultivariateRings/free_modules/","page":"Free Modules","title":"Free Modules","text":"Given an element f  of a free module F over a multivariate polynomial ring with element type T,","category":"page"},{"location":"CommutativeAlgebra/ModulesOverMultivariateRings/free_modules/","page":"Free Modules","title":"Free Modules","text":"parent(f) refers to F, and\ncoordinates(f) to the coordinate vector of f, returned as an object of type SRow{T}.","category":"page"},{"location":"CommutativeAlgebra/ModulesOverMultivariateRings/free_modules/#Examples-3","page":"Free Modules","title":"Examples","text":"","category":"section"},{"location":"CommutativeAlgebra/ModulesOverMultivariateRings/free_modules/","page":"Free Modules","title":"Free Modules","text":"julia> R, (x, y) = polynomial_ring(QQ, [:x, :y]);\n\njulia> F = free_module(R, 3);\n\njulia> f = x*F[1] + y*F[3]\nx*e[1] + y*e[3]\n\njulia> parent(f)\nFree module of rank 3 over R\n\njulia> coordinates(f)\nSparse row with positions [1, 3] and values QQMPolyRingElem[x, y]\n","category":"page"},{"location":"CommutativeAlgebra/ModulesOverMultivariateRings/free_modules/","page":"Free Modules","title":"Free Modules","text":"The zero element of a free module is obtained as follows:","category":"page"},{"location":"CommutativeAlgebra/ModulesOverMultivariateRings/free_modules/","page":"Free Modules","title":"Free Modules","text":"zero(F::AbstractFreeMod)","category":"page"},{"location":"CommutativeAlgebra/ModulesOverMultivariateRings/free_modules/#zero-Tuple{Oscar.AbstractFreeMod}","page":"Free Modules","title":"zero","text":"zero(F::AbstractFreeMod)\n\nReturn the zero element of  F.\n\n\n\n\n\n","category":"method"},{"location":"CommutativeAlgebra/ModulesOverMultivariateRings/free_modules/","page":"Free Modules","title":"Free Modules","text":"Whether a given element of a free module is zero can be tested as follows:","category":"page"},{"location":"CommutativeAlgebra/ModulesOverMultivariateRings/free_modules/","page":"Free Modules","title":"Free Modules","text":"is_zero(f::AbstractFreeModElem)","category":"page"},{"location":"CommutativeAlgebra/ModulesOverMultivariateRings/free_modules/#is_zero-Tuple{Oscar.AbstractFreeModElem}","page":"Free Modules","title":"is_zero","text":"is_zero(f::AbstractFreeModElem)\n\nReturn true if f is zero, false otherwise.\n\n\n\n\n\n","category":"method"},{"location":"CommutativeAlgebra/ModulesOverMultivariateRings/free_modules/","page":"Free Modules","title":"Free Modules","text":"In the graded case, we additionally have:","category":"page"},{"location":"CommutativeAlgebra/ModulesOverMultivariateRings/free_modules/","page":"Free Modules","title":"Free Modules","text":"is_homogeneous(f::FreeModElem)","category":"page"},{"location":"CommutativeAlgebra/ModulesOverMultivariateRings/free_modules/#is_homogeneous-Tuple{FreeModElem}","page":"Free Modules","title":"is_homogeneous","text":"is_homogeneous(f::FreeModElem)\n\nGiven an element f of a graded free module, return true if f is homogeneous, false otherwise.\n\nExamples\n\njulia> R, (x, y, z) = graded_polynomial_ring(QQ, [:x, :y, :z], [1, 2, 3]);\n\njulia> F = free_module(R, 2)\nFree module of rank 2 over R\n\njulia> FF = grade(F, [1,4])\nGraded free module R^1([-1]) + R^1([-4]) of rank 2 over R\n\njulia> f = y^2*2*FF[1]-x*FF[2]\n2*y^2*e[1] - x*e[2]\n\njulia> is_homogeneous(f)\ntrue\n\n\n\n\n\n","category":"method"},{"location":"CommutativeAlgebra/ModulesOverMultivariateRings/free_modules/","page":"Free Modules","title":"Free Modules","text":"degree(f::FreeModElem{T}) where {T<:Union{<:MPolyDecRingElem, <:MPolyQuoRingElem{<:MPolyDecRingElem}}}","category":"page"},{"location":"CommutativeAlgebra/ModulesOverMultivariateRings/free_modules/#degree-Union{Tuple{FreeModElem{T}}, Tuple{T}} where T<:(Union{var\"#s49\", var\"#s44\"} where {var\"#s49\"<:MPolyDecRingElem, var\"#s44\"<:(MPolyQuoRingElem{<:MPolyDecRingElem})})","page":"Free Modules","title":"degree","text":"degree(f::FreeModElem{T}; check::Bool=true) where {T<:AnyGradedRingElem}\n\nGiven a homogeneous element f of a graded free module, return the degree of f.\n\ndegree(::Type{Vector{Int}}, f::FreeModElem)\n\nGiven a homogeneous element f of a mathbb Z^m-graded free module, return the degree of f, converted to a vector of integer numbers.\n\ndegree(::Type{Int}, f::FreeModElem)\n\nGiven a homogeneous element f of a mathbb Z-graded free module, return the degree of f, converted to an integer number.\n\nIf check is set to false, then there is no check for homegeneity. This should be called  internally on provably sane input, as it speeds up computation significantly. \n\nExamples\n\njulia> R, (w, x, y, z) = graded_polynomial_ring(QQ, [:w, :x, :y, :z]);\n\njulia> f = y^2*z − x^2*w\n-w*x^2 + y^2*z\n\njulia> degree(f)\n[3]\n\njulia> typeof(degree(f))\nFinGenAbGroupElem\n\njulia> degree(Int, f)\n3\n\njulia> typeof(degree(Int, f))\nInt64\n\n\n\n\n\n","category":"method"},{"location":"CommutativeAlgebra/ModulesOverMultivariateRings/free_modules/#Tests-on-Free-Modules","page":"Free Modules","title":"Tests on Free Modules","text":"","category":"section"},{"location":"CommutativeAlgebra/ModulesOverMultivariateRings/free_modules/","page":"Free Modules","title":"Free Modules","text":"The tests is_graded, is_standard_graded, is_z_graded, and is_zm_graded carry over analogously to free modules. They return true if the corresponding property is satisfied, and false otherwise. In addition, we have:","category":"page"},{"location":"CommutativeAlgebra/ModulesOverMultivariateRings/free_modules/","page":"Free Modules","title":"Free Modules","text":"==(F::FreeMod, G::FreeMod)","category":"page"},{"location":"CommutativeAlgebra/ModulesOverMultivariateRings/free_modules/#==-Tuple{FreeMod, FreeMod}","page":"Free Modules","title":"==","text":"==(F::FreeMod, G::FreeMod)\n\nReturn  true if F and G are equal, false otherwise.\n\nHere, F and G are equal iff either \n\nboth modules are ungraded and their base rings, ranks, and names for printing the basis elements are equal, \n\nor else \n\nboth modules are graded, the above holds, and for each i, the degrees of the i-th basis elements are equal.\n\n\n\n\n\n","category":"method"},{"location":"CommutativeAlgebra/ModulesOverMultivariateRings/free_modules/","page":"Free Modules","title":"Free Modules","text":"is_isomorphic(F::FreeMod, G::FreeMod)","category":"page"},{"location":"CommutativeAlgebra/ModulesOverMultivariateRings/free_modules/#is_isomorphic-Tuple{FreeMod, FreeMod}","page":"Free Modules","title":"is_isomorphic","text":"is_isomorphic(F::FreeMod, G::FreeMod)\n\nReturn  true if F and G are isomorphic as (graded) modules, false otherwise.\n\nThat is, either \n\nboth modules are ungraded and their base rings and ranks are equal, \n\nor else \n\nboth modules are graded, the above holds, and the multisets of the degrees of the basis elements are equal.\n\nExamples\n\njulia> Rg, (x, y, z) = graded_polynomial_ring(QQ, [:x, :y, :z]);\n\njulia> F = graded_free_module(Rg, [1,1,3,2]);\n\njulia> G1 = graded_free_module(Rg, [1,1,2,3]);\n\njulia> is_isomorphic(F, G1)\ntrue\n\njulia> G2 = graded_free_module(Rg, [1,1,5,6]);\n\njulia> is_isomorphic(F, G2)\nfalse\n\n\n\n\n\n","category":"method"},{"location":"CommutativeAlgebra/ModulesOverMultivariateRings/free_modules/","page":"Free Modules","title":"Free Modules","text":"is_zero(F::AbstractFreeMod)","category":"page"},{"location":"CommutativeAlgebra/ModulesOverMultivariateRings/free_modules/#is_zero-Tuple{Oscar.AbstractFreeMod}","page":"Free Modules","title":"is_zero","text":"is_zero(F::AbstractFreeMod)\n\nReturn true if F is the zero module, false otherwise.\n\n\n\n\n\n","category":"method"},{"location":"CommutativeAlgebra/ModulesOverMultivariateRings/free_modules/#Homomorphisms-from-Free-Modules","page":"Free Modules","title":"Homomorphisms from Free Modules","text":"","category":"section"},{"location":"CommutativeAlgebra/ModulesOverMultivariateRings/free_modules/","page":"Free Modules","title":"Free Modules","text":"All OSCAR types for homomorphisms of the modules considered here belong to the abstract type ModuleFPHom{T1, T2}, where T1 and T2 are the types of domain and codomain respectively. A homomorphism Fto M from a free module F is determined by specifying the images of the basis vectors of F in M. For such homomorphisms, OSCAR provides the concrete type FreeModuleHom{T1, T2} <: ModuleFPHom{T1, T2} as well as the following constructors:","category":"page"},{"location":"CommutativeAlgebra/ModulesOverMultivariateRings/free_modules/","page":"Free Modules","title":"Free Modules","text":"hom(F::FreeMod, M::ModuleFP{T}, V::Vector{<:ModuleFPElem{T}}) where T ","category":"page"},{"location":"CommutativeAlgebra/ModulesOverMultivariateRings/free_modules/#hom-Union{Tuple{T}, Tuple{FreeMod, ModuleFP{T}, Vector{<:ModuleFPElem{T}}}} where T","page":"Free Modules","title":"hom","text":"hom(F::FreeMod, M::ModuleFP{T}, V::Vector{<:ModuleFPElem{T}}) where T\n\nGiven a vector V of rank(F) elements of M,  return the homomorphism F to M which sends the i-th basis vector of F to the i-th entry of V.\n\nhom(F::FreeMod, M::ModuleFP{T}, A::MatElem{T}) where T\n\nGiven a matrix A with rank(F) rows and ngens(M) columns, return the homomorphism F to M which sends the i-th basis vector of F to  the linear combination sum_j Aij*Mj of the generators M[j] of M.\n\nnote: Note\nThe module M may be of type FreeMod or SubquoMod. If both modules F and M are graded, the data must define a graded module homomorphism of some degree. If this degree is the zero element of the (common) grading group, we refer to the homomorphism under consideration as a homogeneous module homomorphism.\n\nExamples\n\njulia> R, (x, y, z) = polynomial_ring(QQ, [:x, :y, :z])\n(Multivariate polynomial ring in 3 variables over QQ, QQMPolyRingElem[x, y, z])\n\njulia> F = free_module(R, 3)\nFree module of rank 3 over R\n\njulia> G = free_module(R, 2)\nFree module of rank 2 over R\n\njulia> V = [y*G[1], x*G[1]+y*G[2], z*G[2]]\n3-element Vector{FreeModElem{QQMPolyRingElem}}:\n y*e[1]\n x*e[1] + y*e[2]\n z*e[2]\n\njulia> a = hom(F, G, V)\nModule homomorphism\n  from F\n  to G\n\njulia> a(F[2])\nx*e[1] + y*e[2]\n\njulia> B = R[y 0; x y; 0 z]\n[y   0]\n[x   y]\n[0   z]\n\njulia> b = hom(F, G, B)\nModule homomorphism\n  from F\n  to G\n\njulia> a == b\ntrue\n\njulia> Rg, (x, y, z) = graded_polynomial_ring(QQ, [:x, :y, :z]);\n\njulia> F1 = graded_free_module(Rg, 3)\nGraded free module Rg^3([0]) of rank 3 over Rg\n\njulia> G1 = graded_free_module(Rg, 2)\nGraded free module Rg^2([0]) of rank 2 over Rg\n\njulia> V1 = [y*G1[1], (x+y)*G1[1]+y*G1[2], z*G1[2]]\n3-element Vector{FreeModElem{MPolyDecRingElem{QQFieldElem, QQMPolyRingElem}}}:\n y*e[1]\n (x + y)*e[1] + y*e[2]\n z*e[2]\n\njulia> a1 = hom(F1, G1, V1)\nGraded module homomorphism of degree [1]\n  from F1\n  to G1\ndefined by\n  e[1] -> y*e[1]\n  e[2] -> (x + y)*e[1] + y*e[2]\n  e[3] -> z*e[2]\n\njulia> F2 = graded_free_module(Rg, [1,1,1])\nGraded free module Rg^3([-1]) of rank 3 over Rg\n\njulia> G2 = graded_free_module(Rg, [0,0])\nGraded free module Rg^2([0]) of rank 2 over Rg\n\njulia> V2 = [y*G2[1], (x+y)*G2[1]+y*G2[2], z*G2[2]]\n3-element Vector{FreeModElem{MPolyDecRingElem{QQFieldElem, QQMPolyRingElem}}}:\n y*e[1]\n (x + y)*e[1] + y*e[2]\n z*e[2]\n\njulia> a2 = hom(F2, G2, V2)\nHomogeneous module homomorphism\n  from F2\n  to G2\ndefined by\n  e[1] -> y*e[1]\n  e[2] -> (x + y)*e[1] + y*e[2]\n  e[3] -> z*e[2]\n\njulia> B = Rg[y 0; x+y y; 0 z]\n[    y   0]\n[x + y   y]\n[    0   z]\n\njulia> b = hom(F2, G2, B)\nHomogeneous module homomorphism\n  from F2\n  to G2\ndefined by\n  e[1] -> y*e[1]\n  e[2] -> (x + y)*e[1] + y*e[2]\n  e[3] -> z*e[2]\n\njulia> a2 == b\ntrue\n\n\n\n\n\n","category":"method"},{"location":"CommutativeAlgebra/ModulesOverMultivariateRings/free_modules/","page":"Free Modules","title":"Free Modules","text":"hom(F::FreeMod, M::ModuleFP{T}, V::Vector{<:ModuleFPElem{T}}, h::RingMapType) where {T, RingMapType}","category":"page"},{"location":"CommutativeAlgebra/ModulesOverMultivariateRings/free_modules/#hom-Union{Tuple{RingMapType}, Tuple{T}, Tuple{FreeMod, ModuleFP{T}, Vector{<:ModuleFPElem{T}}, RingMapType}} where {T, RingMapType}","page":"Free Modules","title":"hom","text":"hom(F::FreeMod, M::ModuleFP{T}, V::Vector{<:ModuleFPElem{T}}, h::RingMapType) where {T, RingMapType}\n\nGiven a vector V of rank(F) elements of M and a ring map h from base_ring(F) to base_ring(M), return the  base_ring(F)-homomorphism F to M which sends the i-th basis vector of F to the i-th entry of V, and the scalars in  base_ring(F) to their images under h.\n\nhom(F::FreeMod, M::ModuleFP{T}, A::MatElem{T}, h::RingMapType) where {T, RingMapType}\n\nGiven a matrix A over base_ring(M) with rank(F) rows and ngens(M) columns and a ring map h from base_ring(F) to base_ring(M), return the base_ring(F)-homomorphism F to M which sends the i-th basis vector of F to  the linear combination sum_j Aij*Mj of the generators M[j] of M, and the  scalars in base_ring(F) to their images under h.\n\nnote: Note\nThe module M may be of type FreeMod or SubquoMod. If both modules F and M are graded, the data must define a graded module homomorphism of some degree. If this degree is the zero element of the (common) grading group, we refer to the homomorphism under consideration as a homogeneous module homomorphism.\n\n\n\n\n\n","category":"method"},{"location":"CommutativeAlgebra/ModulesOverMultivariateRings/free_modules/","page":"Free Modules","title":"Free Modules","text":"Given a homomorphism of type FreeModuleHom, a matrix representing it is recovered by the following function:","category":"page"},{"location":"CommutativeAlgebra/ModulesOverMultivariateRings/free_modules/","page":"Free Modules","title":"Free Modules","text":"matrix(a::FreeModuleHom)","category":"page"},{"location":"CommutativeAlgebra/ModulesOverMultivariateRings/free_modules/#matrix-Tuple{FreeModuleHom}","page":"Free Modules","title":"matrix","text":"matrix(a::FreeModuleHom)\n\nGiven a homomorphism a : F → M of type  FreeModuleHom,  return a matrix A over base_ring(M) with rank(F) rows and  ngens(M) columns such that a(Fi) = sum_j Aij*Mj.\n\nExamples\n\njulia> R, (x, y, z) = polynomial_ring(QQ, [:x, :y, :z])\n(Multivariate polynomial ring in 3 variables over QQ, QQMPolyRingElem[x, y, z])\n\njulia> F = free_module(R, 3)\nFree module of rank 3 over R\n\njulia> G = free_module(R, 2)\nFree module of rank 2 over R\n\njulia> V = [y*G[1], x*G[1]+y*G[2], z*G[2]];\n\njulia> a = hom(F, G, V);\n\njulia> matrix(a)\n[y   0]\n[x   y]\n[0   z]\n\n\n\n\n\n","category":"method"},{"location":"CommutativeAlgebra/ModulesOverMultivariateRings/free_modules/","page":"Free Modules","title":"Free Modules","text":"The domain and codomain of a homomorphism a  of type FreeModuleHom can be recovered by entering domain(a) and codomain(a), respectively.","category":"page"},{"location":"CommutativeAlgebra/ModulesOverMultivariateRings/free_modules/","page":"Free Modules","title":"Free Modules","text":"The functions below test whether a homomorphism of type FreeModuleHom is graded and homogeneous, respectively.","category":"page"},{"location":"CommutativeAlgebra/ModulesOverMultivariateRings/free_modules/","page":"Free Modules","title":"Free Modules","text":"is_graded(a::FreeModuleHom)","category":"page"},{"location":"CommutativeAlgebra/ModulesOverMultivariateRings/free_modules/#is_graded-Tuple{FreeModuleHom}","page":"Free Modules","title":"is_graded","text":"is_graded(a::ModuleFPHom)\n\nReturn true if a is graded, false otherwise.\n\nExamples\n\njulia> R, (x, y, z) = graded_polynomial_ring(QQ, [:x, :y, :z]);\n\njulia> F = graded_free_module(R, 3)\nGraded free module R^3([0]) of rank 3 over R\n\njulia> G = graded_free_module(R, 2)\nGraded free module R^2([0]) of rank 2 over R\n\njulia> V = [y*G[1], x*G[1]+y*G[2], z*G[2]]\n3-element Vector{FreeModElem{MPolyDecRingElem{QQFieldElem, QQMPolyRingElem}}}:\n y*e[1]\n x*e[1] + y*e[2]\n z*e[2]\n\njulia> a = hom(F, G, V)\nGraded module homomorphism of degree [1]\n  from F\n  to G\ndefined by\n  e[1] -> y*e[1]\n  e[2] -> x*e[1] + y*e[2]\n  e[3] -> z*e[2]\n\njulia> is_graded(a)\ntrue\n\n\n\n\n\n","category":"method"},{"location":"CommutativeAlgebra/ModulesOverMultivariateRings/free_modules/","page":"Free Modules","title":"Free Modules","text":"is_homogeneous(a::FreeModuleHom)","category":"page"},{"location":"CommutativeAlgebra/ModulesOverMultivariateRings/free_modules/#is_homogeneous-Tuple{FreeModuleHom}","page":"Free Modules","title":"is_homogeneous","text":"is_homogeneous(a::FreeModuleHom)\n\nReturn true if a is homogeneous, false otherwise\n\nHere, if G is the grading group of a, a is homogeneous if a is graded of degree zero(G).\n\nExamples\n\njulia> R, (x, y, z) = graded_polynomial_ring(QQ, [:x, :y, :z]);\n\njulia> F = graded_free_module(R, 3)\nGraded free module R^3([0]) of rank 3 over R\n\njulia> G = graded_free_module(R, 2)\nGraded free module R^2([0]) of rank 2 over R\n\njulia> V = [y*G[1], x*G[1]+y*G[2], z*G[2]]\n3-element Vector{FreeModElem{MPolyDecRingElem{QQFieldElem, QQMPolyRingElem}}}:\n y*e[1]\n x*e[1] + y*e[2]\n z*e[2]\n\njulia> a = hom(F, G, V)\nGraded module homomorphism of degree [1]\n  from F\n  to G\ndefined by\n  e[1] -> y*e[1]\n  e[2] -> x*e[1] + y*e[2]\n  e[3] -> z*e[2]\n\njulia> is_homogeneous(a)\nfalse\n\n\n\n\n\n","category":"method"},{"location":"CommutativeAlgebra/ModulesOverMultivariateRings/free_modules/","page":"Free Modules","title":"Free Modules","text":"In the graded case, we additionally have:","category":"page"},{"location":"CommutativeAlgebra/ModulesOverMultivariateRings/free_modules/","page":"Free Modules","title":"Free Modules","text":"degree(a::FreeModuleHom)","category":"page"},{"location":"CommutativeAlgebra/ModulesOverMultivariateRings/free_modules/#degree-Tuple{FreeModuleHom}","page":"Free Modules","title":"degree","text":"degree(a::FreeModuleHom; check::Bool=true)\n\nIf a is graded, return the degree of a.\n\nExamples\n\njulia> R, (x, y, z) = graded_polynomial_ring(QQ, [:x, :y, :z]);\n\njulia> F = graded_free_module(R, 3)\nGraded free module R^3([0]) of rank 3 over R\n\njulia> G = graded_free_module(R, 2)\nGraded free module R^2([0]) of rank 2 over R\n\njulia> V = [y*G[1], x*G[1]+y*G[2], z*G[2]]\n3-element Vector{FreeModElem{MPolyDecRingElem{QQFieldElem, QQMPolyRingElem}}}:\n y*e[1]\n x*e[1] + y*e[2]\n z*e[2]\n\njulia> a = hom(F, G, V)\nGraded module homomorphism of degree [1]\n  from F\n  to G\ndefined by\n  e[1] -> y*e[1]\n  e[2] -> x*e[1] + y*e[2]\n  e[3] -> z*e[2]\n\njulia> degree(a)\n[1]\n\n\n\n\n\n","category":"method"},{"location":"CommutativeAlgebra/ModulesOverMultivariateRings/free_modules/","page":"Free Modules","title":"Free Modules","text":"grading_group(a::FreeModuleHom)","category":"page"},{"location":"CommutativeAlgebra/ModulesOverMultivariateRings/free_modules/#grading_group-Tuple{FreeModuleHom}","page":"Free Modules","title":"grading_group","text":"grading_group(a::FreeModuleHom)\n\nIf a is graded, return the grading group of a.\n\nExamples\n\njulia> R, (x, y, z) = graded_polynomial_ring(QQ, [:x, :y, :z]);\n\njulia> F = graded_free_module(R, 3)\nGraded free module R^3([0]) of rank 3 over R\n\njulia> G = graded_free_module(R, 2)\nGraded free module R^2([0]) of rank 2 over R\n\njulia> V = [y*G[1], x*G[1]+y*G[2], z*G[2]]\n3-element Vector{FreeModElem{MPolyDecRingElem{QQFieldElem, QQMPolyRingElem}}}:\n y*e[1]\n x*e[1] + y*e[2]\n z*e[2]\n\njulia> a = hom(F, G, V)\nGraded module homomorphism of degree [1]\n  from F\n  to G\ndefined by\n  e[1] -> y*e[1]\n  e[2] -> x*e[1] + y*e[2]\n  e[3] -> z*e[2]\n\njulia> is_graded(a)\ntrue\n\njulia> grading_group(a)\nZ\n\n\n\n\n\n","category":"method"},{"location":"NumberTheory/intro/","page":"Introduction","title":"Introduction","text":"CurrentModule = Oscar","category":"page"},{"location":"NumberTheory/intro/#number_theory","page":"Introduction","title":"Introduction","text":"","category":"section"},{"location":"NumberTheory/intro/","page":"Introduction","title":"Introduction","text":"The number theory part of OSCAR provides functionality for algebraic number theory.","category":"page"},{"location":"NumberTheory/intro/","page":"Introduction","title":"Introduction","text":"It is under development with regard to providing both the functionality and the documentation. ","category":"page"},{"location":"NumberTheory/intro/","page":"Introduction","title":"Introduction","text":"General textbooks offering details on theory and algorithms include:","category":"page"},{"location":"NumberTheory/intro/","page":"Introduction","title":"Introduction","text":"[Coh93]\n[Coh00]\n[Mar18]\n[PZ97]","category":"page"},{"location":"NumberTheory/intro/#Contact","page":"Introduction","title":"Contact","text":"","category":"section"},{"location":"NumberTheory/intro/","page":"Introduction","title":"Introduction","text":"Please direct questions about this part of OSCAR to the following people:","category":"page"},{"location":"NumberTheory/intro/","page":"Introduction","title":"Introduction","text":"Claus Fieker,\nTommy Hofmann.","category":"page"},{"location":"NumberTheory/intro/","page":"Introduction","title":"Introduction","text":"You can ask questions in the OSCAR Slack.","category":"page"},{"location":"NumberTheory/intro/","page":"Introduction","title":"Introduction","text":"Alternatively, you can raise an issue on github.","category":"page"},{"location":"Hecke/manual/quad_forms/integer_lattices/#Integer-Lattices","page":"Integer Lattices","title":"Integer Lattices","text":"","category":"section"},{"location":"Hecke/manual/quad_forms/integer_lattices/","page":"Integer Lattices","title":"Integer Lattices","text":"CurrentModule = Hecke\nDocTestSetup = quote\n    using Hecke\n  end","category":"page"},{"location":"Hecke/manual/quad_forms/integer_lattices/","page":"Integer Lattices","title":"Integer Lattices","text":"An integer lattice L is a finitely generated mathbbZ-submodule of a quadratic vector space V = mathbbQ^n over the rational numbers. Integer lattices are also known as quadratic forms over the integers. We will refer to them as mathbbZ-lattices.","category":"page"},{"location":"Hecke/manual/quad_forms/integer_lattices/","page":"Integer Lattices","title":"Integer Lattices","text":"A mathbbZ-lattice L has the type ZZLat. It is given in terms of its ambient quadratic space V together with a basis matrix B whose rows span L, i.e. L = mathbbZ^r B where r is the (mathbbZ-module) rank of L.","category":"page"},{"location":"Hecke/manual/quad_forms/integer_lattices/","page":"Integer Lattices","title":"Integer Lattices","text":"To access V and B see ambient_space(L::ZZLat) and basis_matrix(L::ZZLat).","category":"page"},{"location":"Hecke/manual/quad_forms/integer_lattices/#Creation-of-integer-lattices","page":"Integer Lattices","title":"Creation of integer lattices","text":"","category":"section"},{"location":"Hecke/manual/quad_forms/integer_lattices/#From-a-gram-matrix","page":"Integer Lattices","title":"From a gram matrix","text":"","category":"section"},{"location":"Hecke/manual/quad_forms/integer_lattices/","page":"Integer Lattices","title":"Integer Lattices","text":"integer_lattice(B::QQMatrix)","category":"page"},{"location":"Hecke/manual/quad_forms/integer_lattices/#integer_lattice-Tuple{QQMatrix}","page":"Integer Lattices","title":"integer_lattice","text":"integer_lattice([B::MatElem]; gram) -> ZZLat\n\nReturn the Z-lattice with basis matrix B inside the quadratic space with Gram matrix gram.\n\nIf the keyword gram is not specified, the Gram matrix is the identity matrix. If B is not specified, the basis matrix is the identity matrix.\n\nExamples\n\njulia> L = integer_lattice(matrix(QQ, 2, 2, [1//2, 0, 0, 2]));\n\njulia> gram_matrix(L) == matrix(QQ, 2, 2, [1//4, 0, 0, 4])\ntrue\n\njulia> L = integer_lattice(gram = matrix(ZZ, [2 -1; -1 2]));\n\njulia> gram_matrix(L) == matrix(ZZ, [2 -1; -1 2])\ntrue\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/quad_forms/integer_lattices/#In-a-quadratic-space","page":"Integer Lattices","title":"In a quadratic space","text":"","category":"section"},{"location":"Hecke/manual/quad_forms/integer_lattices/","page":"Integer Lattices","title":"Integer Lattices","text":"lattice(V::QuadSpace{QQField, QQMatrix}, B::MatElem;)","category":"page"},{"location":"Hecke/manual/quad_forms/integer_lattices/#lattice-Tuple{Hecke.QuadSpace{QQField, QQMatrix}, MatElem}","page":"Integer Lattices","title":"lattice","text":"lattice(V::AbstractSpace, basis::MatElem ; check::Bool = true) -> AbstractLat\n\nGiven an ambient space V and a matrix basis, return the lattice spanned by the rows of basis inside V. If V is hermitian (resp. quadratic) then the output is a hermitian (resp. quadratic) lattice.\n\nBy default, basis is checked to be of full rank. This test can be disabled by setting check to false.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/quad_forms/integer_lattices/#Special-lattices","page":"Integer Lattices","title":"Special lattices","text":"","category":"section"},{"location":"Hecke/manual/quad_forms/integer_lattices/","page":"Integer Lattices","title":"Integer Lattices","text":"root_lattice(::Symbol, ::Int)\nhyperbolic_plane_lattice(n::Union{Int64, ZZRingElem})\ninteger_lattice(S::Symbol, n::Union{Int64, ZZRingElem})\nleech_lattice\nk3_lattice\nmukai_lattice(::Symbol)\nhyperkaehler_lattice(::Symbol)","category":"page"},{"location":"Hecke/manual/quad_forms/integer_lattices/#root_lattice-Tuple{Symbol, Int64}","page":"Integer Lattices","title":"root_lattice","text":"root_lattice(R::Symbol, n::Int) -> ZZLat\n\nReturn the root lattice of type R given by :A, :D or :E with parameter n.\n\nThe type :I with parameter n = 1 is also allowed and denotes the odd unimodular lattice of rank 1.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/quad_forms/integer_lattices/#hyperbolic_plane_lattice-Tuple{Union{Int64, ZZRingElem}}","page":"Integer Lattices","title":"hyperbolic_plane_lattice","text":"hyperbolic_plane_lattice(n::RationalUnion = 1) -> ZZLat\n\nReturn the hyperbolic plane with intersection form of scale n, that is, the unique (up to isometry) even unimodular hyperbolic mathbb Z-lattice of rank 2, rescaled by n.\n\nExamples\n\njulia> L = hyperbolic_plane_lattice(6);\n\njulia> gram_matrix(L)\n[0   6]\n[6   0]\n\njulia> L = hyperbolic_plane_lattice(ZZ(-13));\n\njulia> gram_matrix(L)\n[  0   -13]\n[-13     0]\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/quad_forms/integer_lattices/#integer_lattice-Tuple{Symbol, Union{Int64, ZZRingElem}}","page":"Integer Lattices","title":"integer_lattice","text":"integer_lattice(S::Symbol, n::RationalUnion = 1) -> ZZlat\n\nGiven S = :H or S = :U, return a mathbb Z-lattice admitting n*J_2 as Gram matrix in some basis, where J_2 is the 2-by-2 matrix with 0's on the main diagonal and 1's elsewhere.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/quad_forms/integer_lattices/#leech_lattice","page":"Integer Lattices","title":"leech_lattice","text":"leech_lattice() -> ZZLat\n\nReturn the Leech lattice.\n\n\n\n\n\nleech_lattice(niemeier_lattice::ZZLat) -> ZZLat, QQMatrix, Int\n\nReturn a triple L, v, h where L is the Leech lattice.\n\nL is an h-neighbor of the Niemeier lattice N with respect to v. This means that L / L ∩ N  ≅ ℤ / h ℤ. Here h is the Coxeter number of the Niemeier lattice.\n\nThis implements the 23 holy constructions of the Leech lattice in [CS99].\n\nExamples\n\njulia> R = integer_lattice(gram=2 * identity_matrix(ZZ, 24));\n\njulia> N = maximal_even_lattice(R) # Some Niemeier lattice\nInteger lattice of rank 24 and degree 24\nwith gram matrix\n[2   1   1   1   0   0   0   0   0   0   0   0   0   0   0   0   1   0   1   1   0   0   0   0]\n[1   2   1   1   0   0   0   0   0   0   0   0   0   0   0   0   1   1   0   1   0   0   0   0]\n[1   1   2   1   0   0   0   0   0   0   0   0   0   0   0   0   1   1   1   0   0   0   0   0]\n[1   1   1   2   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0]\n[0   0   0   0   2   1   1   1   0   0   0   0   1   0   1   1   0   0   0   0   0   0   0   0]\n[0   0   0   0   1   2   1   1   0   0   0   0   1   1   0   1   0   0   0   0   0   0   0   0]\n[0   0   0   0   1   1   2   1   0   0   0   0   1   1   1   0   0   0   0   0   0   0   0   0]\n[0   0   0   0   1   1   1   2   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0]\n[0   0   0   0   0   0   0   0   2   1   1   1   0   0   0   0   0   0   0   0   1   1   1   0]\n[0   0   0   0   0   0   0   0   1   2   1   1   0   0   0   0   0   0   0   0   1   0   1   1]\n[0   0   0   0   0   0   0   0   1   1   2   1   0   0   0   0   0   0   0   0   1   1   0   1]\n[0   0   0   0   0   0   0   0   1   1   1   2   0   0   0   0   0   0   0   0   0   0   0   0]\n[0   0   0   0   1   1   1   0   0   0   0   0   2   1   1   1   0   0   0   0   0   0   0   0]\n[0   0   0   0   0   1   1   0   0   0   0   0   1   2   0   0   0   0   0   0   0   0   0   0]\n[0   0   0   0   1   0   1   0   0   0   0   0   1   0   2   0   0   0   0   0   0   0   0   0]\n[0   0   0   0   1   1   0   0   0   0   0   0   1   0   0   2   0   0   0   0   0   0   0   0]\n[1   1   1   0   0   0   0   0   0   0   0   0   0   0   0   0   2   1   1   1   0   0   0   0]\n[0   1   1   0   0   0   0   0   0   0   0   0   0   0   0   0   1   2   0   0   0   0   0   0]\n[1   0   1   0   0   0   0   0   0   0   0   0   0   0   0   0   1   0   2   0   0   0   0   0]\n[1   1   0   0   0   0   0   0   0   0   0   0   0   0   0   0   1   0   0   2   0   0   0   0]\n[0   0   0   0   0   0   0   0   1   1   1   0   0   0   0   0   0   0   0   0   2   1   1   1]\n[0   0   0   0   0   0   0   0   1   0   1   0   0   0   0   0   0   0   0   0   1   2   0   0]\n[0   0   0   0   0   0   0   0   1   1   0   0   0   0   0   0   0   0   0   0   1   0   2   0]\n[0   0   0   0   0   0   0   0   0   1   1   0   0   0   0   0   0   0   0   0   1   0   0   2]\n\njulia> minimum(N)\n2\n\njulia> det(N)\n1\n\njulia> L, v, h = leech_lattice(N);\n\njulia> minimum(L)\n4\n\njulia> det(L)\n1\n\njulia> h == index(L, intersect(L, N))\ntrue\n\n\nWe illustrate how the Leech lattice is constructed from N, h and v.\n\njulia> Zmodh, _ = residue_ring(ZZ, h);\n\njulia> V = ambient_space(N);\n\njulia> vG = map_entries(x->Zmodh(ZZ(x)), inner_product(V, v, basis_matrix(N)));\n\njulia> LN = transpose(lift(Hecke.kernel(vG; side = :right)))*basis_matrix(N); # vectors whose inner product with `v` is divisible by `h`.\n\njulia> lattice(V, LN) == intersect(L, N)\ntrue\n\njulia> gensL = vcat(LN, 1//h * v);\n\njulia> lattice(V, gensL, isbasis=false) == L\ntrue\n\n\n\n\n\n\n","category":"function"},{"location":"Hecke/manual/quad_forms/integer_lattices/#k3_lattice","page":"Integer Lattices","title":"k3_lattice","text":"k3_lattice()\n\nReturn the integer lattice corresponding to the Beauville-Bogomolov-Fujiki form associated to a K3 surface.\n\nExamples\n\njulia> L = k3_lattice();\n\njulia> is_unimodular(L)\ntrue\n\njulia> signature_tuple(L)\n(3, 0, 19)\n\n\n\n\n\n","category":"function"},{"location":"Hecke/manual/quad_forms/integer_lattices/#mukai_lattice-Tuple{Symbol}","page":"Integer Lattices","title":"mukai_lattice","text":"mukai_lattice(S::Symbol = :K3; extended::Bool = false)\n\nReturn the (extended) Mukai lattice.\n\nIf S == :K3, it returns the (extended) Mukai lattice associated to hyperkaehler manifolds which are deformation equivalent to a moduli space of stable sheaves on a K3 surface.\n\nIf S == :Ab, it returns the (extended) Mukai lattice associated to hyperkaehler manifolds which are deformation equivalent to a moduli space of stable sheaves on an abelian surface.\n\nExamples\n\njulia> L = mukai_lattice();\n\njulia> genus(L)\nGenus symbol for integer lattices\nSignatures: (4, 0, 20)\nLocal symbol:\n  Local genus symbol at 2: 1^24\n\njulia> L = mukai_lattice(; extended = true);\n\njulia> genus(L)\nGenus symbol for integer lattices\nSignatures: (5, 0, 21)\nLocal symbol:\n  Local genus symbol at 2: 1^26\n\njulia> L = mukai_lattice(:Ab);\n\njulia> genus(L)\nGenus symbol for integer lattices\nSignatures: (4, 0, 4)\nLocal symbol:\n  Local genus symbol at 2: 1^8\n\njulia> L = mukai_lattice(:Ab; extended = true);\n\njulia> genus(L)\nGenus symbol for integer lattices\nSignatures: (5, 0, 5)\nLocal symbol:\n  Local genus symbol at 2: 1^10\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/quad_forms/integer_lattices/#hyperkaehler_lattice-Tuple{Symbol}","page":"Integer Lattices","title":"hyperkaehler_lattice","text":"hyperkaehler_lattice(S::Symbol; n::Int = 2)\n\nReturn the integer lattice corresponding to the Beauville-Bogomolov-Fujiki form on a hyperkaehler manifold whose deformation type is determined by S and n.\n\nIf S == :K3 or S == :Kum, then n must be an integer bigger than 2;\nIf S == :OG6 or S == :OG10, the value of n has no effect.\n\nExamples\n\njulia> L = hyperkaehler_lattice(:Kum; n = 3)\nInteger lattice of rank 7 and degree 7\nwith gram matrix\n[0   1   0   0   0   0    0]\n[1   0   0   0   0   0    0]\n[0   0   0   1   0   0    0]\n[0   0   1   0   0   0    0]\n[0   0   0   0   0   1    0]\n[0   0   0   0   1   0    0]\n[0   0   0   0   0   0   -8]\n\njulia> L = hyperkaehler_lattice(:OG6)\nInteger lattice of rank 8 and degree 8\nwith gram matrix\n[0   1   0   0   0   0    0    0]\n[1   0   0   0   0   0    0    0]\n[0   0   0   1   0   0    0    0]\n[0   0   1   0   0   0    0    0]\n[0   0   0   0   0   1    0    0]\n[0   0   0   0   1   0    0    0]\n[0   0   0   0   0   0   -2    0]\n[0   0   0   0   0   0    0   -2]\n\njulia> L = hyperkaehler_lattice(:OG10);\n\njulia> genus(L)\nGenus symbol for integer lattices\nSignatures: (3, 0, 21)\nLocal symbols:\n  Local genus symbol at 2: 1^-24\n  Local genus symbol at 3: 1^-23 3^1\n\njulia> L = hyperkaehler_lattice(:K3; n = 3);\n\njulia> genus(L)\nGenus symbol for integer lattices\nSignatures: (3, 0, 20)\nLocal symbol:\n  Local genus symbol at 2: 1^22 4^1_7\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/quad_forms/integer_lattices/#From-a-genus","page":"Integer Lattices","title":"From a genus","text":"","category":"section"},{"location":"Hecke/manual/quad_forms/integer_lattices/","page":"Integer Lattices","title":"Integer Lattices","text":"Integer lattices can be created as representatives of a genus. See (representative(L::ZZGenus))","category":"page"},{"location":"Hecke/manual/quad_forms/integer_lattices/#Rescaling-the-Quadratic-Form","page":"Integer Lattices","title":"Rescaling the Quadratic Form","text":"","category":"section"},{"location":"Hecke/manual/quad_forms/integer_lattices/","page":"Integer Lattices","title":"Integer Lattices","text":"rescale(::ZZLat, ::RationalUnion)","category":"page"},{"location":"Hecke/manual/quad_forms/integer_lattices/#rescale-Tuple{ZZLat, Union{Integer, QQFieldElem, ZZRingElem, Rational}}","page":"Integer Lattices","title":"rescale","text":"rescale(L::ZZLat, r::RationalUnion) -> ZZLat\n\nReturn the lattice L in the quadratic space with form r \\Phi.\n\nExamples\n\nThis can be useful to apply methods intended for positive definite lattices.\n\njulia> L = integer_lattice(gram=ZZ[-1 0; 0 -1])\nInteger lattice of rank 2 and degree 2\nwith gram matrix\n[-1    0]\n[ 0   -1]\n\njulia> shortest_vectors(rescale(L, -1))\n2-element Vector{Vector{ZZRingElem}}:\n [0, 1]\n [1, 0]\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/quad_forms/integer_lattices/#Attributes","page":"Integer Lattices","title":"Attributes","text":"","category":"section"},{"location":"Hecke/manual/quad_forms/integer_lattices/","page":"Integer Lattices","title":"Integer Lattices","text":"ambient_space(L::ZZLat)\nbasis_matrix(L::ZZLat)\ngram_matrix(L::ZZLat)\nrational_span(L::ZZLat)","category":"page"},{"location":"Hecke/manual/quad_forms/integer_lattices/#ambient_space-Tuple{ZZLat}","page":"Integer Lattices","title":"ambient_space","text":"ambient_space(L::AbstractLat) -> AbstractSpace\n\nReturn the ambient space of the lattice L. If the ambient space is not known, an error is raised.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/quad_forms/integer_lattices/#basis_matrix-Tuple{ZZLat}","page":"Integer Lattices","title":"basis_matrix","text":"basis_matrix(L::ZZLat) -> QQMatrix\n\nReturn the basis matrix B of the integer lattice L.\n\nThe lattice is given by the row span of B seen inside of the ambient quadratic space of L.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/quad_forms/integer_lattices/#gram_matrix-Tuple{ZZLat}","page":"Integer Lattices","title":"gram_matrix","text":"gram_matrix(L::ZZLat) -> QQMatrix\n\nReturn the gram matrix of L.\n\nExamples\n\njulia> L = integer_lattice(matrix(ZZ, [2 0; -1 2]));\n\njulia> gram_matrix(L)\n[ 4   -2]\n[-2    5]\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/quad_forms/integer_lattices/#rational_span-Tuple{ZZLat}","page":"Integer Lattices","title":"rational_span","text":"rational_span(L::ZZLat) -> QuadSpace\n\nReturn the rational span of L, which is the quadratic space with Gram matrix equal to gram_matrix(L).\n\nExamples\n\njulia> L = integer_lattice(matrix(ZZ, [2 0; -1 2]));\n\njulia> rational_span(L)\nQuadratic space of dimension 2\n  over rational field\nwith gram matrix\n[ 4   -2]\n[-2    5]\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/quad_forms/integer_lattices/#Invariants","page":"Integer Lattices","title":"Invariants","text":"","category":"section"},{"location":"Hecke/manual/quad_forms/integer_lattices/","page":"Integer Lattices","title":"Integer Lattices","text":"rank(L::ZZLat)\ndet(L::ZZLat)\n\nscale(L::ZZLat)\nnorm(L::ZZLat)\niseven(L::ZZLat)\nis_integral(L::ZZLat)\n\nis_primary_with_prime(L::ZZLat)\nis_primary(L::ZZLat, p::Union{Integer, ZZRingElem})\nis_elementary_with_prime(L::ZZLat)\nis_elementary(L::ZZLat, p::Union{Integer, ZZRingElem})","category":"page"},{"location":"Hecke/manual/quad_forms/integer_lattices/#rank-Tuple{ZZLat}","page":"Integer Lattices","title":"rank","text":"rank(L::AbstractLat) -> Int\n\nReturn the rank of the underlying module of the lattice L.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/quad_forms/integer_lattices/#det-Tuple{ZZLat}","page":"Integer Lattices","title":"det","text":"det(L::ZZLat) -> QQFieldElem\n\nReturn the determinant of the gram matrix of L.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/quad_forms/integer_lattices/#scale-Tuple{ZZLat}","page":"Integer Lattices","title":"scale","text":"scale(L::ZZLat) -> QQFieldElem\n\nReturn the scale of L.\n\nThe scale of L is defined as the positive generator of the mathbb Z-ideal generated by Phi(x y)  x y in L.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/quad_forms/integer_lattices/#norm-Tuple{ZZLat}","page":"Integer Lattices","title":"norm","text":"norm(L::ZZLat) -> QQFieldElem\n\nReturn the norm of L.\n\nThe norm of L is defined as the positive generator of the mathbb Z- ideal generated by Phi(xx)  x in L.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/quad_forms/integer_lattices/#iseven-Tuple{ZZLat}","page":"Integer Lattices","title":"iseven","text":"iseven(L::ZZLat) -> Bool\n\nReturn whether L is even.\n\nAn integer lattice L in the rational quadratic space (VPhi) is called even if Phi(xx) in 2mathbbZ for all x in L.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/quad_forms/integer_lattices/#is_integral-Tuple{ZZLat}","page":"Integer Lattices","title":"is_integral","text":"is_integral(L::AbstractLat) -> Bool\n\nReturn whether the lattice L is integral.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/quad_forms/integer_lattices/#is_primary_with_prime-Tuple{ZZLat}","page":"Integer Lattices","title":"is_primary_with_prime","text":"is_primary_with_prime(L::ZZLat) -> Bool, ZZRingElem\n\nGiven a mathbb Z-lattice L, return whether L is primary, that is whether L is integral and its discriminant group (see discriminant_group) is a p-group for some prime number p. In case it is, p is also returned as second output.\n\nNote that for unimodular lattices, this function returns (true, 1). If the lattice is not primary, the second return value is -1 by default.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/quad_forms/integer_lattices/#is_primary-Tuple{ZZLat, Union{Integer, ZZRingElem}}","page":"Integer Lattices","title":"is_primary","text":"is_primary(L::ZZLat, p::Union{Integer, ZZRingElem}) -> Bool\n\nGiven an integral mathbb Z-lattice L and a prime number p, return whether L is p-primary, that is whether its discriminant group (see discriminant_group) is a p-group.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/quad_forms/integer_lattices/#is_elementary_with_prime-Tuple{ZZLat}","page":"Integer Lattices","title":"is_elementary_with_prime","text":"is_elementary_with_prime(L::ZZLat) -> Bool, ZZRingElem\n\nGiven a mathbb Z-lattice L, return whether L is elementary, that is whether L is integral and its discriminant group (see discriminant_group) is an elemenentary p-group for some prime number p. In case it is, p is also returned as second output.\n\nNote that for unimodular lattices, this function returns (true, 1). If the lattice is not elementary, the second return value is -1 by default.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/quad_forms/integer_lattices/#is_elementary-Tuple{ZZLat, Union{Integer, ZZRingElem}}","page":"Integer Lattices","title":"is_elementary","text":"is_elementary(L::ZZLat, p::Union{Integer, ZZRingElem}) -> Bool\n\nGiven an integral mathbb Z-lattice L and a prime number p, return whether L is p-elementary, that is whether its discriminant group (see discriminant_group) is an elementary p-group.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/quad_forms/integer_lattices/#The-Genus","page":"Integer Lattices","title":"The Genus","text":"","category":"section"},{"location":"Hecke/manual/quad_forms/integer_lattices/","page":"Integer Lattices","title":"Integer Lattices","text":"For an integral lattice The genus of an integer lattice collects its local invariants. genus(::ZZLat)","category":"page"},{"location":"Hecke/manual/quad_forms/integer_lattices/","page":"Integer Lattices","title":"Integer Lattices","text":"mass(L::ZZLat)\ngenus_representatives(L::ZZLat)","category":"page"},{"location":"Hecke/manual/quad_forms/integer_lattices/#mass-Tuple{ZZLat}","page":"Integer Lattices","title":"mass","text":"mass(L::ZZLat) -> QQFieldElem\n\nReturn the mass of the genus of L.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/quad_forms/integer_lattices/#genus_representatives-Tuple{ZZLat}","page":"Integer Lattices","title":"genus_representatives","text":"genus_representatives(L::ZZLat) -> Vector{ZZLat}\n\nReturn representatives for the isometry classes in the genus of L.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/quad_forms/integer_lattices/#Real-invariants","page":"Integer Lattices","title":"Real invariants","text":"","category":"section"},{"location":"Hecke/manual/quad_forms/integer_lattices/","page":"Integer Lattices","title":"Integer Lattices","text":"signature_tuple(L::ZZLat)\nis_positive_definite(L::ZZLat)\nis_negative_definite(L::ZZLat)\nis_definite(L::ZZLat)","category":"page"},{"location":"Hecke/manual/quad_forms/integer_lattices/#signature_tuple-Tuple{ZZLat}","page":"Integer Lattices","title":"signature_tuple","text":"signature_tuple(L::ZZLat) -> Tuple{Int,Int,Int}\n\nReturn the number of (positive, zero, negative) inertia of L.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/quad_forms/integer_lattices/#is_positive_definite-Tuple{ZZLat}","page":"Integer Lattices","title":"is_positive_definite","text":"is_positive_definite(L::AbstractLat) -> Bool\n\nReturn whether the rational span of the lattice L is positive definite.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/quad_forms/integer_lattices/#is_negative_definite-Tuple{ZZLat}","page":"Integer Lattices","title":"is_negative_definite","text":"is_negative_definite(L::AbstractLat) -> Bool\n\nReturn whether the rational span of the lattice L is negative definite.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/quad_forms/integer_lattices/#is_definite-Tuple{ZZLat}","page":"Integer Lattices","title":"is_definite","text":"is_definite(L::AbstractLat) -> Bool\n\nReturn whether the rational span of the lattice L is definite.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/quad_forms/integer_lattices/#Isometries","page":"Integer Lattices","title":"Isometries","text":"","category":"section"},{"location":"Hecke/manual/quad_forms/integer_lattices/","page":"Integer Lattices","title":"Integer Lattices","text":"automorphism_group_generators(L::ZZLat)\nautomorphism_group_order(L::ZZLat)\nis_isometric(L::ZZLat, M::ZZLat)\nis_locally_isometric(L::ZZLat, M::ZZLat, p::Int)","category":"page"},{"location":"Hecke/manual/quad_forms/integer_lattices/#automorphism_group_generators-Tuple{ZZLat}","page":"Integer Lattices","title":"automorphism_group_generators","text":"automorphism_group_generators(E::EllipticCurve) -> Vector{EllCrvIso}\n\nReturn generators of the automorphism group of E.\n\n\n\n\n\nautomorphism_group_generators(L::AbstractLat; ambient_representation::Bool = true,\n                                              depth::Int = -1, bacher_depth::Int = 0)\n                                                      -> Vector{MatElem}\n\nGiven a definite lattice L, return generators for the automorphism group of L. If ambient_representation == true (the default), the transformations are represented with respect to the ambient space of L. Otherwise, the transformations are represented with respect to the (pseudo-)basis of L.\n\nSetting the parameters depth and bacher_depth to a positive value may improve performance. If set to -1 (default), the used value of depth is chosen heuristically depending on the rank of L. By default, bacher_depth is set to 0.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/quad_forms/integer_lattices/#automorphism_group_order-Tuple{ZZLat}","page":"Integer Lattices","title":"automorphism_group_order","text":"automorphism_group_order(L::AbstractLat; depth::Int = -1, bacher_depth::Int = 0) -> Int\n\nGiven a definite lattice L, return the order of the automorphism group of L.\n\nSetting the parameters depth and bacher_depth to a positive value may improve performance. If set to -1 (default), the used value of depth is chosen heuristically depending on the rank of L. By default, bacher_depth is set to 0.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/quad_forms/integer_lattices/#is_isometric-Tuple{ZZLat, ZZLat}","page":"Integer Lattices","title":"is_isometric","text":"is_isometric(L::AbstractLat, M::AbstractLat; depth::Int = -1, bacher_depth::Int = 0) -> Bool\n\nReturn whether the lattices L and M are isometric.\n\nSetting the parameters depth and bacher_depth to a positive value may improve performance. If set to -1 (default), the used value of depth is chosen heuristically depending on the rank of L. By default, bacher_depth is set to 0.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/quad_forms/integer_lattices/#is_locally_isometric-Tuple{ZZLat, ZZLat, Int64}","page":"Integer Lattices","title":"is_locally_isometric","text":"is_locally_isometric(L::ZZLat, M::ZZLat, p::Int) -> Bool\n\nReturn whether L and M are isometric over the p-adic integers.\n\ni.e. whether L otimes mathbbZ_p cong Motimes mathbbZ_p.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/quad_forms/integer_lattices/#Root-lattices","page":"Integer Lattices","title":"Root lattices","text":"","category":"section"},{"location":"Hecke/manual/quad_forms/integer_lattices/","page":"Integer Lattices","title":"Integer Lattices","text":"root_lattice_recognition(L::ZZLat)\nroot_lattice_recognition_fundamental(L::ZZLat)\nADE_type(G::MatrixElem)\ncoxeter_number(ADE::Symbol, n)\nhighest_root(ADE::Symbol, n)","category":"page"},{"location":"Hecke/manual/quad_forms/integer_lattices/#root_lattice_recognition-Tuple{ZZLat}","page":"Integer Lattices","title":"root_lattice_recognition","text":"root_lattice_recognition(L::ZZLat)\n\nReturn the ADE type of the root sublattice of L.\n\nThe root sublattice is the lattice spanned by the vectors of squared length 1 and 2.  The odd lattice of rank 1 and determinant 1 is denoted by (:I, 1).\n\nInput:\n\nL – a definite and integral mathbbZ-lattice.\n\nOutput:\n\nTwo lists, the first one containing the ADE types and the second one the irreducible root sublattices.\n\nFor more recognizable gram matrices use root_lattice_recognition_fundamental.\n\nExamples\n\njulia> L = integer_lattice(gram=ZZ[4  0 0  0 3  0 3  0;\n                            0 16 8 12 2 12 6 10;\n                            0  8 8  6 2  8 4  5;\n                            0 12 6 10 2  9 5  8;\n                            3  2 2  2 4  2 4  2;\n                            0 12 8  9 2 12 6  9;\n                            3  6 4  5 4  6 6  5;\n                            0 10 5  8 2  9 5  8])\nInteger lattice of rank 8 and degree 8\nwith gram matrix\n[4    0   0    0   3    0   3    0]\n[0   16   8   12   2   12   6   10]\n[0    8   8    6   2    8   4    5]\n[0   12   6   10   2    9   5    8]\n[3    2   2    2   4    2   4    2]\n[0   12   8    9   2   12   6    9]\n[3    6   4    5   4    6   6    5]\n[0   10   5    8   2    9   5    8]\n\njulia> R = root_lattice_recognition(L)\n([(:A, 1), (:D, 6)], ZZLat[Integer lattice of rank 1 and degree 8, Integer lattice of rank 6 and degree 8])\n\njulia> L = integer_lattice(; gram = QQ[1 0 0  0;\n                                       0 9 3  3;\n                                       0 3 2  1;\n                                       0 3 1 11])\nInteger lattice of rank 4 and degree 4\nwith gram matrix\n[1   0   0    0]\n[0   9   3    3]\n[0   3   2    1]\n[0   3   1   11]\n\njulia> root_lattice_recognition(L)\n([(:A, 1), (:I, 1)], ZZLat[Integer lattice of rank 1 and degree 4, Integer lattice of rank 1 and degree 4])\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/quad_forms/integer_lattices/#root_lattice_recognition_fundamental-Tuple{ZZLat}","page":"Integer Lattices","title":"root_lattice_recognition_fundamental","text":"root_lattice_recognition_fundamental(L::ZZLat)\n\nReturn the ADE type of the root sublattice of L as well as the corresponding irreducible root sublattices with basis given by a fundamental root system.\n\nThe type (:I, 1) corresponds to the odd unimodular root lattice of rank 1.\n\nInput:\n\nL – a definite and integral mathbb Z-lattice.\n\nOutput:\n\nthe root sublattice, with basis given by a fundamental root system\nthe ADE types\na Vector consisting of the irreducible root sublattices.\n\nExamples\n\njulia> L = integer_lattice(gram=ZZ[4  0 0  0 3  0 3  0;\n                            0 16 8 12 2 12 6 10;\n                            0  8 8  6 2  8 4  5;\n                            0 12 6 10 2  9 5  8;\n                            3  2 2  2 4  2 4  2;\n                            0 12 8  9 2 12 6  9;\n                            3  6 4  5 4  6 6  5;\n                            0 10 5  8 2  9 5  8])\nInteger lattice of rank 8 and degree 8\nwith gram matrix\n[4    0   0    0   3    0   3    0]\n[0   16   8   12   2   12   6   10]\n[0    8   8    6   2    8   4    5]\n[0   12   6   10   2    9   5    8]\n[3    2   2    2   4    2   4    2]\n[0   12   8    9   2   12   6    9]\n[3    6   4    5   4    6   6    5]\n[0   10   5    8   2    9   5    8]\n\njulia> R = root_lattice_recognition_fundamental(L);\n\njulia> gram_matrix(R[1])\n[2    0    0    0    0    0    0]\n[0    2    0   -1    0    0    0]\n[0    0    2   -1    0    0    0]\n[0   -1   -1    2   -1    0    0]\n[0    0    0   -1    2   -1    0]\n[0    0    0    0   -1    2   -1]\n[0    0    0    0    0   -1    2]\n\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/quad_forms/integer_lattices/#ADE_type-Tuple{MatrixElem}","page":"Integer Lattices","title":"ADE_type","text":"ADE_type(G::MatrixElem) -> Tuple{Symbol,Int64}\n\nReturn the type of the irreducible root lattice with gram matrix G.\n\nSee also root_lattice_recognition.\n\nExamples\n\njulia> Hecke.ADE_type(gram_matrix(root_lattice(:A,3)))\n(:A, 3)\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/quad_forms/integer_lattices/#coxeter_number-Tuple{Symbol, Any}","page":"Integer Lattices","title":"coxeter_number","text":"coxeter_number(ADE::Symbol, n) -> Int\n\nReturn the Coxeter number of the corresponding ADE root lattice.\n\nIf L is a root lattice and R its set of roots, then the Coxeter number h is Rn where n is the rank of L.\n\nExamples\n\njulia> coxeter_number(:D, 4)\n6\n\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/quad_forms/integer_lattices/#highest_root-Tuple{Symbol, Any}","page":"Integer Lattices","title":"highest_root","text":"highest_root(ADE::Symbol, n) -> ZZMatrix\n\nReturn coordinates of the highest root of root_lattice(ADE, n).\n\nExamples\n\njulia> highest_root(:E, 6)\n[1   2   3   2   1   2]\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/quad_forms/integer_lattices/#Module-operations","page":"Integer Lattices","title":"Module operations","text":"","category":"section"},{"location":"Hecke/manual/quad_forms/integer_lattices/","page":"Integer Lattices","title":"Integer Lattices","text":"Most module operations assume that the lattices live in the same ambient space. For instance only lattices in the same ambient space compare.","category":"page"},{"location":"Hecke/manual/quad_forms/integer_lattices/","page":"Integer Lattices","title":"Integer Lattices","text":"Base.:(==)(L1::ZZLat, L2::ZZLat)\nis_sublattice(M::ZZLat, N::ZZLat)\nis_sublattice_with_relations(M::ZZLat, N::ZZLat)\n+(M::ZZLat, N::ZZLat)\nBase.:(*)(a::RationalUnion, L::ZZLat)\nintersect(M::ZZLat, N::ZZLat)\nBase.in(v::Vector, L::ZZLat)\nBase.in(v::QQMatrix, L::ZZLat)\nprimitive_closure(M::ZZLat, N::ZZLat)\nis_primitive(M::ZZLat, N::ZZLat)\nis_primitive(::ZZLat, ::Union{Vector, QQMatrix})\ndivisibility(::ZZLat, ::Union{Vector, QQMatrix})","category":"page"},{"location":"Hecke/manual/quad_forms/integer_lattices/#==-Tuple{ZZLat, ZZLat}","page":"Integer Lattices","title":"==","text":"Return true if both lattices have the same ambient quadratic space and the same underlying module.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/quad_forms/integer_lattices/#is_sublattice-Tuple{ZZLat, ZZLat}","page":"Integer Lattices","title":"is_sublattice","text":"is_sublattice(L::AbstractLat, M::AbstractLat) -> Bool\n\nReturn whether M is a sublattice of the lattice L.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/quad_forms/integer_lattices/#is_sublattice_with_relations-Tuple{ZZLat, ZZLat}","page":"Integer Lattices","title":"is_sublattice_with_relations","text":"is_sublattice_with_relations(M::ZZLat, N::ZZLat) -> Bool, QQMatrix\n\nReturns whether N is a sublattice of M. In this case, the second return value is a matrix B such that B B_M = B_N, where B_M and B_N are the basis matrices of M and N respectively.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/quad_forms/integer_lattices/#+-Tuple{ZZLat, ZZLat}","page":"Integer Lattices","title":"+","text":"+(L::AbstractLat, M::AbstractLat) -> AbstractLat\n\nReturn the sum of the lattices L and M.\n\nThe lattices L and M must have the same ambient space.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/quad_forms/integer_lattices/#*-Tuple{Union{Integer, QQFieldElem, ZZRingElem, Rational}, ZZLat}","page":"Integer Lattices","title":"*","text":"*(a::RationalUnion, L::ZZLat) -> ZZLat\n\nReturn the lattice aM inside the ambient space of M.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/quad_forms/integer_lattices/#intersect-Tuple{ZZLat, ZZLat}","page":"Integer Lattices","title":"intersect","text":"intersect(L::AbstractLat, M::AbstractLat) -> AbstractLat\n\nReturn the intersection of the lattices L and M.\n\nThe lattices L and M must have the same ambient space.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/quad_forms/integer_lattices/#in-Tuple{Vector, ZZLat}","page":"Integer Lattices","title":"in","text":"Base.in(v::Vector, L::ZZLat) -> Bool\n\nReturn whether the vector v lies in the lattice L.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/quad_forms/integer_lattices/#in-Tuple{QQMatrix, ZZLat}","page":"Integer Lattices","title":"in","text":"Base.in(v::QQMatrix, L::ZZLat) -> Bool\n\nReturn whether the row span of v lies in the lattice L.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/quad_forms/integer_lattices/#primitive_closure-Tuple{ZZLat, ZZLat}","page":"Integer Lattices","title":"primitive_closure","text":"primitive_closure(M::ZZLat, N::ZZLat) -> ZZLat\n\nGiven two mathbb Z-lattices M and N with N subseteq mathbbQ M, return the primitive closure M cap mathbbQ N of N in M.\n\nExamples\n\njulia> M = root_lattice(:D, 6);\n\njulia> N = lattice_in_same_ambient_space(M, 3*basis_matrix(M)[1:1,:]);\n\njulia> basis_matrix(N)\n[3   0   0   0   0   0]\n\njulia> N2 = primitive_closure(M, N)\nInteger lattice of rank 1 and degree 6\nwith gram matrix\n[2]\n\njulia> basis_matrix(N2)\n[1   0   0   0   0   0]\n\njulia> M2 = primitive_closure(dual(M), M);\n\njulia> is_integral(M2)\nfalse\n\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/quad_forms/integer_lattices/#is_primitive-Tuple{ZZLat, ZZLat}","page":"Integer Lattices","title":"is_primitive","text":"is_primitive(M::ZZLat, N::ZZLat) -> Bool\n\nGiven two mathbb Z-lattices N subseteq M, return whether N is a primitive sublattice of M.\n\nExamples\n\njulia> U = hyperbolic_plane_lattice(3);\n\njulia> bU = basis_matrix(U);\n\njulia> e1, e2 = bU[1:1,:], bU[2:2,:]\n([1 0], [0 1])\n\njulia> N = lattice_in_same_ambient_space(U, e1 + e2)\nInteger lattice of rank 1 and degree 2\nwith gram matrix\n[6]\n\njulia> is_primitive(U, N)\ntrue\n\njulia> M = root_lattice(:A, 3);\n\njulia> f = matrix(QQ, 3, 3, [0 1 1; -1 -1 -1; 1 1 0]);\n\njulia> N = kernel_lattice(M, f+1)\nInteger lattice of rank 1 and degree 3\nwith gram matrix\n[4]\n\njulia> is_primitive(M, N)\ntrue\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/quad_forms/integer_lattices/#is_primitive-Tuple{ZZLat, Union{QQMatrix, Vector}}","page":"Integer Lattices","title":"is_primitive","text":"is_primitive(L::ZZLat, v::Union{Vector, QQMatrix}) -> Bool\n\nReturn whether the vector v is primitive in L.\n\nA vector v in a mathbb Z-lattice L is called primitive if for all w in L such that v = dw for some integer d, then d = pm 1.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/quad_forms/integer_lattices/#divisibility-Tuple{ZZLat, Union{QQMatrix, Vector}}","page":"Integer Lattices","title":"divisibility","text":"divisibility(L::ZZLat, v::Union{Vector, QQMatrix}) -> QQFieldElem\n\nReturn the divisibility of v with respect to L.\n\nFor a vector v in the ambient quadratic space (V Phi) of L, we call the divisibility of v with the respect to L the non-negative generator of the fractional mathbb Z-ideal Phi(v L).\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/quad_forms/integer_lattices/#Embeddings","page":"Integer Lattices","title":"Embeddings","text":"","category":"section"},{"location":"Hecke/manual/quad_forms/integer_lattices/#Categorical-constructions","page":"Integer Lattices","title":"Categorical constructions","text":"","category":"section"},{"location":"Hecke/manual/quad_forms/integer_lattices/","page":"Integer Lattices","title":"Integer Lattices","text":"direct_sum(x::Vector{ZZLat})\ndirect_product(x::Vector{ZZLat})\nbiproduct(x::Vector{ZZLat})","category":"page"},{"location":"Hecke/manual/quad_forms/integer_lattices/#direct_sum-Tuple{Vector{ZZLat}}","page":"Integer Lattices","title":"direct_sum","text":"direct_sum(x::Vararg{ZZLat}) -> ZZLat, Vector{AbstractSpaceMor}\ndirect_sum(x::Vector{ZZLat}) -> ZZLat, Vector{AbstractSpaceMor}\n\nGiven a collection of mathbb Z-lattices L_1 ldots L_n, return their direct sum L = L_1 oplus ldots oplus L_n, together with the injections L_i to L. (seen as maps between the corresponding ambient spaces).\n\nFor objects of type ZZLat, finite direct sums and finite direct products agree and they are therefore called biproducts. If one wants to obtain L as a direct product with the projections L to L_i, one should call direct_product(x). If one wants to obtain L as a biproduct with the injections L_i to L and the projections L to L_i, one should call biproduct(x).\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/quad_forms/integer_lattices/#direct_product-Tuple{Vector{ZZLat}}","page":"Integer Lattices","title":"direct_product","text":"direct_product(x::Vararg{ZZLat}) -> ZZLat, Vector{AbstractSpaceMor}\ndirect_product(x::Vector{ZZLat}) -> ZZLat, Vector{AbstractSpaceMor}\n\nGiven a collection of mathbb Z-lattices L_1 ldots L_n, return their direct product L = L_1 times ldots times L_n, together with the projections L to L_i. (seen as maps between the corresponding ambient spaces).\n\nFor objects of type ZZLat, finite direct sums and finite direct products agree and they are therefore called biproducts. If one wants to obtain L as a direct sum with the injections L_i to L, one should call direct_sum(x). If one wants to obtain L as a biproduct with the injections L_i to L and the projections L to L_i, one should call biproduct(x).\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/quad_forms/integer_lattices/#biproduct-Tuple{Vector{ZZLat}}","page":"Integer Lattices","title":"biproduct","text":"biproduct(x::Vararg{ZZLat}) -> ZZLat, Vector{AbstractSpaceMor}, Vector{AbstractSpaceMor}\nbiproduct(x::Vector{ZZLat}) -> ZZLat, Vector{AbstractSpaceMor}, Vector{AbstractSpaceMor}\n\nGiven a collection of mathbb Z-lattices L_1 ldots L_n, return their biproduct L = L_1 oplus ldots oplus L_n, together with the injections L_i to L and the projections L to L_i. (seen as maps between the corresponding ambient spaces).\n\nFor objects of type ZZLat, finite direct sums and finite direct products agree and they are therefore called biproducts. If one wants to obtain L as a direct sum with the injections L_i to L, one should call direct_sum(x). If one wants to obtain L as a direct product with the projections L to L_i, one should call direct_product(x).\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/quad_forms/integer_lattices/#Orthogonal-sublattices","page":"Integer Lattices","title":"Orthogonal sublattices","text":"","category":"section"},{"location":"Hecke/manual/quad_forms/integer_lattices/","page":"Integer Lattices","title":"Integer Lattices","text":"orthogonal_submodule(::ZZLat, ::ZZLat)\nirreducible_components(::ZZLat)","category":"page"},{"location":"Hecke/manual/quad_forms/integer_lattices/#orthogonal_submodule-Tuple{ZZLat, ZZLat}","page":"Integer Lattices","title":"orthogonal_submodule","text":"orthogonal_submodule(L::ZZLat, S::ZZLat) -> ZZLat\n\nReturn the largest submodule of L orthogonal to S.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/quad_forms/integer_lattices/#irreducible_components-Tuple{ZZLat}","page":"Integer Lattices","title":"irreducible_components","text":"irreducible_components(L::ZZLat) -> Vector{ZZLat}\n\nReturn the irreducible components L_i of the positive definite lattice L.\n\nThis yields a maximal orthogonal splitting of L as\n\nL = bigoplus_i L_i\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/quad_forms/integer_lattices/#Dual-lattice","page":"Integer Lattices","title":"Dual lattice","text":"","category":"section"},{"location":"Hecke/manual/quad_forms/integer_lattices/","page":"Integer Lattices","title":"Integer Lattices","text":"dual(L::ZZLat)","category":"page"},{"location":"Hecke/manual/quad_forms/integer_lattices/#dual-Tuple{ZZLat}","page":"Integer Lattices","title":"dual","text":"dual(L::AbstractLat) -> AbstractLat\n\nReturn the dual lattice of the lattice L.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/quad_forms/integer_lattices/#Discriminant-group","page":"Integer Lattices","title":"Discriminant group","text":"","category":"section"},{"location":"Hecke/manual/quad_forms/integer_lattices/","page":"Integer Lattices","title":"Integer Lattices","text":"See discriminant_group(L::ZZLat).","category":"page"},{"location":"Hecke/manual/quad_forms/integer_lattices/#Overlattices","page":"Integer Lattices","title":"Overlattices","text":"","category":"section"},{"location":"Hecke/manual/quad_forms/integer_lattices/","page":"Integer Lattices","title":"Integer Lattices","text":"glue_map(L::ZZLat, S::ZZLat, R::ZZLat; check=true)\noverlattice(glue_map::TorQuadModuleMap)\nlocal_modification(M::ZZLat, L::ZZLat, p)\nmaximal_integral_lattice(L::ZZLat)","category":"page"},{"location":"Hecke/manual/quad_forms/integer_lattices/#glue_map-Tuple{ZZLat, ZZLat, ZZLat}","page":"Integer Lattices","title":"glue_map","text":"glue_map(L::ZZLat, S::ZZLat, R::ZZLat; check=true)\n                       -> Tuple{TorQuadModuleMap, TorQuadModuleMap, TorQuadModuleMap}\n\nGiven three integral mathbb Z-lattices L, S and R, with S and R primitive sublattices of L and such that the sum of the ranks of S and R is equal to the rank of L, return the glue map gamma of the primitive extension S+R subseteq L, as well as the inclusion maps of the domain and codomain of gamma into the respective discriminant groups of S and R.\n\nExample\n\njulia> M = root_lattice(:E,8);\n\njulia> f = matrix(QQ, 8, 8, [-1 -1  0  0  0  0  0  0;\n                              1  0  0  0  0  0  0  0;\n                              0  1  1  0  0  0  0  0;\n                              0  0  0  1  0  0  0  0;\n                              0  0  0  0  1  0  0  0;\n                              0  0  0  0  0  1  1  0;\n                             -2 -4 -6 -5 -4 -3 -2 -3;\n                              0  0  0  0  0  0  0  1]);\n\njulia> S = kernel_lattice(M ,f-1)\nInteger lattice of rank 4 and degree 8\nwith gram matrix\n[12   -3    0   -3]\n[-3    2   -1    0]\n[ 0   -1    2    0]\n[-3    0    0    2]\n\njulia> R = kernel_lattice(M , f^2+f+1)\nInteger lattice of rank 4 and degree 8\nwith gram matrix\n[ 2   -1    0    0]\n[-1    2   -6    0]\n[ 0   -6   30   -3]\n[ 0    0   -3    2]\n\njulia> glue, iS, iR = glue_map(M, S, R)\n(Map: finite quadratic module -> finite quadratic module, Map: finite quadratic module -> finite quadratic module, Map: finite quadratic module -> finite quadratic module)\n\njulia> is_bijective(glue)\ntrue\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/quad_forms/integer_lattices/#overlattice-Tuple{TorQuadModuleMap}","page":"Integer Lattices","title":"overlattice","text":"overlattice(glue_map::TorQuadModuleMap) -> ZZLat\n\nGiven the glue map of a primitive extension of mathbb Z-lattices S+R subseteq L, return L.\n\nExample\n\njulia> M = root_lattice(:E,8);\n\njulia> f = matrix(QQ, 8, 8, [ 1  0  0  0  0  0  0  0;\n                              0  1  0  0  0  0  0  0;\n                              1  2  4  4  3  2  1  2;\n                             -2 -4 -6 -5 -4 -3 -2 -3;\n                              2  4  6  4  3  2  1  3;\n                             -1 -2 -3 -2 -1  0  0 -2;\n                              0  0  0  0  0 -1  0  0;\n                             -1 -2 -3 -3 -2 -1  0 -1]);\n\njulia> S = kernel_lattice(M ,f-1)\nInteger lattice of rank 4 and degree 8\nwith gram matrix\n[ 2   -1     0     0]\n[-1    2    -1     0]\n[ 0   -1    12   -15]\n[ 0    0   -15    20]\n\njulia> R = kernel_lattice(M , f^4+f^3+f^2+f+1)\nInteger lattice of rank 4 and degree 8\nwith gram matrix\n[10   -4    0    1]\n[-4    2   -1    0]\n[ 0   -1    4   -3]\n[ 1    0   -3    4]\n\njulia> glue, iS, iR = glue_map(M, S, R);\n\njulia> overlattice(glue) == M\ntrue\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/quad_forms/integer_lattices/#local_modification-Tuple{ZZLat, ZZLat, Any}","page":"Integer Lattices","title":"local_modification","text":"local_modification(M::ZZLat, L::ZZLat, p)\n\nReturn a local modification of M that matches L at p.\n\nINPUT:\n\nM – a \\mathbb{Z}_p-maximal lattice\nL – the a lattice           isomorphic to M over \\QQ_p\np – a prime number\n\nOUTPUT:\n\nan integral lattice M' in the ambient space of M such that M and M' are locally equal at all completions except at p where M' is locally isometric to the lattice L.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/quad_forms/integer_lattices/#maximal_integral_lattice-Tuple{ZZLat}","page":"Integer Lattices","title":"maximal_integral_lattice","text":"maximal_integral_lattice(L::AbstractLat) -> AbstractLat\n\nGiven a lattice L with integral norm, return a maximal integral overlattice M of L.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/quad_forms/integer_lattices/#Sublattices-defined-by-endomorphisms","page":"Integer Lattices","title":"Sublattices defined by endomorphisms","text":"","category":"section"},{"location":"Hecke/manual/quad_forms/integer_lattices/","page":"Integer Lattices","title":"Integer Lattices","text":"kernel_lattice(L::ZZLat, f::MatElem)\ninvariant_lattice(L::ZZLat, G::Vector{<:MatElem})\ncoinvariant_lattice(::ZZLat, ::Union{MatElem, Vector{<:MatElem}})","category":"page"},{"location":"Hecke/manual/quad_forms/integer_lattices/#kernel_lattice-Tuple{ZZLat, MatElem}","page":"Integer Lattices","title":"kernel_lattice","text":"kernel_lattice(L::ZZLat, f::MatElem;\n               ambient_representation::Bool = true) -> ZZLat\n\nGiven a mathbfZ-lattice L and a matrix f inducing an endomorphism of L, return ker(f) is a sublattice of L.\n\nIf ambient_representation is true (the default), the endomorphism is represented with respect to the ambient space of L. Otherwise, the endomorphism is represented with respect to the basis of L.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/quad_forms/integer_lattices/#invariant_lattice-Tuple{ZZLat, Vector{<:MatElem}}","page":"Integer Lattices","title":"invariant_lattice","text":"invariant_lattice(L::ZZLat, G::Vector{MatElem};\n                  ambient_representation::Bool = true) -> ZZLat\ninvariant_lattice(L::ZZLat, G::MatElem;\n                  ambient_representation::Bool = true) -> ZZLat\n\nGiven a mathbfZ-lattice L and a list of matrices G inducing endomorphisms of L (or just one matrix G), return the lattice L^G, consisting on elements fixed by G.\n\nIf ambient_representation is true (the default), the endomorphism is represented with respect to the ambient space of L. Otherwise, the endomorphism is represented with respect to the basis of L.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/quad_forms/integer_lattices/#coinvariant_lattice-Tuple{ZZLat, Union{MatElem, Vector{<:MatElem}}}","page":"Integer Lattices","title":"coinvariant_lattice","text":"coinvariant_lattice(L::ZZLat, G::Vector{MatElem};\n                    ambient_representation::Bool = true) -> ZZLat\ncoinvariant_lattice(L::ZZLat, G::MatElem;\n                    ambient_representation::Bool = true) -> ZZLat\n\nGiven a mathbfZ-lattice L and a list of matrices G inducing endomorphisms of L (or just one matrix G), return the orthogonal complement L_G in L of the fixed lattice L^G (see invariant_lattice).\n\nIf ambient_representation is true (the default), the endomorphism is represented with respect to the ambient space of L. Otherwise, the endomorphism is represented with respect to the basis of L.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/quad_forms/integer_lattices/#Computing-embeddings","page":"Integer Lattices","title":"Computing embeddings","text":"","category":"section"},{"location":"Hecke/manual/quad_forms/integer_lattices/","page":"Integer Lattices","title":"Integer Lattices","text":"embed(S::ZZLat, G::ZZGenus)\nembed_in_unimodular(::ZZLat, ::IntegerUnion, ::IntegerUnion)","category":"page"},{"location":"Hecke/manual/quad_forms/integer_lattices/#embed-Tuple{ZZLat, ZZGenus}","page":"Integer Lattices","title":"embed","text":"embed(S::ZZLat, G::Genus, primitive::Bool=true) -> Bool, embedding\n\nReturn a (primitive) embedding of the integral lattice S into some lattice in the genus of G.\n\njulia> G = integer_genera((8,0), 1, even=true)[1];\n\njulia> L, S, i = embed(root_lattice(:A,5), G);\n\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/quad_forms/integer_lattices/#embed_in_unimodular-Tuple{ZZLat, Union{Integer, ZZRingElem}, Union{Integer, ZZRingElem}}","page":"Integer Lattices","title":"embed_in_unimodular","text":"embed_in_unimodular(S::ZZLat, pos::Int, neg::Int, primitive=true, even=true) -> Bool, L, S', iS, iR\n\nReturn a (primitive) embedding of the integral lattice S into some (even) unimodular lattice of signature (pos, neg).\n\nFor now this works only for even lattices.\n\njulia> NS = direct_sum(integer_lattice(:U), rescale(root_lattice(:A, 16), -1))[1];\n\njulia> LK3, iNS, i = embed_in_unimodular(NS, 3, 19);\n\njulia> genus(LK3)\nGenus symbol for integer lattices\nSignatures: (3, 0, 19)\nLocal symbol:\n  Local genus symbol at 2: 1^22\n\njulia> iNS\nInteger lattice of rank 18 and degree 22\nwith gram matrix\n[0   1    0    0    0    0    0    0    0    0    0    0    0    0    0    0    0    0]\n[1   0    0    0    0    0    0    0    0    0    0    0    0    0    0    0    0    0]\n[0   0   -2    1    0    0    0    0    0    0    0    0    0    0    0    0    0    0]\n[0   0    1   -2    1    0    0    0    0    0    0    0    0    0    0    0    0    0]\n[0   0    0    1   -2    1    0    0    0    0    0    0    0    0    0    0    0    0]\n[0   0    0    0    1   -2    1    0    0    0    0    0    0    0    0    0    0    0]\n[0   0    0    0    0    1   -2    1    0    0    0    0    0    0    0    0    0    0]\n[0   0    0    0    0    0    1   -2    1    0    0    0    0    0    0    0    0    0]\n[0   0    0    0    0    0    0    1   -2    1    0    0    0    0    0    0    0    0]\n[0   0    0    0    0    0    0    0    1   -2    1    0    0    0    0    0    0    0]\n[0   0    0    0    0    0    0    0    0    1   -2    1    0    0    0    0    0    0]\n[0   0    0    0    0    0    0    0    0    0    1   -2    1    0    0    0    0    0]\n[0   0    0    0    0    0    0    0    0    0    0    1   -2    1    0    0    0    0]\n[0   0    0    0    0    0    0    0    0    0    0    0    1   -2    1    0    0    0]\n[0   0    0    0    0    0    0    0    0    0    0    0    0    1   -2    1    0    0]\n[0   0    0    0    0    0    0    0    0    0    0    0    0    0    1   -2    1    0]\n[0   0    0    0    0    0    0    0    0    0    0    0    0    0    0    1   -2    1]\n[0   0    0    0    0    0    0    0    0    0    0    0    0    0    0    0    1   -2]\n\njulia> is_primitive(LK3, iNS)\ntrue\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/quad_forms/integer_lattices/#LLL,-Short-and-Close-Vectors","page":"Integer Lattices","title":"LLL, Short and Close Vectors","text":"","category":"section"},{"location":"Hecke/manual/quad_forms/integer_lattices/#LLL-and-indefinite-LLL","page":"Integer Lattices","title":"LLL and indefinite LLL","text":"","category":"section"},{"location":"Hecke/manual/quad_forms/integer_lattices/","page":"Integer Lattices","title":"Integer Lattices","text":"lll(L::ZZLat; same_ambient::Bool = true)","category":"page"},{"location":"Hecke/manual/quad_forms/integer_lattices/#lll-Tuple{ZZLat}","page":"Integer Lattices","title":"lll","text":"lll(L::ZZLat, same_ambient::Bool = true) -> ZZLat\n\nGiven an integral mathbb Z-lattice L with basis matrix B, compute a basis C of L such that the gram matrix G_C of L with respect to C is LLL-reduced.\n\nBy default, it creates the lattice in the same ambient space as L. This can be disabled by setting same_ambient = false. Works with both definite and indefinite lattices.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/quad_forms/integer_lattices/#Short-Vectors","page":"Integer Lattices","title":"Short Vectors","text":"","category":"section"},{"location":"Hecke/manual/quad_forms/integer_lattices/","page":"Integer Lattices","title":"Integer Lattices","text":"short_vectors\nshortest_vectors\nshort_vectors_iterator\nminimum(L::ZZLat)\nkissing_number(L::ZZLat)","category":"page"},{"location":"Hecke/manual/quad_forms/integer_lattices/#short_vectors","page":"Integer Lattices","title":"short_vectors","text":"short_vectors(L::ZZLat, [lb = 0], ub, [elem_type = ZZRingElem]; check::Bool = true)\n                                   -> Vector{Tuple{Vector{elem_type}, QQFieldElem}}\n\nReturn all tuples (v, n) such that n = v G v^t satisfies lb <= n <= ub, where G is the Gram matrix of L and v is non-zero.\n\nNote that the vectors are computed up to sign (so only one of v and -v appears).\n\nIt is assumed and checked that L is definite.\n\nSee also short_vectors_iterator for an iterator version.\n\n\n\n\n\n","category":"function"},{"location":"Hecke/manual/quad_forms/integer_lattices/#shortest_vectors","page":"Integer Lattices","title":"shortest_vectors","text":"shortest_vectors(L::ZZLat, [elem_type = ZZRingElem]; check::Bool = true)\n                                           -> QQFieldElem, Vector{elem_type}, QQFieldElem}\n\nReturn the list of shortest non-zero vectors in absolute value. Note that the vectors are computed up to sign (so only one of v and -v appears).\n\nIt is assumed and checked that L is definite.\n\nSee also minimum.\n\n\n\n\n\n","category":"function"},{"location":"Hecke/manual/quad_forms/integer_lattices/#short_vectors_iterator","page":"Integer Lattices","title":"short_vectors_iterator","text":"short_vectors_iterator(L::ZZLat, [lb = 0], ub,\n                       [elem_type = ZZRingElem]; check::Bool = true)\n                                -> Tuple{Vector{elem_type}, QQFieldElem} (iterator)\n\nReturn an iterator for all tuples (v, n) such that n = v G v^t satisfies lb <= n <= ub, where G is the Gram matrix of L and v is non-zero.\n\nNote that the vectors are computed up to sign (so only one of v and -v appears).\n\nIt is assumed and checked that L is definite.\n\nSee also short_vectors.\n\n\n\n\n\n","category":"function"},{"location":"Hecke/manual/quad_forms/integer_lattices/#minimum-Tuple{ZZLat}","page":"Integer Lattices","title":"minimum","text":"minimum(L::ZZLat) -> QQFieldElem\n\nReturn the minimum absolute squared length among the non-zero vectors in L.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/quad_forms/integer_lattices/#kissing_number-Tuple{ZZLat}","page":"Integer Lattices","title":"kissing_number","text":"kissing_number(L::ZZLat) -> Int\n\nReturn the Kissing number of the sphere packing defined by L.\n\nThis is the number of non-overlapping spheres touching any other given sphere.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/quad_forms/integer_lattices/#Close-Vectors","page":"Integer Lattices","title":"Close Vectors","text":"","category":"section"},{"location":"Hecke/manual/quad_forms/integer_lattices/","page":"Integer Lattices","title":"Integer Lattices","text":"close_vectors(L::ZZLat, v::Vector, arg...; kw...)","category":"page"},{"location":"Hecke/manual/quad_forms/integer_lattices/#close_vectors-Tuple{ZZLat, Vector, Vararg{Any}}","page":"Integer Lattices","title":"close_vectors","text":"close_vectors(L:ZZLat, v:Vector, [lb,], ub; check::Bool = false)\n                                        -> Vector{Tuple{Vector{Int}}, QQFieldElem}\n\nReturn all tuples (x, d) where x is an element of L such that d = b(v - x, v - x) <= ub. If lb is provided, then also lb <= d.\n\nIf filter is not nothing, then only those x with filter(x) evaluating to true are returned.\n\nBy default, it will be checked whether L is positive definite. This can be disabled setting check = false.\n\nBoth input and output are with respect to the basis matrix of L.\n\nExamples\n\njulia> L = integer_lattice(matrix(QQ, 2, 2, [1, 0, 0, 2]));\n\njulia> close_vectors(L, [1, 1], 1)\n3-element Vector{Tuple{Vector{ZZRingElem}, QQFieldElem}}:\n ([2, 1], 1)\n ([0, 1], 1)\n ([1, 1], 0)\n\njulia> close_vectors(L, [1, 1], 1, 1)\n2-element Vector{Tuple{Vector{ZZRingElem}, QQFieldElem}}:\n ([2, 1], 1)\n ([0, 1], 1)\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/quad_forms/integer_lattices/","page":"Integer Lattices","title":"Integer Lattices","text":"","category":"page"},{"location":"Fields/intro/","page":"Introduction","title":"Introduction","text":"CurrentModule = Oscar\nDocTestSetup = Oscar.doctestsetup()","category":"page"},{"location":"Fields/intro/#fields","page":"Introduction","title":"Introduction","text":"","category":"section"},{"location":"Fields/intro/","page":"Introduction","title":"Introduction","text":"The fields part of OSCAR provides functionality for handling various kinds of fields:","category":"page"},{"location":"Fields/intro/","page":"Introduction","title":"Introduction","text":"the field of rationals\nNumber fields\nGeneric fraction fields\nlocal fields (Padics and Qadics)\nfinite fields\nAlgebraic numbers\nAlgebraic closure of finite prime fields","category":"page"},{"location":"Fields/intro/","page":"Introduction","title":"Introduction","text":"General textbooks offering details on theory and algorithms include:","category":"page"},{"location":"Fields/intro/","page":"Introduction","title":"Introduction","text":"[Coh93]\n[Coh00]\n[LN97]\n[Mar18]\n[PZ97]","category":"page"},{"location":"Fields/intro/#Contact","page":"Introduction","title":"Contact","text":"","category":"section"},{"location":"Fields/intro/","page":"Introduction","title":"Introduction","text":"Please direct questions about this part of OSCAR to the following people:","category":"page"},{"location":"Fields/intro/","page":"Introduction","title":"Introduction","text":"Claus Fieker,\nTommy Hofmann,\nMax Horn.","category":"page"},{"location":"Fields/intro/","page":"Introduction","title":"Introduction","text":"You can ask questions in the OSCAR Slack.","category":"page"},{"location":"Fields/intro/","page":"Introduction","title":"Introduction","text":"Alternatively, you can raise an issue on github.","category":"page"},{"location":"AlgebraicGeometry/Surfaces/EllipticSurface/","page":"Elliptic Surfaces","title":"Elliptic Surfaces","text":"CurrentModule = Oscar","category":"page"},{"location":"AlgebraicGeometry/Surfaces/EllipticSurface/#Elliptic-Surfaces","page":"Elliptic Surfaces","title":"Elliptic Surfaces","text":"","category":"section"},{"location":"AlgebraicGeometry/Surfaces/EllipticSurface/","page":"Elliptic Surfaces","title":"Elliptic Surfaces","text":"See [SS19] for the theory of elliptic surfaces.","category":"page"},{"location":"AlgebraicGeometry/Surfaces/EllipticSurface/","page":"Elliptic Surfaces","title":"Elliptic Surfaces","text":"EllipticSurface","category":"page"},{"location":"AlgebraicGeometry/Surfaces/EllipticSurface/#EllipticSurface","page":"Elliptic Surfaces","title":"EllipticSurface","text":"EllipticSurface{BaseField<:Field, BaseCurveFieldType} <: AbsCoveredScheme{BaseField}\n\nA relatively minimal elliptic surface defined as follows.\n\nA genus 1-fibration is a proper map\n\npi colon X to C\n\nfrom a smooth projective surface X to a smooth projective curve C whose generic fiber is a curve of (arithmetic) genus 1.\n\nThe fibration is relatively minimal if its fibers do not contain any (-1)-curves. We call the fibration elliptic if it is relatively minimal and comes equipped with a section sigma_0colon mathbbP^1 to X. This turns the generic fiber of pi into an elliptic curve Ek(C) where k(C) is the function field of the curve C.\n\nWe further require that pi has at least one singular fiber and that the base field k is perfect. \n\nFor now functionality is restricted to C = mathbbP^1.\n\nThis datatype stores a subgroup of the Mordell-Weil group E(k(C)). It is referred to as the  Mordell-Weil subgroup of X.\n\n\n\n\n\n","category":"type"},{"location":"AlgebraicGeometry/Surfaces/EllipticSurface/#Constructors","page":"Elliptic Surfaces","title":"Constructors","text":"","category":"section"},{"location":"AlgebraicGeometry/Surfaces/EllipticSurface/","page":"Elliptic Surfaces","title":"Elliptic Surfaces","text":"elliptic_surface\nkodaira_neron_model(E::EllipticCurve)","category":"page"},{"location":"AlgebraicGeometry/Surfaces/EllipticSurface/#elliptic_surface","page":"Elliptic Surfaces","title":"elliptic_surface","text":"elliptic_surface(generic_fiber::EllipticCurve,\n                 euler_characteristic::Int,\n                 mwl_gens::Vector{<:EllipticCurvePoint}=EllipticCurvePoint[];\n                 is_basis::Bool=true)\n                 -> EllipticSurface\n\nReturn the relatively minimal elliptic surface with generic fiber Ek(t).\n\nThis is also known as the Kodaira-Néron model of E.\n\nInput:\n\ngeneric_fiber – an elliptic curve over a function field\neuler_characteristic – the Euler characteristic of the Kodaira-Néron model of E.\nmwl_gens – a vector of rational points of the generic fiber\nis_basis – if set to false compute a reduced basis from mwl_gens\n\nExamples\n\njulia> Qt, t = polynomial_ring(QQ, :t);\n\njulia> Qtf = fraction_field(Qt);\n\njulia> E = elliptic_curve(Qtf, [0,0,0,0,t^5*(t-1)^2]);\n\njulia> X3 = elliptic_surface(E, 2)\nElliptic surface\n  over rational field\nwith generic fiber\n  -x^3 + y^2 - t^7 + 2*t^6 - t^5\n\n\n\n\n\n\nelliptic_surface(g::MPolyRingElem, P::Vector{<:RingElem})\n\nTransform a bivariate polynomial g of the form y^2 - Q(x) with Q(x) of degree at most 4 to Weierstrass form, apply Tate's algorithm and  return the corresponding relatively minimal elliptic surface  as well as the coordinate transformation.\n\n\n\n\n\n","category":"function"},{"location":"AlgebraicGeometry/Surfaces/EllipticSurface/#kodaira_neron_model-Tuple{EllipticCurve}","page":"Elliptic Surfaces","title":"kodaira_neron_model","text":"kodaira_neron_model(E::EllipticCurve) -> EllipticSurface\n\nReturn the Kodaira-Neron model of the elliptic curve E.\n\n\n\n\n\n","category":"method"},{"location":"AlgebraicGeometry/Surfaces/EllipticSurface/#Attributes","page":"Elliptic Surfaces","title":"Attributes","text":"","category":"section"},{"location":"AlgebraicGeometry/Surfaces/EllipticSurface/","page":"Elliptic Surfaces","title":"Elliptic Surfaces","text":"generic_fiber(S::EllipticSurface)\nzero_section(S::EllipticSurface)\neuler_characteristic(X::EllipticSurface)\nfibration(X::EllipticSurface)\nweierstrass_chart(X::EllipticSurface)\nweierstrass_chart_on_minimal_model(X::EllipticSurface)\nweierstrass_model(X::EllipticSurface)\nweierstrass_contraction(X::EllipticSurface)\nfibration_on_weierstrass_model(X::EllipticSurface)","category":"page"},{"location":"AlgebraicGeometry/Surfaces/EllipticSurface/#generic_fiber-Tuple{EllipticSurface}","page":"Elliptic Surfaces","title":"generic_fiber","text":"generic_fiber(X::EllipticSurface) -> EllipticCurve\n\nReturn the generic fiber as an elliptic curve.\n\n\n\n\n\n","category":"method"},{"location":"AlgebraicGeometry/Surfaces/EllipticSurface/#zero_section-Tuple{EllipticSurface}","page":"Elliptic Surfaces","title":"zero_section","text":"zero_section(X::EllipticSurface) -> AbsWeilDivisor\n\nReturn the zero section of the relatively minimal elliptic fibration picolon X to C.\n\n\n\n\n\n","category":"method"},{"location":"AlgebraicGeometry/Surfaces/EllipticSurface/#euler_characteristic-Tuple{EllipticSurface}","page":"Elliptic Surfaces","title":"euler_characteristic","text":"euler_characteristic(X::EllipticSurface) -> Int\n\nReturn the Euler characteristic chi(mathcalO_X).\n\n\n\n\n\n","category":"method"},{"location":"AlgebraicGeometry/Surfaces/EllipticSurface/#fibration-Tuple{EllipticSurface}","page":"Elliptic Surfaces","title":"fibration","text":"fibration(X::EllipticSurface)\n\nReturn the elliptic fibration X to mathbbP^1.\n\n\n\n\n\n","category":"method"},{"location":"AlgebraicGeometry/Surfaces/EllipticSurface/#weierstrass_chart-Tuple{EllipticSurface}","page":"Elliptic Surfaces","title":"weierstrass_chart","text":"weierstrass_chart(X::EllipticSurface)\n\nReturn the Weierstrass chart of X on its weierstrass_model.\n\n\n\n\n\n","category":"method"},{"location":"AlgebraicGeometry/Surfaces/EllipticSurface/#weierstrass_chart_on_minimal_model-Tuple{EllipticSurface}","page":"Elliptic Surfaces","title":"weierstrass_chart_on_minimal_model","text":"weierstrass_chart_on_minimal_model(X::EllipticSurface)\n\nReturn an affine chart U of X which is isomorphic to the weierstrass_chart  of X on its weierstrass_model, but with all singular fibers removed.\n\nMore precisely, the affine coordinates of U are (xyt) and the chart is  constructed as the vanishing locus of\n\ny^2 + a_1(t) xy + a_3 y = x^3 + a_2 x^2 + a_4 x + a_6\n\nminus the reducible singular fibers.\n\n\n\n\n\n","category":"method"},{"location":"AlgebraicGeometry/Surfaces/EllipticSurface/#weierstrass_model-Tuple{EllipticSurface}","page":"Elliptic Surfaces","title":"weierstrass_model","text":"weierstrass_model(X::EllipticSurface) -> CoveredScheme, CoveredClosedEmbedding\n\nReturn the Weierstrass model W of X and the inclusion in its ambient projective bundle\n\nSsubseteq mathbbP( mathcalO_mathbbP^1(-2s) oplus mathcalO_mathbbP^1(-3s) oplus mathcalO_mathbbP^1)\n\n\n\n\n\n","category":"method"},{"location":"AlgebraicGeometry/Surfaces/EllipticSurface/#weierstrass_contraction-Tuple{EllipticSurface}","page":"Elliptic Surfaces","title":"weierstrass_contraction","text":"weierstrass_contraction(X::EllipticSurface) -> SchemeMor\n\nReturn the contraction morphism of X to its Weierstrass model.\n\nThis triggers the computation of the underlying_scheme of X as a blowup from its Weierstrass model. It may take a few minutes.\n\n\n\n\n\n","category":"method"},{"location":"AlgebraicGeometry/Surfaces/EllipticSurface/#fibration_on_weierstrass_model-Tuple{EllipticSurface}","page":"Elliptic Surfaces","title":"fibration_on_weierstrass_model","text":"fibration_on_weierstrass_model(X::EllipticSurface)\n\nReturn the elliptic fibration W to mathbbP^1 where W is the Weierstrass model of X.\n\n\n\n\n\n","category":"method"},{"location":"AlgebraicGeometry/Surfaces/EllipticSurface/#Reducible-fibers-and-the-trivial-lattice","page":"Elliptic Surfaces","title":"Reducible fibers and the trivial lattice","text":"","category":"section"},{"location":"AlgebraicGeometry/Surfaces/EllipticSurface/","page":"Elliptic Surfaces","title":"Elliptic Surfaces","text":"trivial_lattice(X::EllipticSurface)\nreducible_fibers(S::EllipticSurface)\nfiber_cartier(S::EllipticSurface, P::Vector = ZZ.([0,1]))\nfiber_components(S::EllipticSurface, P; algorithm=:exceptional_divisors)","category":"page"},{"location":"AlgebraicGeometry/Surfaces/EllipticSurface/#trivial_lattice-Tuple{EllipticSurface}","page":"Elliptic Surfaces","title":"trivial_lattice","text":"trivial_lattice(X::EllipticSurface) -> Vector{AbsWeilDivisor}, ZZMatrix\n\nReturn a basis for the trivial lattice as well as its Gram matrix.\n\nThe trivial lattice is the sublattice of the numerical lattice spanned by fiber components and the zero section of X.\n\nwarning: Warning\nThe ordering of the basis is in general not canonical and may change in between sessions. \n\n\n\n\n\n","category":"method"},{"location":"AlgebraicGeometry/Surfaces/EllipticSurface/#reducible_fibers-Tuple{EllipticSurface}","page":"Elliptic Surfaces","title":"reducible_fibers","text":"reducible_fibers(X::EllipticSurface)\n\nReturn the reducible fibers of X.\n\nThe output format is the following: A list [F1, ..., Fn] where each entry Fi represents a reducible fiber.\n\nThe list F has the following entries:\n\nA point P in mathbbP^1 such that F = pi^-1(P);\nThe ADE-type of the fiber;\nThe fiber F as a Weil divisor, including its multiplicities;\nThe irreducible components of the fiber. The first component intersects the zero section;\nTheir intersection matrix.\n\n\n\n\n\n","category":"method"},{"location":"AlgebraicGeometry/Surfaces/EllipticSurface/#fiber_cartier","page":"Elliptic Surfaces","title":"fiber_cartier","text":"fiber_cartier(X::EllipticSurface, P::Vector = ZZ.([0,1])) -> EffectiveCartierDivisor\n\nReturn the fiber of picolon X to C over Pin C as a Cartier divisor.\n\n\n\n\n\n","category":"function"},{"location":"AlgebraicGeometry/Surfaces/EllipticSurface/#fiber_components-Tuple{EllipticSurface, Any}","page":"Elliptic Surfaces","title":"fiber_components","text":"fiber_components(X::EllipticSurface, P) -> Vector{<:AbsWeilDivisor}\n\nReturn the fiber components of the fiber over the point P in C.\n\n\n\n\n\n","category":"method"},{"location":"AlgebraicGeometry/Surfaces/EllipticSurface/#Mordell-Weil-group-and-related-lattices","page":"Elliptic Surfaces","title":"Mordell Weil group and related lattices","text":"","category":"section"},{"location":"AlgebraicGeometry/Surfaces/EllipticSurface/","page":"Elliptic Surfaces","title":"Elliptic Surfaces","text":"Since we require that pi colon X to C has a section, the generic fibre of pi is an elliptic curve Ek(C). The group E(k(C)) of its rational points is called the Mordell-Weil group. It is a finitely generated abelian group. In general it is difficult to compute.","category":"page"},{"location":"AlgebraicGeometry/Surfaces/EllipticSurface/","page":"Elliptic Surfaces","title":"Elliptic Surfaces","text":"The height paring gives the free part of the Mordell-Weil group the structure of a quadratic lattice over the integers – the so called Mordell-Weil lattice. ","category":"page"},{"location":"AlgebraicGeometry/Surfaces/EllipticSurface/","page":"Elliptic Surfaces","title":"Elliptic Surfaces","text":"algebraic_lattice(X::EllipticSurface)\nmordell_weil_sublattice(S::EllipticSurface)\nmordell_weil_torsion(S::EllipticSurface)\nsection(X::EllipticSurface, P::EllipticCurvePoint)\nbasis_representation(X::EllipticSurface, D::AbsWeilDivisor)","category":"page"},{"location":"AlgebraicGeometry/Surfaces/EllipticSurface/#algebraic_lattice-Tuple{EllipticSurface}","page":"Elliptic Surfaces","title":"algebraic_lattice","text":"algebraic_lattice(X) -> Vector{AbsWeilDivisor}, ZZLat\n\nReturn the sublattice L of the numerical lattice spanned by fiber components, torsion sections and the sections provided at the construction of X.\n\nThe first return value is a list B of vectors corresponding to the standard basis of the ambient space of L. The second consists of generators T for the torsion part of the Mordell-Weil group.  Together B and L generate the algebraic lattice. However, they are linearly dependent. The third return value is the lattice L.\n\nwarning: Warning\nThe ordering of the fiber components is in general not canonical and may change in between sessions. \n\n\n\n\n\n","category":"method"},{"location":"AlgebraicGeometry/Surfaces/EllipticSurface/#mordell_weil_sublattice-Tuple{EllipticSurface}","page":"Elliptic Surfaces","title":"mordell_weil_sublattice","text":"mordell_weil_sublattice(X::EllipticSurface) -> Vector{EllipticCurvePoint}, ZZLat\n\nReturn the (sublattice) of the Mordell-Weil lattice of X  spanned by the sections of X supplied at its construction.\n\nThe Mordell-Weil lattice is represented in the same vector space as the algebraic lattice (with quadratic form rescaled by -1).\n\n\n\n\n\n","category":"method"},{"location":"AlgebraicGeometry/Surfaces/EllipticSurface/#mordell_weil_torsion-Tuple{EllipticSurface}","page":"Elliptic Surfaces","title":"mordell_weil_torsion","text":"mordell_weil_torsion(X::EllipticSurface) -> Vector{EllipticCurvePoint}\n\nReturn the torsion part of the Mordell-Weil group of the generic fiber of X.\n\n\n\n\n\n","category":"method"},{"location":"AlgebraicGeometry/Surfaces/EllipticSurface/#section-Tuple{EllipticSurface, EllipticCurvePoint}","page":"Elliptic Surfaces","title":"section","text":"section(X::EllipticSurface, P::EllipticCurvePoint) -> EllipticSurfaceSection\n\nGiven a rational point Pin E(C) of the generic fiber EC of picolon X to C, return its closure in X as a AbsWeilDivisor.\n\n\n\n\n\n","category":"method"},{"location":"AlgebraicGeometry/Surfaces/EllipticSurface/#basis_representation-Tuple{EllipticSurface, Oscar.AbsWeilDivisor}","page":"Elliptic Surfaces","title":"basis_representation","text":"basis_representation(X::EllipticSurface, D::AbsWeilDivisor)\n\nReturn the vector representing the numerical class of D with respect to the basis of the ambient space of algebraic_lattice(X).\n\n\n\n\n\n","category":"method"},{"location":"AlgebraicGeometry/Surfaces/EllipticSurface/#Updating-the-Mordell-Weil-group","page":"Elliptic Surfaces","title":"Updating the Mordell Weil group","text":"","category":"section"},{"location":"AlgebraicGeometry/Surfaces/EllipticSurface/","page":"Elliptic Surfaces","title":"Elliptic Surfaces","text":"Since the Mordell-Weil group is hard to compute, the user has to provide its generators, or at least generators of a subgroup at construction of the surface. In some cases it may be convenient to enter the basis after creation, although it is in general not recommended. The following function are meant for this purpose.","category":"page"},{"location":"AlgebraicGeometry/Surfaces/EllipticSurface/","page":"Elliptic Surfaces","title":"Elliptic Surfaces","text":"set_mordell_weil_basis!(X::EllipticSurface, mwl_basis::Vector{<:EllipticCurvePoint})\nupdate_mwl_basis!(S::EllipticSurface, mwl_gens::Vector{<:EllipticCurvePoint})\nalgebraic_lattice_primitive_closure!(S::EllipticSurface)\nalgebraic_lattice_primitive_closure(S::EllipticSurface, p)","category":"page"},{"location":"AlgebraicGeometry/Surfaces/EllipticSurface/#set_mordell_weil_basis!-Tuple{EllipticSurface, Vector{<:EllipticCurvePoint}}","page":"Elliptic Surfaces","title":"set_mordell_weil_basis!","text":"set_mordell_weil_basis!(X::EllipticSurface, mwl_basis::Vector{EllipticCurvePoint})\n\nSet a basis for the Mordell-Weil sublattice of X or at least of a sublattice.\n\nThis invalidates previous computations depending on the generators of the Mordell Weil lattice such as the algebraic_lattice. Use with care.\n\nThe points in mwl_basis must be linearly independent.\n\n\n\n\n\n","category":"method"},{"location":"AlgebraicGeometry/Surfaces/EllipticSurface/#update_mwl_basis!-Tuple{EllipticSurface, Vector{<:EllipticCurvePoint}}","page":"Elliptic Surfaces","title":"update_mwl_basis!","text":"update_mwl_basis!(X::EllipticSurface, mwl_gens::Vector{<:EllipticCurvePoint})\n\nCompute a reduced basis of the sublattice of the Mordell-Weil lattice spanned by mwl_gens and set these as the new generators of the Mordell-Weil lattice of X.\n\n\n\n\n\n","category":"method"},{"location":"AlgebraicGeometry/Surfaces/EllipticSurface/#algebraic_lattice_primitive_closure!-Tuple{EllipticSurface}","page":"Elliptic Surfaces","title":"algebraic_lattice_primitive_closure!","text":"algebraic_lattice_primitive_closure!(X::EllipticSurface)\n\nCompute the primitive closure of the algebraic lattice of X inside its numerical lattice and update the generators of its Mordell–Weil group accordingly.\n\nThe algorithm works by computing suitable division points in its Mordell Weil group.\n\n\n\n\n\n","category":"method"},{"location":"AlgebraicGeometry/Surfaces/EllipticSurface/#algebraic_lattice_primitive_closure-Tuple{EllipticSurface, Any}","page":"Elliptic Surfaces","title":"algebraic_lattice_primitive_closure","text":"algebraic_lattice_primitive_closure(X::EllipticSurface, p) -> Vector{<:EllipticCurvePoint}\n\nReturn sections P_1dots P_n of the generic fiber, such that together with the generators of the algebraic lattice A, they generate\n\nfrac1p A cap N\n\nwhere N is the numerical lattice of X.\n\nThe algorithm proceeds by computing division points in the Mordell-Weil subgroup of X and using information coming from the discriminant group of the algebraic lattice to do so.\n\n\n\n\n\n","category":"method"},{"location":"AlgebraicGeometry/Surfaces/EllipticSurface/#Morphisms","page":"Elliptic Surfaces","title":"Morphisms","text":"","category":"section"},{"location":"AlgebraicGeometry/Surfaces/EllipticSurface/","page":"Elliptic Surfaces","title":"Elliptic Surfaces","text":"isomorphism_from_generic_fibers\nisomorphisms(X::EllipticSurface, Y::EllipticSurface)\ntranslation_morphism(X::EllipticSurface, P::EllipticCurvePoint)","category":"page"},{"location":"AlgebraicGeometry/Surfaces/EllipticSurface/#isomorphism_from_generic_fibers","page":"Elliptic Surfaces","title":"isomorphism_from_generic_fibers","text":"isomorphism_from_generic_fibers(X::EllipticSurface, Y::EllipticSurface, f::Hecke.EllCrvIso) -> MorphismFromRationalFunctions\n\nGiven an isomorphism f between the generic fibers of X and Y, return the corresponding  isomorphism of X and Y over mathbbP^1. \n\n\n\n\n\nisomorphism_from_generic_fibers(X::EllipticSurface, Y::EllipticSurface) -> MorphismFromRationalFunctions\n\nGiven given two elliptic surfaces X and Y whose generic fibers are isomorphic,  return the corresponding isomorphism of X and Y over mathbbP^1. \n\n\n\n\n\n","category":"function"},{"location":"AlgebraicGeometry/Surfaces/EllipticSurface/#isomorphisms-Tuple{EllipticSurface, EllipticSurface}","page":"Elliptic Surfaces","title":"isomorphisms","text":"isomorphisms(X::EllipticSurface, Y::EllipticSurface) -> Vector{MorphismFromRationalFunctions}\n\nGiven two elliptic surfaces X to mathbbP^1 and Y to mathbbP^1 return all  isomorphisms X to Y such that there exists Möbius transformation mathbbP^1 to mathbbP^1 fitting in the following commutative diagram.\n\nbeginarrayccc\n  X  to  Y \n  downarrow   downarrow\n  mathbbP^1  to   mathbbP^1\nendarray\n\n\n\n\n\n","category":"method"},{"location":"AlgebraicGeometry/Surfaces/EllipticSurface/#translation_morphism-Tuple{EllipticSurface, EllipticCurvePoint}","page":"Elliptic Surfaces","title":"translation_morphism","text":"translation_morphism(X::EllipticSurface, P::EllipticCurvePoint) -> MorphismFromRationalFunctions\n\nReturn the automorphism of X defined by fiberwise translation by the section P.\n\n\n\n\n\n","category":"method"},{"location":"AlgebraicGeometry/Surfaces/EllipticSurface/#Fibration-hopping","page":"Elliptic Surfaces","title":"Fibration hopping","text":"","category":"section"},{"location":"AlgebraicGeometry/Surfaces/EllipticSurface/","page":"Elliptic Surfaces","title":"Elliptic Surfaces","text":"The methods in this section are available only for elliptically fibered K3 surfaces.  A K3 surface X may admit several elliptic fibrations ","category":"page"},{"location":"AlgebraicGeometry/Surfaces/EllipticSurface/","page":"Elliptic Surfaces","title":"Elliptic Surfaces","text":"pi colon X to mathbbP^1","category":"page"},{"location":"AlgebraicGeometry/Surfaces/EllipticSurface/","page":"Elliptic Surfaces","title":"Elliptic Surfaces","text":"Fibration hopping is a way to compute them.  See e.g. [BE23] and [BZ23].","category":"page"},{"location":"AlgebraicGeometry/Surfaces/EllipticSurface/","page":"Elliptic Surfaces","title":"Elliptic Surfaces","text":"A divisor F on X is called elliptic if it is primitive, isotropic and nef.  The linear system F of an elliptic divisor F induces a genus one fibration on X. Conversely, the class of a fiber F of an elliptic fibration is an elliptic divisor. Two elliptic fibrations on X with elliptic divisors F_1 and F_2 are called n-neighbors if their intersection number is F_1F_2=n.","category":"page"},{"location":"AlgebraicGeometry/Surfaces/EllipticSurface/","page":"Elliptic Surfaces","title":"Elliptic Surfaces","text":"linear_system(X::EllipticSurface, P::EllipticCurvePoint, k::Int)\ntwo_neighbor_step(X::EllipticSurface, F::Vector{QQFieldElem})\nelliptic_parameter(X::EllipticSurface, F::Vector{QQFieldElem})\npushforward_on_algebraic_lattices(f::MorphismFromRationalFunctions{<:EllipticSurface, <:EllipticSurface})","category":"page"},{"location":"AlgebraicGeometry/Surfaces/EllipticSurface/#linear_system-Tuple{EllipticSurface, EllipticCurvePoint, Int64}","page":"Elliptic Surfaces","title":"linear_system","text":"linear_system(X::EllipticSurface, P::EllipticCurvePoint, k::Int) -> LinearSystem\n\nCompute the linear system O + P + k F on the elliptic surface X. Here F is the class of the fiber over 01, O the zero section and P any section given as a point on the generic fiber.\n\nThe linear system is represented in terms of the Weierstrass coordinates.\n\n\n\n\n\n","category":"method"},{"location":"AlgebraicGeometry/Surfaces/EllipticSurface/#two_neighbor_step-Tuple{EllipticSurface, Vector{QQFieldElem}}","page":"Elliptic Surfaces","title":"two_neighbor_step","text":"two_neighbor_step(X::EllipticSurface, F1::Vector{QQFieldElem})\n\nLet F be the class of a fiber of the elliptic fibration on X.  Given an isotropic nef divisor F_1 with F_1F = 2, compute the linear system F_1 and return the corresponding generic fiber as a double cover C of the projective line branched over four points.\n\nInput: F_1 is represented as a vector in the algebraic_lattice(X) X must be a K3 surface\n\nOutput: A tuple (C, (x1, y1, t1)) defined as follows.\n\nC is given by a polynomial y_1^2 - q(x_1) in k(t_1)x_1y_1 with q of degree 3 or 4.\n(x1,y1,t1) are expressed as rational functions in terms of the weierstrass coordinates (x,y,t).\n\n\n\n\n\n","category":"method"},{"location":"AlgebraicGeometry/Surfaces/EllipticSurface/#elliptic_parameter-Tuple{EllipticSurface, Vector{QQFieldElem}}","page":"Elliptic Surfaces","title":"elliptic_parameter","text":"elliptic_parameter(X::EllipticSurface, F::Vector{QQFieldElem}) -> LinearSystem\n\nReturn the elliptic parameter u of the divisor class F. \n\nThe input F must be given with respect to the basis of algebraic_lattice(X) and be an isotropic nef divisor.  This method assumes that X is a K3 surface.\n\n\n\n\n\n","category":"method"},{"location":"AlgebraicGeometry/Surfaces/EllipticSurface/#pushforward_on_algebraic_lattices-Tuple{MorphismFromRationalFunctions{<:EllipticSurface, <:EllipticSurface}}","page":"Elliptic Surfaces","title":"pushforward_on_algebraic_lattices","text":"pushforward_on_algebraic_lattices(f::MorphismFromRationalFunctions{<:EllipticSurface, <:EllipticSurface}) -> QQMatrix\n\nReturn the pushforward f_* V_1 to V_2 where V_i is the ambient quadratic space of the algebraic_lattice.\n\nThis assumes that the image f_*(V_1) is contained in V_2. If this is not the case, you will get   f_* composed with the orthogonal projection to V_2. \n\n\n\n\n\n","category":"method"},{"location":"AlgebraicGeometry/Surfaces/EllipticSurface/#Contact","page":"Elliptic Surfaces","title":"Contact","text":"","category":"section"},{"location":"AlgebraicGeometry/Surfaces/EllipticSurface/","page":"Elliptic Surfaces","title":"Elliptic Surfaces","text":"Please direct questions about this part of OSCAR to the following people:","category":"page"},{"location":"AlgebraicGeometry/Surfaces/EllipticSurface/","page":"Elliptic Surfaces","title":"Elliptic Surfaces","text":"Simon Brandhorst.\nMatthias Zach,","category":"page"},{"location":"AlgebraicGeometry/Surfaces/EllipticSurface/","page":"Elliptic Surfaces","title":"Elliptic Surfaces","text":"You can ask questions in the OSCAR Slack.","category":"page"},{"location":"AlgebraicGeometry/Surfaces/EllipticSurface/","page":"Elliptic Surfaces","title":"Elliptic Surfaces","text":"Alternatively, you can raise an issue on github.","category":"page"},{"location":"manualindex/","page":"Index","title":"Index","text":"","category":"page"},{"location":"Hecke/manual/quad_forms/Zgenera/#Genera-of-Integer-Lattices","page":"Genera of Integer Lattices","title":"Genera of Integer Lattices","text":"","category":"section"},{"location":"Hecke/manual/quad_forms/Zgenera/","page":"Genera of Integer Lattices","title":"Genera of Integer Lattices","text":"CurrentModule = Hecke\nDocTestSetup = quote\n    using Hecke\n  end","category":"page"},{"location":"Hecke/manual/quad_forms/Zgenera/","page":"Genera of Integer Lattices","title":"Genera of Integer Lattices","text":"Two mathbbZ-lattices M and N are said to be in the same genus if their completions M otimes mathbbZ_p and N otimes mathbbZ_p are isometric for all prime numbers p as well as M otimes mathbbR cong Notimes mathbbR.","category":"page"},{"location":"Hecke/manual/quad_forms/Zgenera/","page":"Genera of Integer Lattices","title":"Genera of Integer Lattices","text":"The genus of a mathbbZ-lattice is encoded in its Conway-Sloane genus symbol. The genus symbol itself is a collection of its local genus symbols. See [CS99] Chapter 15 for the definitions. Note that genera for non-integral lattices are supported.","category":"page"},{"location":"Hecke/manual/quad_forms/Zgenera/","page":"Genera of Integer Lattices","title":"Genera of Integer Lattices","text":"The class ZZGenus supports genera of mathbbZ-lattices.","category":"page"},{"location":"Hecke/manual/quad_forms/Zgenera/","page":"Genera of Integer Lattices","title":"Genera of Integer Lattices","text":"ZZGenus","category":"page"},{"location":"Hecke/manual/quad_forms/Zgenera/#ZZGenus","page":"Genera of Integer Lattices","title":"ZZGenus","text":"ZZGenus\n\nA collection of local genus symbols (at primes) and a signature pair. Together they represent the genus of a non-degenerate integer_lattice.\n\n\n\n\n\n","category":"type"},{"location":"Hecke/manual/quad_forms/Zgenera/#Creation-of-Genera","page":"Genera of Integer Lattices","title":"Creation of Genera","text":"","category":"section"},{"location":"Hecke/manual/quad_forms/Zgenera/#From-an-integral-Lattice","page":"Genera of Integer Lattices","title":"From an integral Lattice","text":"","category":"section"},{"location":"Hecke/manual/quad_forms/Zgenera/","page":"Genera of Integer Lattices","title":"Genera of Integer Lattices","text":"genus(::ZZLat)","category":"page"},{"location":"Hecke/manual/quad_forms/Zgenera/#genus-Tuple{ZZLat}","page":"Genera of Integer Lattices","title":"genus","text":"genus(L::ZZLat) -> ZZGenus\n\nReturn the genus of the lattice L.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/quad_forms/Zgenera/#From-a-gram-matrix","page":"Genera of Integer Lattices","title":"From a gram matrix","text":"","category":"section"},{"location":"Hecke/manual/quad_forms/Zgenera/","page":"Genera of Integer Lattices","title":"Genera of Integer Lattices","text":"genus(A::MatElem)","category":"page"},{"location":"Hecke/manual/quad_forms/Zgenera/#genus-Tuple{MatElem}","page":"Genera of Integer Lattices","title":"genus","text":"genus(A::MatElem) -> ZZGenus\n\nReturn the genus of a mathbb Z-lattice with gram matrix A.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/quad_forms/Zgenera/#Enumeration-of-genus-symbols","page":"Genera of Integer Lattices","title":"Enumeration of genus symbols","text":"","category":"section"},{"location":"Hecke/manual/quad_forms/Zgenera/","page":"Genera of Integer Lattices","title":"Genera of Integer Lattices","text":"integer_genera(sig_pair::Tuple{Int,Int}, determinant::Union{Int,ZZRingElem})","category":"page"},{"location":"Hecke/manual/quad_forms/Zgenera/#integer_genera-Tuple{Tuple{Int64, Int64}, Union{Int64, ZZRingElem}}","page":"Genera of Integer Lattices","title":"integer_genera","text":"integer_genera(sig_pair::Vector{Int}, determinant::RationalUnion;\n       min_scale::RationalUnion = min(one(QQ), QQ(abs(determinant))),\n       max_scale::RationalUnion = max(one(QQ), QQ(abs(determinant))),\n       even=false)                                         -> Vector{ZZGenus}\n\nReturn a list of all genera with the given conditions. Genera of non-integral mathbb Z-lattices are also supported.\n\nArguments\n\nsig_pair: a pair of non-negative integers giving the signature\ndeterminant: a rational number; the sign is ignored\nmin_scale: a rational number; return only genera whose scale is an integer multiple of min_scale (default: min(one(QQ), QQ(abs(determinant))))\nmax_scale: a rational number; return only genera such that max_scale is an integer multiple of the scale (default: max(one(QQ), QQ(abs(determinant))))\neven: boolean; if set to true, return only the even genera (default: false)\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/quad_forms/Zgenera/#From-other-genus-symbols","page":"Genera of Integer Lattices","title":"From other genus symbols","text":"","category":"section"},{"location":"Hecke/manual/quad_forms/Zgenera/","page":"Genera of Integer Lattices","title":"Genera of Integer Lattices","text":"direct_sum(G1::ZZGenus, G2::ZZGenus)","category":"page"},{"location":"Hecke/manual/quad_forms/Zgenera/#direct_sum-Tuple{ZZGenus, ZZGenus}","page":"Genera of Integer Lattices","title":"direct_sum","text":"direct_sum(G1::ZZGenus, G2::ZZGenus) -> ZZGenus\n\nReturn the genus of the direct sum of G1 and G2.\n\nThe direct sum is defined via representatives.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/quad_forms/Zgenera/#Attributes-of-the-genus","page":"Genera of Integer Lattices","title":"Attributes of the genus","text":"","category":"section"},{"location":"Hecke/manual/quad_forms/Zgenera/","page":"Genera of Integer Lattices","title":"Genera of Integer Lattices","text":"dim(G::ZZGenus)\nrank(G::ZZGenus)\nsignature(G::ZZGenus)\ndet(G::ZZGenus)\niseven(G::ZZGenus)\nis_definite(G::ZZGenus)\nlevel(G::ZZGenus)\nscale(G::ZZGenus)\nnorm(G::ZZGenus)\nprimes(G::ZZGenus)\nis_integral(G::ZZGenus)","category":"page"},{"location":"Hecke/manual/quad_forms/Zgenera/#dim-Tuple{ZZGenus}","page":"Genera of Integer Lattices","title":"dim","text":"dim(G::ZZGenus) -> Int\n\nReturn the dimension of this genus.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/quad_forms/Zgenera/#rank-Tuple{ZZGenus}","page":"Genera of Integer Lattices","title":"rank","text":"rank(G::ZZGenus) -> Int\n\nReturn the rank of a (representative of) the genus G.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/quad_forms/Zgenera/#signature-Tuple{ZZGenus}","page":"Genera of Integer Lattices","title":"signature","text":"signature(G::ZZGenus) -> Int\n\nReturn the signature of this genus.\n\nThe signature is p - n where p is the number of positive eigenvalues and n the number of negative eigenvalues.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/quad_forms/Zgenera/#det-Tuple{ZZGenus}","page":"Genera of Integer Lattices","title":"det","text":"det(G::ZZGenus) -> QQFieldElem\n\nReturn the determinant of this genus.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/quad_forms/Zgenera/#iseven-Tuple{ZZGenus}","page":"Genera of Integer Lattices","title":"iseven","text":"iseven(G::ZZGenus) -> Bool\n\nReturn if this genus is even.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/quad_forms/Zgenera/#is_definite-Tuple{ZZGenus}","page":"Genera of Integer Lattices","title":"is_definite","text":"is_definite(G::ZZGenus) -> Bool\n\nReturn if this genus is definite.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/quad_forms/Zgenera/#level-Tuple{ZZGenus}","page":"Genera of Integer Lattices","title":"level","text":"level(G::ZZGenus) -> QQFieldElem\n\nReturn the level of this genus.\n\nThis is the denominator of the inverse gram matrix of a representative.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/quad_forms/Zgenera/#scale-Tuple{ZZGenus}","page":"Genera of Integer Lattices","title":"scale","text":"scale(G::ZZGenus) -> QQFieldElem\n\nReturn the scale of this genus.\n\nLet L be a lattice with bilinear form b. The scale of (L,b) is defined as the ideal b(L,L).\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/quad_forms/Zgenera/#norm-Tuple{ZZGenus}","page":"Genera of Integer Lattices","title":"norm","text":"norm(G::ZZGenus) -> QQFieldElem\n\nReturn the norm of this genus.\n\nLet L be a lattice with bilinear form b. The norm of (L,b) is defined as the ideal generated by b(xx)  x in L.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/quad_forms/Zgenera/#primes-Tuple{ZZGenus}","page":"Genera of Integer Lattices","title":"primes","text":"primes(G::ZZGenus) -> Vector{ZZRingElem}\n\nReturn the list of primes of the local symbols of G.\n\nNote that 2 is always in the output since the 2-adic symbol of a ZZGenus is, by convention, always defined.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/quad_forms/Zgenera/#is_integral-Tuple{ZZGenus}","page":"Genera of Integer Lattices","title":"is_integral","text":"is_integral(G::ZZGenus) -> Bool\n\nReturn whether G is a genus of integral mathbb Z-lattices.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/quad_forms/Zgenera/#Discriminant-group","page":"Genera of Integer Lattices","title":"Discriminant group","text":"","category":"section"},{"location":"Hecke/manual/quad_forms/Zgenera/","page":"Genera of Integer Lattices","title":"Genera of Integer Lattices","text":"discriminant_group(::ZZGenus)","category":"page"},{"location":"Hecke/manual/quad_forms/Zgenera/#Primary-genera","page":"Genera of Integer Lattices","title":"Primary genera","text":"","category":"section"},{"location":"Hecke/manual/quad_forms/Zgenera/","page":"Genera of Integer Lattices","title":"Genera of Integer Lattices","text":"is_primary_with_prime(G::ZZGenus)\nis_primary(G::ZZGenus, p::Union{Integer, ZZRingElem})\nis_elementary_with_prime(G::ZZGenus)\nis_elementary(G::ZZGenus, p::Union{Integer, ZZRingElem})","category":"page"},{"location":"Hecke/manual/quad_forms/Zgenera/#is_primary_with_prime-Tuple{ZZGenus}","page":"Genera of Integer Lattices","title":"is_primary_with_prime","text":"is_primary_with_prime(G::ZZGenus) -> Bool, ZZRingElem\n\nGiven a genus of mathbb Z-lattices G, return whether it is primary, that is whether the bilinear form is integral and the associated discriminant form (see discriminant_group) is a p-group for some prime number p. In case it is, p is also returned as second output.\n\nNote that for unimodular genera, this function returns (true, 1). If the genus is not primary, the second return value is -1 by default.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/quad_forms/Zgenera/#is_primary-Tuple{ZZGenus, Union{Integer, ZZRingElem}}","page":"Genera of Integer Lattices","title":"is_primary","text":"is_primary(G::ZZGenus, p::Union{Integer, ZZRingElem}) -> Bool\n\nGiven a genus of integral mathbb Z-lattices G and a prime number p, return whether G is p-primary, that is whether the associated discriminant form (see discriminant_group) is a p-group.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/quad_forms/Zgenera/#is_elementary_with_prime-Tuple{ZZGenus}","page":"Genera of Integer Lattices","title":"is_elementary_with_prime","text":"is_elementary_with_prime(G::ZZGenus) -> Bool, ZZRingElem\n\nGiven a genus of mathbb Z-lattices G, return whether it is elementary, that is whether the bilinear form is inegtral and the associated discriminant form (see discriminant_group) is an elementary p-group for some prime number p. In case it is, p is also returned as second output.\n\nNote that for unimodular genera, this function returns (true, 1). If the genus is not elementary, the second return value is -1 by default.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/quad_forms/Zgenera/#is_elementary-Tuple{ZZGenus, Union{Integer, ZZRingElem}}","page":"Genera of Integer Lattices","title":"is_elementary","text":"is_elementary(G::ZZGenus, p::Union{Integer, ZZRingElem}) -> Bool\n\nGiven a genus of integral mathbb Z-lattices G and a prime number p, return whether G is p-elementary, that is whether its associated discriminant form (see discriminant_group) is an elementary p-group.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/quad_forms/Zgenera/#local-Symbol","page":"Genera of Integer Lattices","title":"local Symbol","text":"","category":"section"},{"location":"Hecke/manual/quad_forms/Zgenera/","page":"Genera of Integer Lattices","title":"Genera of Integer Lattices","text":"local_symbol(G::ZZGenus, p)","category":"page"},{"location":"Hecke/manual/quad_forms/Zgenera/#local_symbol-Tuple{ZZGenus, Any}","page":"Genera of Integer Lattices","title":"local_symbol","text":"local_symbol(G::ZZGenus, p) -> ZZLocalGenus\n\nReturn the local symbol at p.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/quad_forms/Zgenera/#Representative(s)","page":"Genera of Integer Lattices","title":"Representative(s)","text":"","category":"section"},{"location":"Hecke/manual/quad_forms/Zgenera/","page":"Genera of Integer Lattices","title":"Genera of Integer Lattices","text":"quadratic_space(G::ZZGenus)\nrational_representative(G::ZZGenus)\nrepresentative(G::ZZGenus)\nrepresentatives(G::ZZGenus)\nmass(G::ZZGenus)\nrescale(::ZZGenus, ::RationalUnion)","category":"page"},{"location":"Hecke/manual/quad_forms/Zgenera/#quadratic_space-Tuple{ZZGenus}","page":"Genera of Integer Lattices","title":"quadratic_space","text":"quadratic_space(G::ZZGenus) -> QuadSpace{QQField, QQMatrix}\n\nReturn the quadratic space defined by this genus.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/quad_forms/Zgenera/#rational_representative-Tuple{ZZGenus}","page":"Genera of Integer Lattices","title":"rational_representative","text":"rational_representative(G::ZZGenus) -> QuadSpace{QQField, QQMatrix}\n\nReturn the quadratic space defined by this genus.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/quad_forms/Zgenera/#representative-Tuple{ZZGenus}","page":"Genera of Integer Lattices","title":"representative","text":"representative(G::ZZGenus) -> ZZLat\n\nCompute a representative of this genus && cache it.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/quad_forms/Zgenera/#representatives-Tuple{ZZGenus}","page":"Genera of Integer Lattices","title":"representatives","text":"representatives(G::ZZGenus) -> Vector{ZZLat}\n\nReturn a list of representatives of the isometry classes in this genus.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/quad_forms/Zgenera/#mass-Tuple{ZZGenus}","page":"Genera of Integer Lattices","title":"mass","text":"mass(G::ZZGenus) -> QQFieldElem\n\nReturn the mass of this genus.\n\nThe genus must be definite. Let L_1, ... L_n be a complete list of representatives of the isometry classes in this genus. Its mass is defined as sum_i=1^n frac1O(L_i).\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/quad_forms/Zgenera/#rescale-Tuple{ZZGenus, Union{Integer, QQFieldElem, ZZRingElem, Rational}}","page":"Genera of Integer Lattices","title":"rescale","text":"rescale(G::ZZGenus, a::RationalUnion) -> ZZGenus\n\nGiven a genus symbol G of mathbb Z-lattices, return the genus symbol of any representative of G rescaled by a.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/quad_forms/Zgenera/#Embeddings-and-Representations","page":"Genera of Integer Lattices","title":"Embeddings and Representations","text":"","category":"section"},{"location":"Hecke/manual/quad_forms/Zgenera/","page":"Genera of Integer Lattices","title":"Genera of Integer Lattices","text":"represents(G1::ZZGenus, G2::ZZGenus)","category":"page"},{"location":"Hecke/manual/quad_forms/Zgenera/#represents-Tuple{ZZGenus, ZZGenus}","page":"Genera of Integer Lattices","title":"represents","text":"represents(G1::ZZGenus, G2::ZZGenus) -> Bool\n\nReturn if G1 represents G2. That is if some element in the genus of G1 represents some element in the genus of G2.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/quad_forms/Zgenera/#Local-genus-Symbols","page":"Genera of Integer Lattices","title":"Local genus Symbols","text":"","category":"section"},{"location":"Hecke/manual/quad_forms/Zgenera/","page":"Genera of Integer Lattices","title":"Genera of Integer Lattices","text":"ZZLocalGenus","category":"page"},{"location":"Hecke/manual/quad_forms/Zgenera/#ZZLocalGenus","page":"Genera of Integer Lattices","title":"ZZLocalGenus","text":"ZZLocalGenus\n\nLocal genus symbol over a p-adic ring.\n\nThe genus symbol of a component p^m A for odd prime = p is of the form (m,n,d), where\n\nm = valuation of the component\nn = rank of A\nd = det(A) \\in \\{1,u\\} for a normalized quadratic non-residue u.\n\nThe genus symbol of a component 2^m A is of the form (m, n, s, d, o), where\n\nm = valuation of the component\nn = rank of A\nd = det(A) in {1,3,5,7}\ns = 0 (or 1) if even (or odd)\no = oddity of A (= 0 if s = 0) in Z/8Z     = the trace of the diagonalization of A\n\nThe genus symbol is a list of such symbols (ordered by m) for each of the Jordan blocks A_1,...,A_t.\n\nReference: [CS99] Chapter 15, Section 7.\n\nArguments\n\nprime: a prime number\nsymbol: the list of invariants for Jordan blocks A_t,...,A_t given as a list of lists of integers\n\n\n\n\n\n","category":"type"},{"location":"Hecke/manual/quad_forms/Zgenera/#Creation","page":"Genera of Integer Lattices","title":"Creation","text":"","category":"section"},{"location":"Hecke/manual/quad_forms/Zgenera/","page":"Genera of Integer Lattices","title":"Genera of Integer Lattices","text":"genus(::ZZLat, ::IntegerUnion)\ngenus(::QQMatrix, ::IntegerUnion)","category":"page"},{"location":"Hecke/manual/quad_forms/Zgenera/#genus-Tuple{ZZLat, Union{Integer, ZZRingElem}}","page":"Genera of Integer Lattices","title":"genus","text":"genus(L::ZZLat, p::IntegerUnion) -> ZZLocalGenus\n\nReturn the local genus symbol of L at the prime p.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/quad_forms/Zgenera/#genus-Tuple{QQMatrix, Union{Integer, ZZRingElem}}","page":"Genera of Integer Lattices","title":"genus","text":"genus(A::QQMatrix, p::IntegerUnion) -> ZZLocalGenus\n\nReturn the local genus symbol of a Z-lattice with gram matrix A at the prime p.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/quad_forms/Zgenera/#Attributes","page":"Genera of Integer Lattices","title":"Attributes","text":"","category":"section"},{"location":"Hecke/manual/quad_forms/Zgenera/","page":"Genera of Integer Lattices","title":"Genera of Integer Lattices","text":"prime(S::ZZLocalGenus)\niseven(S::ZZLocalGenus)\nsymbol(S::ZZLocalGenus, scale::Int)\nhasse_invariant(S::ZZLocalGenus)\ndet(S::ZZLocalGenus)\ndim(S::ZZLocalGenus)\nrank(S::ZZLocalGenus)\nexcess(S::ZZLocalGenus)\nsignature(S::ZZLocalGenus)\noddity(S::ZZLocalGenus)\nscale(S::ZZLocalGenus)\nnorm(S::ZZLocalGenus)\nlevel(S::ZZLocalGenus)","category":"page"},{"location":"Hecke/manual/quad_forms/Zgenera/#prime-Tuple{ZZLocalGenus}","page":"Genera of Integer Lattices","title":"prime","text":"prime(S::ZZLocalGenus) -> ZZRingElem\n\nReturn the prime p of this p-adic genus.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/quad_forms/Zgenera/#iseven-Tuple{ZZLocalGenus}","page":"Genera of Integer Lattices","title":"iseven","text":"iseven(S::ZZLocalGenus) -> Bool\n\nReturn if the underlying p-adic lattice is even.\n\nIf p is odd, every lattice is even.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/quad_forms/Zgenera/#symbol-Tuple{ZZLocalGenus, Int64}","page":"Genera of Integer Lattices","title":"symbol","text":"symbol(S::ZZLocalGenus, scale::Int) -> Vector{Int}\n\nReturn the underlying lists of integers for the Jordan block of the given scale\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/quad_forms/Zgenera/#hasse_invariant-Tuple{ZZLocalGenus}","page":"Genera of Integer Lattices","title":"hasse_invariant","text":"hasse_invariant(S::ZZLocalGenus) -> Int\n\nReturn the Hasse invariant of a representative. If the representative is diagonal (a1, ... , an) Then the Hasse invariant is\n\nprod_i  j(a_i a_j)_p\n\n.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/quad_forms/Zgenera/#det-Tuple{ZZLocalGenus}","page":"Genera of Integer Lattices","title":"det","text":"det(S::ZZLocalGenus) -> QQFieldElem\n\nReturn an rational representing the determinant of this genus.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/quad_forms/Zgenera/#dim-Tuple{ZZLocalGenus}","page":"Genera of Integer Lattices","title":"dim","text":"dim(S::ZZLocalGenus) -> Int\n\nReturn the dimension of this genus.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/quad_forms/Zgenera/#rank-Tuple{ZZLocalGenus}","page":"Genera of Integer Lattices","title":"rank","text":"rank(S::ZZLocalGenus) -> Int\n\nReturn the rank of (a representative of) S.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/quad_forms/Zgenera/#excess-Tuple{ZZLocalGenus}","page":"Genera of Integer Lattices","title":"excess","text":"excess(S::ZZLocalGenus) -> zzModRingElem\n\nReturn the p-excess of the quadratic form whose Hessian matrix is the symmetric matrix A.\n\nWhen p = 2 the p-excess is called the oddity. The p-excess is always even && is divisible by 4 if p is congruent 1 mod 4.\n\nReference\n\n[CS99] pp 370-371.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/quad_forms/Zgenera/#signature-Tuple{ZZLocalGenus}","page":"Genera of Integer Lattices","title":"signature","text":"signature(S::ZZLocalGenus) -> zzModRingElem\n\nReturn the p-signature of this p-adic form.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/quad_forms/Zgenera/#oddity-Tuple{ZZLocalGenus}","page":"Genera of Integer Lattices","title":"oddity","text":"oddity(S::ZZLocalGenus) -> zzModRingElem\n\nReturn the oddity of this even form. The oddity is also called the 2-signature\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/quad_forms/Zgenera/#scale-Tuple{ZZLocalGenus}","page":"Genera of Integer Lattices","title":"scale","text":"scale(S::ZZLocalGenus) -> QQFieldElem\n\nReturn the scale of this local genus.\n\nLet L be a lattice with bilinear form b. The scale of (L,b) is defined as the ideal b(L,L).\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/quad_forms/Zgenera/#norm-Tuple{ZZLocalGenus}","page":"Genera of Integer Lattices","title":"norm","text":"norm(S::ZZLocalGenus) -> QQFieldElem\n\nReturn the norm of this local genus.\n\nLet L be a lattice with bilinear form b. The norm of (L,b) is defined as the ideal generated by b(xx)  x in L.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/quad_forms/Zgenera/#level-Tuple{ZZLocalGenus}","page":"Genera of Integer Lattices","title":"level","text":"level(S::ZZLocalGenus) -> QQFieldElem\n\nReturn the maximal scale of a jordan component.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/quad_forms/Zgenera/#Representative","page":"Genera of Integer Lattices","title":"Representative","text":"","category":"section"},{"location":"Hecke/manual/quad_forms/Zgenera/","page":"Genera of Integer Lattices","title":"Genera of Integer Lattices","text":"representative(S::ZZLocalGenus)\ngram_matrix(S::ZZLocalGenus)\nrescale(S::ZZLocalGenus, a::RationalUnion)","category":"page"},{"location":"Hecke/manual/quad_forms/Zgenera/#representative-Tuple{ZZLocalGenus}","page":"Genera of Integer Lattices","title":"representative","text":"representative(S::ZZLocalGenus) -> ZZLat\n\nReturn an integer lattice which represents this local genus.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/quad_forms/Zgenera/#gram_matrix-Tuple{ZZLocalGenus}","page":"Genera of Integer Lattices","title":"gram_matrix","text":"gram_matrix(S::ZZLocalGenus) -> MatElem\n\nReturn a gram matrix of some representative of this local genus.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/quad_forms/Zgenera/#rescale-Tuple{ZZLocalGenus, Union{Integer, QQFieldElem, ZZRingElem, Rational}}","page":"Genera of Integer Lattices","title":"rescale","text":"rescale(G::ZZLocalGenus, a::RationalUnion) -> ZZLocalGenus\n\nGiven a local genus symbol G of mathbb Z-lattices, return the local genus symbol of any representative of G rescaled by a.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/quad_forms/Zgenera/#Direct-sums","page":"Genera of Integer Lattices","title":"Direct sums","text":"","category":"section"},{"location":"Hecke/manual/quad_forms/Zgenera/","page":"Genera of Integer Lattices","title":"Genera of Integer Lattices","text":"direct_sum(S1::ZZLocalGenus, S2::ZZLocalGenus)","category":"page"},{"location":"Hecke/manual/quad_forms/Zgenera/#direct_sum-Tuple{ZZLocalGenus, ZZLocalGenus}","page":"Genera of Integer Lattices","title":"direct_sum","text":"direct_sum(S1::ZZLocalGenus, S2::ZZLocalGenus) -> ZZLocalGenus\n\nReturn the local genus of the direct sum of two representatives.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/quad_forms/Zgenera/#Embeddings/Representations","page":"Genera of Integer Lattices","title":"Embeddings/Representations","text":"","category":"section"},{"location":"Hecke/manual/quad_forms/Zgenera/","page":"Genera of Integer Lattices","title":"Genera of Integer Lattices","text":"represents(G1::ZZLocalGenus, G2::ZZLocalGenus)","category":"page"},{"location":"Hecke/manual/quad_forms/Zgenera/#represents-Tuple{ZZLocalGenus, ZZLocalGenus}","page":"Genera of Integer Lattices","title":"represents","text":"represents(g1::ZZLocalGenus, g2::ZZLocalGenus) -> Bool\n\nReturn whether g1 represents g2.\n\nBased on O'Meara Integral Representations of Quadratic Forms Over Local Fields Note that for p == 2 there is a typo in O'Meara Theorem 3 (V). The correct statement is (V) 2^i(1+4omega) to mathfrakL_i+1mathfrakl_i.\n\n\n\n\n\n","category":"method"},{"location":"AlgebraicGeometry/ToricVarieties/ToricDivisors/","page":"Toric Divisors","title":"Toric Divisors","text":"CurrentModule = Oscar","category":"page"},{"location":"AlgebraicGeometry/ToricVarieties/ToricDivisors/#Toric-Divisors","page":"Toric Divisors","title":"Toric Divisors","text":"","category":"section"},{"location":"AlgebraicGeometry/ToricVarieties/ToricDivisors/#Introduction","page":"Toric Divisors","title":"Introduction","text":"","category":"section"},{"location":"AlgebraicGeometry/ToricVarieties/ToricDivisors/","page":"Toric Divisors","title":"Toric Divisors","text":"Toric divisors are those divisors that are invariant under the torus action. They are formal sums of the codimension one orbits, and these in turn correspond to the rays of the underlying fan.","category":"page"},{"location":"AlgebraicGeometry/ToricVarieties/ToricDivisors/#Constructors","page":"Toric Divisors","title":"Constructors","text":"","category":"section"},{"location":"AlgebraicGeometry/ToricVarieties/ToricDivisors/#General-constructors","page":"Toric Divisors","title":"General constructors","text":"","category":"section"},{"location":"AlgebraicGeometry/ToricVarieties/ToricDivisors/","page":"Toric Divisors","title":"Toric Divisors","text":"divisor_of_character(v::NormalToricVarietyType, character::Vector{T}) where {T <: IntegerUnion}\ntoric_divisor(v::NormalToricVarietyType, coeffs::Vector{T}) where {T <: IntegerUnion}","category":"page"},{"location":"AlgebraicGeometry/ToricVarieties/ToricDivisors/#divisor_of_character-Union{Tuple{T}, Tuple{Union{AffineNormalToricVariety, CyclicQuotientSingularity, NormalToricVariety}, Vector{T}}} where T<:Union{Integer, ZZRingElem}","page":"Toric Divisors","title":"divisor_of_character","text":"divisor_of_character(v::NormalToricVarietyType, character::Vector{T}) where {T <: IntegerUnion}\n\nConstruct the torus invariant divisor associated to a character of the normal toric variety v.\n\nExamples\n\njulia> divisor_of_character(projective_space(NormalToricVariety, 2), [1, 2])\nTorus-invariant, non-prime divisor on a normal toric variety\n\n\n\n\n\n","category":"method"},{"location":"AlgebraicGeometry/ToricVarieties/ToricDivisors/#toric_divisor-Union{Tuple{T}, Tuple{Union{AffineNormalToricVariety, CyclicQuotientSingularity, NormalToricVariety}, Vector{T}}} where T<:Union{Integer, ZZRingElem}","page":"Toric Divisors","title":"toric_divisor","text":"toric_divisor(v::NormalToricVarietyType, coeffs::Vector{T}) where {T <: IntegerUnion}\n\nConstruct the torus invariant divisor on the normal toric variety v as linear  combination of the torus invariant prime divisors of v. The coefficients of this  linear combination are passed as list of integers as first argument.\n\nExamples\n\njulia> toric_divisor(projective_space(NormalToricVariety, 2), [1, 1, 2])\nTorus-invariant, non-prime divisor on a normal toric variety\n\n\n\n\n\n","category":"method"},{"location":"AlgebraicGeometry/ToricVarieties/ToricDivisors/#Addition,-subtraction-and-scalar-multiplication","page":"Toric Divisors","title":"Addition, subtraction and scalar multiplication","text":"","category":"section"},{"location":"AlgebraicGeometry/ToricVarieties/ToricDivisors/","page":"Toric Divisors","title":"Toric Divisors","text":"Toric divisors can be added and subtracted via the usual + and - operators. Moreover, multiplication by scalars from the left is supported for scalars which are integers or of type ZZRingElem.","category":"page"},{"location":"AlgebraicGeometry/ToricVarieties/ToricDivisors/#Special-divisors","page":"Toric Divisors","title":"Special divisors","text":"","category":"section"},{"location":"AlgebraicGeometry/ToricVarieties/ToricDivisors/","page":"Toric Divisors","title":"Toric Divisors","text":"trivial_divisor(v::NormalToricVarietyType)\nanticanonical_divisor(v::NormalToricVarietyType)\ncanonical_divisor(v::NormalToricVarietyType)","category":"page"},{"location":"AlgebraicGeometry/ToricVarieties/ToricDivisors/#trivial_divisor-Tuple{Union{AffineNormalToricVariety, CyclicQuotientSingularity, NormalToricVariety}}","page":"Toric Divisors","title":"trivial_divisor","text":"trivial_divisor(v::NormalToricVarietyType)\n\nConstruct the trivial divisor of a normal toric variety.\n\nExamples\n\njulia> v = projective_space(NormalToricVariety, 2)\nNormal toric variety\n\njulia> trivial_divisor(v)\nTorus-invariant, non-prime divisor on a normal toric variety\n\n\n\n\n\n","category":"method"},{"location":"AlgebraicGeometry/ToricVarieties/ToricDivisors/#anticanonical_divisor-Tuple{Union{AffineNormalToricVariety, CyclicQuotientSingularity, NormalToricVariety}}","page":"Toric Divisors","title":"anticanonical_divisor","text":"anticanonical_divisor(v::NormalToricVarietyType)\n\nConstruct the anticanonical divisor of a normal toric variety.\n\nExamples\n\njulia> v = projective_space(NormalToricVariety, 2)\nNormal toric variety\n\njulia> anticanonical_divisor(v)\nTorus-invariant, non-prime divisor on a normal toric variety\n\n\n\n\n\n","category":"method"},{"location":"AlgebraicGeometry/ToricVarieties/ToricDivisors/#canonical_divisor-Tuple{Union{AffineNormalToricVariety, CyclicQuotientSingularity, NormalToricVariety}}","page":"Toric Divisors","title":"canonical_divisor","text":"canonical_divisor(v::NormalToricVarietyType)\n\nConstruct the canonical divisor of a normal toric variety.\n\nExamples\n\njulia> v = projective_space(NormalToricVariety, 2)\nNormal toric variety\n\njulia> canonical_divisor(v)\nTorus-invariant, non-prime divisor on a normal toric variety\n\n\n\n\n\n","category":"method"},{"location":"AlgebraicGeometry/ToricVarieties/ToricDivisors/#Properties-of-toric-divisors","page":"Toric Divisors","title":"Properties of toric divisors","text":"","category":"section"},{"location":"AlgebraicGeometry/ToricVarieties/ToricDivisors/","page":"Toric Divisors","title":"Toric Divisors","text":"Equality of toric divisors can be tested via ==.","category":"page"},{"location":"AlgebraicGeometry/ToricVarieties/ToricDivisors/","page":"Toric Divisors","title":"Toric Divisors","text":"To check if a toric divisor is trivial, one can invoke is_trivial. This checks if all coefficients of the toric divisor in question are zero. This must not be confused with a toric divisor being principal, for which we support the following:","category":"page"},{"location":"AlgebraicGeometry/ToricVarieties/ToricDivisors/","page":"Toric Divisors","title":"Toric Divisors","text":"is_principal(td::ToricDivisor)","category":"page"},{"location":"AlgebraicGeometry/ToricVarieties/ToricDivisors/#is_principal-Tuple{ToricDivisor}","page":"Toric Divisors","title":"is_principal","text":"is_principal(td::ToricDivisor)\n\nDetermine whether the toric divisor td is principal.\n\nExamples\n\njulia> F4 = hirzebruch_surface(NormalToricVariety, 4)\nNormal toric variety\n\njulia> td = toric_divisor(F4, [1,0,0,0])\nTorus-invariant, prime divisor on a normal toric variety\n\njulia> is_principal(td)\nfalse\n\n\n\n\n\n","category":"method"},{"location":"AlgebraicGeometry/ToricVarieties/ToricDivisors/","page":"Toric Divisors","title":"Toric Divisors","text":"Beyond this, we support the following properties of toric divisors:","category":"page"},{"location":"AlgebraicGeometry/ToricVarieties/ToricDivisors/","page":"Toric Divisors","title":"Toric Divisors","text":"is_ample(td::ToricDivisor)\nis_basepoint_free(td::ToricDivisor)\nis_cartier(td::ToricDivisor)\nis_effective(td::ToricDivisor)\nis_integral(td::ToricDivisor)\nis_nef(td::ToricDivisor)\nis_prime(td::ToricDivisor)\nis_q_cartier(td::ToricDivisor)\nis_very_ample(td::ToricDivisor)","category":"page"},{"location":"AlgebraicGeometry/ToricVarieties/ToricDivisors/#is_ample-Tuple{ToricDivisor}","page":"Toric Divisors","title":"is_ample","text":"is_ample(td::ToricDivisor)\n\nDetermine whether the toric divisor td is ample.\n\nExamples\n\njulia> F4 = hirzebruch_surface(NormalToricVariety, 4)\nNormal toric variety\n\njulia> td = toric_divisor(F4, [1,0,0,0])\nTorus-invariant, prime divisor on a normal toric variety\n\njulia> is_ample(td)\nfalse\n\n\n\n\n\n","category":"method"},{"location":"AlgebraicGeometry/ToricVarieties/ToricDivisors/#is_basepoint_free-Tuple{ToricDivisor}","page":"Toric Divisors","title":"is_basepoint_free","text":"is_basepoint_free(td::ToricDivisor)\n\nDetermine whether the toric divisor td is basepoint free.\n\nExamples\n\njulia> F4 = hirzebruch_surface(NormalToricVariety, 4)\nNormal toric variety\n\njulia> td = toric_divisor(F4, [1,0,0,0])\nTorus-invariant, prime divisor on a normal toric variety\n\njulia> is_basepoint_free(td)\ntrue\n\n\n\n\n\n","category":"method"},{"location":"AlgebraicGeometry/ToricVarieties/ToricDivisors/#is_cartier-Tuple{ToricDivisor}","page":"Toric Divisors","title":"is_cartier","text":"is_cartier(td::ToricDivisor)\n\nChecks if the divisor td is Cartier.\n\nExamples\n\njulia> F4 = hirzebruch_surface(NormalToricVariety, 4)\nNormal toric variety\n\njulia> td = toric_divisor(F4, [1,0,0,0])\nTorus-invariant, prime divisor on a normal toric variety\n\njulia> is_cartier(td)\ntrue\n\n\n\n\n\n","category":"method"},{"location":"AlgebraicGeometry/ToricVarieties/ToricDivisors/#is_effective-Tuple{ToricDivisor}","page":"Toric Divisors","title":"is_effective","text":"is_effective(td::ToricDivisor)\n\nDetermine whether the toric divisor td is effective, i.e. if all of its coefficients are non-negative.\n\nExamples\n\njulia> P2 = projective_space(NormalToricVariety,2)\nNormal toric variety\n\njulia> td = toric_divisor(P2, [1,-1,0])\nTorus-invariant, non-prime divisor on a normal toric variety\n\njulia> is_effective(td)\nfalse\n\njulia> td2 = toric_divisor(P2, [1,2,3])\nTorus-invariant, non-prime divisor on a normal toric variety\n\njulia> is_effective(td2)\ntrue\n\n\n\n\n\n","category":"method"},{"location":"AlgebraicGeometry/ToricVarieties/ToricDivisors/#is_integral-Tuple{ToricDivisor}","page":"Toric Divisors","title":"is_integral","text":"is_integral(td::ToricDivisor)\n\nDetermine whether the toric divisor td is integral.\n\nExamples\n\njulia> F4 = hirzebruch_surface(NormalToricVariety, 4)\nNormal toric variety\n\njulia> td = toric_divisor(F4, [1,0,0,0])\nTorus-invariant, prime divisor on a normal toric variety\n\njulia> is_integral(td)\ntrue\n\n\n\n\n\n","category":"method"},{"location":"AlgebraicGeometry/ToricVarieties/ToricDivisors/#is_nef-Tuple{ToricDivisor}","page":"Toric Divisors","title":"is_nef","text":"is_nef(td::ToricDivisor)\n\nDetermine whether the toric divisor td is nef.\n\nExamples\n\njulia> F4 = hirzebruch_surface(NormalToricVariety, 4)\nNormal toric variety\n\njulia> td = toric_divisor(F4, [1,0,0,0])\nTorus-invariant, prime divisor on a normal toric variety\n\njulia> is_nef(td)\ntrue\n\n\n\n\n\n","category":"method"},{"location":"AlgebraicGeometry/ToricVarieties/ToricDivisors/#is_prime-Tuple{ToricDivisor}","page":"Toric Divisors","title":"is_prime","text":"is_prime(td::ToricDivisor)\n\nDetermine whether the toric divisor td is a prime divisor.\n\nExamples\n\njulia> F4 = hirzebruch_surface(NormalToricVariety, 4)\nNormal toric variety\n\njulia> td = toric_divisor(F4, [1,0,0,0])\nTorus-invariant, prime divisor on a normal toric variety\n\njulia> is_prime(td)\ntrue\n\n\n\n\n\n","category":"method"},{"location":"AlgebraicGeometry/ToricVarieties/ToricDivisors/#is_q_cartier-Tuple{ToricDivisor}","page":"Toric Divisors","title":"is_q_cartier","text":"is_q_cartier(td::ToricDivisor)\n\nDetermine whether the toric divisor td is Q-Cartier.\n\nExamples\n\njulia> F4 = hirzebruch_surface(NormalToricVariety, 4)\nNormal toric variety\n\njulia> td = toric_divisor(F4, [1,0,0,0])\nTorus-invariant, prime divisor on a normal toric variety\n\njulia> is_q_cartier(td)\ntrue\n\n\n\n\n\n","category":"method"},{"location":"AlgebraicGeometry/ToricVarieties/ToricDivisors/#is_very_ample-Tuple{ToricDivisor}","page":"Toric Divisors","title":"is_very_ample","text":"is_very_ample(td::ToricDivisor)\n\nDetermine whether the toric divisor td is very ample.\n\nExamples\n\njulia> F4 = hirzebruch_surface(NormalToricVariety, 4)\nNormal toric variety\n\njulia> td = toric_divisor(F4, [1,0,0,0])\nTorus-invariant, prime divisor on a normal toric variety\n\njulia> is_very_ample(td)\nfalse\n\n\n\n\n\n","category":"method"},{"location":"AlgebraicGeometry/ToricVarieties/ToricDivisors/#Attributes","page":"Toric Divisors","title":"Attributes","text":"","category":"section"},{"location":"AlgebraicGeometry/ToricVarieties/ToricDivisors/","page":"Toric Divisors","title":"Toric Divisors","text":"coefficients(td::ToricDivisor)\npolyhedron(td::ToricDivisor)\ntoric_variety(td::ToricDivisor)","category":"page"},{"location":"AlgebraicGeometry/ToricVarieties/ToricDivisors/#coefficients-Tuple{ToricDivisor}","page":"Toric Divisors","title":"coefficients","text":"coefficients(td::ToricDivisor)\n\nIdentify the coefficients of a toric divisor in the group of torus invariant Weil divisors.\n\nExamples\n\njulia> F4 = hirzebruch_surface(NormalToricVariety, 4)\nNormal toric variety\n\njulia> D = toric_divisor(F4, [1, 2, 3, 4])\nTorus-invariant, non-prime divisor on a normal toric variety\n\njulia> coefficients(D)\n4-element Vector{ZZRingElem}:\n 1\n 2\n 3\n 4\n\n\n\n\n\n","category":"method"},{"location":"AlgebraicGeometry/ToricVarieties/ToricDivisors/#polyhedron-Tuple{ToricDivisor}","page":"Toric Divisors","title":"polyhedron","text":"polyhedron(td::ToricDivisor)\n\nConstruct the polyhedron P_D of a torus invariant divisor D=td as in 4.3.2 of [CLS11]. The lattice points of this polyhedron correspond to the global sections of the divisor.\n\nExamples\n\nThe polyhedron of the divisor with all coefficients equal to zero is a point, if the ambient variety is complete. Changing the coefficients corresponds to moving hyperplanes. One direction moves the hyperplane away from the origin, the other moves it across. In the latter case there are no global sections anymore and the polyhedron becomes empty.\n\njulia> F4 = hirzebruch_surface(NormalToricVariety, 4)\nNormal toric variety\n\njulia> td0 = toric_divisor(F4, [0,0,0,0])\nTorus-invariant, non-prime divisor on a normal toric variety\n\njulia> is_feasible(polyhedron(td0))\ntrue\n\njulia> dim(polyhedron(td0))\n0\n\njulia> td1 = toric_divisor(F4, [1,0,0,0])\nTorus-invariant, prime divisor on a normal toric variety\n\njulia> is_feasible(polyhedron(td1))\ntrue\n\njulia> td2 = toric_divisor(F4, [-1,0,0,0])\nTorus-invariant, non-prime divisor on a normal toric variety\n\njulia> is_feasible(polyhedron(td2))\nfalse\n\n\n\n\n\n","category":"method"},{"location":"AlgebraicGeometry/ToricVarieties/ToricDivisors/#toric_variety-Tuple{ToricDivisor}","page":"Toric Divisors","title":"toric_variety","text":"toric_variety(td::ToricDivisor)\n\nReturn the toric variety of a torus-invariant Weil divisor.\n\nExamples\n\njulia> F4 = hirzebruch_surface(NormalToricVariety, 4);\n\njulia> D = toric_divisor(F4, [1, 2, 3, 4]);\n\njulia> toric_variety(D)\nNormal toric variety\n\n\n\n\n\n","category":"method"},{"location":"AlgebraicGeometry/ToricVarieties/ToricDivisors/","page":"Toric Divisors","title":"Toric Divisors","text":"The following attributes are supported by experimental code:","category":"page"},{"location":"AlgebraicGeometry/ToricVarieties/ToricDivisors/","page":"Toric Divisors","title":"Toric Divisors","text":"scheme(td::ToricDivisor)\nforget_toric_structure(td::ToricDivisor)","category":"page"},{"location":"AlgebraicGeometry/ToricVarieties/ToricDivisors/#scheme-Tuple{ToricDivisor}","page":"Toric Divisors","title":"scheme","text":"scheme(td::ToricDivisor)\n\nEvery toric divisor has an underlying scheme-theoretic Weil divisor. This method returns the scheme, on which said scheme-theoretic divisor is defined. In the case at hand, this is by design the toric variety at hand, which knows its underlying scheme. The latter can be accessed with the function underlying_toric_structure.\n\nExamples\n\njulia> P3 = projective_space(NormalToricVariety, 3)\nNormal toric variety\n\njulia> td = toric_divisor(P3, [0, 1, 0, 0])\nTorus-invariant, prime divisor on a normal toric variety\n\njulia> scheme(td)\nNormal toric variety\n\njulia> forget_toric_structure(scheme(td))\n(Scheme over QQ covered with 4 patches, Hom: scheme over QQ covered with 4 patches -> normal toric variety)\n\nwarning: Experimental\nThis function is part of the experimental code in Oscar. Please read here for more details.\n\n\n\n\n\n","category":"method"},{"location":"AlgebraicGeometry/ToricVarieties/ToricDivisors/#forget_toric_structure-Tuple{ToricDivisor}","page":"Toric Divisors","title":"forget_toric_structure","text":"forget_toric_structure(td::ToricDivisor)\n\nEvery toric divisor has an underlying scheme-theoretic Weil divisor. This method returns said divisor.\n\nExamples\n\njulia> P3 = projective_space(NormalToricVariety, 3)\nNormal toric variety\n\njulia> td = toric_divisor(P3, [0, 1, 0, 0])\nTorus-invariant, prime divisor on a normal toric variety\n\njulia> forget_toric_structure(td)\nEffective weil divisor\n  on normal, 3-dimensional toric variety\nwith coefficients in integer ring\ngiven as the formal sum of\n  1 * sheaf of ideals\n\nwarning: Experimental\nThis function is part of the experimental code in Oscar. Please read here for more details.\n\n\n\n\n\n","category":"method"},{"location":"AlgebraicGeometry/ToricVarieties/AlgebraicCycles/","page":"The Chow ring","title":"The Chow ring","text":"CurrentModule = Oscar","category":"page"},{"location":"AlgebraicGeometry/ToricVarieties/AlgebraicCycles/#The-Chow-ring","page":"The Chow ring","title":"The Chow ring","text":"","category":"section"},{"location":"AlgebraicGeometry/ToricVarieties/AlgebraicCycles/","page":"The Chow ring","title":"The Chow ring","text":"Algebraic cycles are formal linear sum of irreducible subvarieties over the integers. Perse, algebraic cycles do not admit a well-defined intersection product.","category":"page"},{"location":"AlgebraicGeometry/ToricVarieties/AlgebraicCycles/","page":"The Chow ring","title":"The Chow ring","text":"To see this, think of intersecting a non-trivial algebraic cycle C with itself. Of course, in set theory we can intersect C with itself and the result is again C. However, for a well-defined intersection theory, we would ask that the self-intersection of C is an algebraic cycle of strictly smaller dimension.","category":"page"},{"location":"AlgebraicGeometry/ToricVarieties/AlgebraicCycles/","page":"The Chow ring","title":"The Chow ring","text":"In theory, this is resolved by saying that the self-intersection of C is given by intersecting C with a distinct algebraic cycle D which is obtained by moving C a little bit. The general phrase for this is to \"move C in general position\".","category":"page"},{"location":"AlgebraicGeometry/ToricVarieties/AlgebraicCycles/","page":"The Chow ring","title":"The Chow ring","text":"This leads to a famous notion of equivalence among algebraic cycles, the so-called rational equivalence. The set of equivalence classes of algebraic cycles together with the intersection product then furnishes the Chow ring of the variety in question.","category":"page"},{"location":"AlgebraicGeometry/ToricVarieties/AlgebraicCycles/","page":"The Chow ring","title":"The Chow ring","text":"For complete and simplicial toric varieties, many things are known about the Chow ring and algebraic cycles (cf. section 12.5 in [CLS11]:","category":"page"},{"location":"AlgebraicGeometry/ToricVarieties/AlgebraicCycles/","page":"The Chow ring","title":"The Chow ring","text":"By theorem 12.5.3 of [CLS11], there is an isomorphism among the Chow ring and the cohomology ring. Note that the cohomology ring is naturally graded (cf. last paragraph on page 593 in [CLS11]). However, the Chow ring is usually considered as a non-graded ring. To match this general convention, and in particular the implementation of the Chow ring for matroids in OSCAR, the toric Chow ring is constructed as a non-graded ring.\nBy theorem 12.5.3 of [CLS11], the Chow ring is isomorphic to the quotient of the non-graded Cox ring and a certain ideal. Specifically, the ideal in question is the sum of the ideal of linear relations and the Stanley-Reisner ideal.\nIt is worth noting that the ideal of linear relations is not homogeneous with respect to the class group grading of the Cox ring. In order to construct the cohomology ring, one can introduce a mathbbZ-grading on the Cox ring such that the ideal of linear relations and the Stanley-Reisner ideal are homogeneous.\nFinally, by lemma 12.5.1 of [CLS11], generators of the rational equivalence classes of algebraic cycles are one-to-one to the cones in the fan of the toric variety.","category":"page"},{"location":"AlgebraicGeometry/ToricVarieties/AlgebraicCycles/#Constructors","page":"The Chow ring","title":"Constructors","text":"","category":"section"},{"location":"AlgebraicGeometry/ToricVarieties/AlgebraicCycles/#General-constructors","page":"The Chow ring","title":"General constructors","text":"","category":"section"},{"location":"AlgebraicGeometry/ToricVarieties/AlgebraicCycles/","page":"The Chow ring","title":"The Chow ring","text":"rational_equivalence_class(v::NormalToricVarietyType, p::MPolyQuoRingElem)\nrational_equivalence_class(v::NormalToricVarietyType, coefficients::Vector{T}) where {T <: IntegerUnion}","category":"page"},{"location":"AlgebraicGeometry/ToricVarieties/AlgebraicCycles/#rational_equivalence_class-Tuple{Union{AffineNormalToricVariety, CyclicQuotientSingularity, NormalToricVariety}, MPolyQuoRingElem}","page":"The Chow ring","title":"rational_equivalence_class","text":"rational_equivalence_class(v::NormalToricVarietyType, p::MPolyQuoRingElem)\n\nConstruct the rational equivalence class of algebraic cycles corresponding to a linear combination of cones.\n\nExamples\n\njulia> P2 = projective_space(NormalToricVariety, 2)\nNormal toric variety\n\njulia> chow_ring(P2)\nQuotient\n  of multivariate polynomial ring in 3 variables x1, x2, x3\n    over rational field\n  by ideal (x1 - x3, x2 - x3, x1*x2*x3)\n\njulia> (x1, x2, x3) = gens(chow_ring(P2))\n3-element Vector{MPolyQuoRingElem{QQMPolyRingElem}}:\n x1\n x2\n x3\n\njulia> rational_equivalence_class(P2, x1)\nRational equivalence classon a normal toric variety represented by V(x3)\n\n\n\n\n\n","category":"method"},{"location":"AlgebraicGeometry/ToricVarieties/AlgebraicCycles/#rational_equivalence_class-Union{Tuple{T}, Tuple{Union{AffineNormalToricVariety, CyclicQuotientSingularity, NormalToricVariety}, Vector{T}}} where T<:Union{Integer, ZZRingElem}","page":"The Chow ring","title":"rational_equivalence_class","text":"rational_equivalence_class(v::NormalToricVarietyType, coefficients::Vector{T}) where {T <: IntegerUnion}\n\nConstruct the rational equivalence class of algebraic cycles corresponding to a linear combination of cones.\n\nExamples\n\njulia> P2 = projective_space(NormalToricVariety, 2)\nNormal toric variety\n\njulia> rational_equivalence_class(P2, [6, 5, 4, 3, 2, 1])\nRational equivalence class on a normal toric variety represented by 15V(x1,x3)+6V(x3)\n\n\n\n\n\n","category":"method"},{"location":"AlgebraicGeometry/ToricVarieties/AlgebraicCycles/#toric_special_constructors","page":"The Chow ring","title":"Special constructors","text":"","category":"section"},{"location":"AlgebraicGeometry/ToricVarieties/AlgebraicCycles/","page":"The Chow ring","title":"The Chow ring","text":"rational_equivalence_class(d::ToricDivisor)\nrational_equivalence_class(c::ToricDivisorClass)\nrational_equivalence_class(l::ToricLineBundle)\nrational_equivalence_class(cc::CohomologyClass)\nrational_equivalence_class(sv::ClosedSubvarietyOfToricVariety)","category":"page"},{"location":"AlgebraicGeometry/ToricVarieties/AlgebraicCycles/#rational_equivalence_class-Tuple{ToricDivisor}","page":"The Chow ring","title":"rational_equivalence_class","text":"rational_equivalence_class(d::ToricDivisor)\n\nConstruct the rational equivalence class of algebraic cycles corresponding to the toric divisor d.\n\nExamples\n\njulia> P2 = projective_space(NormalToricVariety, 2)\nNormal toric variety\n\njulia> d = toric_divisor(P2, [1, 2, 3])\nTorus-invariant, non-prime divisor on a normal toric variety\n\njulia> rational_equivalence_class(d)\nRational equivalence class on a normal toric variety represented by 6V(x3)\n\n\n\n\n\n","category":"method"},{"location":"AlgebraicGeometry/ToricVarieties/AlgebraicCycles/#rational_equivalence_class-Tuple{ToricDivisorClass}","page":"The Chow ring","title":"rational_equivalence_class","text":"rational_equivalence_class(c::ToricDivisorClass)\n\nConstruct the algebraic cycle corresponding to the toric divisor class c.\n\nExamples\n\njulia> P2 = projective_space(NormalToricVariety, 2)\nNormal toric variety\n\njulia> tdc = toric_divisor_class(P2, [2])\nDivisor class on a normal toric variety\n\njulia> rational_equivalence_class(tdc)\nRational equivalence class on a normal toric variety represented by 2V(x3)\n\n\n\n\n\n","category":"method"},{"location":"AlgebraicGeometry/ToricVarieties/AlgebraicCycles/#rational_equivalence_class-Tuple{ToricLineBundle}","page":"The Chow ring","title":"rational_equivalence_class","text":"RationalEquivalenceClass(l::ToricLineBundle)\n\nConstruct the toric algebraic cycle corresponding to the toric line bundle l.\n\nExamples\n\njulia> P2 = projective_space(NormalToricVariety, 2)\nNormal toric variety\n\njulia> l = toric_line_bundle(P2, [2])\nToric line bundle on a normal toric variety\n\njulia> polynomial(rational_equivalence_class(l))\n2*x3\n\n\n\n\n\n","category":"method"},{"location":"AlgebraicGeometry/ToricVarieties/AlgebraicCycles/#rational_equivalence_class-Tuple{CohomologyClass}","page":"The Chow ring","title":"rational_equivalence_class","text":"rational_equivalence_class(cc::CohomologyClass)\n\nConstruct the toric algebraic cycle corresponding to the cohomology class cc.\n\nExamples\n\njulia> P2 = projective_space(NormalToricVariety, 2)\nNormal toric variety\n\njulia> (x1, x2, x3) = gens(cohomology_ring(P2))\n3-element Vector{MPolyQuoRingElem{MPolyDecRingElem{QQFieldElem, QQMPolyRingElem}}}:\n x1\n x2\n x3\n\njulia> cc = CohomologyClass(P2, x1+x2)\nCohomology class on a normal toric variety given by x1 + x2\n\njulia> rational_equivalence_class(cc)\nRational equivalence class on a normal toric variety represented by 2V(x3)\n\n\n\n\n\n","category":"method"},{"location":"AlgebraicGeometry/ToricVarieties/AlgebraicCycles/#rational_equivalence_class-Tuple{ClosedSubvarietyOfToricVariety}","page":"The Chow ring","title":"rational_equivalence_class","text":"rational_equivalence_class(sv::ClosedSubvarietyOfToricVariety)\n\nConstruct the rational equivalence class of algebraic cycles of a closed subvariety of a normal toric variety.\n\nExamples\n\njulia> ntv = normal_toric_variety(Oscar.normal_fan(Oscar.cube(2)))\nNormal toric variety\n\njulia> set_coordinate_names(ntv, [\"x1\", \"x2\", \"y1\", \"y2\"]);\n\njulia> (x1, x2, y1, y2) = gens(cox_ring(ntv))\n4-element Vector{MPolyDecRingElem{QQFieldElem, QQMPolyRingElem}}:\n x1\n x2\n y1\n y2\n\njulia> sv = closed_subvariety_of_toric_variety(ntv, [x1^2+x1*x2+x2^2, y2])\nClosed subvariety of a normal toric variety\n\njulia> rational_equivalence_class(sv)\nRational equivalence class on a normal toric variety represented by 2V(x2,y2)\n\n\n\n\n\n","category":"method"},{"location":"AlgebraicGeometry/ToricVarieties/AlgebraicCycles/#Addition,-subtraction-and-scalar-multiplication","page":"The Chow ring","title":"Addition, subtraction and scalar multiplication","text":"","category":"section"},{"location":"AlgebraicGeometry/ToricVarieties/AlgebraicCycles/","page":"The Chow ring","title":"The Chow ring","text":"Algebraic cycles can be added and subtracted via the usual + and - operators. Moreover, multiplication by scalars from the left is supported for scalars which are integers or of type ZZRingElem.","category":"page"},{"location":"AlgebraicGeometry/ToricVarieties/AlgebraicCycles/","page":"The Chow ring","title":"The Chow ring","text":"Note that one can easily define the Chow ring also a formal linear sums of irreducible subvarieties with coefficients being rational numbers. We support this more general ring and therefore also allow for left multiplication with scalars of type QQFieldElem.","category":"page"},{"location":"AlgebraicGeometry/ToricVarieties/AlgebraicCycles/#Intersection-product","page":"The Chow ring","title":"Intersection product","text":"","category":"section"},{"location":"AlgebraicGeometry/ToricVarieties/AlgebraicCycles/","page":"The Chow ring","title":"The Chow ring","text":"The intersection product of algebraic cycles is implemented via *. This makes sense, since algebraic cycles on toric varieties are elements of the Chow ring, which in turn is (a certain) quotient of the Cox ring. Hence, internally, an algebraic cycle can be thought of as a polynomial in this ring and the intersection product corresponds to the product of two (equivalence classes of) polynomials.","category":"page"},{"location":"AlgebraicGeometry/ToricVarieties/AlgebraicCycles/","page":"The Chow ring","title":"The Chow ring","text":"An algebraic cycle can be intersected n- with itself via ^n, where n can be an integer of of type ZZRingElem.","category":"page"},{"location":"AlgebraicGeometry/ToricVarieties/AlgebraicCycles/","page":"The Chow ring","title":"The Chow ring","text":"A closed subvarieties defines in a natural way a rational equivalence class (cf. Special constructors). This allows to compute intersection products among closed subvarieties and rational equivalence classes in the Chow ring.","category":"page"},{"location":"AlgebraicGeometry/ToricVarieties/AlgebraicCycles/#Attributes","page":"The Chow ring","title":"Attributes","text":"","category":"section"},{"location":"AlgebraicGeometry/ToricVarieties/AlgebraicCycles/#Defining-attributes","page":"The Chow ring","title":"Defining attributes","text":"","category":"section"},{"location":"AlgebraicGeometry/ToricVarieties/AlgebraicCycles/","page":"The Chow ring","title":"The Chow ring","text":"toric_variety(ac::RationalEquivalenceClass)\npolynomial(ac::RationalEquivalenceClass)\npolynomial(ring::MPolyQuoRing, ac::RationalEquivalenceClass)","category":"page"},{"location":"AlgebraicGeometry/ToricVarieties/AlgebraicCycles/#toric_variety-Tuple{RationalEquivalenceClass}","page":"The Chow ring","title":"toric_variety","text":"toric_variety(ac::RationalEquivalenceClass)\n\nReturn the normal toric variety of a rational equivalence class of algebraic cycles.\n\nExamples\n\njulia> dP2 = del_pezzo_surface(NormalToricVariety, 2)\nNormal toric variety\n\njulia> d = toric_divisor(dP2, [1, 2, 3, 4, 5])\nTorus-invariant, non-prime divisor on a normal toric variety\n\njulia> ac = rational_equivalence_class(d)\nRational equivalence class on a normal toric variety represented by 6V(x3)+V(e1)+7V(e2)\n\njulia> toric_variety(ac)\nNormal, simplicial toric variety\n\n\n\n\n\n","category":"method"},{"location":"AlgebraicGeometry/ToricVarieties/AlgebraicCycles/#polynomial-Tuple{RationalEquivalenceClass}","page":"The Chow ring","title":"polynomial","text":"polynomial(ac::RationalEquivalenceClass)\n\nOn a simplicial and complete toric variety, the Chow ring is isomorphic to a certain quotient of the Cox ring. This function returns the ring element corresponding to a given rational equivalence class of algebraic cycles.\n\nExamples\n\njulia> dP2 = del_pezzo_surface(NormalToricVariety, 2)\nNormal toric variety\n\njulia> d = toric_divisor(dP2, [1, 2, 3, 4, 5])\nTorus-invariant, non-prime divisor on a normal toric variety\n\njulia> ac = rational_equivalence_class(d)\nRational equivalence class on a normal toric variety represented by 6V(x3)+V(e1)+7V(e2)\n\njulia> polynomial(ac)\n6*x3 + e1 + 7*e2\n\n\n\n\n\n","category":"method"},{"location":"AlgebraicGeometry/ToricVarieties/AlgebraicCycles/#polynomial-Tuple{MPolyQuoRing, RationalEquivalenceClass}","page":"The Chow ring","title":"polynomial","text":"polynomial(ring::MPolyQuoRing, ac::RationalEquivalenceClass)\n\nOn a simplicial and complete toric variety, the Chow ring is isomorphic to a certain quotient of the Cox ring. This function returns the ring element corresponding to a given rational equivalence class of algebraic cycles. The first argument of this function allows to obtain this ring element in a different ring. This allows to change the coefficient ring if desired.\n\nExamples\n\njulia> dP2 = del_pezzo_surface(NormalToricVariety, 2)\nNormal toric variety\n\njulia> d = toric_divisor(dP2, [1, 2, 3, 4, 5])\nTorus-invariant, non-prime divisor on a normal toric variety\n\njulia> ac = rational_equivalence_class(d)\nRational equivalence class on a normal toric variety represented by 6V(x3)+V(e1)+7V(e2)\n\njulia> R, _ = polynomial_ring(QQ, 5)\n(Multivariate polynomial ring in 5 variables over QQ, QQMPolyRingElem[x1, x2, x3, x4, x5])\n\njulia> (x1, x2, x3, x4, x5) = gens(R)\n5-element Vector{QQMPolyRingElem}:\n x1\n x2\n x3\n x4\n x5\n\njulia> sr_and_linear_relation_ideal = ideal([x1*x3, x1*x5, x2*x4, x2*x5, x3*x4, x1 + x2 - x5, x2 + x3 - x4 - x5])\nIdeal generated by\n  x1*x3\n  x1*x5\n  x2*x4\n  x2*x5\n  x3*x4\n  x1 + x2 - x5\n  x2 + x3 - x4 - x5\n\njulia> R_quo = quo(R, sr_and_linear_relation_ideal)[1]\nQuotient\n  of multivariate polynomial ring in 5 variables x1, x2, x3, x4, x5\n    over rational field\n  by ideal (x1*x3, x1*x5, x2*x4, x2*x5, x3*x4, x1 + x2 - x5, x2 + x3 - x4 - x5)\n\njulia> polynomial(R_quo, ac)\n6*x3 + x4 + 7*x5\n\n\n\n\n\n","category":"method"},{"location":"AlgebraicGeometry/ToricVarieties/AlgebraicCycles/#Representatives","page":"The Chow ring","title":"Representatives","text":"","category":"section"},{"location":"AlgebraicGeometry/ToricVarieties/AlgebraicCycles/","page":"The Chow ring","title":"The Chow ring","text":"In order to see a geometric interpretation of rational equivalence classes of algebraic cycles most efficiently, it is best to replace self-intersections by transverse complete intersections. Indeed, within the regime of simplicial, complete toric varieties this is always possible. However, this involves a choice. Consequently, the following methods will pick a special choice and return values for that particular choice of representative of the rational equivalence class in question.","category":"page"},{"location":"AlgebraicGeometry/ToricVarieties/AlgebraicCycles/","page":"The Chow ring","title":"The Chow ring","text":"representative(ac::RationalEquivalenceClass)","category":"page"},{"location":"AlgebraicGeometry/ToricVarieties/AlgebraicCycles/#representative-Tuple{RationalEquivalenceClass}","page":"The Chow ring","title":"representative","text":"representative(ac::RationalEquivalenceClass)\n\nReturn a polynomial in the Cox ring mapping to polynomial(ac).\n\nExamples\n\njulia> dP2 = del_pezzo_surface(NormalToricVariety, 2)\nNormal toric variety\n\njulia> d = toric_divisor(dP2, [1, 2, 3, 4, 5])\nTorus-invariant, non-prime divisor on a normal toric variety\n\njulia> ac = rational_equivalence_class(d)\nRational equivalence class on a normal toric variety represented by 6V(x3)+V(e1)+7V(e2)\n\njulia> ac*ac\nRational equivalence class on a normal toric variety represented by 34V(x2,x3)\n\njulia> representative(ac*ac)\n34*x2*x3\n\n\n\n\n\n","category":"method"},{"location":"AlgebraicGeometry/ToricVarieties/AlgebraicCycles/","page":"The Chow ring","title":"The Chow ring","text":"It can be rather convenient to investigate such a representative in order to understand the geometric meaning of a rational equivalence class. For this purpose, we support the following methods.","category":"page"},{"location":"AlgebraicGeometry/ToricVarieties/AlgebraicCycles/","page":"The Chow ring","title":"The Chow ring","text":"coefficients(ac::RationalEquivalenceClass)\ncomponents(ac::RationalEquivalenceClass)","category":"page"},{"location":"AlgebraicGeometry/ToricVarieties/AlgebraicCycles/#coefficients-Tuple{RationalEquivalenceClass}","page":"The Chow ring","title":"coefficients","text":"coefficients(ac::RationalEquivalenceClass)\n\nReturn the coefficients of polynomial(ac).\n\nExamples\n\njulia> dP2 = del_pezzo_surface(NormalToricVariety, 2)\nNormal toric variety\n\njulia> d = toric_divisor(dP2, [1, 2, 3, 4, 5])\nTorus-invariant, non-prime divisor on a normal toric variety\n\njulia> ac = rational_equivalence_class(d)\nRational equivalence class on a normal toric variety represented by 6V(x3)+V(e1)+7V(e2)\n\njulia> coefficients(ac*ac)\n1-element Vector{QQFieldElem}:\n -34\n\n\n\n\n\n","category":"method"},{"location":"AlgebraicGeometry/ToricVarieties/AlgebraicCycles/#components-Tuple{RationalEquivalenceClass}","page":"The Chow ring","title":"components","text":"components(ac::RationalEquivalenceClass)\n\nTurn each monomial of representative(ac) into a closed subvariety and return the list formed from these subvarieties. Note that each of these subvarieties is irreducible and their formal linear sum, with the coefficients computed by the method coefficients(ac::RationalEquivalenceClass), defines an algebraic cycle, whose rational equivalence class is identical to the one given to this method.\n\nExamples\n\njulia> dP2 = del_pezzo_surface(NormalToricVariety, 2)\nNormal toric variety\n\njulia> d = toric_divisor(dP2, [1, 2, 3, 4, 5])\nTorus-invariant, non-prime divisor on a normal toric variety\n\njulia> ac = rational_equivalence_class(d)\nRational equivalence class on a normal toric variety represented by 6V(x3)+V(e1)+7V(e2)\n\njulia> length(components(ac*ac))\n1\n\n\n\n\n\n","category":"method"},{"location":"AlgebraicGeometry/ToricVarieties/AlgebraicCycles/#Other-attributes","page":"The Chow ring","title":"Other attributes","text":"","category":"section"},{"location":"AlgebraicGeometry/ToricVarieties/AlgebraicCycles/","page":"The Chow ring","title":"The Chow ring","text":"cohomology_class(ac::RationalEquivalenceClass)","category":"page"},{"location":"AlgebraicGeometry/ToricVarieties/AlgebraicCycles/#cohomology_class-Tuple{RationalEquivalenceClass}","page":"The Chow ring","title":"cohomology_class","text":"cohomology_class(ac::RationalEquivalenceClass)\n\nReturn the cohomology class of a rational equilvalence class of algebraic cycles.\n\nExamples\n\njulia> dP2 = del_pezzo_surface(NormalToricVariety, 2)\nNormal toric variety\n\njulia> d = toric_divisor(dP2, [1, 2, 3, 4, 5])\nTorus-invariant, non-prime divisor on a normal toric variety\n\njulia> ac = rational_equivalence_class(d)\nRational equivalence class on a normal toric variety represented by 6V(x3)+V(e1)+7V(e2)\n\njulia> cohomology_class(ac)\nCohomology class on a normal toric variety given by 6*x3 + e1 + 7*e2\n\n\n\n\n\n","category":"method"},{"location":"AlgebraicGeometry/ToricVarieties/AlgebraicCycles/#Properties","page":"The Chow ring","title":"Properties","text":"","category":"section"},{"location":"AlgebraicGeometry/ToricVarieties/AlgebraicCycles/","page":"The Chow ring","title":"The Chow ring","text":"One can check if a rational equivalence class of algebraic cycles is trivial via is_trivial. Equality can be tested with ==.","category":"page"},{"location":"AlgebraicGeometry/ToricVarieties/AlgebraicCycles/#Special-attributes-of-toric-varieties","page":"The Chow ring","title":"Special attributes of toric varieties","text":"","category":"section"},{"location":"AlgebraicGeometry/ToricVarieties/AlgebraicCycles/","page":"The Chow ring","title":"The Chow ring","text":"chow_ring(v::NormalToricVarietyType)\ngens_of_rational_equivalence_classes(v::NormalToricVarietyType)\nmap_gens_of_chow_ring_to_cox_ring(v::NormalToricVarietyType)","category":"page"},{"location":"AlgebraicGeometry/ToricVarieties/AlgebraicCycles/#chow_ring-Tuple{Union{AffineNormalToricVariety, CyclicQuotientSingularity, NormalToricVariety}}","page":"The Chow ring","title":"chow_ring","text":"chow_ring(v::NormalToricVarietyType)\n\nReturn the Chow ring of the simplicial toric variety v.\n\nWhile [CLS11] focus on simplicial and complete varieties to define the Chow ring, it was described in [Peg14] that this notion can also be extended to non-complete varieties. We explicitly support the Chow ring also for non-complete varieties.\n\nThis is demonstrated by the following example. Note that the computation for the non-complete variety leads to a Chow ring which is identical to the Chow ring of a certain matroid. This observation can be anticipated by e.g. the results in [FY04].\n\nExamples\n\njulia> p2 = projective_space(NormalToricVariety, 2);\n\njulia> is_complete(p2)\ntrue\n\njulia> ngens(chow_ring(p2))\n3\n\njulia> v = normal_toric_variety(incidence_matrix([[1], [2], [3]]), [[1, 0], [0, 1], [-1, -1]])\nNormal toric variety\n\njulia> is_complete(v)\nfalse\n\njulia> set_coordinate_names(v, [\"x_{1}\", \"x_{2}\", \"x_{3}\"])\n\njulia> chow_ring(v)\nQuotient\n  of multivariate polynomial ring in 3 variables x_{1}, x_{2}, x_{3}\n    over rational field\n  by ideal (x_{1} - x_{3}, x_{2} - x_{3}, x_{1}*x_{2}, x_{1}*x_{3}, x_{2}*x_{3})\n\njulia> M = cycle_matroid(complete_graph(3))\nMatroid of rank 2 on 3 elements\n\njulia> chow_ring(M)\nQuotient\n  of multivariate polynomial ring in 3 variables x_{Edge(2, 1)}, x_{Edge(3, 1)}, x_{Edge(3, 2)}\n    over rational field\n  by ideal with 5 generators\n\n\n\n\n\n","category":"method"},{"location":"AlgebraicGeometry/ToricVarieties/AlgebraicCycles/#gens_of_rational_equivalence_classes-Tuple{Union{AffineNormalToricVariety, CyclicQuotientSingularity, NormalToricVariety}}","page":"The Chow ring","title":"gens_of_rational_equivalence_classes","text":"gens_of_rational_equivalence_classes(v::NormalToricVarietyType)\n\nReturn a list of generators of the Chow ring of a complete, simplicial toric variety.\n\nRecall that the cones of a complete, simplicial toric variety can be seen as generators of the Chow ring (lemma 12.5.1 in [CLS11]). This function first maps each cone to an element of the Chow ring and then removes elements by taking rational equivalence into account.\n\nExamples\n\njulia> p2 = projective_space(NormalToricVariety, 2);\n\njulia> gens_of_rational_equivalence_classes(p2)\n6-element Vector{MPolyQuoRingElem{QQMPolyRingElem}}:\n x3^2\n x3^2\n x3^2\n x3\n x3\n x3\n\n\n\n\n\n","category":"method"},{"location":"AlgebraicGeometry/ToricVarieties/AlgebraicCycles/#map_gens_of_chow_ring_to_cox_ring-Tuple{Union{AffineNormalToricVariety, CyclicQuotientSingularity, NormalToricVariety}}","page":"The Chow ring","title":"map_gens_of_chow_ring_to_cox_ring","text":"map_gens_of_chow_ring_to_cox_ring(v::NormalToricVarietyType)\n\nReturn a dictionary which maps the generators of the chow ring to monomials in the Cox ring. This dictionary involves a choice, i.e. is not unique.\n\nExamples\n\njulia> p2 = projective_space(NormalToricVariety, 2);\n\njulia> map_gens_of_chow_ring_to_cox_ring(p2)\nDict{QQMPolyRingElem, MPolyDecRingElem{QQFieldElem, QQMPolyRingElem}} with 2 entries:\n  x3^2 => x1*x3\n  x3   => x3\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/number_fields/fields/#Number-field-operations","page":"Number field operations","title":"Number field operations","text":"","category":"section"},{"location":"Hecke/manual/number_fields/fields/","page":"Number field operations","title":"Number field operations","text":"CurrentModule = Hecke\nDocTestSetup = quote\n  using Hecke\nend","category":"page"},{"location":"Hecke/manual/number_fields/fields/#Creation-of-number-fields","page":"Number field operations","title":"Creation of number fields","text":"","category":"section"},{"location":"Hecke/manual/number_fields/fields/","page":"Number field operations","title":"Number field operations","text":"General number fields can be created using the function number_field. To create a simple number field given by a defining polynomial or a non-simple number field given by defining polynomials, the following functions can be used.","category":"page"},{"location":"Hecke/manual/number_fields/fields/","page":"Number field operations","title":"Number field operations","text":"number_field(::DocuDummy)\nnumber_field(::DocuDummy2)","category":"page"},{"location":"Hecke/manual/number_fields/fields/#number_field-Tuple{Hecke.DocuDummy}","page":"Number field operations","title":"number_field","text":"number_field(f::Poly{NumFieldElem}, s::VarName;\n            cached::Bool = false, check::Bool = false) -> NumField, NumFieldElem\n\nGiven an irreducible polynomial f in Kx over some number field K, this function creates the simple number field L = Kx(f) and returns (L b), where b is the class of x in L. The string s is used only for printing the primitive element b.\n\ncheck: Controls whether irreducibility of f is checked.\ncached: Controls whether the result is cached.\n\nExamples\n\njulia> K, a = quadratic_field(5);\n\njulia> Kt, t = K[\"t\"];\n\njulia> L, b = number_field(t^3 - 3, \"b\");\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/number_fields/fields/#number_field-Tuple{Hecke.DocuDummy2}","page":"Number field operations","title":"number_field","text":"number_field(f::Vector{PolyRingElem{<:NumFieldElem}}, s::VarName=\"_\\$\", check = true)\n                                          -> NumField, Vector{NumFieldElem}\n\nGiven a list f_1 ldots f_n of univariate polynomials in Kx over some number field K, constructs the extension Kx_1 ldots x_n(f_1(x_1) ldots f_n(x_n)).\n\nExamples\n\njulia> Qx, x = QQ[\"x\"];\n\njulia> K, a = number_field([x^2 - 2, x^2 - 3], \"a\")\n(Non-simple number field of degree 4 over QQ, AbsNonSimpleNumFieldElem[a1, a2])\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/number_fields/fields/","page":"Number field operations","title":"Number field operations","text":"tip: Tip\nMany of the constructors have arguments of type Symbol or AbstractString.  If used, they define the appearance in printing, and printing only.  The named parameter check can be true or false, the default being true.  This parameter controls whether the polynomials defining the number field are tested for irreducibility or not. Given that this can be potentially very time consuming if the degree if large, one can disable this test. Note however, that the behaviour of Hecke is undefined if a reducible polynomial is used to define a field.The named boolean parameter cached can be used to disable caching. Two number fields defined using the same polynomial from the identical polynomial ring and the same (identical) symbol/string will be identical if cached == true and different if cached == false.","category":"page"},{"location":"Hecke/manual/number_fields/fields/","page":"Number field operations","title":"Number field operations","text":"For frequently used number fields like quadratic fields, cyclotomic fields or radical extensions, the following functions are provided:","category":"page"},{"location":"Hecke/manual/number_fields/fields/","page":"Number field operations","title":"Number field operations","text":"cyclotomic_field(n::Int)\nquadratic_field(d::ZZRingElem)\nwildanger_field(n::Int, B::ZZRingElem)\nradical_extension(n::Int, a::NumFieldElem)\nrationals_as_number_field()","category":"page"},{"location":"Hecke/manual/number_fields/fields/#cyclotomic_field-Tuple{Int64}","page":"Number field operations","title":"cyclotomic_field","text":"cyclotomic_field(n::Int, s::VarName = \"z_$n\", t = \"_\\$\"; cached::Bool = true)\n\nReturn a tuple R x consisting of the parent object R and generator x of the n-th cyclotomic field, mathbbQ(zeta_n). The supplied string s specifies how the generator of the number field should be printed. If provided, the string t specifies how the generator of the polynomial ring from which the number field is constructed, should be printed. If it is not supplied, a default dollar sign will be used to represent the variable.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/number_fields/fields/#quadratic_field-Tuple{ZZRingElem}","page":"Number field operations","title":"quadratic_field","text":"quadratic_field(d::IntegerUnion) -> AbsSimpleNumField, AbsSimpleNumFieldElem\n\nReturns the field with defining polynomial x^2 - d.\n\nExamples\n\njulia> quadratic_field(5)\n(Real quadratic field defined by x^2 - 5, sqrt(5))\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/number_fields/fields/#wildanger_field-Tuple{Int64, ZZRingElem}","page":"Number field operations","title":"wildanger_field","text":"wildanger_field(n::Int, B::ZZRingElem) -> AbsSimpleNumField, AbsSimpleNumFieldElem\n\nReturns the field with defining polynomial x^n + sum_i=0^n-1 (-1)^n-iBx^i. These fields tend to have non-trivial class groups.\n\nExamples\n\njulia> wildanger_field(3, ZZ(10), \"a\")\n(Number field of degree 3 over QQ, a)\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/number_fields/fields/#radical_extension-Tuple{Int64, NumFieldElem}","page":"Number field operations","title":"radical_extension","text":"radical_extension(n::Int, a::NumFieldElem, s = \"_$\";\n               check = true, cached = true) -> NumField, NumFieldElem\n\nGiven an element a of a number field K and an integer n, create the simple extension of K with the defining polynomial x^n - a.\n\nExamples\n\njulia> radical_extension(5, QQ(2), \"a\")\n(Number field of degree 5 over QQ, a)\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/number_fields/fields/#rationals_as_number_field-Tuple{}","page":"Number field operations","title":"rationals_as_number_field","text":"rationals_as_number_field() -> AbsSimpleNumField, AbsSimpleNumFieldElem\n\nReturns the rational numbers as the number field defined by x - 1.\n\nExamples\n\njulia> rationals_as_number_field()\n(Number field of degree 1 over QQ, 1)\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/number_fields/fields/#Basic-properties","page":"Number field operations","title":"Basic properties","text":"","category":"section"},{"location":"Hecke/manual/number_fields/fields/","page":"Number field operations","title":"Number field operations","text":"basis(::SimpleNumField)\nbasis(::NonSimpleNumField)\nabsolute_basis(::NumField)\ndefining_polynomial(::SimpleNumField)\ndefining_polynomials(::NonSimpleNumField)\nabsolute_primitive_element(::NumField)\ncomponent(::NonSimpleNumField, ::Int)\nbase_field(::NumField)","category":"page"},{"location":"Hecke/manual/number_fields/fields/#basis-Tuple{SimpleNumField}","page":"Number field operations","title":"basis","text":"basis(L::SimpleNumField) -> Vector{NumFieldElem}\n\nReturn the canonical basis of a simple extension LK, that is, the elements 1adotsca^d - 1, where d is the degree of K and a the primitive element.\n\nExamples\n\njulia> Qx, x = QQ[\"x\"];\n\njulia> K, a = number_field(x^2 - 2, \"a\");\n\njulia> basis(K)\n2-element Vector{AbsSimpleNumFieldElem}:\n 1\n a\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/number_fields/fields/#basis-Tuple{NonSimpleNumField}","page":"Number field operations","title":"basis","text":"basis(L::NonSimpleNumField) -> Vector{NumFieldElem}\n\nReturns the canonical basis of a non-simple extension LK. If L = K(a_1dotsca_n) where each a_i has degree d_i, then the basis will be a_1^i_1dotsm a_d^i_d with 0 leq i_j leq d_j - 1 for 1 leq j leq n.\n\nExamples\n\njulia> Qx, x = QQ[\"x\"];\n\njulia> K, (a1, a2) = number_field([x^2 - 2, x^2 - 3], \"a\");\n\njulia> basis(K)\n4-element Vector{AbsNonSimpleNumFieldElem}:\n 1\n a1\n a2\n a1*a2\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/number_fields/fields/#absolute_basis-Tuple{NumField}","page":"Number field operations","title":"absolute_basis","text":"absolute_basis(K::NumField) -> Vector{NumFieldElem}\n\nReturns an array of elements that form a basis of K (as a vector space) over the rationals.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/number_fields/fields/#defining_polynomial-Tuple{SimpleNumField}","page":"Number field operations","title":"defining_polynomial","text":"defining_polynomial(L::SimpleNumField) -> PolyRingElem\n\nGiven a simple number field LK, constructed as L = Kx(f), this function returns f.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/number_fields/fields/#defining_polynomials-Tuple{NonSimpleNumField}","page":"Number field operations","title":"defining_polynomials","text":"defining_polynomials(L::NonSimpleNumField) -> Vector{PolyRingElem}\n\nGiven a non-simple number field LK, constructed as L = Kx(f_1dotscf_r), return the vector containing the f_i's.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/number_fields/fields/#absolute_primitive_element-Tuple{NumField}","page":"Number field operations","title":"absolute_primitive_element","text":"absolute_primitive_element(K::NumField) -> NumFieldElem\n\nGiven a number field K, this function returns an element gamma in K such that K = mathbfQ(gamma).\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/number_fields/fields/#component-Tuple{NonSimpleNumField, Int64}","page":"Number field operations","title":"component","text":"component(L::NonSimpleNumField, i::Int) -> SimpleNumField, Map\n\nGiven a non-simple extension LK, this function returns the simple number field corresponding to the i-th component of L together with its embedding.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/number_fields/fields/#base_field-Tuple{NumField}","page":"Number field operations","title":"base_field","text":"base_field(L::NumField) -> NumField\n\nGiven a number field LK this function returns the base field K. For absolute extensions this returns mathbfQ.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/number_fields/fields/#Invariants","page":"Number field operations","title":"Invariants","text":"","category":"section"},{"location":"Hecke/manual/number_fields/fields/","page":"Number field operations","title":"Number field operations","text":"degree(::NumField)\nabsolute_degree(::NumField)\nsignature(::NumField)\nunit_group_rank(::NumField)\nclass_number(::AbsSimpleNumField)\nrelative_class_number(::AbsSimpleNumField)\nregulator(::AbsSimpleNumField)\ndiscriminant(::SimpleNumField)\nabsolute_discriminant(::SimpleNumField)","category":"page"},{"location":"Hecke/manual/number_fields/fields/#degree-Tuple{NumField}","page":"Number field operations","title":"degree","text":"degree(L::NumField) -> Int\n\nGiven a number field LK, this function returns the degree of L over K.\n\nExamples\n\njulia> Qx, x = QQ[\"x\"];\n\njulia> K, a = number_field(x^2 - 2, \"a\");\n\njulia> degree(K)\n2\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/number_fields/fields/#absolute_degree-Tuple{NumField}","page":"Number field operations","title":"absolute_degree","text":"absolute_degree(L::NumField) -> Int\n\nGiven a number field LK, this function returns the degree of L over mathbf Q.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/number_fields/fields/#signature-Tuple{NumField}","page":"Number field operations","title":"signature","text":"signature(K::NumField)\n\nReturn the signature of the number field of K.\n\nExamples\n\njulia> Qx, x = QQ[\"x\"];\n\njulia> K, a = number_field(x^2 - 2, \"a\");\n\njulia> signature(K)\n(2, 0)\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/number_fields/fields/#unit_group_rank-Tuple{NumField}","page":"Number field operations","title":"unit_group_rank","text":"unit_group_rank(K::NumField) -> Int\n\nReturn the rank of the unit group of any order of K.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/number_fields/fields/#class_number-Tuple{AbsSimpleNumField}","page":"Number field operations","title":"class_number","text":"class_number(K::AbsSimpleNumField) -> ZZRingElem\n\nReturns the class number of K.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/number_fields/fields/#relative_class_number-Tuple{AbsSimpleNumField}","page":"Number field operations","title":"relative_class_number","text":"relative_class_number(K::AbsSimpleNumField) -> ZZRingElem\n\nReturns the relative class number of K. The field must be a CM-field.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/number_fields/fields/#regulator-Tuple{AbsSimpleNumField}","page":"Number field operations","title":"regulator","text":"regulator(K::AbsSimpleNumField)\n\nComputes the regulator of K, i.e. the discriminant of the unit lattice for the maximal order of K.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/number_fields/fields/#discriminant-Tuple{SimpleNumField}","page":"Number field operations","title":"discriminant","text":"discriminant(L::SimpleNumField) -> NumFieldElem\n\nThe discriminant of the defining polynomial of L, not the discriminant of the maximal order of L.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/number_fields/fields/#absolute_discriminant-Tuple{SimpleNumField}","page":"Number field operations","title":"absolute_discriminant","text":"absolute_discriminant(L::SimpleNumField, QQ) -> QQFieldElem\n\nThe absolute discriminant of the defining polynomial of L, not the discriminant of the maximal order of L. This is the norm of the discriminant times the d-th power of the discriminant of the base field, where d is the degree of L.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/number_fields/fields/#Predicates","page":"Number field operations","title":"Predicates","text":"","category":"section"},{"location":"Hecke/manual/number_fields/fields/","page":"Number field operations","title":"Number field operations","text":"is_simple(::NumField)\nis_absolute(::NumField)\nis_totally_real(::NumField)\nis_totally_complex(::NumField)\nis_cm_field(::NumField)\nis_kummer_extension(::SimpleNumField)\nis_radical_extension(::SimpleNumField)\nis_linearly_disjoint(::SimpleNumField, ::SimpleNumField)\nis_weakly_ramified(::AbsSimpleNumField, ::AbsNumFieldOrderIdeal{AbsSimpleNumField, AbsSimpleNumFieldElem})\nis_tamely_ramified(::AbsSimpleNumField)\nis_tamely_ramified(::AbsSimpleNumField, p::Int)\nis_abelian(::NumField)","category":"page"},{"location":"Hecke/manual/number_fields/fields/#is_simple-Tuple{NumField}","page":"Number field operations","title":"is_simple","text":"is_simple(L::NumField) -> Bool\n\nGiven a number field LK this function returns whether L is simple, that is, whether LK is defined by a univariate polynomial.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/number_fields/fields/#is_absolute-Tuple{NumField}","page":"Number field operations","title":"is_absolute","text":"is_absolute(L::NumField) -> Bool\n\nReturns whether L is an absolute extension, that is, whether the base field of L is mathbfQ.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/number_fields/fields/#is_totally_real-Tuple{NumField}","page":"Number field operations","title":"is_totally_real","text":"is_totally_real(K::NumField) -> Bool\n\nReturn true if and only if K is totally real, that is, if all roots of the defining polynomial are real.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/number_fields/fields/#is_totally_complex-Tuple{NumField}","page":"Number field operations","title":"is_totally_complex","text":"is_totally_complex(K::NumField) -> Bool\n\nReturn true if and only if K is totally complex, that is, if all roots of the defining polynomial are not real.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/number_fields/fields/#is_cm_field-Tuple{NumField}","page":"Number field operations","title":"is_cm_field","text":"is_cm_field(K::AbsSimpleNumField) -> Bool, NumFieldHom{AbsSimpleNumField, AbsSimpleNumField}\n\nGiven a number field K, this function returns true and the complex conjugation if the field is CM, false and the identity otherwise.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/number_fields/fields/#is_kummer_extension-Tuple{SimpleNumField}","page":"Number field operations","title":"is_kummer_extension","text":"is_kummer_extension(L::SimpleNumField) -> Bool\n\nTests if LK is a Kummer extension, that is, if the defining polynomial is of the form x^n - b for some b in K and if K contains the n-th roots of unity.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/number_fields/fields/#is_radical_extension-Tuple{SimpleNumField}","page":"Number field operations","title":"is_radical_extension","text":"is_radical_extension(L::SimpleNumField) -> Bool\n\nTests if LK is pure, that is, if the defining polynomial is of the form x^n - b for some b in K.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/number_fields/fields/#is_linearly_disjoint-Tuple{SimpleNumField, SimpleNumField}","page":"Number field operations","title":"is_linearly_disjoint","text":"is_linearly_disjoint(K::SimpleNumField, L::SimpleNumField) -> Bool\n\nGiven two number fields K and L with the same base field k, this function returns whether K and L are linear disjoint over k.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/number_fields/fields/#is_weakly_ramified-Tuple{AbsSimpleNumField, AbsSimpleNumFieldOrderIdeal}","page":"Number field operations","title":"is_weakly_ramified","text":"is_weakly_ramified(K::AbsSimpleNumField, P::AbsNumFieldOrderIdeal{AbsSimpleNumField, AbsSimpleNumFieldElem}) -> Bool\n\nGiven a prime ideal P of a number field K, return whether P is weakly ramified, that is, whether the second ramification group is trivial.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/number_fields/fields/#is_tamely_ramified-Tuple{AbsSimpleNumField}","page":"Number field operations","title":"is_tamely_ramified","text":"is_tamely_ramified(K::AbsSimpleNumField) -> Bool\n\nReturns whether the number field K is tamely ramified.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/number_fields/fields/#is_tamely_ramified-Tuple{AbsSimpleNumField, Int64}","page":"Number field operations","title":"is_tamely_ramified","text":"is_tamely_ramified(O::AbsSimpleNumFieldOrder, p::Union{Int, ZZRingElem}) -> Bool\n\nReturns whether the integer p is tamely ramified in mathcal O. It is assumed that p is prime.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/number_fields/fields/#is_abelian-Tuple{NumField}","page":"Number field operations","title":"is_abelian","text":"is_abelian(L::NumField) -> Bool\n\nCheck if the number field LK is abelian over K.  The function is probabilistic and assumes GRH.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/number_fields/fields/#Subfields","page":"Number field operations","title":"Subfields","text":"","category":"section"},{"location":"Hecke/manual/number_fields/fields/","page":"Number field operations","title":"Number field operations","text":"is_subfield(::SimpleNumField, ::SimpleNumField)\nsubfields(::SimpleNumField)\nprincipal_subfields(::SimpleNumField)\ncompositum(::AbsSimpleNumField, ::AbsSimpleNumField)\nembedding(::NumField, ::NumField)\nnormal_closure(::AbsSimpleNumField)\nrelative_simple_extension(::NumField, ::NumField)\nis_subfield_normal(::AbsSimpleNumField, ::AbsSimpleNumField)","category":"page"},{"location":"Hecke/manual/number_fields/fields/#is_subfield-Tuple{SimpleNumField, SimpleNumField}","page":"Number field operations","title":"is_subfield","text":"is_subfield(K::SimpleNumField, L::SimpleNumField) -> Bool, Map\n\nReturn true and an injection from K to L if K is a subfield of L. Otherwise the function returns false and a morphism mapping everything to 0.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/number_fields/fields/#subfields-Tuple{SimpleNumField}","page":"Number field operations","title":"subfields","text":"subfields(L::SimpleNumField) -> Vector{Tuple{NumField, Map}}\n\nGiven a simple extension LK, returns all subfields of L containing K as tuples (k iota) consisting of a simple extension k and an embedding iota k to K.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/number_fields/fields/#principal_subfields-Tuple{SimpleNumField}","page":"Number field operations","title":"principal_subfields","text":"principal_subfields(L::SimpleNumField) -> Vector{Tuple{NumField, Map}}\n\nReturn the principal subfields of L as pairs consisting of a subfield k and an embedding k to L.\n\nExamples\n\njulia> Qx, x = QQ[\"x\"];\n\njulia> K, a = number_field(x^8 - x^4 + 1);\n\njulia> length(principal_subfields(K))\n8\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/number_fields/fields/#compositum-Tuple{AbsSimpleNumField, AbsSimpleNumField}","page":"Number field operations","title":"compositum","text":"compositum(K::AbsSimpleNumField, L::AbsSimpleNumField) -> AbsSimpleNumField, Map, Map\n\nAssuming L is normal (which is not checked), compute the compositum C of the 2 fields together with the embedding of K to C and L to C.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/number_fields/fields/#embedding-Tuple{NumField, NumField}","page":"Number field operations","title":"embedding","text":"embedding(k::NumField, K::NumField) -> Map\n\nAssuming k is known to be a subfield of K, return the embedding map.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/number_fields/fields/#normal_closure-Tuple{AbsSimpleNumField}","page":"Number field operations","title":"normal_closure","text":"normal_closure(K::AbsSimpleNumField) -> AbsSimpleNumField, NumFieldHom{AbsSimpleNumField, AbsSimpleNumField}\n\nThe normal closure of K together with the embedding map.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/number_fields/fields/#relative_simple_extension-Tuple{NumField, NumField}","page":"Number field operations","title":"relative_simple_extension","text":"relative_simple_extension(K::NumField, k::NumField) -> RelSimpleNumField\n\nGiven two fields Ksupset k, it returns K as a simple relative extension L of k and an isomorphism L to K.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/number_fields/fields/#is_subfield_normal-Tuple{AbsSimpleNumField, AbsSimpleNumField}","page":"Number field operations","title":"is_subfield_normal","text":"  is_subfield_normal(K::AbsSimpleNumField, L::AbsSimpleNumField) -> Bool, NumFieldHom{AbsSimpleNumField, AbsSimpleNumField}\n\nReturns true and an injection from K to L if K is a subfield of L. Otherwise the function returns false and a morphism mapping everything to 0.\n\nThis function assumes that K is normal.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/number_fields/fields/#Conversion","page":"Number field operations","title":"Conversion","text":"","category":"section"},{"location":"Hecke/manual/number_fields/fields/","page":"Number field operations","title":"Number field operations","text":"simplify(::AbsSimpleNumField)\nabsolute_simple_field(K::NumField)\nsimple_extension(::NonSimpleNumField)\nsimplified_simple_extension(::NonSimpleNumField)","category":"page"},{"location":"Hecke/manual/number_fields/fields/#simplify-Tuple{AbsSimpleNumField}","page":"Number field operations","title":"simplify","text":"simplify(K::AbsSimpleNumField; canonical::Bool = false) -> AbsSimpleNumField, NumFieldHom{AbsSimpleNumField, AbsSimpleNumField}\n\nTries to find an isomorphic field L given by a \"simpler\" defining polynomial. By default, \"simple\" is defined to be of smaller index, testing is done only using a LLL-basis of the maximal order.\n\nIf canonical is set to true, then a canonical defining polynomial is found, where canonical is using the definition of PARI's polredabs, which is described in http://beta.lmfdb.org/knowledge/show/nf.polredabs.\n\nBoth versions require a LLL reduced basis for the maximal order.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/number_fields/fields/#absolute_simple_field-Tuple{NumField}","page":"Number field operations","title":"absolute_simple_field","text":"absolute_simple_field(K::NumField) -> NumField, Map\n\nGiven a number field K, this function returns an absolute simple number field MmathbfQ together with a mathbfQ-linear isomorphism M to K.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/number_fields/fields/#simple_extension-Tuple{NonSimpleNumField}","page":"Number field operations","title":"simple_extension","text":"simple_extension(L::NonSimpleNumField) -> SimpleNumField, Map\n\nGiven a non-simple extension LK, this function computes a simple extension MK and a K-linear isomorphism M to L.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/number_fields/fields/#simplified_simple_extension-Tuple{NonSimpleNumField}","page":"Number field operations","title":"simplified_simple_extension","text":"simplified_simple_extension(L::NonSimpleNumField) -> SimpleNumField, Map\n\nGiven a non-simple extension LK, this function returns an isomorphic simple number field with a \"small\" defining equation together with the isomorphism.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/number_fields/fields/#Morphisms","page":"Number field operations","title":"Morphisms","text":"","category":"section"},{"location":"Hecke/manual/number_fields/fields/","page":"Number field operations","title":"Number field operations","text":"is_isomorphic(::SimpleNumField, ::SimpleNumField)\nis_isomorphic_with_map(::SimpleNumField, ::SimpleNumField)\nis_involution(::NumFieldHom{AbsSimpleNumField, AbsSimpleNumField})\nfixed_field(::NumFieldHom)\nautomorphism_list(::NumField)\nautomorphism_group(::AbsSimpleNumField)\ncomplex_conjugation(::AbsSimpleNumField)","category":"page"},{"location":"Hecke/manual/number_fields/fields/#is_isomorphic-Tuple{SimpleNumField, SimpleNumField}","page":"Number field operations","title":"is_isomorphic","text":"is_isomorphic(K::SimpleNumField, L::SimpleNumField) -> Bool\n\nReturn true if K and L are isomorphic, otherwise false.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/number_fields/fields/#is_isomorphic_with_map-Tuple{SimpleNumField, SimpleNumField}","page":"Number field operations","title":"is_isomorphic_with_map","text":"is_isomorphic_with_map(K::SimpleNumField, L::SimpleNumField) -> Bool, Map\n\nReturn true and an isomorphism from K to L if K and L are isomorphic. Otherwise the function returns false and a morphism mapping everything to 0.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/number_fields/fields/#is_involution-Tuple{NumFieldHom{AbsSimpleNumField, AbsSimpleNumField}}","page":"Number field operations","title":"is_involution","text":"is_involution(f::NumFieldHom{AbsSimpleNumField, AbsSimpleNumField}) -> Bool\n\nReturns true if f is an involution, i.e. if f^2 is the identity, false otherwise.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/number_fields/fields/#fixed_field-Tuple{NumFieldHom}","page":"Number field operations","title":"fixed_field","text":"fixed_field(K::SimpleNumField,\n            sigma::Map;\n            simplify::Bool = true) -> number_field, NumFieldHom{AbsSimpleNumField, AbsSimpleNumField}\n\nGiven a number field K and an automorphism sigma of K, this function returns the fixed field of sigma as a pair (L i) consisting of a number field L and an embedding of L into K.\n\nBy default, the function tries to find a small defining polynomial of L. This can be disabled by setting simplify = false.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/number_fields/fields/#automorphism_list-Tuple{NumField}","page":"Number field operations","title":"automorphism_list","text":"automorphism_list(L::NumField) -> Vector{NumFieldHom}\n\nGiven a number field LK, return a list of all K-automorphisms of L.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/number_fields/fields/#automorphism_group-Tuple{AbsSimpleNumField}","page":"Number field operations","title":"automorphism_group","text":"automorphism_group(K::NumField) -> GenGrp, GrpGenToNfMorSet\n\nGiven a number field K, this function returns a group G and a map from G to the automorphisms of K.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/number_fields/fields/#complex_conjugation-Tuple{AbsSimpleNumField}","page":"Number field operations","title":"complex_conjugation","text":"complex_conjugation(K::AbsSimpleNumField)\n\nGiven a normal number field, this function returns an automorphism which is the restriction of complex conjugation at one embedding.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/number_fields/fields/#Galois-theory","page":"Number field operations","title":"Galois theory","text":"","category":"section"},{"location":"Hecke/manual/number_fields/fields/","page":"Number field operations","title":"Number field operations","text":"normal_basis(::NumField)\ndecomposition_group(::AbsSimpleNumField, ::AbsNumFieldOrderIdeal{AbsSimpleNumField, AbsSimpleNumFieldElem}, ::Map)\nramification_group(::AbsSimpleNumField, ::AbsNumFieldOrderIdeal{AbsSimpleNumField, AbsSimpleNumFieldElem}, ::Int, ::Map)\ninertia_subgroup(::AbsSimpleNumField, ::AbsNumFieldOrderIdeal{AbsSimpleNumField, AbsSimpleNumFieldElem}, ::Map)","category":"page"},{"location":"Hecke/manual/number_fields/fields/#normal_basis-Tuple{NumField}","page":"Number field operations","title":"normal_basis","text":"normal_basis(L::NumField) -> NumFieldElem\n\nGiven a normal number field LK, this function returns an element a of L, such that the orbit of a under the Galois group of LK is an K-basis of L.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/number_fields/fields/#decomposition_group-Tuple{AbsSimpleNumField, AbsSimpleNumFieldOrderIdeal, Map}","page":"Number field operations","title":"decomposition_group","text":"decomposition_group(K::AbsSimpleNumField, P::AbsNumFieldOrderIdeal{AbsSimpleNumField, AbsSimpleNumFieldElem}, m::Map)\n                                              -> Grp, GrpToGrp\n\nGiven a prime ideal P of a number field K and a map m return from automorphism_group(K), return the decomposition group of P as a subgroup of the domain of m.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/number_fields/fields/#ramification_group-Tuple{AbsSimpleNumField, AbsSimpleNumFieldOrderIdeal, Int64, Map}","page":"Number field operations","title":"ramification_group","text":"ramification_group(K::AbsSimpleNumField, P::AbsNumFieldOrderIdeal{AbsSimpleNumField, AbsSimpleNumFieldElem}, m::Map) -> Grp, GrpToGrp\n\nGiven a prime ideal P of a number field K and a map m return from automorphism_group(K), return the ramification group of P as a subgroup of the domain of m.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/number_fields/fields/#inertia_subgroup-Tuple{AbsSimpleNumField, AbsSimpleNumFieldOrderIdeal, Map}","page":"Number field operations","title":"inertia_subgroup","text":"inertia_subgroup(K::AbsSimpleNumField, P::AbsNumFieldOrderIdeal{AbsSimpleNumField, AbsSimpleNumFieldElem}, m::Map) -> Grp, GrpToGrp\n\nGiven a prime ideal P of a number field K and a map m return from automorphism_group(K), return the inertia subgroup of P as a subgroup of the domain of m.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/number_fields/fields/#Infinite-places","page":"Number field operations","title":"Infinite places","text":"","category":"section"},{"location":"Hecke/manual/number_fields/fields/","page":"Number field operations","title":"Number field operations","text":"infinite_places(K::NumField)\nreal_places(K::AbsSimpleNumField)\ncomplex_places(K::AbsSimpleNumField)\nisreal(::Plc)\nis_complex(::Plc)","category":"page"},{"location":"Hecke/manual/number_fields/fields/#infinite_places-Tuple{NumField}","page":"Number field operations","title":"infinite_places","text":"infinite_places(K::NumField) -> Vector{InfPlc}\n\nReturn all infinite places of the number field.\n\nExamples\n\njulia> K,  = quadratic_field(5);\n\njulia> infinite_places(K)\n2-element Vector{InfPlc{AbsSimpleNumField, AbsSimpleNumFieldEmbedding}}:\n Infinite place corresponding to (Complex embedding corresponding to -2.24 of real quadratic field)\n Infinite place corresponding to (Complex embedding corresponding to 2.24 of real quadratic field)\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/number_fields/fields/#real_places-Tuple{AbsSimpleNumField}","page":"Number field operations","title":"real_places","text":"real_places(K::NumField) -> Vector{InfPlc}\n\nReturn all infinite real places of the number field.\n\nExamples\n\njulia> K,  = quadratic_field(5);\n\njulia> infinite_places(K)\n2-element Vector{InfPlc{AbsSimpleNumField, AbsSimpleNumFieldEmbedding}}:\n Infinite place corresponding to (Complex embedding corresponding to -2.24 of real quadratic field)\n Infinite place corresponding to (Complex embedding corresponding to 2.24 of real quadratic field)\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/number_fields/fields/#complex_places-Tuple{AbsSimpleNumField}","page":"Number field operations","title":"complex_places","text":"complex_places(K::NumField) -> Vector{InfPlc}\n\nReturn all infinite complex places of K.\n\nExamples\n\njulia> K,  = quadratic_field(-5);\n\njulia> complex_places(K)\n1-element Vector{InfPlc{AbsSimpleNumField, AbsSimpleNumFieldEmbedding}}:\n Infinite place corresponding to (Complex embedding corresponding to 0.00 + 2.24 * i of imaginary quadratic field)\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/number_fields/fields/#isreal-Tuple{Plc}","page":"Number field operations","title":"isreal","text":"isreal(P::Plc)\n\nReturn whether the embedding into mathbfC defined by P is real or not.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/number_fields/fields/#is_complex-Tuple{Plc}","page":"Number field operations","title":"is_complex","text":"is_complex(P::Plc) -> Bool\n\nReturn whether the embedding into mathbfC defined by P is complex or not.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/number_fields/fields/#Miscellaneous","page":"Number field operations","title":"Miscellaneous","text":"","category":"section"},{"location":"Hecke/manual/number_fields/fields/","page":"Number field operations","title":"Number field operations","text":"norm_equation(::AbsSimpleNumField, ::Any)\nlorenz_module(::AbsSimpleNumField, ::Int)\nkummer_failure(::AbsSimpleNumFieldElem, ::Int, ::Int)\nis_defining_polynomial_nice(::AbsSimpleNumField)","category":"page"},{"location":"Hecke/manual/number_fields/fields/#norm_equation-Tuple{AbsSimpleNumField, Any}","page":"Number field operations","title":"norm_equation","text":"norm_equation(K::AnticNumerField, a) -> AbsSimpleNumFieldElem\n\nFor a an integer or rational, try to find T in K s.th. N(T) = a. Raises an error if unsuccessful.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/number_fields/fields/#lorenz_module-Tuple{AbsSimpleNumField, Int64}","page":"Number field operations","title":"lorenz_module","text":"lorenz_module(k::AbsSimpleNumField, n::Int) -> AbsNumFieldOrderIdeal{AbsSimpleNumField, AbsSimpleNumFieldElem}\n\nFinds an ideal A s.th. for all positive units e = 1 bmod A we have that e is an n-th power. Uses Lorenz, number theory, 9.3.1. If containing is set, it has to be an integral ideal. The resulting ideal will be a multiple of this.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/number_fields/fields/#kummer_failure-Tuple{AbsSimpleNumFieldElem, Int64, Int64}","page":"Number field operations","title":"kummer_failure","text":"kummer_failure(x::AbsSimpleNumFieldElem, M::Int, N::Int) -> Int\n\nComputes the quotient of N and K(zeta_M sqrtN(x))colon K(zeta_M), where K is the field containing x and N divides M.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/number_fields/fields/#is_defining_polynomial_nice-Tuple{AbsSimpleNumField}","page":"Number field operations","title":"is_defining_polynomial_nice","text":"is_defining_polynomial_nice(K::AbsSimpleNumField)\n\nTests if the defining polynomial of K is integral and monic.\n\n\n\n\n\n","category":"method"},{"location":"AlgebraicGeometry/Schemes/RationalPointsProjective/","page":"Rational Points on Projective Schemes","title":"Rational Points on Projective Schemes","text":"CurrentModule = Oscar\nDocTestSetup = Oscar.doctestsetup()","category":"page"},{"location":"AlgebraicGeometry/Schemes/RationalPointsProjective/#Rational-Points-on-Projective-Schemes","page":"Rational Points on Projective Schemes","title":"Rational Points on Projective Schemes","text":"","category":"section"},{"location":"AlgebraicGeometry/Schemes/RationalPointsProjective/","page":"Rational Points on Projective Schemes","title":"Rational Points on Projective Schemes","text":"AbsProjectiveRationalPoint\nProjectiveRationalPoint\ncoordinates(P::ProjectiveRationalPoint)\nideal(P::AbsProjectiveRationalPoint)\nscheme(P::ProjectiveRationalPoint)\nnormalize!(a::AbsProjectiveRationalPoint{<:FieldElem})\nnormalize!(a::AbsProjectiveRationalPoint{ZZRingElem})","category":"page"},{"location":"AlgebraicGeometry/Schemes/RationalPointsProjective/#AbsProjectiveRationalPoint","page":"Rational Points on Projective Schemes","title":"AbsProjectiveRationalPoint","text":"AbsProjectiveRationalPoint\n\nA rational point P of a projective scheme X. We refer to X as the parent of P.\n\nLet k be a field. A rational point is an element of mathbbP^n(k) = k^n+1 setminus 0  k^* where two vectors vw in k^n+1 setminus 0 are identified if v = alpha w for a non-zero scalar alpha in k^*.\n\nLet X subseteq mathbbP^n_k be an algebraic set or more generally a closed subscheme defined by the homogeneous ideal I = (f_1 dots f_r). Then a rational point of X is p in mathbbP^n(k) such that f_1(p) = dots = f_n(p) = 0.\n\nThis type includes points in weighted projective space.\n\n\n\n\n\n","category":"type"},{"location":"AlgebraicGeometry/Schemes/RationalPointsProjective/#ProjectiveRationalPoint","page":"Rational Points on Projective Schemes","title":"ProjectiveRationalPoint","text":"ProjectiveRationalPoint{CoeffType<:RingElem, ParentType<:AbsProjectiveScheme}\n\nType for rational points in projective varieties.\n\nExamples\n\njulia> P2 = projective_space(QQ, 2);\n\njulia> P2([4, 0 , 2//3])\nProjective rational point\n  of Projective 2-space over QQ with coordinates [s0, s1, s2]\nwith coordinates (4 : 0 : 2//3)\n\n\n\n\n\n\n","category":"type"},{"location":"AlgebraicGeometry/Schemes/RationalPointsProjective/#coordinates-Tuple{Oscar.ProjectiveRationalPoint}","page":"Rational Points on Projective Schemes","title":"coordinates","text":"coordinates(p::AbsProjectiveRationalPoint{S,T}) -> Vector{S}\n\nReturn the homogeneous coordinates of the rational point p.\n\n\n\n\n\n","category":"method"},{"location":"AlgebraicGeometry/Schemes/RationalPointsProjective/#ideal-Tuple{Oscar.AbsProjectiveRationalPoint}","page":"Rational Points on Projective Schemes","title":"ideal","text":"ideal(P::AbsProjectiveRationalPoint)\n\nReturn the homogeneous ideal associated to P in the homogeneous coordinate ring of its ambient space.\n\n\n\n\n\n","category":"method"},{"location":"AlgebraicGeometry/Schemes/RationalPointsProjective/#scheme-Tuple{Oscar.ProjectiveRationalPoint}","page":"Rational Points on Projective Schemes","title":"scheme","text":"scheme(P::AbsProjectiveRationalPoint) -> AbsProjectiveScheme\n\nReturn the rational point P viewed as a reduced, projective subscheme of its ambient projective space.\n\n\n\n\n\n","category":"method"},{"location":"AlgebraicGeometry/Schemes/RationalPointsProjective/#normalize!-Tuple{Oscar.AbsProjectiveRationalPoint{<:FieldElem}}","page":"Rational Points on Projective Schemes","title":"normalize!","text":"normalize!(a::AbsProjectiveRationalPoint{<:FieldElem})\n\nNormalize a such that its first non-zero coordinate is one.\n\n\n\n\n\n","category":"method"},{"location":"AlgebraicGeometry/Schemes/RationalPointsProjective/#normalize!-Tuple{Oscar.AbsProjectiveRationalPoint{ZZRingElem}}","page":"Rational Points on Projective Schemes","title":"normalize!","text":"normalize!(a::AbsProjectiveRationalPoint{ZZRingElem})\n\nNormalize a such that its first non-zero coordinate is positive.\n\n\n\n\n\n","category":"method"},{"location":"Combinatorics/phylogenetic_trees/","page":"Phylogenetic Trees","title":"Phylogenetic Trees","text":"CurrentModule = Oscar","category":"page"},{"location":"Combinatorics/phylogenetic_trees/#Phylogenetic-Trees","page":"Phylogenetic Trees","title":"Phylogenetic Trees","text":"","category":"section"},{"location":"Combinatorics/phylogenetic_trees/#Introduction","page":"Phylogenetic Trees","title":"Introduction","text":"","category":"section"},{"location":"Combinatorics/phylogenetic_trees/","page":"Phylogenetic Trees","title":"Phylogenetic Trees","text":"Phylogenetic trees represent the evolutionary history of some species of consideration. Here we consider phylogenetic trees with branch lengths as defined in [SS03].","category":"page"},{"location":"Combinatorics/phylogenetic_trees/#Construction","page":"Phylogenetic Trees","title":"Construction","text":"","category":"section"},{"location":"Combinatorics/phylogenetic_trees/","page":"Phylogenetic Trees","title":"Phylogenetic Trees","text":"phylogenetic_tree","category":"page"},{"location":"Combinatorics/phylogenetic_trees/#phylogenetic_tree","page":"Phylogenetic Trees","title":"phylogenetic_tree","text":"phylogenetic_tree(T::Type{<:Union{Float64, QQFieldElem}}, newick::String)\n\nConstructs a rooted phylogenetic tree with Newick representation newick. T indicates the numerical type of the edge lengths.\n\nExamples\n\nMake a phylogenetic tree with 4 leaves from its Newick representation and print its taxa and cophenetic matrix.\n\njulia> phylo_t = phylogenetic_tree(Float64, \"((H:3,(C:1,B:1):2):1,G:4);\");\n\njulia> taxa(phylo_t)\n4-element Vector{String}:\n \"B\"\n \"C\"\n \"G\"\n \"H\"\n\njulia> cophenetic_matrix(phylo_t)\n4×4 Matrix{Float64}:\n 0.0  2.0  8.0  6.0\n 2.0  0.0  8.0  6.0\n 8.0  8.0  0.0  8.0\n 6.0  6.0  8.0  0.0\n\n\n\n\n\nphylogenetic_tree(M::Matrix{T}, taxa::Vector{String}) where T <: Union{Float64, QQFieldElem}\n\nConstructs a phylogenetic tree with cophenetic matrix M and taxa taxa. The matrix M must be ultrametric, otherwise an error will be thrown.\n\nExamples\n\nMake a phylogenetic tree on 4 taxa with given cophenetic matrix and print one Newick representation.\n\njulia> mat = [0. 2 8 6; 2 0 8 6; 8 8 0 8; 6 6 8 0]\n4×4 Matrix{Float64}:\n 0.0  2.0  8.0  6.0\n 2.0  0.0  8.0  6.0\n 8.0  8.0  0.0  8.0\n 6.0  6.0  8.0  0.0\n\njulia> tax = [\"Bonobo\", \"Chimpanzee\", \"Gorilla\", \"Human\"]\n4-element Vector{String}:\n \"Bonobo\"\n \"Chimpanzee\"\n \"Gorilla\"\n \"Human\"\n\njulia> tree_mat = phylogenetic_tree(mat, tax);\n\njulia> newick(tree_mat)\n\"Gorilla:4,(Human:3,(Bonobo:1,Chimpanzee:1):2):1;\"\n\n\n\n\n\n","category":"function"},{"location":"Combinatorics/phylogenetic_trees/#Some-Helpful-Functions","page":"Phylogenetic Trees","title":"Some Helpful Functions","text":"","category":"section"},{"location":"Combinatorics/phylogenetic_trees/","page":"Phylogenetic Trees","title":"Phylogenetic Trees","text":"adjacency_tree\nis_equidistant\ncophenetic_matrix\ntaxa\nnewick\ntropical_median_consensus","category":"page"},{"location":"Combinatorics/phylogenetic_trees/#adjacency_tree","page":"Phylogenetic Trees","title":"adjacency_tree","text":"adjacency_tree(ptree::PhylogeneticTree)\n\nReturns the underlying graph of the phylogenetic tree ptree.\n\nExamples\n\nMake a phylogenetic tree with given Newick format and print its underlying graph.\n\njulia> ptree = phylogenetic_tree(Float64, \"((H:3,(C:1,B:1):2):1,G:4);\");\n\njulia> adjacency_tree(ptree)\nDirected graph with 7 nodes and the following edges:\n(1, 2)(1, 7)(2, 3)(2, 4)(4, 5)(4, 6)\n\n\n\n\n\n","category":"function"},{"location":"Combinatorics/phylogenetic_trees/#is_equidistant","page":"Phylogenetic Trees","title":"is_equidistant","text":"is_equidistant(ptree::PhylogeneticTree)\n\nChecks if the phylogenetic tree ptree is equidistant.\n\nExamples\n\nMake a phylogenetic tree with given Newick format and check if it is equidistant.\n\njulia> ptree = phylogenetic_tree(Float64, \"((H:3,(C:1,B:1):2):1,G:4);\");\n\njulia> is_equidistant(ptree)\ntrue\n\n\n\n\n\n","category":"function"},{"location":"Combinatorics/phylogenetic_trees/#cophenetic_matrix","page":"Phylogenetic Trees","title":"cophenetic_matrix","text":"cophenetic_matrix(ptree::PhylogeneticTree)\n\nReturns the cophenetic matrix of the phylogenetic tree ptree.\n\nExamples\n\nMake a phylogenetic tree with given Newick format and print its cophenetic matrix.\n\njulia> ptree = phylogenetic_tree(Float64, \"((H:3,(C:1,B:1):2):1,G:4);\");\n\njulia> cophenetic_matrix(ptree)\n4×4 Matrix{Float64}:\n 0.0  2.0  8.0  6.0\n 2.0  0.0  8.0  6.0\n 8.0  8.0  0.0  8.0\n 6.0  6.0  8.0  0.0\n\n\n\n\n\n","category":"function"},{"location":"Combinatorics/phylogenetic_trees/#taxa","page":"Phylogenetic Trees","title":"taxa","text":"taxa(ptree::PhylogeneticTree)\n\nReturns the taxa of the phylogenetic tree ptree.\n\nExamples\n\nMake a phylogenetic tree with given Newick format and print its taxa.\n\njulia> ptree = phylogenetic_tree(Float64, \"((H:3,(C:1,B:1):2):1,G:4);\");\n\njulia> taxa(ptree)\n4-element Vector{String}:\n \"B\"\n \"C\"\n \"G\"\n \"H\"\n\n\n\n\n\n","category":"function"},{"location":"Combinatorics/phylogenetic_trees/#newick","page":"Phylogenetic Trees","title":"newick","text":"newick(ptree::PhylogeneticTree)\n\nReturns a Newick representation of the phylogenetic tree ptree.\n\nExamples\n\nMake a phylogenetic tree from a matrix and print a Newick representation of it.\n\njulia> mat = [0. 2 8 6; 2 0 8 6; 8 8 0 8; 6 6 8 0]\n4×4 Matrix{Float64}:\n 0.0  2.0  8.0  6.0\n 2.0  0.0  8.0  6.0\n 8.0  8.0  0.0  8.0\n 6.0  6.0  8.0  0.0\n\njulia> tax = [\"Bonobo\", \"Chimpanzee\", \"Gorilla\", \"Human\"]\n4-element Vector{String}:\n \"Bonobo\"\n \"Chimpanzee\"\n \"Gorilla\"\n \"Human\"\n\njulia> tree_mat = phylogenetic_tree(mat, tax);\n\njulia> newick(tree_mat)\n\"Gorilla:4,(Human:3,(Bonobo:1,Chimpanzee:1):2):1;\"\n\n\n\n\n\n","category":"function"},{"location":"Combinatorics/phylogenetic_trees/#tropical_median_consensus","page":"Phylogenetic Trees","title":"tropical_median_consensus","text":"tropical_median_consensus(arr::Vector{PhylogeneticTree{T}})\n\nComputes the tropical median consensus tree of the phylogenetic trees from the vector arr.\n\nExamples\n\nCompute the tropical median consensus of three trees and print one of its Newick representations.\n\njulia> t1 = phylogenetic_tree(Float64, \"((H:30,(C:10,B:10):20):10,G:40);\");\n\njulia> t2 = phylogenetic_tree(Float64, \"(((H:10,C:10):20,B:30):10,G:40);\");\n\njulia> t3 = phylogenetic_tree(Float64, \"((H:25,C:25):15,(B:15,G:15):25);\");\n\njulia> arr = [t1, t2, t3];\n\njulia> tc = tropical_median_consensus(arr);\n\njulia> newick(tc)\n\"G:40,(B:35,(C:30,H:30):5):5;\"\n\n\n\n\n\ntropical_median_consensus(trees::Vararg{PhylogeneticTree, N}) where {N}\n\nComputes the tropical median consensus tree of any number of phylogenetic trees given as parameters.\n\nExamples\n\nCompute the tropical median consensus of three trees and print one of its Newick representations.\n\njulia> t1 = phylogenetic_tree(Float64, \"((H:30,(C:10,B:10):20):10,G:40);\");\n\njulia> t2 = phylogenetic_tree(Float64, \"(((H:10,C:10):20,B:30):10,G:40);\");\n\njulia> t3 = phylogenetic_tree(Float64, \"((H:25,C:25):15,(B:15,G:15):25);\");\n\njulia> tc = tropical_median_consensus(t1, t2, t3);\n\njulia> newick(tc)\n\"G:40,(B:35,(C:30,H:30):5):5;\"\n\n\n\n\n\n","category":"function"},{"location":"Groups/grouphom/","page":"Group homomorphisms","title":"Group homomorphisms","text":"CurrentModule = Oscar\nDocTestSetup = Oscar.doctestsetup()","category":"page"},{"location":"Groups/grouphom/#Group-homomorphisms","page":"Group homomorphisms","title":"Group homomorphisms","text":"","category":"section"},{"location":"Groups/grouphom/","page":"Group homomorphisms","title":"Group homomorphisms","text":"In OSCAR, a group homomorphism from G to H is an object of parametric type GAPGroupHomomorphism{S,T}, where S and T are the types of G and H respectively.","category":"page"},{"location":"Groups/grouphom/","page":"Group homomorphisms","title":"Group homomorphisms","text":"A homomorphism from G to H can be defined in two ways.","category":"page"},{"location":"Groups/grouphom/","page":"Group homomorphisms","title":"Group homomorphisms","text":"Writing explicitly the images of the generators of G:","category":"page"},{"location":"Groups/grouphom/","page":"Group homomorphisms","title":"Group homomorphisms","text":"f = hom(G,H,[x1,x2,...],[y1,y2,...])","category":"page"},{"location":"Groups/grouphom/","page":"Group homomorphisms","title":"Group homomorphisms","text":"Here, [x1,x2,...] must be a generating set for G (not necessarily minimal) and [y1,y2,...] is a vector of elements of H of the same length of [x1,x2,...]. This assigns to f the value of the group homomorphism sending x_i into y_i.","category":"page"},{"location":"Groups/grouphom/","page":"Group homomorphisms","title":"Group homomorphisms","text":"An exception is thrown if such a homomorphism does not exist.","category":"page"},{"location":"Groups/grouphom/","page":"Group homomorphisms","title":"Group homomorphisms","text":"Taking an existing function g satisfying the group homomorphism properties:","category":"page"},{"location":"Groups/grouphom/","page":"Group homomorphisms","title":"Group homomorphisms","text":"f = hom(G,H,g)","category":"page"},{"location":"Groups/grouphom/","page":"Group homomorphisms","title":"Group homomorphisms","text":"An exception is thrown if the function g does not define a group homomorphism.","category":"page"},{"location":"Groups/grouphom/","page":"Group homomorphisms","title":"Group homomorphisms","text":"Example: The following procedures define the same homomorphism (conjugation by x) in the two ways explained above.","category":"page"},{"location":"Groups/grouphom/","page":"Group homomorphisms","title":"Group homomorphisms","text":"julia> S=symmetric_group(4);\n\njulia> x=S[1];\n\njulia> f=hom(S,S,gens(S),[S[1]^x,S[2]^x]);\n\njulia> g=hom(S,S,y->y^x);\n\njulia> f==g\ntrue","category":"page"},{"location":"Groups/grouphom/","page":"Group homomorphisms","title":"Group homomorphisms","text":"hom(G::GAPGroup, H::GAPGroup, img::Function)\nhom(G::GAPGroup, H::GAPGroup, gensG::Vector, imgs::Vector)\nimage(f::GAPGroupHomomorphism, x::GAPGroupElem)\npreimage(f::GAPGroupHomomorphism, x::GAPGroupElem)\nrestrict_homomorphism(f::GAPGroupHomomorphism, H::GAPGroup)","category":"page"},{"location":"Groups/grouphom/#hom-Tuple{Oscar.GAPGroup, Oscar.GAPGroup, Function}","page":"Group homomorphisms","title":"hom","text":"hom(G::GAPGroup, H::GAPGroup, f::Function)\n\nReturn the group homomorphism defined by the function f.\n\n\n\n\n\n","category":"method"},{"location":"Groups/grouphom/#hom-Tuple{Oscar.GAPGroup, Oscar.GAPGroup, Vector, Vector}","page":"Group homomorphisms","title":"hom","text":"hom(G::GAPGroup, H::GAPGroup, gensG::Vector = gens(G), imgs::Vector; check::Bool = true)\n\nReturn the group homomorphism defined by gensG[i] -> imgs[i] for every i. In order to work, the elements of gensG must generate G.\n\nIf check is set to false then it is not checked whether the mapping defines a group homomorphism.\n\n\n\n\n\n","category":"method"},{"location":"Groups/grouphom/#image-Tuple{GAPGroupHomomorphism, GAPGroupElem}","page":"Group homomorphisms","title":"image","text":"image(f::GAPGroupHomomorphism, x::GAPGroupElem)\n(f::GAPGroupHomomorphism)(x::GAPGroupElem)\n\nReturn f(x).\n\n\n\n\n\n","category":"method"},{"location":"Groups/grouphom/#preimage-Tuple{GAPGroupHomomorphism, GAPGroupElem}","page":"Group homomorphisms","title":"preimage","text":"preimage(f::GAPGroupHomomorphism, x::GAPGroupElem)\n\nReturn an element y in the domain of f with the property f(y) == x. See has_preimage_with_preimage(f::GAPGroupHomomorphism, x::GAPGroupElem; check::Bool = true) for a check whether x has such a preimage.\n\n\n\n\n\n","category":"method"},{"location":"Groups/grouphom/#restrict_homomorphism-Tuple{GAPGroupHomomorphism, Oscar.GAPGroup}","page":"Group homomorphisms","title":"restrict_homomorphism","text":"restrict_homomorphism(f::GAPGroupHomomorphism, H::Group)\nrestrict_homomorphism(f::GAPGroupElem{AutomorphismGroup{T}}, H::T) where T <: Group\n\nReturn the restriction of f to H. An exception is thrown if H is not a subgroup of domain(f).\n\n\n\n\n\n","category":"method"},{"location":"Groups/grouphom/","page":"Group homomorphisms","title":"Group homomorphisms","text":"OSCAR has also the following standard homomorphism.","category":"page"},{"location":"Groups/grouphom/","page":"Group homomorphisms","title":"Group homomorphisms","text":"id_hom\ntrivial_morphism","category":"page"},{"location":"Groups/grouphom/#id_hom","page":"Group homomorphisms","title":"id_hom","text":"id_hom(T::TorQuadModule) -> TorQuadModuleMap\n\nAlias for identity_map.\n\n\n\n\n\nid_hom(G::GAPGroup)\n\nReturn the identity homomorphism on the group G.\n\n\n\n\n\n","category":"function"},{"location":"Groups/grouphom/#trivial_morphism","page":"Group homomorphisms","title":"trivial_morphism","text":"trivial_morphism(T::TorQuadModule, U::TorQuadModule) -> TorQuadModuleMap\n\nReturn the abelian group homomorphism between T and U sending every elements of T to the zero element of U.\n\n\n\n\n\ntrivial_morphism(T::TorQuadModule) -> TorQuadModuleMap\n\nReturn the abelian group endomorphism of T sending every elements of T to the zero element of T.\n\n\n\n\n\ntrivial_morphism(G::GAPGroup, H::GAPGroup = G)\n\nReturn the homomorphism from G to H sending every element of G into the identity of H.\n\n\n\n\n\n","category":"function"},{"location":"Groups/grouphom/","page":"Group homomorphisms","title":"Group homomorphisms","text":"To evaluate the homomorphism f in the element x of G, it is possible to use the instruction","category":"page"},{"location":"Groups/grouphom/","page":"Group homomorphisms","title":"Group homomorphisms","text":"image(f,x)","category":"page"},{"location":"Groups/grouphom/","page":"Group homomorphisms","title":"Group homomorphisms","text":"or the more compact notations f(x) and x^f.","category":"page"},{"location":"Groups/grouphom/","page":"Group homomorphisms","title":"Group homomorphisms","text":"Example:","category":"page"},{"location":"Groups/grouphom/","page":"Group homomorphisms","title":"Group homomorphisms","text":"julia> S=symmetric_group(4);\n\njulia> f=hom(S,S,x->x^S[1]);\n\njulia> x=cperm(S,[1,2]);\n\njulia> image(f,x)\n(2,3)\n\njulia> f(x)\n(2,3)\n\njulia> x^f\n(2,3)","category":"page"},{"location":"Groups/grouphom/","page":"Group homomorphisms","title":"Group homomorphisms","text":"A sort of \"inverse\" of the evaluation is the following","category":"page"},{"location":"Groups/grouphom/","page":"Group homomorphisms","title":"Group homomorphisms","text":"has_preimage_with_preimage(f::GAPGroupHomomorphism, x::GAPGroupElem; check::Bool = true)","category":"page"},{"location":"Groups/grouphom/#has_preimage_with_preimage-Tuple{GAPGroupHomomorphism, GAPGroupElem}","page":"Group homomorphisms","title":"has_preimage_with_preimage","text":"has_preimage_with_preimage(f::GAPGroupHomomorphism, x::GAPGroupElem; check::Bool = true)\n\nReturn (true, y) if there exists y in domain(f) such that f(y) = x holds; otherwise, return (false, o) where o is the identity of domain(f).\n\nIf check is set to false then the test whether x is an element of image(f) is omitted.\n\n\n\n\n\n","category":"method"},{"location":"Groups/grouphom/","page":"Group homomorphisms","title":"Group homomorphisms","text":"Example:","category":"page"},{"location":"Groups/grouphom/","page":"Group homomorphisms","title":"Group homomorphisms","text":"julia> S=symmetric_group(4);\n\njulia> f=hom(S,S,x->x^S[1]);\n\njulia> x=cperm(S,[1,2]);\n\njulia> has_preimage_with_preimage(f,x)\n(true, (1,4))","category":"page"},{"location":"Groups/grouphom/#Operations-on-homomorphisms","page":"Group homomorphisms","title":"Operations on homomorphisms","text":"","category":"section"},{"location":"Groups/grouphom/","page":"Group homomorphisms","title":"Group homomorphisms","text":"OSCAR supports the following operations on homomorphisms.","category":"page"},{"location":"Groups/grouphom/","page":"Group homomorphisms","title":"Group homomorphisms","text":"inv(f) = the inverse of f. An exception is thrown if f is not bijective.\nf^n = the homomorphism f composed n times with itself. An exception is thrown if the domain and the codomain of f do not coincide (unless n=1). If n is negative, the result is the inverse of f composed n times with itself.\ncompose(f, g) = composition of f and g. This works only if the codomain of f coincides with the domain of g. Shorter equivalent expressions are f*g and g(f).\nExample:","category":"page"},{"location":"Groups/grouphom/","page":"Group homomorphisms","title":"Group homomorphisms","text":"julia> S=symmetric_group(4);\n\njulia> f=hom(S,S,x->x^S[1]);\n\njulia> g=hom(S,S,x->x^S[2]);\n\njulia> f*g==hom(S,S,x->x^(S[1]*S[2]))\ntrue\n\njulia> f==f^-3\ntrue","category":"page"},{"location":"Groups/grouphom/","page":"Group homomorphisms","title":"Group homomorphisms","text":"note: Note\nThe composition operation * has to be read from the right to the left. So, (f*g)(x) is equivalent to g(f(x)).","category":"page"},{"location":"Groups/grouphom/#Properties-of-homomorphisms","page":"Group homomorphisms","title":"Properties of homomorphisms","text":"","category":"section"},{"location":"Groups/grouphom/","page":"Group homomorphisms","title":"Group homomorphisms","text":"OSCAR implements the following attributes of homomorphisms, in addition to the usual domain and codomain.","category":"page"},{"location":"Groups/grouphom/","page":"Group homomorphisms","title":"Group homomorphisms","text":"is_injective(f::GAPGroupHomomorphism)\nis_surjective(f::GAPGroupHomomorphism)\nis_bijective(f::GAPGroupHomomorphism)\nis_invertible(f::GAPGroupHomomorphism)\nis_invariant(f::GAPGroupHomomorphism, H::GAPGroup)","category":"page"},{"location":"Groups/grouphom/#is_injective-Tuple{GAPGroupHomomorphism}","page":"Group homomorphisms","title":"is_injective","text":"is_injective(f::GAPGroupHomomorphism)\n\nReturn whether f is injective.\n\n\n\n\n\n","category":"method"},{"location":"Groups/grouphom/#is_surjective-Tuple{GAPGroupHomomorphism}","page":"Group homomorphisms","title":"is_surjective","text":"is_surjective(f::GAPGroupHomomorphism)\n\nReturn whether f is surjective.\n\n\n\n\n\n","category":"method"},{"location":"Groups/grouphom/#is_bijective-Tuple{GAPGroupHomomorphism}","page":"Group homomorphisms","title":"is_bijective","text":"is_bijective(f::GAPGroupHomomorphism)\n\nReturn whether f is bijective.\n\n\n\n\n\n","category":"method"},{"location":"Groups/grouphom/#is_invertible-Tuple{GAPGroupHomomorphism}","page":"Group homomorphisms","title":"is_invertible","text":"is_invertible(f::GAPGroupHomomorphism)\n\nReturn whether f is invertible.\n\n\n\n\n\n","category":"method"},{"location":"Groups/grouphom/#is_invariant-Tuple{GAPGroupHomomorphism, Oscar.GAPGroup}","page":"Group homomorphisms","title":"is_invariant","text":"is_invariant(f::GAPGroupHomomorphism, H::GAPGroup)\n\nReturn whether f(H) == H holds. An exception is thrown if domain(f) and codomain(f) are not equal or if H is not contained in domain(f).\n\n\n\n\n\n","category":"method"},{"location":"Groups/grouphom/#Subgroups-described-by-homomorphisms","page":"Group homomorphisms","title":"Subgroups described by homomorphisms","text":"","category":"section"},{"location":"Groups/grouphom/","page":"Group homomorphisms","title":"Group homomorphisms","text":"The following functions compute subgroups or quotients of either the domain or the codomain. Analogously to the functions described in Sections Subgroups and Quotients, the output consists of a pair (H, g), where H is a subgroup (resp. quotient) and g is its embedding (resp. projection) homomorphism.","category":"page"},{"location":"Groups/grouphom/","page":"Group homomorphisms","title":"Group homomorphisms","text":"kernel(f::GAPGroupHomomorphism)\nimage(f::GAPGroupHomomorphism)\nimage(f::GAPGroupHomomorphism{S, T}, H::S) where S <: GAPGroup where T <: GAPGroup\ncokernel(f::GAPGroupHomomorphism)\npreimage(f::GAPGroupHomomorphism{S, T}, H::T) where S <: GAPGroup where T <: GAPGroup","category":"page"},{"location":"Groups/grouphom/#kernel-Tuple{GAPGroupHomomorphism}","page":"Group homomorphisms","title":"kernel","text":"kernel(f::GAPGroupHomomorphism)\n\nReturn the kernel of f, together with its embedding into domain(f).\n\n\n\n\n\n","category":"method"},{"location":"Groups/grouphom/#image-Tuple{GAPGroupHomomorphism}","page":"Group homomorphisms","title":"image","text":"image(f::GAPGroupHomomorphism)\n\nReturn the image of f as subgroup of codomain(f), together with the embedding homomorphism.\n\n\n\n\n\n","category":"method"},{"location":"Groups/grouphom/#image-Union{Tuple{S}, Tuple{T}, Tuple{GAPGroupHomomorphism{S, T}, S}} where {T<:Oscar.GAPGroup, S<:Oscar.GAPGroup}","page":"Group homomorphisms","title":"image","text":"image(f::GAPGroupHomomorphism{S, T}, H::S) where S <: GAPGroup where T <: GAPGroup\n(f::GAPGroupHomomorphism{S, T})(H::S)\n\nReturn f(H), together with the embedding homomorphism into codomain(f).\n\n\n\n\n\n","category":"method"},{"location":"Groups/grouphom/#cokernel-Tuple{GAPGroupHomomorphism}","page":"Group homomorphisms","title":"cokernel","text":"cokernel(f::GAPGroupHomomorphism)\n\nReturn the cokernel of f, that is, the quotient of the codomain of f by the normal closure of the image.\n\n\n\n\n\n","category":"method"},{"location":"Groups/grouphom/#preimage-Union{Tuple{S}, Tuple{T}, Tuple{GAPGroupHomomorphism{S, T}, T}} where {T<:Oscar.GAPGroup, S<:Oscar.GAPGroup}","page":"Group homomorphisms","title":"preimage","text":"preimage(f::GAPGroupHomomorphism{S, T}, H::GAPGroup) where S <: GAPGroup where T <: GAPGroup\n\nIf H is a subgroup of the codomain of f, return the subgroup f^-1(H), together with its embedding homomorphism into the domain of f.\n\n\n\n\n\n","category":"method"},{"location":"Groups/grouphom/#Group-isomorphisms","page":"Group homomorphisms","title":"Group isomorphisms","text":"","category":"section"},{"location":"Groups/grouphom/","page":"Group homomorphisms","title":"Group homomorphisms","text":"For all functions that return group isomorphisms, we have the following rule about the direction of the result.","category":"page"},{"location":"Groups/grouphom/","page":"Group homomorphisms","title":"Group homomorphisms","text":"If two groups are given as inputs then the domain of the returned isomorphism is the first given group and the codomain is the second.","category":"page"},{"location":"Groups/grouphom/","page":"Group homomorphisms","title":"Group homomorphisms","text":"If one group is given then the domain of the result is this group, and the codomain is some new group constructed by the function.","category":"page"},{"location":"Groups/grouphom/","page":"Group homomorphisms","title":"Group homomorphisms","text":"is_isomorphic(G::GAPGroup, H::GAPGroup)\nis_isomorphic_with_map(G::GAPGroup, H::GAPGroup)\nisomorphism(G::GAPGroup, H::GAPGroup)","category":"page"},{"location":"Groups/grouphom/#is_isomorphic-Tuple{Oscar.GAPGroup, Oscar.GAPGroup}","page":"Group homomorphisms","title":"is_isomorphic","text":"is_isomorphic(G::Group, H::Group)\n\nReturn true if G and H are isomorphic groups, and false otherwise.\n\nExamples\n\njulia> is_isomorphic(symmetric_group(3), dihedral_group(6))\ntrue\n\n\n\n\n\n","category":"method"},{"location":"Groups/grouphom/#is_isomorphic_with_map-Tuple{Oscar.GAPGroup, Oscar.GAPGroup}","page":"Group homomorphisms","title":"is_isomorphic_with_map","text":"is_isomorphic_with_map(G::Group, H::Group)\n\nReturn (true,f) if G and H are isomorphic groups, where f is a group isomorphism. Otherwise, return (false,f), where f is the trivial homomorphism.\n\nExamples\n\njulia> is_isomorphic_with_map(symmetric_group(3), dihedral_group(6))\n(true, Hom: Sym(3) -> pc group)\n\n\n\n\n\n","category":"method"},{"location":"Groups/grouphom/#isomorphism-Tuple{Oscar.GAPGroup, Oscar.GAPGroup}","page":"Group homomorphisms","title":"isomorphism","text":"isomorphism(G::Group, H::Group)\n\nReturn a group isomorphism between G and H if they are isomorphic groups. Otherwise throw an exception.\n\nExamples\n\njulia> isomorphism(symmetric_group(3), dihedral_group(6))\nGroup homomorphism\n  from Sym(3)\n  to pc group of order 6\n\n\n\n\n\n","category":"method"},{"location":"Groups/grouphom/","page":"Group homomorphisms","title":"Group homomorphisms","text":"isomorphism(::Type{T}, G::GAPGroup) where T <: Union{SubPcGroup, PermGroup}\nisomorphism(::Type{FinGenAbGroup}, G::GAPGroup)\nsimplified_fp_group(G::FPGroup)","category":"page"},{"location":"Groups/grouphom/#isomorphism-Union{Tuple{T}, Tuple{Type{T}, Oscar.GAPGroup}} where T<:Union{PermGroup, SubPcGroup}","page":"Group homomorphisms","title":"isomorphism","text":"isomorphism(::Type{T}, G::GAPGroup) where T <: Union{SubPcGroup, SubFPGroup, PermGroup}\nisomorphism(::Type{T}, G::GAPGroup; on_gens=false) where T <: Union{PcGroup, FPGroup}\n\nReturn an isomorphism from G to a group H of type T. An exception is thrown if no such isomorphism exists.\n\nIf on_gens is true then gens(G) is guaranteed to correspond to gens(H); an exception is thrown if this is not possible.\n\nIsomorphisms are cached in G, subsequent calls of isomorphism with the same T (and the same value of on_gens) yield identical results.\n\nIf only the image of such an isomorphism is needed, use T(G).\n\nExamples\n\njulia> G = dihedral_group(6)\nPc group of order 6\n\njulia> iso = isomorphism(PermGroup, G)\nGroup homomorphism\n  from pc group of order 6\n  to permutation group of degree 3 and order 6\n\njulia> permutation_group(G)\nPermutation group of degree 3 and order 6\n\njulia> codomain(iso) === ans\ntrue\n\n\n\n\n\n","category":"method"},{"location":"Groups/grouphom/#isomorphism-Tuple{Type{FinGenAbGroup}, Oscar.GAPGroup}","page":"Group homomorphisms","title":"isomorphism","text":"isomorphism(::Type{FinGenAbGroup}, G::GAPGroup)\n\nReturn a map from G to an isomorphic (additive) group of type FinGenAbGroup. An exception is thrown if G is not abelian or not finite.\n\n\n\n\n\n","category":"method"},{"location":"Groups/grouphom/#simplified_fp_group-Tuple{FPGroup}","page":"Group homomorphisms","title":"simplified_fp_group","text":"simplified_fp_group(G::FPGroup)\n\nReturn a group H of type FPGroup and an isomorphism f from G to H, where the presentation of H was obtained from the presentation of G by applying Tietze transformations in order to reduce it with respect to the number of generators, the number of relators, and the relator lengths.\n\nExamples\n\njulia> F = free_group(3)\nFree group of rank 3\n\njulia> G = quo(F, [gen(F,1)])[1]\nFinitely presented group of infinite order\n\njulia> simplified_fp_group(G)[1]\nFinitely presented group of infinite order\n\n\n\n\n\n","category":"method"},{"location":"Groups/grouphom/#Other-homomorphisms","page":"Group homomorphisms","title":"Other homomorphisms","text":"","category":"section"},{"location":"Groups/grouphom/","page":"Group homomorphisms","title":"Group homomorphisms","text":"epimorphism_from_free_group(G::GAPGroup)","category":"page"},{"location":"Groups/grouphom/#epimorphism_from_free_group-Tuple{Oscar.GAPGroup}","page":"Group homomorphisms","title":"epimorphism_from_free_group","text":"epimorphism_from_free_group(G::GAPGroup)\n\nReturn an epimorphism epi from a free group F == domain(epi) onto G, where F has the same number of generators as G and such that for each i it maps gen(F,i) to gen(G,i).\n\nA useful application of this function is expressing an element of G as a word in its generators.\n\nExamples\n\njulia> G = symmetric_group(4);\n\njulia> epi = epimorphism_from_free_group(G)\nGroup homomorphism\n  from free group of rank 2\n  to Sym(4)\n\njulia> pi = G([2,4,3,1])\n(1,2,4)\n\njulia> w = preimage(epi, pi);\n\njulia> map_word(w, gens(G))\n(1,2,4)\n\n\n\n\n\n","category":"method"},{"location":"DeveloperDocumentation/design_decisions/#Design-Decisions","page":"Design Decisions","title":"Design Decisions","text":"","category":"section"},{"location":"DeveloperDocumentation/design_decisions/","page":"Design Decisions","title":"Design Decisions","text":"This document covers the ideas and design decisions behind OSCAR, as well as some pitfalls to avoid.","category":"page"},{"location":"DeveloperDocumentation/design_decisions/#OSCAR-what-is-the-idea","page":"Design Decisions","title":"OSCAR - what is the idea","text":"","category":"section"},{"location":"DeveloperDocumentation/design_decisions/","page":"Design Decisions","title":"Design Decisions","text":"OSCAR is the innovative, next generation Computer Algebra System. The ultimate goal for OSCAR is to compete with (and ideally beat) Magma and Sage in our areas of expertise. OSCAR should be accessible, even for the youngest student who is familiar with these objects. OSCAR should follow general mathematical conventions to support the widest possible range of applications.","category":"page"},{"location":"DeveloperDocumentation/design_decisions/","page":"Design Decisions","title":"Design Decisions","text":"The key idea for development of OSCAR is to pick a single textbook for every area and follow the conventions in there.  This way we get a consistent interface.","category":"page"},{"location":"DeveloperDocumentation/design_decisions/#OSCAR-and-Julia","page":"Design Decisions","title":"OSCAR and Julia","text":"","category":"section"},{"location":"DeveloperDocumentation/design_decisions/","page":"Design Decisions","title":"Design Decisions","text":"OSCAR is written in Julia, but is not Julia, nor can it be.  Some examples to illustrate what that means: Julia's matrices are arrays (of arbitrary dimension), parameterized by the type of the entries (apart from banded, sparse, ... special matrices). In the numerical world, the type mostly defines the representation of an object","category":"page"},{"location":"DeveloperDocumentation/design_decisions/","page":"Design Decisions","title":"Design Decisions","text":"double and variations\ncomplex\nBigFloat\nInt\nBigInt","category":"page"},{"location":"DeveloperDocumentation/design_decisions/","page":"Design Decisions","title":"Design Decisions","text":"In algebra, this is either not true or terribly inefficient (or impossible) Take mathbbZnmathbbZ integers modulo n, and matrices over it","category":"page"},{"location":"DeveloperDocumentation/design_decisions/","page":"Design Decisions","title":"Design Decisions","text":"Then either:","category":"page"},{"location":"DeveloperDocumentation/design_decisions/","page":"Design Decisions","title":"Design Decisions","text":"n is part of the type -> every function is recompiled for every n - which kills all modular (Chinese remainder theorem  (CRT) based) algorithms\nn is not part of the type, then it needs to be elsewhere, e.g. in the  parent, or in every element, or by passing additional arguments, or ...","category":"page"},{"location":"DeveloperDocumentation/design_decisions/","page":"Design Decisions","title":"Design Decisions","text":"Furthermore, if n is BigInt (ZZRingElem), so no bittype, then it cannot be part of the type.","category":"page"},{"location":"DeveloperDocumentation/design_decisions/","page":"Design Decisions","title":"Design Decisions","text":"For non-empty matrices, this can be compensated if the entries store enough information, but for empty matrices this information needs to be collected elsewhere.","category":"page"},{"location":"DeveloperDocumentation/design_decisions/","page":"Design Decisions","title":"Design Decisions","text":"To summarize, normal Julia infrastructure does not suffice for our purposes in many places. Hence we provide our own, which any code contributions should use. If functions are missing in it, then please","category":"page"},{"location":"DeveloperDocumentation/design_decisions/","page":"Design Decisions","title":"Design Decisions","text":"add them\nor tell us","category":"page"},{"location":"DeveloperDocumentation/design_decisions/#Mathematical-Context-in-OSCAR","page":"Design Decisions","title":"Mathematical Context in OSCAR","text":"","category":"section"},{"location":"DeveloperDocumentation/design_decisions/","page":"Design Decisions","title":"Design Decisions","text":"When studying mathematics, the exact meaning of a term or object is determined by context. In OSCAR, this does not work. The meaning has to be part of either","category":"page"},{"location":"DeveloperDocumentation/design_decisions/","page":"Design Decisions","title":"Design Decisions","text":"the object\nor the question posed about the object","category":"page"},{"location":"DeveloperDocumentation/design_decisions/","page":"Design Decisions","title":"Design Decisions","text":"As an example: in classical number theory there is the convention that many definitions that are trivial for fields are silently applied to the ring of integers. One speaks of the unit group of the number field, meaning the unit group of the ring of integers. Let alpha be an element explicitly constructed as an element of the number field, not of the ring of integers, then","category":"page"},{"location":"DeveloperDocumentation/design_decisions/","page":"Design Decisions","title":"Design Decisions","text":"is_unit will just test if it is non-zero (unit in a field as a special type of ring)\nis_unit_in_ring_of_integers would supply the context for the other interpretation.","category":"page"},{"location":"DeveloperDocumentation/design_decisions/","page":"Design Decisions","title":"Design Decisions","text":"In OSCAR, this context is mostly supplied by the type of the object and possibly the parent, e.g. the containing ring/ field/ group.","category":"page"},{"location":"DeveloperDocumentation/design_decisions/#What-Do-We-Have:","page":"Design Decisions","title":"What Do We Have:","text":"","category":"section"},{"location":"DeveloperDocumentation/design_decisions/","page":"Design Decisions","title":"Design Decisions","text":"We have a large codebase for infrastructure in place, comprising at least","category":"page"},{"location":"DeveloperDocumentation/design_decisions/","page":"Design Decisions","title":"Design Decisions","text":"matrices\npolynomials (univariate and multivariate)\npower series\nnumber fields\n(abelian) groups\npolytopes, cones, linear programs\npolyhedral fans\n... and MUCH more","category":"page"},{"location":"DeveloperDocumentation/design_decisions/","page":"Design Decisions","title":"Design Decisions","text":"For specialized functionality we can access the entirety of the following software frameworks on a lower level:","category":"page"},{"location":"DeveloperDocumentation/design_decisions/","page":"Design Decisions","title":"Design Decisions","text":"polymake\nSingular\nGap","category":"page"},{"location":"DeveloperDocumentation/design_decisions/","page":"Design Decisions","title":"Design Decisions","text":"So: Please use it. It is safe to assume all can be improved, however, if we try to perfect every single line of code again and again, we won't get anywhere; there is a balance to be found. For preference: ","category":"page"},{"location":"DeveloperDocumentation/design_decisions/","page":"Design Decisions","title":"Design Decisions","text":"Correctness > Interoperability, Readability\nInteroperability > Speed\nReadability > Speed","category":"page"},{"location":"DeveloperDocumentation/design_decisions/","page":"Design Decisions","title":"Design Decisions","text":"Having said that: of course, sometimes pure speed matters, but not nearly as often as people think.","category":"page"},{"location":"DeveloperDocumentation/design_decisions/#What-Is-Missing?","page":"Design Decisions","title":"What Is Missing?","text":"","category":"section"},{"location":"DeveloperDocumentation/design_decisions/","page":"Design Decisions","title":"Design Decisions","text":"The infrastructure is incomplete, e.g. we do not have","category":"page"},{"location":"DeveloperDocumentation/design_decisions/","page":"Design Decisions","title":"Design Decisions","text":"combinatorial manifolds\nsurfaces\ntropical polytopes\n....","category":"page"},{"location":"DeveloperDocumentation/design_decisions/","page":"Design Decisions","title":"Design Decisions","text":"Since we are a relatively small team and OSCAR is still very new, the usual","category":"page"},{"location":"DeveloperDocumentation/design_decisions/","page":"Design Decisions","title":"Design Decisions","text":"I work for 6 month in a separate repo on a branch and then will dazzle you\nwith perfect code and cool examples","category":"page"},{"location":"DeveloperDocumentation/design_decisions/","page":"Design Decisions","title":"Design Decisions","text":"approach is not going to work for now. It will result in everyone fixing the same infrastructure problems over and over again. Please consider to work, e.g. in a file/directory  in Oscar/examples and push on a regular basis, even, or in particular, incomplete code. Break it down into small pull requests. Please also see the Introduction for new developers.","category":"page"},{"location":"DeveloperDocumentation/design_decisions/#Practical-Development","page":"Design Decisions","title":"Practical Development","text":"","category":"section"},{"location":"DeveloperDocumentation/design_decisions/#Creating-New-Basic-Types","page":"Design Decisions","title":"Creating New Basic Types","text":"","category":"section"},{"location":"DeveloperDocumentation/design_decisions/","page":"Design Decisions","title":"Design Decisions","text":"If you encounter the need for a new basic type, say a new multivariate ring, please consider the ramifications:","category":"page"},{"location":"DeveloperDocumentation/design_decisions/","page":"Design Decisions","title":"Design Decisions","text":"can you do matrices?\nmodules?\nideals?\ngraded stuff?\n\"complete\" arithmetic?\ninteraction with other types? (map to residue rings, apply automorphisms, ...)\nin fact, everything the other MPoly type can?","category":"page"},{"location":"DeveloperDocumentation/design_decisions/","page":"Design Decisions","title":"Design Decisions","text":"If no: at least use \"our\" types to interface your function, better still, use our type and complain about lack of functionality/ speed/ interface (or provide patches).","category":"page"},{"location":"DeveloperDocumentation/design_decisions/","page":"Design Decisions","title":"Design Decisions","text":"This applies to all foundations! They are all incomplete, and they can all be improved BUT if everyone does their own foundations, we cannot work together.","category":"page"},{"location":"DeveloperDocumentation/design_decisions/","page":"Design Decisions","title":"Design Decisions","text":"danger: Expert definitions\nAs a reminder, please stick to \"global definitions\" and not \"experts\" versions of definitions. Reasoning such as: \"but all experts know and expect this - it is always done this way\" will make your function impossible to be used by outsiders. Feel free to add the other \"expert\" definition layer if you need.","category":"page"},{"location":"NumberTheory/galois/","page":"Galois Theory","title":"Galois Theory","text":"CurrentModule = Oscar\nDocTestSetup = Oscar.doctestsetup()","category":"page"},{"location":"NumberTheory/galois/#Galois-Theory","page":"Galois Theory","title":"Galois Theory","text":"","category":"section"},{"location":"NumberTheory/galois/","page":"Galois Theory","title":"Galois Theory","text":"Let K be a finite (separable) field extension of k. Then, in contrast to most of  the literature we distinguish two concepts","category":"page"},{"location":"NumberTheory/galois/","page":"Galois Theory","title":"Galois Theory","text":"the automorphism group\nthe Galois group","category":"page"},{"location":"NumberTheory/galois/","page":"Galois Theory","title":"Galois Theory","text":"The automorphism group deals with the actual automorphism of K fixing k and thus is, in general trivial. Access is via two constructions:","category":"page"},{"location":"NumberTheory/galois/","page":"Galois Theory","title":"Galois Theory","text":"a list of all automorphisms (usually only the identity)\nthe group of automorphisms, returned as an abstract group and a map linking group elements to actual automorphisms","category":"page"},{"location":"NumberTheory/galois/","page":"Galois Theory","title":"Galois Theory","text":"On the other hand, the Galois group is isomorphic to the automorphism group of the normal closure and is explicitly given as a group of permutations of the roots  of the defining polynomial. Thus even in the case of K over k being normal, elements of the Galois group do not immediately give automorphisms at all.","category":"page"},{"location":"NumberTheory/galois/","page":"Galois Theory","title":"Galois Theory","text":"Currently, the computation of Galois groups is possible for","category":"page"},{"location":"NumberTheory/galois/","page":"Galois Theory","title":"Galois Theory","text":"K a simple extension of the rationals (AbsSimpleNumField)\nK a simple extension of an AbsSimpleNumField \nK a finite extension of the rational function field over the  rationals. In this case the  monodromy group can be computed as well, ie. the automorphism group over the  complex numbers.\nf a polynomial over the rationals, or an AbsSimpleNumField","category":"page"},{"location":"NumberTheory/galois/","page":"Galois Theory","title":"Galois Theory","text":"Independently of the Galois group, subfields, that is intermediate fields between K and k can be computed as well.","category":"page"},{"location":"NumberTheory/galois/#Automorphism-Group","page":"Galois Theory","title":"Automorphism Group","text":"","category":"section"},{"location":"NumberTheory/galois/","page":"Galois Theory","title":"Galois Theory","text":"The automorphisms are computed using various specialized factoring algorithms: lifting the roots of the defining polynomial in the given field modulo suitable prime ideal powers and recovering the true roots from this information.","category":"page"},{"location":"NumberTheory/galois/","page":"Galois Theory","title":"Galois Theory","text":"The main information is included in the number field chapter, see for example","category":"page"},{"location":"NumberTheory/galois/","page":"Galois Theory","title":"Galois Theory","text":"automorphism_list(::Hecke.NumFieldHom)\nautomorphism_group(::NumField)\nautomorphism_group(::NumField, ::NumField)","category":"page"},{"location":"NumberTheory/galois/#Subfields","page":"Galois Theory","title":"Subfields","text":"","category":"section"},{"location":"NumberTheory/galois/","page":"Galois Theory","title":"Galois Theory","text":"The main information is included in the number field chapter, see","category":"page"},{"location":"NumberTheory/galois/","page":"Galois Theory","title":"Galois Theory","text":"subfields(K::SimpleNumField; degree::Int = -1)\nHecke.principal_subfields(K::SimpleNumField)\nsubfields(FF::Generic.FunctionField{QQFieldElem})","category":"page"},{"location":"NumberTheory/galois/","page":"Galois Theory","title":"Galois Theory","text":"By setting set_verbosity_level(:Subfields, n::Int) to 1 or 2 information about the progress can be obtained.","category":"page"},{"location":"NumberTheory/galois/#Galois-Group","page":"Galois Theory","title":"Galois Group","text":"","category":"section"},{"location":"NumberTheory/galois/","page":"Galois Theory","title":"Galois Theory","text":"The computation of Galois groups follows Stauduhars algorithm with many improvements, see ... for an overview.","category":"page"},{"location":"NumberTheory/galois/","page":"Galois Theory","title":"Galois Theory","text":"The entrire computation can also be thought of finding a description of the splitting field of the polynomial. In fact, the information returned can be used to verify any algebraic identity between the roots, and find explicit subfields of the splitting field as well.","category":"page"},{"location":"NumberTheory/galois/","page":"Galois Theory","title":"Galois Theory","text":"Information about the progress is available via","category":"page"},{"location":"NumberTheory/galois/","page":"Galois Theory","title":"Galois Theory","text":"set_verbosity_level(:GaloisGroup, n::Int)\nset_verbosity_level(:GaloisInvariants, n::Int)","category":"page"},{"location":"NumberTheory/galois/","page":"Galois Theory","title":"Galois Theory","text":"galois_group(K::AbsSimpleNumField, extra::Int = 5; useSubfields::Bool = true, pStart::Int = 2*degree(K), prime::Int = 0)\ngalois_group(f::PolyRingElem{<:FieldElem})","category":"page"},{"location":"NumberTheory/galois/#galois_group","page":"Galois Theory","title":"galois_group","text":"galois_group(K::AbsSimpleNumField, extra::Int = 5; useSubfields::Bool = true, pStart::Int = 2*degree(K)) -> PermGroup, GaloisCtx\n\nComputes the Galois group of the splitting field of the defining polynomial of K. Currently the polynomial needs to be monic.\n\nThe group is returned as an explicit permutation group permuting the roots as contained in the context object (the 2nd return value). The roots live in a suitable unramifed extension of the p-adics.\n\nExamples\n\njulia> K, a = cyclotomic_field(5);\n\njulia> G, C = galois_group(K)\n(Permutation group of degree 4 and order 4, Galois context for x^4 + x^3 + x^2 + x + 1 and prime 19)\n\njulia> describe(G)\n\"C4\"\n\njulia> roots(C, 2)\n4-element Vector{QadicFieldElem}:\n (4*19^0 + 2*19^1 + O(19^2))*a + 5*19^0 + 9*19^1 + O(19^2)\n (15*19^0 + 16*19^1 + O(19^2))*a + 9*19^0 + 7*19^1 + O(19^2)\n (18*19^0 + 18*19^1 + O(19^2))*a + 12*19^0 + O(19^2)\n (19^0 + O(19^2))*a + 11*19^0 + 19^1 + O(19^2)\n\n\n\n\n\n","category":"function"},{"location":"NumberTheory/galois/#galois_group-Tuple{PolyRingElem{<:FieldElem}}","page":"Galois Theory","title":"galois_group","text":"galois_group(f::PolyRingElem{<:FieldElem})\n\nComputes the automorphism group of a splitting field of f as an explicit group of permutations of the roots. Furthermore, the GaloisCtx is returned allowing algorithmic access to the splitting field.\n\n\n\n\n\n","category":"method"},{"location":"NumberTheory/galois/","page":"Galois Theory","title":"Galois Theory","text":"Over the rational function field, we can also compute the monodromy group:","category":"page"},{"location":"NumberTheory/galois/","page":"Galois Theory","title":"Galois Theory","text":"DocTestFilters = r\"Galois context\\(.*\\]\\)\"","category":"page"},{"location":"NumberTheory/galois/","page":"Galois Theory","title":"Galois Theory","text":"julia> Qt, t = rational_function_field(QQ, \"t\");\n\njulia> Qtx, x = Qt[:x];\n\njulia> F, a = function_field(x^6 + 108*t^2 + 108*t + 27);\n\njulia> subfields(F)\n4-element Vector{Any}:\n (Function Field over QQ with defining polynomial a^3 + 54*t + 27, (1//12*_a^4 + (3//2*t + 3//4)*_a)//(t + 1//2))\n (Function Field over QQ with defining polynomial a^2 + 108*t^2 + 108*t + 27, _a^3)\n (Function Field over QQ with defining polynomial a^3 - 108*t^2 - 108*t - 27, -_a^2)\n (Function Field over QQ with defining polynomial a^3 - 54*t - 27, (-1//12*_a^4 + (3//2*t + 3//4)*_a)//(t + 1//2))\n\njulia> galois_group(F)\n(Permutation group of degree 6 and order 6, Galois context for s^6 + 108*t^2 + 540*t + 675)\n\njulia> G, C, k = galois_group(F, overC = true)\n(Permutation group of degree 6 and order 3, Galois context for s^6 + 108*t^2 + 540*t + 675, Number field of degree 2 over QQ)\n","category":"page"},{"location":"NumberTheory/galois/","page":"Galois Theory","title":"Galois Theory","text":"So, while the splitting field over Q(t) has degree 6, the galois group there is isomorphic to the S(3) or D(3) (on 6 points), the splitting field over C(t) is only of degree 3. Here the group collapses to a cyclic group of degree 3, the algebraic closure of Q in the splitting field is the quadratic field returned last. It can be seen to be isomorphic to a cyclotomic field:","category":"page"},{"location":"NumberTheory/galois/","page":"Galois Theory","title":"Galois Theory","text":"DocTestFilters = nothing","category":"page"},{"location":"NumberTheory/galois/","page":"Galois Theory","title":"Galois Theory","text":"julia> is_isomorphic(k, cyclotomic_field(3)[1])\ntrue","category":"page"},{"location":"NumberTheory/galois/","page":"Galois Theory","title":"Galois Theory","text":"The information returned consists always at least of a group G and a GaloisCtx: C. Jointly, they can be used to further work with the information:","category":"page"},{"location":"NumberTheory/galois/","page":"Galois Theory","title":"Galois Theory","text":"roots(C::Oscar.GaloisGrp.GaloisCtx{Hecke.qAdicRootCtx}, pr::Int)\nOscar.GaloisGrp.upper_bound\nOscar.GaloisGrp.isinteger\nOscar.GaloisGrp.resolvent(C::Oscar.GaloisGrp.GaloisCtx, G::PermGroup, U::PermGroup, extra::Int = 5)","category":"page"},{"location":"NumberTheory/galois/#roots-Tuple{Oscar.GaloisGrp.GaloisCtx{Hecke.qAdicRootCtx}, Int64}","page":"Galois Theory","title":"roots","text":"roots(G::GaloisCtx, pr::Int)\n\nThe roots of the polynomial used to define the Galois context in the fixed order used in the algorithm. The roots are returned up to a precision of pr p-adic digits, thus they are correct modulo p^pr\n\nFor non-monic polynomials the roots are scaled by the leading coefficient. If raw is set to true, the scaling is omitted. The bound in the GaloisCtx is also adjusted.\n\n\n\n\n\n","category":"method"},{"location":"NumberTheory/galois/#upper_bound","page":"Galois Theory","title":"upper_bound","text":"upper_bound(G::GaloisCtx, f...)\n\nGiven a GaloisCtx and some multivariate function, upper_bound the image of f upon evaluation at the roots implicit in G.\n\nf can be\n\na multivariate polynomial or straight-line polynomial (strictly: any object allowing evaluate\nelementary_symmetric or power_sum, in which case more arguments are needed: the array with the values and the index. upper_bound(G, power_sum, A, i) is equivalent to upper_bound(G, power_sum(A, i)) but more efficient.\n\nIn every case a univariate polynomial (over the integers) can be added, it will act as a Tschirnhaus-transformation, ie. the roots (bounds) implicit in G will first be transformed.\n\n\n\n\n\n","category":"function"},{"location":"NumberTheory/galois/#isinteger","page":"Galois Theory","title":"isinteger","text":"isinteger(C::GaloisCtx, B::BoundRingElem, v)\n\nFor an element v representing an integral polynomial evaluated at the roots stored in C, known to be bounded from above by B, either return true and an explicit (algebraic) integer in the base ring of the context or return false.\n\n\n\n\n\n","category":"function"},{"location":"NumberTheory/galois/#resolvent","page":"Galois Theory","title":"resolvent","text":"resolvent(C::GaloisCtx, G::PermGroup, U::PermGroup)\n\nFind a G-relative H-invariant I and form the corresponding resolvent polynomial prod (x-I^t) where the product runs over all coset-representatives of G/U.\n\n\n\n\n\n","category":"function"},{"location":"NumberTheory/galois/","page":"Galois Theory","title":"Galois Theory","text":"To illustrate:","category":"page"},{"location":"NumberTheory/galois/","page":"Galois Theory","title":"Galois Theory","text":"julia> Qx, x = QQ[:x];\n\njulia> f = (x^2-2)*(x^2-3);\n\njulia> G, C = galois_group(f)\n(Permutation group of degree 4 and order 4, Galois context for x^4 - 5*x^2 + 6 and prime 11)\n\njulia> r = roots(C, 5)\n4-element Vector{QadicFieldElem}:\n 5*11^0 + 2*11^1 + 6*11^2 + 8*11^3 + 11^4 + O(11^5)\n 6*11^0 + 8*11^1 + 4*11^2 + 2*11^3 + 9*11^4 + O(11^5)\n (10*11^0 + 4*11^1 + 4*11^2 + 10*11^3 + 8*11^4 + O(11^5))*a + 2*11^0 + 6*11^1 + 4*11^2 + 3*11^3 + 9*11^4 + O(11^5)\n (11^0 + 6*11^1 + 6*11^2 + 2*11^4 + O(11^5))*a + 9*11^0 + 4*11^1 + 6*11^2 + 7*11^3 + 11^4 + O(11^5)\n\njulia> r[1]^2\n3*11^0 + O(11^5)\n\njulia> r[3]^2\n2*11^0 + O(11^5)","category":"page"},{"location":"NumberTheory/galois/","page":"Galois Theory","title":"Galois Theory","text":"To illustrate the use as a splitting field, we will prove that r[1]^2 is actually an integer - and that r[1]+r[3] is not.","category":"page"},{"location":"NumberTheory/galois/","page":"Galois Theory","title":"Galois Theory","text":"Any multivariate polynomial in four variables and with integer coefficients defines via evaluation at the roots an element in the splitting field. In case the evaluation is  actually an integer, this can be proven with the tools provided.","category":"page"},{"location":"NumberTheory/galois/","page":"Galois Theory","title":"Galois Theory","text":"julia> I, s = polynomial_ring(ZZ, 4);\n\njulia> s[1]^2\nx1^2\n","category":"page"},{"location":"NumberTheory/galois/","page":"Galois Theory","title":"Galois Theory","text":"Next, we need a bound for the evaluation as a complex number, and compute the precision necessary:","category":"page"},{"location":"NumberTheory/galois/","page":"Galois Theory","title":"Galois Theory","text":"julia> B = Oscar.GaloisGrp.upper_bound(C, s[1]^2)\n(x <= 36)\n\njulia> pr = Oscar.GaloisGrp.bound_to_precision(C, B)\n7\n","category":"page"},{"location":"NumberTheory/galois/","page":"Galois Theory","title":"Galois Theory","text":"Finally, we evaluate the polynomial at the roots and verify that the exact value is 3:","category":"page"},{"location":"NumberTheory/galois/","page":"Galois Theory","title":"Galois Theory","text":"julia> evaluate(s[1]^2, roots(C, 7))\n3*11^0 + O(11^7)\n\njulia> Oscar.GaloisGrp.isinteger(C, B, ans)\n(true, 3)","category":"page"},{"location":"NumberTheory/galois/","page":"Galois Theory","title":"Galois Theory","text":"Now, to show that r[1] + r[3] is not an integer:","category":"page"},{"location":"NumberTheory/galois/","page":"Galois Theory","title":"Galois Theory","text":"julia> B = Oscar.GaloisGrp.upper_bound(C, s[1] + s[3])\n(x <= 12)\n\njulia> Oscar.GaloisGrp.isinteger(C, B, evaluate(s[1] + s[3], roots(C, 7)))\n(false, nothing)","category":"page"},{"location":"NumberTheory/galois/","page":"Galois Theory","title":"Galois Theory","text":"More interestingly, we can use this to find the minimal polynomial of r[1] + r[3]. Generically, the Galois-conjugates of r[1]+r[3] should be the G-orbit of s[1]+s[3] evaluated at the roots.","category":"page"},{"location":"NumberTheory/galois/","page":"Galois Theory","title":"Galois Theory","text":"Once the orbit is known, the coefficients of the minimal polynomial are just the elementary symmetric functions evaluated at the roots: ","category":"page"},{"location":"NumberTheory/galois/","page":"Galois Theory","title":"Galois Theory","text":"julia> o = collect(orbit(G, s[1]+s[3]))\n4-element Vector{ZZMPolyRingElem}:\n x1 + x3\n x1 + x4\n x2 + x4\n x2 + x3\n\njulia> for i=1:4\n         B = Oscar.GaloisGrp.upper_bound(C, elementary_symmetric, o, i)\n         pr = Oscar.GaloisGrp.bound_to_precision(C, B)\n         co = [evaluate(x, roots(C, pr)) for x = o]\n         println(i, \": \", Oscar.GaloisGrp.isinteger(C, B, elementary_symmetric(co, i)))\n       end\n1: (true, 0)\n2: (true, -10)\n3: (true, 0)\n4: (true, 1)","category":"page"},{"location":"NumberTheory/galois/","page":"Galois Theory","title":"Galois Theory","text":"So, x^4-10x^2+1 should be the minimal polynomial to sqrt 3 + sqrt 2 - which it is.","category":"page"},{"location":"NumberTheory/galois/","page":"Galois Theory","title":"Galois Theory","text":"In the case of computations over the rational function field, both the precision and the bound are more complicated - but can be used in the same way: Here, the roots are power series with q-adic coefficients, thus the precision has to cover both the precision of the coefficient as well as the number of terms in the series. Similarly, in this context, an isinteger is now a polynomial with integer coefficients. Thus the bound needs to bound the degree as well as the coefficient size.","category":"page"},{"location":"NumberTheory/galois/","page":"Galois Theory","title":"Galois Theory","text":"julia> Qt,t = rational_function_field(QQ, \"t\");\n\njulia> Qtx, x = Qt[:x];\n\njulia> F, a = function_field(x^3+t+2);\n\njulia> G, C = galois_group(F);\n\njulia> describe(G)\n\"S3\"\n\njulia> _, s = slpoly_ring(ZZ, 3);\n\njulia> B = Oscar.GaloisGrp.upper_bound(C, prod(s))\n(x <= (9261, 2, 1))\n\njulia> pr = Oscar.GaloisGrp.bound_to_precision(C, B)\n(2, 2)\n\njulia> Oscar.GaloisGrp.isinteger(C, B, evaluate(prod(s), roots(C, pr)))\n(true, -t - 2)","category":"page"},{"location":"NumberTheory/galois/","page":"Galois Theory","title":"Galois Theory","text":"galois_quotient(C::Oscar.GaloisGrp.GaloisCtx, Q::PermGroup)\ngalois_quotient(C::Oscar.GaloisGrp.GaloisCtx, d::Int)\ngalois_quotient(C::Oscar.GaloisGrp.GaloisCtx, d::Int, n::Int)\ngalois_quotient(f::PolyRingElem, p::Vector{Int})\nfixed_field(GC::Oscar.GaloisGrp.GaloisCtx, U::PermGroup, extra::Int = 5)\nminpoly(C::Oscar.GaloisGrp.GaloisCtx, I, extra::Int = 5)","category":"page"},{"location":"NumberTheory/galois/#galois_quotient-Tuple{Oscar.GaloisGrp.GaloisCtx, PermGroup}","page":"Galois Theory","title":"galois_quotient","text":"galois_quotient(C::GaloisCtx, Q::PermGroup)\n\nFinds all(?) subfields of the splitting field s.th. the galois group will be permutation isomorphic to Q.\n\n\n\n\n\n","category":"method"},{"location":"NumberTheory/galois/#galois_quotient-Tuple{Oscar.GaloisGrp.GaloisCtx, Int64}","page":"Galois Theory","title":"galois_quotient","text":"galois_quotient(C::GaloisCtx, d::Int)\n\nFinds all(?) subfields (up to isomorphism) of the splitting field of degree d with galois group isomorphic to the original one.\n\nExamples\n\njulia> Qx, x = QQ[:x];\n\njulia> G, C = galois_group(x^3-2);\n\njulia> galois_quotient(C, 6)\n1-element Vector{Any}:\n Number field of degree 6 over QQ\n\njulia> galois_group(ans[1])\n(Permutation group of degree 6 and order 6, Galois context for x^6 + 324*x^4 - 4*x^3 + 34992*x^2 + 1296*x + 1259716 and prime 13)\n\njulia> is_isomorphic(ans[1], G)\ntrue\n\n\n\n\n\n","category":"method"},{"location":"NumberTheory/galois/#galois_quotient-Tuple{Oscar.GaloisGrp.GaloisCtx, Int64, Int64}","page":"Galois Theory","title":"galois_quotient","text":"galois_quotient(C::GaloisCtx, d::Int, n::Int)\n\nFinds all subfields of the splitting field with galois group the n-th transitive group in degree d\n\n\n\n\n\n","category":"method"},{"location":"NumberTheory/galois/#galois_quotient-Tuple{PolyRingElem, Vector{Int64}}","page":"Galois Theory","title":"galois_quotient","text":"galois_quotient(f::PolyRingElem, p::Vector{Int})\n\nEquivalent to\n\ngalois_quotient(galois_group(f)[2], p[1], p[2])\n\nFinds all subfields of the splitting field of f with galois group the p[2]-th transitive group of degree p[1]\n\n\n\n\n\n","category":"method"},{"location":"NumberTheory/galois/#fixed_field","page":"Galois Theory","title":"fixed_field","text":"fixed_field(GC::GaloisCtx, U::PermGroup, extra::Int = 5)\n\nGiven the GaloisCtx as returned by a call to galois_group and a subgroup U of the Galois group, compute the field fixed by U as a simple extension.\n\n\n\n\n\n","category":"function"},{"location":"NumberTheory/galois/#minpoly","page":"Galois Theory","title":"minpoly","text":"minpoly(C::GaloisCtx, I, extra::Int = 5)\n\nComputes the minimal polynomial of I evaluated at the roots stored in C.\n\n\n\n\n\n","category":"function"},{"location":"NumberTheory/galois/","page":"Galois Theory","title":"Galois Theory","text":"Oscar.GaloisGrp.cauchy_ideal(f::PolyRingElem{<:FieldElem})\nOscar.GaloisGrp.galois_ideal(C::Oscar.GaloisGrp.GaloisCtx, extra::Int = 5)","category":"page"},{"location":"NumberTheory/galois/#cauchy_ideal-Tuple{PolyRingElem{<:FieldElem}}","page":"Galois Theory","title":"cauchy_ideal","text":"cauchy_ideal(f::PolyRingElem{<:FieldElem})\n\nThe coefficients of f are the elementary symmetric functions evaluated at the roots of f. The cauchy_ideal is the ideal generated by the differences between the elementary symmetric functions and the coefficients.\n\nExamples\n\njulia> Qx, x = QQ[:x];\n\njulia> cauchy_ideal(x^4-2)\nIdeal generated by\n  x4^4 - 2\n  x3^3 + x3^2*x4 + x3*x4^2 + x4^3\n  x2^2 + x2*x3 + x2*x4 + x3^2 + x3*x4 + x4^2\n  x1 + x2 + x3 + x4\n\n\n\n\n\n","category":"method"},{"location":"NumberTheory/galois/#galois_ideal","page":"Galois Theory","title":"galois_ideal","text":"galois_ideal(C::GaloisCtx, extra::Int = 5)\n\nThe so-called Galois ideal is a description of the splitting field of the polynomial underlying Cas a quotient by some maximal ideal. Algebraically, this ideal is an irreducible component of the Cauchy ideal, the ideal generated by the elementary symmetric functions and the coefficients of the polynomial.\n\nExamples\n\njulia> Qx, x = QQ[:x];\n\njulia> i = galois_ideal(galois_group(x^4-2)[2])\nIdeal generated by\n  x4^4 - 2\n  x3^3 + x3^2*x4 + x3*x4^2 + x4^3\n  x2^2 + x2*x3 + x2*x4 + x3^2 + x3*x4 + x4^2\n  x1 + x2 + x3 + x4\n  x1*x3 + x2*x4\n  x1^2*x3^2 + x2^2*x4^2 - 4\n  x1^4 - 2\n  x2^4 - 2\n  x3^4 - 2\n  x4^4 - 2\n\njulia> k, _ = number_field(i);\n\njulia> length(roots(k, x^4-2))\n4\n\n\n\n\n\n","category":"function"},{"location":"NumberTheory/galois/","page":"Galois Theory","title":"Galois Theory","text":"Over the integers, if the Galois group is solvable, the roots can be expressed  as radicals:","category":"page"},{"location":"NumberTheory/galois/","page":"Galois Theory","title":"Galois Theory","text":"solve(f::ZZPolyRingElem)\nfixed_field(C::Oscar.GaloisGrp.GaloisCtx, s::Vector{PermGroup})","category":"page"},{"location":"NumberTheory/galois/#solve-Tuple{ZZPolyRingElem}","page":"Galois Theory","title":"solve","text":"Oscar.solve(f::ZZPolyRingElem; max_prec::Int=typemax(Int))\nOscar.solve(f::QQPolyRingElem; max_prec::Int=typemax(Int))\n\nCompute a presentation of the roots of f in a radical tower. The necessary roots of unity are not themselves computed as radicals.\n\nSee also galois_group.\n\nVERBOSE\n\nSupports set_verbosity_level(:SolveRadical, i) to obtain information.\n\nExamples\n\njulia> Qx,x = QQ[:x];\n\njulia> K, r = solve(x^3+3*x+5)\n(Relative number field over with defining polynomial x^3 + (3*z_3 + 3//2)*a2 + 135//2\n over Relative number field over with defining polynomial x^2 + 783\n over Number field over Rational Field with defining polynomial x^2 + x + 1, Any[((1//81*z_3 + 1//162)*a2 - 5//18)*a3^2 + 1//3*a3, ((-1//162*z_3 + 1//162)*a2 + 5//18*z_3 + 5//18)*a3^2 + 1//3*z_3*a3, ((-1//162*z_3 - 1//81)*a2 - 5//18*z_3)*a3^2 + (-1//3*z_3 - 1//3)*a3])\n\njulia> #z_3 indicates the 3-rd root-of-1 used\n\njulia> map(x^3+3*x+5, r)\n3-element Vector{Hecke.RelSimpleNumFieldElem{Hecke.RelSimpleNumFieldElem{AbsSimpleNumFieldElem}}}:\n 0\n 0\n 0\n\njulia> solve(cyclotomic(12, x)) #zeta_12 as radical\n(Relative number field over with defining polynomial x^2 - 3//4\n over Number field over Rational Field with defining polynomial x^2 + 1, Any[a2 + 1//2*a1, a2 - 1//2*a1, -a2 - 1//2*a1, -a2 + 1//2*a1])\n\n\nwarning: Experimental\nThis function is part of the experimental code in Oscar. Please read here for more details.\n\n\n\n\n\n","category":"method"},{"location":"NumberTheory/galois/#fixed_field-Tuple{Oscar.GaloisGrp.GaloisCtx, Vector{PermGroup}}","page":"Galois Theory","title":"fixed_field","text":"fixed_field(C::GaloisCtx, s::Vector{PermGroup})\n\nGiven a descending chain of subgroups, each being maximal in the previous one, compute the corresponding subfields as a tower.\n\nExamples\n\njulia> Qx, x = QQ[:x];\n\njulia> G, C = galois_group(x^3-3*x+17)\n(Sym(3), Galois context for x^3 - 3*x + 17 and prime 7)\n\njulia> d = derived_series(G)\n3-element Vector{PermGroup}:\n Sym(3)\n Alt(3)\n Permutation group of degree 3 and order 1\n\njulia> fixed_field(C, d)\n(Relative number field of degree 3 over number field, a2)\n\nwarning: Experimental\nThis function is part of the experimental code in Oscar. Please read here for more details.\n\n\n\n\n\n","category":"method"},{"location":"DeveloperDocumentation/release/#Release-management","page":"Release management","title":"Release management","text":"","category":"section"},{"location":"DeveloperDocumentation/release/","page":"Release management","title":"Release management","text":"We roughly follow the julia release process. The following outlines the approach taken for OSCAR 1.0.0 but is subject to change depending in how this works out.","category":"page"},{"location":"DeveloperDocumentation/release/","page":"Release management","title":"Release management","text":"Before preparing the release branch two developers are chosen to take care of managing the branches and taking final decisions on which changes can be merged during the release process.","category":"page"},{"location":"DeveloperDocumentation/release/#Branches","page":"Release management","title":"Branches","text":"","category":"section"},{"location":"DeveloperDocumentation/release/","page":"Release management","title":"Release management","text":"Assuming the current master has version number X.Y.0-DEV, in preparation for the next release a branch release-X.Y is created directly on GitHub. Once that is done the master should be set to X.Y+1.0-DEV.","category":"page"},{"location":"DeveloperDocumentation/release/","page":"Release management","title":"Release management","text":"note: Note\nPlease use the script etc/update_version.sh for version changes.","category":"page"},{"location":"DeveloperDocumentation/release/#Backports","page":"Release management","title":"Backports","text":"","category":"section"},{"location":"DeveloperDocumentation/release/","page":"Release management","title":"Release management","text":"The backports should be mostly bug-fixes and small improvements but no major new features or refactorings, to minimize the risk of regressions. Every change that is considered for backporting has to be merged to master first. Once in the stage of release candidates only small bug-fixes and documentation changes should be added.","category":"page"},{"location":"DeveloperDocumentation/release/","page":"Release management","title":"Release management","text":"Changes for the release, after the branch was created, are mostly done by cherry-picking the commits from master that correspond to the already merged PRs. Preferably with git cherry-pick -x to keep a reference to the original commit. The cherry-picked commits are collected on a backports-release-X.Y branch and a corresponding PR, like for release 1.0.0-rc1. Please take care to set the merge target for the PR to the release-X.Y branch.","category":"page"},{"location":"DeveloperDocumentation/release/","page":"Release management","title":"Release management","text":"Once this set of changes is complete the PR is merged to the release branch, using a proper merge commit, i.e. please do not squash or rebase this. The list of backported PRs may be added to the commit message for the merge.","category":"page"},{"location":"DeveloperDocumentation/release/#Conflicts","page":"Release management","title":"Conflicts","text":"","category":"section"},{"location":"DeveloperDocumentation/release/","page":"Release management","title":"Release management","text":"If changes from another PR cannot be cleanly applied to the backports branch it may be necessary to create a separate PR targeting the backports branch to manually backport changes from that PR and resolve any conflicts. Make sure that the branch for this PR branches off from the release branch and not from master (to avoid picking up unrelated commits). Then cherry-pick the relevant commits and fix any conflicts.","category":"page"},{"location":"DeveloperDocumentation/release/#Pre-releases","page":"Release management","title":"Pre-releases","text":"","category":"section"},{"location":"DeveloperDocumentation/release/","page":"Release management","title":"Release management","text":"For the next pre-release create a new PR to the release branch adjusting the version, this may be merged with a rebase to avoid some extra commits. That commit can then be tagged on GitHub as a new pre-release.","category":"page"},{"location":"DeveloperDocumentation/release/","page":"Release management","title":"Release management","text":"note: Note\nPre-releases cannot be registered in the julia registry.","category":"page"},{"location":"DeveloperDocumentation/release/","page":"Release management","title":"Release management","text":"For OSCAR 1.0.0 we plan to have one or two release candidates but unlike julia and due to the tight schedule no -alpha or -beta versions.","category":"page"},{"location":"DeveloperDocumentation/release/#Releases","page":"Release management","title":"Releases","text":"","category":"section"},{"location":"DeveloperDocumentation/release/","page":"Release management","title":"Release management","text":"Once the version is at X.Y.0 the version can be registered in the julia registry with @JuliaRegistrator register(). In this case TagBot will create the corresponding release, but preferably recheck and clean up the list of changes since unfortunately TagBot currently does not take the branch into account and will show all PRs that have been merged to master.","category":"page"},{"location":"DeveloperDocumentation/release/","page":"Release management","title":"Release management","text":"Consider deploying a released version at zenodo.","category":"page"},{"location":"DeveloperDocumentation/release/#Bugfix-releases","page":"Release management","title":"Bugfix releases","text":"","category":"section"},{"location":"DeveloperDocumentation/release/","page":"Release management","title":"Release management","text":"Further bugfix releases X.Y.Z can be created in a similar manner, skipping the pre-releases.","category":"page"},{"location":"AbstractAlgebra/module/","page":"Finitely presented modules","title":"Finitely presented modules","text":"CurrentModule = AbstractAlgebra\nDocTestSetup = AbstractAlgebra.doctestsetup()","category":"page"},{"location":"AbstractAlgebra/module/#Finitely-presented-modules","page":"Finitely presented modules","title":"Finitely presented modules","text":"","category":"section"},{"location":"AbstractAlgebra/module/","page":"Finitely presented modules","title":"Finitely presented modules","text":"AbstractAlgebra allows the construction of finitely presented modules (i.e. with finitely many generators and relations), starting from free modules.","category":"page"},{"location":"AbstractAlgebra/module/","page":"Finitely presented modules","title":"Finitely presented modules","text":"The generic code provided by AbstractAlgebra will only work for modules over euclidean domains.","category":"page"},{"location":"AbstractAlgebra/module/","page":"Finitely presented modules","title":"Finitely presented modules","text":"Free modules can be built over both commutative and noncommutative rings. Other types of module are restricted to fields and euclidean rings.","category":"page"},{"location":"AbstractAlgebra/module/#Abstract-types","page":"Finitely presented modules","title":"Abstract types","text":"","category":"section"},{"location":"AbstractAlgebra/module/","page":"Finitely presented modules","title":"Finitely presented modules","text":"AbstractAlgebra provides two abstract types for finitely presented modules and their elements:","category":"page"},{"location":"AbstractAlgebra/module/","page":"Finitely presented modules","title":"Finitely presented modules","text":"FPModule{T} is the abstract type for finitely presented module parent","category":"page"},{"location":"AbstractAlgebra/module/","page":"Finitely presented modules","title":"Finitely presented modules","text":"types","category":"page"},{"location":"AbstractAlgebra/module/","page":"Finitely presented modules","title":"Finitely presented modules","text":"FPModuleElem{T} is the abstract type for finitely presented module","category":"page"},{"location":"AbstractAlgebra/module/","page":"Finitely presented modules","title":"Finitely presented modules","text":"element types","category":"page"},{"location":"AbstractAlgebra/module/","page":"Finitely presented modules","title":"Finitely presented modules","text":"Note that the abstract types are parameterised. The type T should usually be the type of elements of the ring the module is over.","category":"page"},{"location":"AbstractAlgebra/module/#Module-functions","page":"Finitely presented modules","title":"Module functions","text":"","category":"section"},{"location":"AbstractAlgebra/module/","page":"Finitely presented modules","title":"Finitely presented modules","text":"All finitely presented modules over a Euclidean domain implement the following functions.","category":"page"},{"location":"AbstractAlgebra/module/#Basic-functions","page":"Finitely presented modules","title":"Basic functions","text":"","category":"section"},{"location":"AbstractAlgebra/module/","page":"Finitely presented modules","title":"Finitely presented modules","text":"zero(M::FPModule)","category":"page"},{"location":"AbstractAlgebra/module/","page":"Finitely presented modules","title":"Finitely presented modules","text":"iszero(m::FPModuleElem{T}) where T <: RingElement","category":"page"},{"location":"AbstractAlgebra/module/","page":"Finitely presented modules","title":"Finitely presented modules","text":"Return true if the given module element is zero.","category":"page"},{"location":"AbstractAlgebra/module/","page":"Finitely presented modules","title":"Finitely presented modules","text":"number_of_generators(M::FPModule{T}) where T <: RingElement","category":"page"},{"location":"AbstractAlgebra/module/","page":"Finitely presented modules","title":"Finitely presented modules","text":"Return the number of generators of the module M in its current representation.","category":"page"},{"location":"AbstractAlgebra/module/","page":"Finitely presented modules","title":"Finitely presented modules","text":"gen(M::FPModule{T}, i::Int) where T <: RingElement","category":"page"},{"location":"AbstractAlgebra/module/","page":"Finitely presented modules","title":"Finitely presented modules","text":"Return the i-th generator (indexed from 1) of the module M.","category":"page"},{"location":"AbstractAlgebra/module/","page":"Finitely presented modules","title":"Finitely presented modules","text":"gens(M::FPModule{T}) where T <: RingElement","category":"page"},{"location":"AbstractAlgebra/module/","page":"Finitely presented modules","title":"Finitely presented modules","text":"Return a Julia array of the generators of the module M.","category":"page"},{"location":"AbstractAlgebra/module/","page":"Finitely presented modules","title":"Finitely presented modules","text":"rels(M::FPModule{T}) where T <: RingElement","category":"page"},{"location":"AbstractAlgebra/module/","page":"Finitely presented modules","title":"Finitely presented modules","text":"Return a Julia vector of all the relations between the generators of M. Each relation is given as an AbstractAlgebra row matrix.","category":"page"},{"location":"AbstractAlgebra/module/","page":"Finitely presented modules","title":"Finitely presented modules","text":"Examples","category":"page"},{"location":"AbstractAlgebra/module/","page":"Finitely presented modules","title":"Finitely presented modules","text":"julia> M = free_module(QQ, 2)\nVector space of dimension 2 over rationals\n\njulia> n = number_of_generators(M)\n2\n\njulia> G = gens(M)\n2-element Vector{AbstractAlgebra.Generic.FreeModuleElem{Rational{BigInt}}}:\n (1//1, 0//1)\n (0//1, 1//1)\n\njulia> R = rels(M)\nAbstractAlgebra.Generic.MatSpaceElem{Rational{BigInt}}[]\n\njulia> g1 = gen(M, 1)\n(1//1, 0//1)\n\njulia> !iszero(g1)\ntrue\n\njulia> M = free_module(QQ, 2)\nVector space of dimension 2 over rationals\n\njulia> z = zero(M)\n(0//1, 0//1)\n\njulia> iszero(z)\ntrue","category":"page"},{"location":"AbstractAlgebra/module/#Element-constructors","page":"Finitely presented modules","title":"Element constructors","text":"","category":"section"},{"location":"AbstractAlgebra/module/","page":"Finitely presented modules","title":"Finitely presented modules","text":"We can construct elements of a module M by specifying linear combinations of the generators of M. This is done by passing a vector of ring elements.","category":"page"},{"location":"AbstractAlgebra/module/","page":"Finitely presented modules","title":"Finitely presented modules","text":"(M::FPModule{T})(v::Vector{T}) where T <: RingElement","category":"page"},{"location":"AbstractAlgebra/module/","page":"Finitely presented modules","title":"Finitely presented modules","text":"Construct the element of the module M corresponding to sum_i givi where gi are the generators of the module M. The resulting element will lie in the module M.","category":"page"},{"location":"AbstractAlgebra/module/#Coercions","page":"Finitely presented modules","title":"Coercions","text":"","category":"section"},{"location":"AbstractAlgebra/module/","page":"Finitely presented modules","title":"Finitely presented modules","text":"Given a module M and an element n of a module N, it is possible to coerce n into M using the notation M(n) in certain circumstances.","category":"page"},{"location":"AbstractAlgebra/module/","page":"Finitely presented modules","title":"Finitely presented modules","text":"In particular the element n will be automatically coerced along any canonical injection of a submodule map and along any canonical projection of a quotient map. There must be a path from N to M along such maps.","category":"page"},{"location":"AbstractAlgebra/module/","page":"Finitely presented modules","title":"Finitely presented modules","text":"Examples","category":"page"},{"location":"AbstractAlgebra/module/","page":"Finitely presented modules","title":"Finitely presented modules","text":"F = free_module(ZZ, 3)\n\nS1, f = sub(F, [rand(F, -10:10)])\n\nS, g = sub(F, [rand(F, -10:10)])\nQ, h = quo(F, S)\n\nm = rand(S1, -10:10)\nn = Q(m)","category":"page"},{"location":"AbstractAlgebra/module/#Arithmetic-operators","page":"Finitely presented modules","title":"Arithmetic operators","text":"","category":"section"},{"location":"AbstractAlgebra/module/","page":"Finitely presented modules","title":"Finitely presented modules","text":"Elements of a module can be added, subtracted or multiplied by an element of the ring the module is defined over and compared for equality.","category":"page"},{"location":"AbstractAlgebra/module/","page":"Finitely presented modules","title":"Finitely presented modules","text":"In the case of a noncommutative ring, both left and right scalar multiplication are defined.","category":"page"},{"location":"AbstractAlgebra/module/#Basic-manipulation","page":"Finitely presented modules","title":"Basic manipulation","text":"","category":"section"},{"location":"AbstractAlgebra/module/","page":"Finitely presented modules","title":"Finitely presented modules","text":"zero(M::FPModule)","category":"page"},{"location":"AbstractAlgebra/module/","page":"Finitely presented modules","title":"Finitely presented modules","text":"Examples","category":"page"},{"location":"AbstractAlgebra/module/","page":"Finitely presented modules","title":"Finitely presented modules","text":"julia> M = free_module(QQ, 2)\nVector space of dimension 2 over rationals\n\njulia> z = zero(M)\n(0//1, 0//1)","category":"page"},{"location":"AbstractAlgebra/module/#Element-indexing","page":"Finitely presented modules","title":"Element indexing","text":"","category":"section"},{"location":"AbstractAlgebra/module/","page":"Finitely presented modules","title":"Finitely presented modules","text":"Base.getindex(m::FPModuleElem{T}) where T <: RingElement","category":"page"},{"location":"AbstractAlgebra/module/#getindex-Union{Tuple{AbstractAlgebra.FPModuleElem{T}}, Tuple{T}} where T<:RingElement","page":"Finitely presented modules","title":"getindex","text":"getindex(a::Fac, b) -> Int\n\nIf b is a factor of a, the corresponding exponent is returned. Otherwise an error is thrown.\n\n\n\n\n\ngetindex(A::SMat, i::Int, j::Int)\n\nGiven a sparse matrix A = (a_ij)_i j, return the entry a_ij.\n\n\n\n\n\ngetindex(A::SMat, i::Int) -> SRow\n\nGiven a sparse matrix A and an index i, return the i-th row of A.\n\n\n\n\n\n","category":"method"},{"location":"AbstractAlgebra/module/","page":"Finitely presented modules","title":"Finitely presented modules","text":"Examples","category":"page"},{"location":"AbstractAlgebra/module/","page":"Finitely presented modules","title":"Finitely presented modules","text":"julia> F = free_module(ZZ, 3)\nFree module of rank 3 over integers\n\njulia> m = F(BigInt[2, -5, 4])\n(2, -5, 4)\n\njulia> m[1]\n2","category":"page"},{"location":"AbstractAlgebra/module/#Module-comparison","page":"Finitely presented modules","title":"Module comparison","text":"","category":"section"},{"location":"AbstractAlgebra/module/","page":"Finitely presented modules","title":"Finitely presented modules","text":"==(::FPModule{T}, ::FPModule{T}) where T <: RingElement","category":"page"},{"location":"AbstractAlgebra/module/#==-Union{Tuple{T}, Tuple{AbstractAlgebra.FPModule{T}, AbstractAlgebra.FPModule{T}}} where T<:RingElement","page":"Finitely presented modules","title":"==","text":"==(M::FPModule{T}, N::FPModule{T}) where T <: RingElement\n\nReturn true if the modules are (constructed to be) the same module elementwise. This is not object equality and it is not isomorphism. In fact, each method of constructing modules (submodules, quotient modules, products, etc.) must extend this notion of equality to the modules they create.\n\n\n\n\n\n","category":"method"},{"location":"AbstractAlgebra/module/","page":"Finitely presented modules","title":"Finitely presented modules","text":"Examples","category":"page"},{"location":"AbstractAlgebra/module/","page":"Finitely presented modules","title":"Finitely presented modules","text":"julia> M = free_module(QQ, 2)\nVector space of dimension 2 over rationals\n\njulia> M == M\ntrue\n","category":"page"},{"location":"AbstractAlgebra/module/#Isomorphism","page":"Finitely presented modules","title":"Isomorphism","text":"","category":"section"},{"location":"AbstractAlgebra/module/","page":"Finitely presented modules","title":"Finitely presented modules","text":"is_isomorphic(::FPModule{T}, ::FPModule{T}) where T <: RingElement","category":"page"},{"location":"AbstractAlgebra/module/#is_isomorphic-Union{Tuple{T}, Tuple{AbstractAlgebra.FPModule{T}, AbstractAlgebra.FPModule{T}}} where T<:RingElement","page":"Finitely presented modules","title":"is_isomorphic","text":"is_isomorphic(M::FPModule{T}, N::FPModule{T}) where T <: RingElement\n\nReturn true if the modules M and N are isomorphic.\n\n\n\n\n\n","category":"method"},{"location":"AbstractAlgebra/module/","page":"Finitely presented modules","title":"Finitely presented modules","text":"note: Note\nNote that this function relies on the Smith normal form over the base ring of the modules being able to be made unique. This is true for Euclidean domains for which divrem has a fixed choice of quotient and remainder, but it will not in general be true for Euclidean rings that are not domains.","category":"page"},{"location":"AbstractAlgebra/module/","page":"Finitely presented modules","title":"Finitely presented modules","text":"Examples","category":"page"},{"location":"AbstractAlgebra/module/","page":"Finitely presented modules","title":"Finitely presented modules","text":"julia> M = free_module(ZZ, 3)\nFree module of rank 3 over integers\n\njulia> m1 = rand(M, -10:10)\n(3, -1, 0)\n\njulia> m2 = rand(M, -10:10)\n(4, 4, -7)\n\njulia> S, f = sub(M, [m1, m2])\n(Submodule over integers with 2 generators and no relations, Hom: S -> M)\n\njulia> I, g = image(f)\n(Submodule over integers with 2 generators and no relations, Hom: I -> M)\n\njulia> is_isomorphic(S, I)\ntrue\n","category":"page"},{"location":"AbstractAlgebra/module/#Invariant-Factor-Decomposition","page":"Finitely presented modules","title":"Invariant Factor Decomposition","text":"","category":"section"},{"location":"AbstractAlgebra/module/","page":"Finitely presented modules","title":"Finitely presented modules","text":"For modules over a euclidean domain one can take the invariant factor decomposition to determine the structure of the module. The invariant factors are unique up to multiplication by a unit, and even unique if a  canonical_unit is available for the ring that canonicalises elements.","category":"page"},{"location":"AbstractAlgebra/module/","page":"Finitely presented modules","title":"Finitely presented modules","text":"snf(::FPModule{T}) where T <: RingElement\ninvariant_factors(::FPModule{T}) where T <: RingElement","category":"page"},{"location":"AbstractAlgebra/module/#snf-Union{Tuple{AbstractAlgebra.FPModule{T}}, Tuple{T}} where T<:RingElement","page":"Finitely presented modules","title":"snf","text":"snf(m::FPModule{T}) where T <: RingElement\n\nReturn a pair M, f consisting of the invariant factor decomposition M of the module m and a module homomorphism (isomorphisms) f  M to m. The module M is itself a module which can be manipulated as any other module in the system.\n\n\n\n\n\n","category":"method"},{"location":"AbstractAlgebra/module/#invariant_factors-Union{Tuple{AbstractAlgebra.FPModule{T}}, Tuple{T}} where T<:RingElement","page":"Finitely presented modules","title":"invariant_factors","text":"invariant_factors(m::FPModule{T}) where T <: RingElement\n\nReturn a vector of the invariant factors of the module M.\n\n\n\n\n\n","category":"method"},{"location":"AbstractAlgebra/module/","page":"Finitely presented modules","title":"Finitely presented modules","text":"Examples","category":"page"},{"location":"AbstractAlgebra/module/","page":"Finitely presented modules","title":"Finitely presented modules","text":"julia> M = free_module(ZZ, 3)\nFree module of rank 3 over integers\n\njulia> m1 = rand(M, -10:10)\n(3, -1, 0)\n\njulia> m2 = rand(M, -10:10)\n(4, 4, -7)\n\njulia> S, f = sub(M, [m1, m2])\n(Submodule over integers with 2 generators and no relations, Hom: S -> M)\n\njulia> Q, g = quo(M, S)\n(Quotient module over integers with 2 generators and relations:\n[16 -21], Hom: M -> Q)\n\njulia> I, f = snf(Q)\n(Invariant factor decomposed module over integers with invariant factors BigInt[0], Hom: I -> Q)\n\njulia> invs = invariant_factors(Q)\n1-element Vector{BigInt}:\n 0\n","category":"page"},{"location":"Groups/pcgroup/","page":"Polycyclic groups","title":"Polycyclic groups","text":"CurrentModule = Oscar\nDocTestSetup = Oscar.doctestsetup()","category":"page"},{"location":"Groups/pcgroup/#Polycyclic-groups","page":"Polycyclic groups","title":"Polycyclic groups","text":"","category":"section"},{"location":"Groups/pcgroup/","page":"Polycyclic groups","title":"Polycyclic groups","text":"PcGroup\nPcGroupElem\nmap_word(g::Union{PcGroupElem, SubPcGroupElem}, genimgs::Vector; genimgs_inv::Vector = Vector(undef, length(genimgs)), init = nothing)","category":"page"},{"location":"Groups/pcgroup/#PcGroup","page":"Polycyclic groups","title":"PcGroup","text":"PcGroup\n\nPolycyclic group, a group that is defined by a finite presentation of a special kind, a so-called polycyclic presentation. Contrary to arbitrary finitely presented groups (see Finitely presented groups), this presentation allows for efficient computations with the group elements.\n\nFor a group G of type PcGroup, the elements in gens(G) satisfy the relators of the underlying presentation.\n\nFunctions that compute subgroups of G return groups of type SubPcGroup.\n\nExamples\n\ncyclic_group(n::Int): cyclic group of order n\nabelian_group(PcGroup, v::Vector{Int}): direct product of cyclic groups of the orders v[1], v[2], ..., v[length(v)]\n\n\n\n\n\n","category":"type"},{"location":"Groups/pcgroup/#PcGroupElem","page":"Polycyclic groups","title":"PcGroupElem","text":"PcGroupElem\n\nElement of a polycyclic group.\n\nThe generators of a polycyclic group are displayed as f1, f2, f3, etc., and every element of a polycyclic group is displayed as product of the generators.\n\nExamples\n\njulia> G = abelian_group(PcGroup, [2, 3]);\n\njulia> G[1], G[2]\n(f1, f2)\n\njulia> G[2]*G[1]\nf1*f2\n\nNote that this does not define Julia variables named f1, f2, etc.! To get the generators of the group G, use gens(G); for convenience they can also be accessed as G[1], G[2], as shown in Section Elements of groups.\n\n\n\n\n\n","category":"type"},{"location":"Groups/pcgroup/#map_word-Tuple{Union{PcGroupElem, SubPcGroupElem}, Vector}","page":"Polycyclic groups","title":"map_word","text":"map_word(g::Union{PcGroupElem, SubPcGroupElem}, genimgs::Vector; genimgs_inv::Vector = Vector(undef, length(genimgs)), init = nothing)\n\nReturn the product R_1 R_2 cdots R_n that is described by g, which is a product of the form g_i_1^e_1 g_i_2^e_2 cdots g_i_n^e_n where g_i is the i-th entry in the defining polycyclic generating sequence of full_group(parent(g)) and the e_i are nonzero integers, and R_j = imgs[i_j]^e_j.\n\nExamples\n\njulia> G = dihedral_group(10)\nPc group of order 10\n\njulia> x, y = gens(G);  g = x * y^4\nf1*f2^4\n\njulia> map_word(g, gens(free_group(:x, :y)))\nx*y^4\n\n\n\n\n\n","category":"method"},{"location":"Groups/pcgroup/","page":"Polycyclic groups","title":"Polycyclic groups","text":"Julia has the following functions that allow to generate polycyclic groups:","category":"page"},{"location":"Groups/pcgroup/","page":"Polycyclic groups","title":"Polycyclic groups","text":"abelian_group(::Type{T}, v::Vector{Int}) where T <: GAPGroup\nelementary_abelian_group\ncyclic_group\ndihedral_group\nquaternion_group","category":"page"},{"location":"Groups/pcgroup/#abelian_group-Union{Tuple{T}, Tuple{Type{T}, Vector{Int64}}} where T<:Oscar.GAPGroup","page":"Polycyclic groups","title":"abelian_group","text":"abelian_group(::Type{T} = PcGroup, v::Vector{S}) where T <: Group where S <: IntegerUnion\n\nReturn the direct product of cyclic groups of the orders v[1], v[2], ldots, v[n], as an instance of T. Here, T must be one of PermGroup, FPGroup, SubFPGroup, PcGroup, or SubPcGroup.\n\nThe gens value of the returned group corresponds to v, that is, the number of generators is equal to length(v) and the order of the i-th generator is v[i].\n\nwarning: Warning\nThe type need to be specified in the input of the function abelian_group, otherwise a group of type FinGenAbGroup is returned, which is not a GAP group type. In future versions of Oscar, this may change.\n\n\n\n\n\n","category":"method"},{"location":"Groups/pcgroup/#elementary_abelian_group","page":"Polycyclic groups","title":"elementary_abelian_group","text":"elementary_abelian_group(::Type{T} = PcGroup, n::S) where T <: Group where S <: IntegerUnion\n\nReturn the elementary abelian group group of order n, as an instance of T. Here, T must be one of PermGroup, FPGroup, SubFPGroup, PcGroup, SubPcGroup, or FinGenAbGroup, and n must be a prime power or 1.\n\nThe gens vector of the result has minimal length.\n\nExamples\n\njulia> g = elementary_abelian_group(27)\nPc group of order 27\n\njulia> g = elementary_abelian_group(PermGroup, 27)\nPermutation group of degree 9 and order 27\n\n\n\n\n\n","category":"function"},{"location":"Groups/pcgroup/#cyclic_group","page":"Polycyclic groups","title":"cyclic_group","text":"cyclic_group(::Type{T} = PcGroup, n::IntegerUnion)\ncyclic_group(::Type{T} = PcGroup, n::PosInf)\n\nReturn the cyclic group of order n, as an instance of type T.\n\nExamples\n\njulia> G = cyclic_group(5)\nPc group of order 5\n\njulia> G = cyclic_group(PermGroup, 5)\nPermutation group of degree 5 and order 5\n\njulia> G = cyclic_group(PosInf())\nPc group of infinite order\n\n\n\n\n\n\n","category":"function"},{"location":"Groups/pcgroup/#dihedral_group","page":"Polycyclic groups","title":"dihedral_group","text":"dihedral_group(::Type{T} = PcGroup, n::Union{IntegerUnion,PosInf})\n\nReturn the dihedral group of order n, as an instance of T, where T is in {PcGroup, SubPcGroup, PermGroup, FPGroup, SubFPGroup}.\n\nwarning: Warning\nThere are two competing conventions for interpreting the argument n: In the one we use, the returned group has order n, and thus n must always be even. In the other, n indicates that the group describes the symmetry of an n-gon, and thus the group has order 2n.\n\nExamples\n\njulia> dihedral_group(6)\nPc group of order 6\n\njulia> dihedral_group(PermGroup, 6)\nPermutation group of degree 3\n\njulia> dihedral_group(PosInf())\nPc group of infinite order\n\njulia> dihedral_group(7)\nERROR: ArgumentError: n must be a positive even integer or infinity\n\n\n\n\n\n","category":"function"},{"location":"Groups/pcgroup/#quaternion_group","page":"Polycyclic groups","title":"quaternion_group","text":"quaternion_group(::Type{T} = PcGroup, n::IntegerUnion)\n\nReturn the (generalized) quaternion group of order n, as an instance of T, where n is a power of 2 and T is in {PcGroup, SubPcGroup, PermGroup,FPGroup, SubFPGroup}.\n\nExamples\n\njulia> g = quaternion_group(8)\nPc group of order 8\n\njulia> quaternion_group(PermGroup, 8)\nPermutation group of degree 8\n\njulia> g = quaternion_group(FPGroup, 8)\nFinitely presented group of order 8\n\njulia> relators(g)\n3-element Vector{FPGroupElem}:\n r^2*s^-2\n s^4\n r^-1*s*r*s\n\n\n\n\n\n\n","category":"function"},{"location":"Combinatorics/graphs/","page":"Graphs","title":"Graphs","text":"CurrentModule = Oscar","category":"page"},{"location":"Combinatorics/graphs/#Graphs","page":"Graphs","title":"Graphs","text":"","category":"section"},{"location":"Combinatorics/graphs/#Introduction","page":"Graphs","title":"Introduction","text":"","category":"section"},{"location":"Combinatorics/graphs/","page":"Graphs","title":"Graphs","text":"Graphs are a fundamental object within all of mathematics and computer science. A graph consists of two sets of data:","category":"page"},{"location":"Combinatorics/graphs/","page":"Graphs","title":"Graphs","text":"a finite set V = 1ldotsn of vertices; and\na finite set E subseteq Vtimes V of edges.","category":"page"},{"location":"Combinatorics/graphs/","page":"Graphs","title":"Graphs","text":"There are two types of graphs, directed and undirected. For a directed graph the elements of E are considered to be ordered pairs, for an undirected graph the elements of E are unordered pairs or rather sets with two elements.","category":"page"},{"location":"Combinatorics/graphs/","page":"Graphs","title":"Graphs","text":"The interface is modeled alongside the Graphs.jl interface to allow for easier integration elsewhere.","category":"page"},{"location":"Combinatorics/graphs/","page":"Graphs","title":"Graphs","text":"warning: Warning\nThe mechanism for removing a vertex is slightly different in out implementation to the Graphs.jl implementation: In Graphs.jl first the vertex to be removed is swapped with the last vertex, then the last vertex is removed. In our implementation, the vertex is removed and all subsequent vertices have their labels changed. Hence edges can be different in the two implementations after removing a vertex.","category":"page"},{"location":"Combinatorics/graphs/#Construction","page":"Graphs","title":"Construction","text":"","category":"section"},{"location":"Combinatorics/graphs/","page":"Graphs","title":"Graphs","text":"Graph{T}(nverts::Int64) where {T <: Union{Directed, Undirected}}\ndual_graph(p::Polyhedron)\nvertex_edge_graph(p::Polyhedron; modulo_lineality=false)\ngraph_from_adjacency_matrix\ngraph_from_edges","category":"page"},{"location":"Combinatorics/graphs/#Graph-Union{Tuple{Int64}, Tuple{T}} where T<:Union{Directed, Undirected}","page":"Graphs","title":"Graph","text":"Graph{T}(nverts::Int64) where {T <: Union{Directed, Undirected}}\n\nConstruct a graph on nverts vertices and no edges. T indicates whether the graph should be Directed or Undirected.\n\nExamples\n\nMake a directed graph with 5 vertices and print the number of nodes and edges.\n\njulia> g = Graph{Directed}(5);\n\njulia> n_vertices(g)\n5\n\njulia> n_edges(g)\n0\n\n\n\n\n\n","category":"method"},{"location":"Combinatorics/graphs/#dual_graph-Tuple{Polyhedron}","page":"Graphs","title":"dual_graph","text":"dual_graph(p::Polyhedron)\n\nReturn the dual graph of a Polyhedron, vertices of the graph correspond to facets of the polyhedron and there is an edge between two vertices if the corresponding facets are neighboring, meaning their intersection is a codimension 2 face of the polyhedron.\n\nFor bounded polyhedra containing 0 in the interior this is the same as the edge graph the polar dual polyhedron.\n\nExamples\n\nConstruct the dual graph of the cube. This is the same as the edge graph of the octahedron, so it has 6 vertices and 12 edges.\n\njulia> c = cube(3);\n\njulia> g = dual_graph(c);\n\njulia> n_vertices(g)\n6\n\njulia> n_edges(g)\n12\n\n\n\n\n\n","category":"method"},{"location":"Combinatorics/graphs/#vertex_edge_graph-Tuple{Polyhedron}","page":"Graphs","title":"vertex_edge_graph","text":"vertex_edge_graph(p::Polyhedron)\n\nReturn the edge graph of a Polyhedron, vertices of the graph correspond to vertices of the polyhedron, there is an edge between two vertices if the polyhedron has an edge between the corresponding vertices. The resulting graph is Undirected. If the polyhedron has lineality, then it has no vertices or bounded edges, so the vertex_edge_graph will be the empty graph. In this case, the keyword argument can be used to consider the polyhedron modulo its lineality space.\n\nExamples\n\nConstruct the edge graph of the cube. Like the cube it has 8 vertices and 12 edges.\n\njulia> c = cube(3);\n\njulia> g = vertex_edge_graph(c);\n\njulia> n_vertices(g)\n8\n\njulia> n_edges(g)\n12\n\n\n\n\n\n","category":"method"},{"location":"Combinatorics/graphs/#graph_from_adjacency_matrix","page":"Graphs","title":"graph_from_adjacency_matrix","text":"graph_from_adjacency_matrix(::Type{T}, G) where {T <:Union{Directed, Undirected}}\n\nReturn the graph with adjacency matrix G.\n\nThis means that the nodes i j are connected by an edge if and only if G_ij is one. In the undirected case, it is assumed that i  j i.e. the upper triangular part of G is ignored.\n\nExamples\n\njulia> G = ZZ[0 0; 1 0]\n[0   0]\n[1   0]\n\njulia> graph_from_adjacency_matrix(Directed, G)\nDirected graph with 2 nodes and the following edges:\n(2, 1)\n\njulia> graph_from_adjacency_matrix(Undirected, G)\nUndirected graph with 2 nodes and the following edges:\n(2, 1)\n\n\n\n\n\n\n","category":"function"},{"location":"Combinatorics/graphs/#graph_from_edges","page":"Graphs","title":"graph_from_edges","text":"graph_from_edges(edges::Vector{Vector{Int}})\ngraph_from_edges(::Type{T}, edges::Vector{Vector{Int}}, n_vertices::Int=-1) where {T <:Union{Directed, Undirected}}\n\nCreates a graph from a vector of edges. There is an optional input for number of vertices, graph_from_edges  will ignore any negative integers and throw an error when the input is less than the maximum vertex index in edges.\n\nExamples\n\njulia> G = graph_from_edges([[1,3],[3,5],[4,5],[2,4],[2,3]])\nUndirected graph with 5 nodes and the following edges:\n(3, 1)(3, 2)(4, 2)(5, 3)(5, 4)\n\njulia> G = graph_from_edges(Directed, [[1,3]], 4)\nDirected graph with 4 nodes and the following edges:\n(1, 3)\n\n\n\n\n\n","category":"function"},{"location":"Combinatorics/graphs/#Modifying-graphs","page":"Graphs","title":"Modifying graphs","text":"","category":"section"},{"location":"Combinatorics/graphs/","page":"Graphs","title":"Graphs","text":"add_edge!(g::Graph{T}, source::Int64, target::Int64) where {T <: Union{Directed, Undirected}}\nadd_vertices!(g::Graph{T}, n::Int64) where {T <: Union{Directed, Undirected}}\nadd_vertex!(g::Graph{T}) where {T <: Union{Directed, Undirected}}\nrem_edge!(g::Graph{T}, s::Int64, t::Int64) where {T <: Union{Directed, Undirected}}\nrem_vertex!(g::Graph{T}, v::Int64) where {T <: Union{Directed, Undirected}}\nrem_vertices!(g::Graph{T}, a::AbstractVector{Int64}) where {T <: Union{Directed, Undirected}}","category":"page"},{"location":"Combinatorics/graphs/#add_edge!-Union{Tuple{T}, Tuple{Graph{T}, Int64, Int64}} where T<:Union{Directed, Undirected}","page":"Graphs","title":"add_edge!","text":"add_edge!(g::Graph{T}, s::Int64, t::Int64) where {T <: Union{Directed, Undirected}}\n\nAdd edge (s,t) to the graph g. Return true if a new edge (s,t) was added, false otherwise.\n\nExamples\n\njulia> g = Graph{Directed}(2);\n\njulia> add_edge!(g, 1, 2)\ntrue\n\njulia> add_edge!(g, 1, 2)\nfalse\n\njulia> n_edges(g)\n1\n\n\n\n\n\n","category":"method"},{"location":"Combinatorics/graphs/#add_vertices!-Union{Tuple{T}, Tuple{Graph{T}, Int64}} where T<:Union{Directed, Undirected}","page":"Graphs","title":"add_vertices!","text":"add_vertices!(g::Graph{T}, n::Int64) where {T <: Union{Directed, Undirected}}\n\nAdd a n new vertices to the graph g. Return the number of vertices that were actually added to the graph g.\n\nExamples\n\njulia> g = Graph{Directed}(2);\n\njulia> n_vertices(g)\n2\n\njulia> add_vertices!(g, 5);\n\njulia> n_vertices(g)\n7\n\n\n\n\n\n","category":"method"},{"location":"Combinatorics/graphs/#add_vertex!-Union{Tuple{Graph{T}}, Tuple{T}} where T<:Union{Directed, Undirected}","page":"Graphs","title":"add_vertex!","text":"add_vertex!(g::Graph{T}) where {T <: Union{Directed, Undirected}}\n\nAdd a vertex to the graph g. Return true if there a new vertex was actually added.\n\nExamples\n\njulia> g = Graph{Directed}(2);\n\njulia> n_vertices(g)\n2\n\njulia> add_vertex!(g)\ntrue\n\njulia> n_vertices(g)\n3\n\n\n\n\n\n","category":"method"},{"location":"Combinatorics/graphs/#rem_edge!-Union{Tuple{T}, Tuple{Graph{T}, Int64, Int64}} where T<:Union{Directed, Undirected}","page":"Graphs","title":"rem_edge!","text":"rem_edge!(g::Graph{T}, s::Int64, t::Int64) where {T <: Union{Directed, Undirected}}\nrem_edge!(g::Graph{T}, e::Edge) where {T <: Union{Directed, Undirected}}\n\nRemove edge (s,t) from the graph g. Return true if there was an edge from s to t and it got removed, false otherwise.\n\nExamples\n\njulia> g = Graph{Directed}(2);\n\njulia> add_edge!(g, 1, 2)\ntrue\n\njulia> n_edges(g)\n1\n\njulia> rem_edge!(g, 1, 2)\ntrue\n\njulia> n_edges(g)\n0\n\n\n\n\n\n","category":"method"},{"location":"Combinatorics/graphs/#rem_vertex!-Union{Tuple{T}, Tuple{Graph{T}, Int64}} where T<:Union{Directed, Undirected}","page":"Graphs","title":"rem_vertex!","text":"rem_vertex!(g::Graph{T}, v::Int64) where {T <: Union{Directed, Undirected}}\n\nRemove the vertex v from the graph g. Return true if node v existed and was actually removed, false otherwise. Please note that this will shift the indices of the vertices with index larger than v, but it will preserve the vertex ordering.\n\nExamples\n\njulia> g = Graph{Directed}(2);\n\njulia> n_vertices(g)\n2\n\njulia> rem_vertex!(g, 1)\ntrue\n\njulia> n_vertices(g)\n1\n\n\n\n\n\n","category":"method"},{"location":"Combinatorics/graphs/#rem_vertices!-Union{Tuple{T}, Tuple{Graph{T}, AbstractVector{Int64}}} where T<:Union{Directed, Undirected}","page":"Graphs","title":"rem_vertices!","text":"rem_vertices!(g::Graph{T}, a::AbstractArray{Int64}) where {T <: Union{Directed, Undirected}}\n\nRemove the vertices in a from the graph g. Return true if at least one vertex was removed. Please note that this will shift the indices of some of the remaining vertices, but it will preserve the vertex ordering.\n\nExamples\n\njulia> g = Graph{Directed}(2);\n\njulia> n_vertices(g)\n2\n\njulia> rem_vertices!(g, [1, 2])\ntrue\n\njulia> n_vertices(g)\n0\n\n\n\n\n\n","category":"method"},{"location":"Combinatorics/graphs/#Auxiliary-functions","page":"Graphs","title":"Auxiliary functions","text":"","category":"section"},{"location":"Combinatorics/graphs/","page":"Graphs","title":"Graphs","text":"adjacency_matrix(g::Graph)\nall_neighbors(g::Graph{T}, v::Int64) where {T <: Union{Directed, Undirected}}\nautomorphism_group_generators(g::Graph{T}) where {T <: Union{Directed, Undirected}}\ncomplete_graph(n::Int64)\ncomplete_bipartite_graph(n::Int64, m::Int64)\ndegree(g::Graph, v::Int)\nedges(g::Graph{T}) where {T <: Union{Directed, Undirected}}\nhas_edge(g::Graph{T}, source::Int64, target::Int64) where {T <: Union{Directed, Undirected}}\nhas_vertex(g::Graph{T}, v::Int64) where {T <: Union{Directed, Undirected}}\nlaplacian_matrix(g::Graph)\nn_edges(g::Graph{T}) where {T <: Union{Directed, Undirected}}\nn_vertices(g::Graph{T}) where {T <: Union{Directed, Undirected}}\ninneighbors(g::Graph{T}, v::Int64) where {T <: Union{Directed, Undirected}}\nneighbors(g::Graph{T}, v::Int64) where {T <: Union{Directed, Undirected}}\noutneighbors(g::Graph{T}, v::Int64) where {T <: Union{Directed, Undirected}}\nshortest_path_dijkstra\nis_isomorphic(g1::Graph{T}, g2::Graph{T}) where {T <: Union{Directed, Undirected}}\nis_isomorphic_with_permutation(G1::Graph, G2::Graph)","category":"page"},{"location":"Combinatorics/graphs/#adjacency_matrix-Tuple{Graph}","page":"Graphs","title":"adjacency_matrix","text":"adjacency_matrix(g::Graph{T}) where {T <: Union{Directed, Undirected}}\n\nReturn an unsigned (boolean) adjacency matrix representing a graph g. If g is undirected, the adjacency matrix will be symmetric. For g being directed, the adjacency matrix has a 1 at (u,v) if there is an edge u->v.\n\nExamples\n\nAdjacency matrix for a directed graph:\n\njulia> G = Graph{Directed}(3)\nDirected graph with 3 nodes and no edges\n\njulia> add_edge!(G,1,3)\ntrue\n\njulia> add_edge!(G,1,2)\ntrue\n\njulia> adjacency_matrix(G)\n3×3 IncidenceMatrix\n[2, 3]\n[]\n[]\n\n\njulia> matrix(ZZ, adjacency_matrix(G))\n[0   1   1]\n[0   0   0]\n[0   0   0]\n\nAdjacency matrix for an undirected graph:\n\njulia> G = vertex_edge_graph(cube(2))\nUndirected graph with 4 nodes and the following edges:\n(2, 1)(3, 1)(4, 2)(4, 3)\n\njulia> adjacency_matrix(G)\n4×4 IncidenceMatrix\n[2, 3]\n[1, 4]\n[1, 4]\n[2, 3]\n\n\njulia> matrix(ZZ, adjacency_matrix(G))\n[0   1   1   0]\n[1   0   0   1]\n[1   0   0   1]\n[0   1   1   0]\n\n\n\n\n\n","category":"method"},{"location":"Combinatorics/graphs/#all_neighbors-Union{Tuple{T}, Tuple{Graph{T}, Int64}} where T<:Union{Directed, Undirected}","page":"Graphs","title":"all_neighbors","text":"all_neighbors(g::Graph{T}, v::Int64) where {T <: Union{Directed, Undirected}}\n\nReturn all vertices of a graph g that are connected to the vertex v via an edge, independent of the edge direction.\n\nExamples\n\njulia> g = Graph{Directed}(5);\n\njulia> add_edge!(g, 1, 3);\n\njulia> add_edge!(g, 3, 4);\n\njulia> all_neighbors(g, 3)\n2-element Vector{Int64}:\n 1\n 4\n\njulia> all_neighbors(g, 4)\n1-element Vector{Int64}:\n 3\n\n\n\n\n\n","category":"method"},{"location":"Combinatorics/graphs/#automorphism_group_generators-Union{Tuple{Graph{T}}, Tuple{T}} where T<:Union{Directed, Undirected}","page":"Graphs","title":"automorphism_group_generators","text":"automorphism_group_generators(g::Graph{T}) where {T <: Union{Directed, Undirected}}\n\nReturn generators of the automorphism group of the graph g.\n\nExamples\n\njulia> g = complete_graph(4);\n\njulia> automorphism_group_generators(g)\n3-element Vector{PermGroupElem}:\n (3,4)\n (2,3)\n (1,2)\n\n\n\n\n\n","category":"method"},{"location":"Combinatorics/graphs/#complete_graph-Tuple{Int64}","page":"Graphs","title":"complete_graph","text":"complete_graph(n::Int64)\n\nAssemble the undirected complete graph on n nodes.\n\nExamples\n\njulia> g = complete_graph(3);\n\njulia> collect(edges(g))\n3-element Vector{Edge}:\n Edge(2, 1)\n Edge(3, 1)\n Edge(3, 2)\n\n\n\n\n\n","category":"method"},{"location":"Combinatorics/graphs/#complete_bipartite_graph-Tuple{Int64, Int64}","page":"Graphs","title":"complete_bipartite_graph","text":"complete_bipartite_graph(n::Int64, m::Int64)\n\nAssemble the undirected complete bipartite graph between n and m nodes.\n\nExamples\n\njulia> g = complete_bipartite_graph(2,2);\n\njulia> collect(edges(g))\n4-element Vector{Edge}:\n Edge(3, 1)\n Edge(3, 2)\n Edge(4, 1)\n Edge(4, 2)\n\n\n\n\n\n","category":"method"},{"location":"Combinatorics/graphs/#degree-Tuple{Graph, Int64}","page":"Graphs","title":"degree","text":"degree(g::Graph{T} [, v::Int64]) where {T <: Union{Directed, Undirected}}\n\nReturn the degree of the vertex v in the graph g. If v is missing, return the list of degrees of all vertices.\n\nExamples\n\njulia> g = vertex_edge_graph(icosahedron());\n\njulia> degree(g, 1)\n5\n\n\n\n\n\n","category":"method"},{"location":"Combinatorics/graphs/#edges-Union{Tuple{Graph{T}}, Tuple{T}} where T<:Union{Directed, Undirected}","page":"Graphs","title":"edges","text":"edges(g::Graph{T}) where {T <: Union{Directed, Undirected}}\n\nReturn an iterator over the edges of the graph g.\n\nExamples\n\nA triangle has three edges.\n\njulia> triangle = simplex(2);\n\njulia> g = vertex_edge_graph(triangle);\n\njulia> collect(edges(g))\n3-element Vector{Edge}:\n Edge(2, 1)\n Edge(3, 1)\n Edge(3, 2)\n\n\n\n\n\n","category":"method"},{"location":"Combinatorics/graphs/#has_edge-Union{Tuple{T}, Tuple{Graph{T}, Int64, Int64}} where T<:Union{Directed, Undirected}","page":"Graphs","title":"has_edge","text":"has_edge(g::Graph{T}, source::Int64, target::Int64) where {T <: Union{Directed, Undirected}}\n\nCheck for an edge in a graph.\n\nExamples\n\nCheck for the edge 1to 2 in the edge graph of a triangle.\n\njulia> triangle = simplex(2);\n\njulia> g = vertex_edge_graph(triangle);\n\njulia> has_edge(g, 1, 2)\ntrue\n\n\n\n\n\n","category":"method"},{"location":"Combinatorics/graphs/#has_vertex-Union{Tuple{T}, Tuple{Graph{T}, Int64}} where T<:Union{Directed, Undirected}","page":"Graphs","title":"has_vertex","text":"has_vertex(g::Graph{T}, v::Int64) where {T <: Union{Directed, Undirected}}\n\nCheck for a vertex in a graph.\n\nExamples\n\nThe edge graph of a triangle only has 3 vertices.\n\njulia> triangle = simplex(2);\n\njulia> g = vertex_edge_graph(triangle);\n\njulia> has_vertex(g, 1)\ntrue\n\njulia> has_vertex(g, 4)\nfalse\n\n\n\n\n\n","category":"method"},{"location":"Combinatorics/graphs/#laplacian_matrix-Tuple{Graph}","page":"Graphs","title":"laplacian_matrix","text":"laplacian_matrix(g::Graph{T}) where {T <: Union{Directed, Undirected}}\n\nReturn the Laplacian matrix of the graph g. The Laplacian matrix of a graph can be written as the difference of D, where D is a quadratic matrix with the degrees of g on the diagonal, and the adjacency matrix of g. For an undirected graph, the Laplacian matrix is symmetric.\n\nExamples\n\njulia> G = vertex_edge_graph(cube(2))\nUndirected graph with 4 nodes and the following edges:\n(2, 1)(3, 1)(4, 2)(4, 3)\n\njulia> laplacian_matrix(G)\n[ 2   -1   -1    0]\n[-1    2    0   -1]\n[-1    0    2   -1]\n[ 0   -1   -1    2]\n\n\n\n\n\n","category":"method"},{"location":"Combinatorics/graphs/#n_edges-Union{Tuple{Graph{T}}, Tuple{T}} where T<:Union{Directed, Undirected}","page":"Graphs","title":"n_edges","text":"n_edges(g::Graph{T}) where {T <: Union{Directed, Undirected}}\n\nReturn the number of edges of a graph.\n\nExamples\n\nThe edge graph of the cube has 12 edges just like the cube itself.\n\njulia> c = cube(3);\n\njulia> g = vertex_edge_graph(c);\n\njulia> n_edges(g)\n12\n\n\n\n\n\n","category":"method"},{"location":"Combinatorics/graphs/#n_vertices-Union{Tuple{Graph{T}}, Tuple{T}} where T<:Union{Directed, Undirected}","page":"Graphs","title":"n_vertices","text":"n_vertices(g::Graph{T}) where {T <: Union{Directed, Undirected}}\n\nReturn the number of vertices of a graph.\n\nExamples\n\nThe edge graph of the cube has eight vertices, just like the cube itself.\n\njulia> c = cube(3);\n\njulia> g = vertex_edge_graph(c);\n\njulia> n_vertices(g)\n8\n\n\n\n\n\n","category":"method"},{"location":"Combinatorics/graphs/#inneighbors-Union{Tuple{T}, Tuple{Graph{T}, Int64}} where T<:Union{Directed, Undirected}","page":"Graphs","title":"inneighbors","text":"inneighbors(g::Graph{T}, v::Int64) where {T <: Union{Directed, Undirected}}\n\nReturn the vertices of a graph g that have an edge going towards v. For an undirected graph, all neighboring vertices are returned.\n\nExamples\n\njulia> g = Graph{Directed}(5);\n\njulia> add_edge!(g, 1, 3);\n\njulia> add_edge!(g, 3, 4);\n\njulia> inneighbors(g, 3)\n1-element Vector{Int64}:\n 1\n\njulia> inneighbors(g, 1)\nInt64[]\n\n\n\n\n\n","category":"method"},{"location":"Combinatorics/graphs/#neighbors-Union{Tuple{T}, Tuple{Graph{T}, Int64}} where T<:Union{Directed, Undirected}","page":"Graphs","title":"neighbors","text":"neighbors(g::Graph{T}, v::Int64) where {T <: Union{Directed, Undirected}}\n\nReturn the neighboring vertices of a vertex v in a graph g. If the graph is directed, the neighbors reachable via outgoing edges are returned.\n\nExamples\n\njulia> g = Graph{Directed}(5);\n\njulia> add_edge!(g, 1, 3);\n\njulia> add_edge!(g, 3, 4);\n\njulia> neighbors(g, 3)\n1-element Vector{Int64}:\n 4\n\n\n\n\n\n","category":"method"},{"location":"Combinatorics/graphs/#outneighbors-Union{Tuple{T}, Tuple{Graph{T}, Int64}} where T<:Union{Directed, Undirected}","page":"Graphs","title":"outneighbors","text":"outneighbors(g::Graph{T}, v::Int64) where {T <: Union{Directed, Undirected}}\n\nReturn the vertices of a graph g that are target of an edge coming from v. For an undirected graph, all neighboring vertices are returned.\n\nExamples\n\njulia> g = Graph{Directed}(5);\n\njulia> add_edge!(g, 1, 3);\n\njulia> add_edge!(g, 3, 4);\n\njulia> outneighbors(g, 3)\n1-element Vector{Int64}:\n 4\n\njulia> outneighbors(g, 4)\nInt64[]\n\n\n\n\n\n","category":"method"},{"location":"Combinatorics/graphs/#shortest_path_dijkstra","page":"Graphs","title":"shortest_path_dijkstra","text":"shortest_path_dijkstra(g::Graph{T}, s::Int64, t::Int64; reverse::Bool=false) where {T <: Union{Directed, Undirected}}\n\nCompute the shortest path between two vertices in a graph using Dijkstra's algorithm. All edges are set to have a length of 1. The optional parameter indicates whether the edges should be considered reversed.\n\nExamples\n\njulia> g = Graph{Directed}(3);\n\njulia> add_edge!(g, 1, 2);\n\njulia> add_edge!(g, 2, 3);\n\njulia> add_edge!(g, 3, 1);\n\njulia> shortest_path_dijkstra(g, 3, 1)\n2-element Vector{Int64}:\n 3\n 1\n\njulia> shortest_path_dijkstra(g, 1, 3)\n3-element Vector{Int64}:\n 1\n 2\n 3\n\njulia> shortest_path_dijkstra(g, 3, 1; reverse=true)\n3-element Vector{Int64}:\n 3\n 2\n 1\n\n\n\n\n\n","category":"function"},{"location":"Combinatorics/graphs/#is_isomorphic-Union{Tuple{T}, Tuple{Graph{T}, Graph{T}}} where T<:Union{Directed, Undirected}","page":"Graphs","title":"is_isomorphic","text":"is_isomorphic(g1::Graph{T}, g2::Graph{T}) where {T <: Union{Directed, Undirected}}\n\nChecks if the graph g1 is isomorphic to the graph g2.\n\nExamples\n\njulia> is_isomorphic(vertex_edge_graph(simplex(3)), dual_graph(simplex(3)))\ntrue\n\njulia> is_isomorphic(vertex_edge_graph(cube(3)), dual_graph(cube(3)))\nfalse\n\n\n\n\n\n","category":"method"},{"location":"Combinatorics/graphs/#is_isomorphic_with_permutation-Tuple{Graph, Graph}","page":"Graphs","title":"is_isomorphic_with_permutation","text":"is_isomorphic_with_permutation(G1::Graph, G2::Graph) -> Bool, Vector{Int}\n\nReturn whether G1 is isomorphic to G2 as well as a permutation of the nodes of G1 such that both graphs agree.\n\nExamples\n\njulia> is_isomorphic_with_permutation(vertex_edge_graph(simplex(3)), dual_graph(simplex(3)))\n(true, [1, 2, 3, 4])\n\n\n\n\n\n\n","category":"method"},{"location":"Combinatorics/graphs/#Edges","page":"Graphs","title":"Edges","text":"","category":"section"},{"location":"Combinatorics/graphs/","page":"Graphs","title":"Graphs","text":"dst(e::Edge)\nreverse(e::Edge)\nsrc(e::Edge)","category":"page"},{"location":"Combinatorics/graphs/#dst-Tuple{Edge}","page":"Graphs","title":"dst","text":"dst(e::Edge)\n\nReturn the destination of an edge.\n\nExamples\n\njulia> g = complete_graph(2);\n\njulia> E = collect(edges(g));\n\njulia> e = E[1]\nEdge(2, 1)\n\njulia> dst(e)\n1\n\n\n\n\n\n","category":"method"},{"location":"Combinatorics/graphs/#reverse-Tuple{Edge}","page":"Graphs","title":"reverse","text":"reverse(e::Edge)\n\nReturn the edge in the opposite direction of the edge e.\n\nExamples\n\njulia> g = complete_graph(2);\n\njulia> E = collect(edges(g));\n\njulia> e = E[1]\nEdge(2, 1)\n\njulia> reverse(e)\nEdge(1, 2)\n\n\n\n\n\n","category":"method"},{"location":"Combinatorics/graphs/#src-Tuple{Edge}","page":"Graphs","title":"src","text":"src(e::Edge)\n\nReturn the source of an edge.\n\nExamples\n\njulia> g = complete_graph(2);\n\njulia> E = collect(edges(g));\n\njulia> e = E[1]\nEdge(2, 1)\n\njulia> src(e)\n2\n\n\n\n\n\n","category":"method"},{"location":"Combinatorics/graphs/#Saving-and-loading","page":"Graphs","title":"Saving and loading","text":"","category":"section"},{"location":"Combinatorics/graphs/","page":"Graphs","title":"Graphs","text":"Objects of type Graph can be saved to a file and loaded with the methods load and save.  The file is in JSON format and contains the underlying polymake object. In particular, this file can now be read by both polymake and OSCAR.","category":"page"},{"location":"Combinatorics/graphs/#Quantum-Automorphisms","page":"Graphs","title":"Quantum Automorphisms","text":"","category":"section"},{"location":"Combinatorics/graphs/","page":"Graphs","title":"Graphs","text":"quantum_automorphism_group(G::Graph{Undirected})","category":"page"},{"location":"Combinatorics/graphs/#quantum_automorphism_group-Tuple{Graph{Undirected}}","page":"Graphs","title":"quantum_automorphism_group","text":"quantum_automorphism_group(G::Graph{Undirected})\n\nReturn the ideal that defines the quantum automorphism group of the undirected graph G.\n\nExamples\n\njulia> G = graph_from_edges([[1, 2], [2, 4]]);\n\njulia> qAut = quantum_automorphism_group(G);\n\njulia> length(gens(qAut))\n184\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/orders/elements/#Elements","page":"Elements","title":"Elements","text":"","category":"section"},{"location":"Hecke/manual/orders/elements/","page":"Elements","title":"Elements","text":"CurrentModule = Hecke","category":"page"},{"location":"Hecke/manual/orders/elements/","page":"Elements","title":"Elements","text":"Elements in orders have two representations: they can be viewed as elements in the mathbf Z^n giving the coefficients wrt to the order basis where they are elements in. On the other hand, as every order is in a field, they also have a representation as number field elements. Since, asymptotically, operations are more efficient in the field (due to fast polynomial arithmetic) than in the order, the primary representation is that as a field element.","category":"page"},{"location":"Hecke/manual/orders/elements/#Creation","page":"Elements","title":"Creation","text":"","category":"section"},{"location":"Hecke/manual/orders/elements/","page":"Elements","title":"Elements","text":"Elements are constructed either as linear combinations of basis elements or via explicit coercion. Elements will be of type AbsNumFieldOrderElem, the type if actually parametrized by the type of the surrounding field and the type of the field elements. E.g. the type of any element in any order of an absolute simple field will be AbsSimpleNumFieldOrderElem","category":"page"},{"location":"Hecke/manual/orders/elements/","page":"Elements","title":"Elements","text":"AbsNumFieldOrder","category":"page"},{"location":"Hecke/manual/orders/elements/#AbsNumFieldOrder","page":"Elements","title":"AbsNumFieldOrder","text":"  (O::NumFieldOrder)(a::NumFieldElem, check::Bool = true) -> NumFieldOrderElem\n\nGiven an element a of the ambient number field of mathcal O, this function coerces the element into mathcal O. It will be checked that a is contained in mathcal O if and only if check is true.\n\n\n\n\n\n  (O::NumFieldOrder)(a::NumFieldOrderElem, check::Bool = true) -> NumFieldOrderElem\n\nGiven an element a of some order in the ambient number field of mathcal O, this function coerces the element into mathcal O. It will be checked that a is contained in mathcal O if and only if check is true.\n\n\n\n\n\n  (O::NumFieldOrder)(a::IntegerUnion) -> NumFieldOrderElem\n\nGiven an element a of type ZZRingElem or Integer, this function coerces the element into mathcal O.\n\n\n\n\n\n  (O::AbsNumFieldOrder)(arr::Vector{ZZRingElem})\n\nReturns the element of mathcal O with coefficient vector arr.\n\n\n\n\n\n  (O::AbsNumFieldOrder)(arr::Vector{Integer})\n\nReturns the element of mathcal O with coefficient vector arr.\n\n\n\n\n\n","category":"type"},{"location":"Hecke/manual/orders/elements/#Basic-properties","page":"Elements","title":"Basic properties","text":"","category":"section"},{"location":"Hecke/manual/orders/elements/","page":"Elements","title":"Elements","text":"parent(::AbsSimpleNumFieldOrderElem)\nelem_in_nf(::AbsSimpleNumFieldOrderElem)\ncoordinates(::AbsSimpleNumFieldOrderElem)\ndiscriminant(::Vector{AbsSimpleNumFieldOrderElem})\n==(::AbsSimpleNumFieldOrderElem, ::AbsSimpleNumFieldOrderElem)","category":"page"},{"location":"Hecke/manual/orders/elements/#parent-Tuple{AbsSimpleNumFieldOrderElem}","page":"Elements","title":"parent","text":"parent(a::NumFieldOrderElem) -> NumFieldOrder\n\nReturns the order of which a is an element.\n\n\n\n\n\nparent(a::MatRingElem{T}) where T <: NCRingElement\n\nReturn the parent object of the given matrix.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/orders/elements/#elem_in_nf-Tuple{AbsSimpleNumFieldOrderElem}","page":"Elements","title":"elem_in_nf","text":"elem_in_nf(a::NumFieldOrderElem) -> NumFieldElem\n\nReturns the element a considered as an element of the ambient number field.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/orders/elements/#coordinates-Tuple{AbsSimpleNumFieldOrderElem}","page":"Elements","title":"coordinates","text":"coordinates(a::AbsNumFieldOrderElem) -> Vector{ZZRingElem}\n\nReturns the coefficient vector of a with respect to the basis of the order.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/orders/elements/#discriminant-Tuple{Vector{AbsSimpleNumFieldOrderElem}}","page":"Elements","title":"discriminant","text":"discriminant(B::Vector{NumFieldOrderElem})\n\nReturns the discriminant of the family B of algebraic numbers, i.e. det((tr(Bi*Bj))_i j)^2.\n\n\n\n\n\ndiscriminant(E::EllipticCurve) -> FieldElem\n\nReturn the discriminant of E.\n\n\n\n\n\ndiscriminant(C::HypellCrv{T}) -> T\n\nCompute the discriminant of C.\n\n\n\n\n\ndiscriminant(O::AlgssRelOrd)\n\nReturns the discriminant of O.\n\n\n\n\n\ndiscriminant(g::Vector)\n\nCompute the product of all differences of distinct elements in the array.    \n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/orders/elements/#==-Tuple{AbsSimpleNumFieldOrderElem, AbsSimpleNumFieldOrderElem}","page":"Elements","title":"==","text":"==(x::NumFieldOrderElem, y::NumFieldOrderElem) -> Bool\n\nReturns whether x and y are equal.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/orders/elements/#Arithmetic","page":"Elements","title":"Arithmetic","text":"","category":"section"},{"location":"Hecke/manual/orders/elements/","page":"Elements","title":"Elements","text":"All the usual arithmetic operatinos are defined:","category":"page"},{"location":"Hecke/manual/orders/elements/","page":"Elements","title":"Elements","text":"-(::NUmFieldOrdElem)\n+(::NumFieldOrderElem, ::NumFieldOrderElem)\n-(::NumFieldOrderElem, ::NumFieldOrderElem)\n*(::NumFieldOrderElem, ::NumFieldOrderElem)\n^(::NumFieldOrderElem, ::Int)\nmod(::AbsNumFieldOrderElem, ::Int)\nmod_sym(::NumFieldOrderElem, ::ZZRingElem)\npowermod(::AbsNumFieldOrderElem, ::ZZRingElem, ::Int)","category":"page"},{"location":"Hecke/manual/orders/elements/#Miscellaneous","page":"Elements","title":"Miscellaneous","text":"","category":"section"},{"location":"Hecke/manual/orders/elements/","page":"Elements","title":"Elements","text":"representation_matrix(::AbsNumFieldOrderElem)\nrepresentation_matrix(::AbsSimpleNumFieldOrderElem, ::AbsSimpleNumField)\ntr(::NumFieldOrderElem)\nnorm(::NumFieldOrderElem)\nabsolute_norm(::AbsNumFieldOrderElem)\nabsolute_tr(::AbsNumFieldOrderElem)\nrand(::AbsSimpleNumFieldOrder, ::Int)\nminkowski_map(::AbsSimpleNumFieldOrderElem, ::Int)\nconjugates_arb(::AbsSimpleNumFieldOrderElem, ::Int)\nconjugates_arb_log(::AbsSimpleNumFieldOrderElem, ::Int)\nt2(::AbsSimpleNumFieldOrderElem, ::Int)\nminpoly(::AbsSimpleNumFieldOrderElem)\ncharpoly(::AbsSimpleNumFieldOrderElem)\nfactor(::AbsSimpleNumFieldOrderElem)\ndenominator(a::NumFieldElem, O::RelNumFieldOrder)\ndiscriminant(::Vector{AbsNumFieldOrderElem})","category":"page"},{"location":"Hecke/manual/orders/elements/#representation_matrix-Tuple{AbsNumFieldOrderElem}","page":"Elements","title":"representation_matrix","text":"representation_matrix(a::AbsNumFieldOrderElem) -> ZZMatrix\n\nReturns the representation matrix of the element a.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/orders/elements/#representation_matrix-Tuple{AbsSimpleNumFieldOrderElem, AbsSimpleNumField}","page":"Elements","title":"representation_matrix","text":"representation_matrix(a::AbsNumFieldOrderElem, K::AbsSimpleNumField) -> FakeFmpqMat\n\nReturns the representation matrix of the element a considered as an element of the ambient number field K. It is assumed that K is the ambient number field of the order of a.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/orders/elements/#tr-Tuple{NumFieldOrderElem}","page":"Elements","title":"tr","text":"tr(a::NumFieldOrderElem)\n\nReturns the trace of a as an element of the base ring.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/orders/elements/#norm-Tuple{NumFieldOrderElem}","page":"Elements","title":"norm","text":"norm(a::NumFieldOrderElem)\n\nReturns the norm of a as an element in the base ring.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/orders/elements/#absolute_norm-Tuple{AbsNumFieldOrderElem}","page":"Elements","title":"absolute_norm","text":"absolute_norm(a::NumFieldOrderElem) -> ZZRingElem\n\nReturn the absolute norm as an integer.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/orders/elements/#absolute_tr-Tuple{AbsNumFieldOrderElem}","page":"Elements","title":"absolute_tr","text":"absolute_tr(a::NumFieldOrderElem) -> ZZRingElem\n\nReturn the absolute trace as an integer.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/orders/elements/#rand-Tuple{AbsSimpleNumFieldOrder, Int64}","page":"Elements","title":"rand","text":"rand(O::AbsSimpleNumFieldOrder, n::IntegerUnion) -> AbsNumFieldOrderElem\n\nComputes a coefficient vector with entries uniformly distributed in -ndotsc-101dotscn and returns the corresponding element of the order mathcal O.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/orders/elements/#minkowski_map-Tuple{AbsSimpleNumFieldOrderElem, Int64}","page":"Elements","title":"minkowski_map","text":"minkowski_map(a::NumFieldOrderElem, abs_tol::Int) -> Vector{ArbFieldElem}\n\nReturns the image of a under the Minkowski embedding. Every entry of the array returned is of type ArbFieldElem with radius less then 2^-abs_tol.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/orders/elements/#conjugates_arb-Tuple{AbsSimpleNumFieldOrderElem, Int64}","page":"Elements","title":"conjugates_arb","text":"conjugates_arb(x::NumFieldOrderElem, abs_tol::Int) -> Vector{AcbFieldElem}\n\nCompute the conjugates of x as elements of type AcbFieldElem. Recall that we order the complex conjugates sigma_r+1(x)sigma_r+2s(x) such that sigma_i(x) = overlinesigma_i + s(x) for r + 2 leq i leq r + s.\n\nEvery entry y of the array returned satisfies radius(real(y)) < 2^-abs_tol, radius(imag(y)) < 2^-abs_tol respectively.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/orders/elements/#conjugates_arb_log-Tuple{AbsSimpleNumFieldOrderElem, Int64}","page":"Elements","title":"conjugates_arb_log","text":"conjugates_arb_log(x::NumFieldOrderElem, abs_tol::Int) -> Vector{ArbFieldElem}\n\nReturns the elements (log(lvert sigma_1(x) rvert)dotsclog(lvertsigma_r(x) rvert) dotsc2log(lvert sigma_r+1(x) rvert)dotsc 2log(lvert sigma_r+s(x)rvert)) as elements of type ArbFieldElem radius less then 2^-abs_tol.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/orders/elements/#t2-Tuple{AbsSimpleNumFieldOrderElem, Int64}","page":"Elements","title":"t2","text":"t2(x::NumFieldOrderElem, abs_tol::Int = 32) -> ArbFieldElem\n\nReturn the T_2-norm of x. The radius of the result will be less than 2^-abs_tol.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/orders/elements/#minpoly-Tuple{AbsSimpleNumFieldOrderElem}","page":"Elements","title":"minpoly","text":"minpoly(M::MatElem{T}, charpoly_only::Bool = false) where {T <: RingElement}\nminpoly(S::PolyRing{T}, M::MatElem{T}, charpoly_only::Bool = false) where {T <: RingElement}\n\nReturn the minimal polynomial p of the square matrix M. If a polynomial ring S over the same base ring as Y is supplied, the resulting polynomial is an element of it.\n\nExamples\n\njulia> R = GF(13)\nFinite field F_13\n\njulia> S, y = polynomial_ring(R, :y)\n(Univariate polynomial ring in y over R, y)\n\njulia> M = R[7 6 1;\n             7 7 5;\n             8 12 5]\n[7    6   1]\n[7    7   5]\n[8   12   5]\n\njulia> A = minpoly(S, M)\ny^2 + 10*y\n\njulia> A = minpoly(M)\nx^2 + 10*x\n\n\n\n\n\n\nminpoly(a::AbsNumFieldOrderElem) -> ZZPolyRingElem\n\nThe minimal polynomial of a.\n\n\n\n\n\nminpoly(S::Ring, M::MatRingElem{T}, charpoly_only::Bool = false) where {T <: RingElement}\n\nReturn the minimal polynomial p of the matrix M. The polynomial ring S of the resulting polynomial must be supplied and the matrix must be square.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/orders/elements/#charpoly-Tuple{AbsSimpleNumFieldOrderElem}","page":"Elements","title":"charpoly","text":"charpoly(Y::MatrixElem{T}) where {T <: RingElement}\ncharpoly(S::PolyRing{T}, Y::MatrixElem{T}) where {T <: RingElement}\n\nReturn the characteristic polynomial p of the square matrix Y. If a polynomial ring S over the same base ring as Y is supplied, the resulting polynomial is an element of it.\n\nExamples\n\njulia> R, = residue_ring(ZZ, 7);\n\njulia> S = matrix_space(R, 4, 4)\nMatrix space of 4 rows and 4 columns\n  over residue ring of integers modulo 7\n\njulia> T, y = polynomial_ring(R, :y)\n(Univariate polynomial ring in y over R, y)\n\njulia> M = S([R(1) R(2) R(4) R(3); R(2) R(5) R(1) R(0);\n              R(6) R(1) R(3) R(2); R(1) R(1) R(3) R(5)])\n[1   2   4   3]\n[2   5   1   0]\n[6   1   3   2]\n[1   1   3   5]\n\njulia> A = charpoly(T, M)\ny^4 + 2*y^2 + 6*y + 2\n\njulia> A = charpoly(M)\nx^4 + 2*x^2 + 6*x + 2\n\n\n\n\n\ncharpoly(a::AbsNumFieldOrderElem) -> ZZPolyRingElem\ncharpoly(a::AbsNumFieldOrderElem, ZZ) -> ZZPolyRingElem\n\nThe characteristic polynomial of a.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/orders/elements/#factor-Tuple{AbsSimpleNumFieldOrderElem}","page":"Elements","title":"factor","text":"factor(a::AbsSimpleNumFieldOrderElem) -> Fac{AbsSimpleNumFieldOrderElem}\n\nComputes a factorization of a into irreducible elements. The return value is a factorization fac, which satisfies a = unit(fac) * prod(p^e for (p, e) in fac).\n\nThe function requires that a is non-zero and that all prime ideals containing a are principal, which is for example satisfied if class group of the order of a is trivial.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/orders/elements/#denominator-Tuple{NumFieldElem, Hecke.RelNumFieldOrder}","page":"Elements","title":"denominator","text":"denominator(a::NumFieldElem, O::AbsSimpleNumFieldOrder) -> ZZRingElem\n\nReturns the smallest positive integer k such that k cdot a is contained in mathcal O.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/orders/elements/#discriminant-Tuple{Vector{AbsNumFieldOrderElem}}","page":"Elements","title":"discriminant","text":"discriminant(B::Vector{NumFieldOrderElem})\n\nReturns the discriminant of the family B of algebraic numbers, i.e. det((tr(Bi*Bj))_i j)^2.\n\n\n\n\n\ndiscriminant(E::EllipticCurve) -> FieldElem\n\nReturn the discriminant of E.\n\n\n\n\n\ndiscriminant(C::HypellCrv{T}) -> T\n\nCompute the discriminant of C.\n\n\n\n\n\ndiscriminant(O::AlgssRelOrd)\n\nReturns the discriminant of O.\n\n\n\n\n\ndiscriminant(g::Vector)\n\nCompute the product of all differences of distinct elements in the array.    \n\n\n\n\n\n","category":"method"},{"location":"CommutativeAlgebra/ModulesOverMultivariateRings/intro/","page":"Introduction","title":"Introduction","text":"CurrentModule = Oscar","category":"page"},{"location":"CommutativeAlgebra/ModulesOverMultivariateRings/intro/#modules_multivariate","page":"Introduction","title":"Introduction","text":"","category":"section"},{"location":"CommutativeAlgebra/ModulesOverMultivariateRings/intro/","page":"Introduction","title":"Introduction","text":"Our focus in this section is on finitely presented modules over rings from the following list:","category":"page"},{"location":"CommutativeAlgebra/ModulesOverMultivariateRings/intro/","page":"Introduction","title":"Introduction","text":"multivariate polynomial rings (OSCAR type MPolyRing),\nquotients of multivariate polynomial rings  (OSCAR type MPolyQuoRing), and\nlocalizations of the above rings (OSCAR types MPolyLocRing, MPolyQuoLocRing).","category":"page"},{"location":"CommutativeAlgebra/ModulesOverMultivariateRings/intro/","page":"Introduction","title":"Introduction","text":"Hence, if not mentioned otherwise, the word module refers to a finitely presented module over a ring of one of the above types. Offering a sparse way of implementing free modules, the OSCAR type FreeMod provides the basis for implementing all modules discussed here. More concretely, the general way of implementing a module is to represent it as a subquotient, that is, as a submodule of a quotient of a free module. Note that subquotients form the smallest class of modules which naturally  includes both submodules and quotients of free modules.","category":"page"},{"location":"CommutativeAlgebra/ModulesOverMultivariateRings/intro/","page":"Introduction","title":"Introduction","text":"note: Note\nMost functions in this section rely on Gröbner (standard) bases techniques. Thus, the functions should not be applied to modules over rings other than those from the list above. See the Linear Algebra chapter for module types which are designed to handle modules over Euclidean domains.","category":"page"},{"location":"CommutativeAlgebra/ModulesOverMultivariateRings/intro/","page":"Introduction","title":"Introduction","text":"note: Note\nFor simplicity of the presentation in what follows, functions are often only illustrated by examples   with focus on modules over multivariate polynomial rings, but work similarly for modules over a ring of any of the above types.","category":"page"},{"location":"Hecke/manual/number_fields/internal/","page":"Internals","title":"Internals","text":"CurrentModule = Hecke","category":"page"},{"location":"Hecke/manual/number_fields/internal/#Internals","page":"Internals","title":"Internals","text":"","category":"section"},{"location":"Hecke/manual/number_fields/internal/#Types-of-number-fields","page":"Internals","title":"Types of number fields","text":"","category":"section"},{"location":"Hecke/manual/number_fields/internal/","page":"Internals","title":"Internals","text":"Number fields, in Hecke, come in several different types:","category":"page"},{"location":"Hecke/manual/number_fields/internal/","page":"Internals","title":"Internals","text":"AbsSimpleNumField: a finite simple extension of the rational numbers mathbfQ\nAbsNonSimpleNumField: a finite extension of mathbfQ given by several polynomials. We will refer to this as a non-simple field - even though mathematically we can find a primitive elements.\nRelSimpleNumField: a finite simple extension of a number field. This is actually parametried by the (element) type of the coefficient field. The complete type of an extension of an absolute field (AbsSimpleNumField) is RelSimpleNumField{AbsSimpleNumFieldElem}. The next extension thus will be RelSimpleNumField{RelSimpleNumFieldElem{AbsSimpleNumFieldElem}}.\nRelNonSimpleNumField: extensions of number fields given by several polynomials.  This too will be referred to as a non-simple field.","category":"page"},{"location":"Hecke/manual/number_fields/internal/","page":"Internals","title":"Internals","text":"The simple types AbsSimpleNumField and RelSimpleNumField are also called simple fields in the rest of this document, RelSimpleNumField and RelNonSimpleNumField are referred to as relative extensions while AbsSimpleNumField and AbsNonSimpleNumField are called absolute.","category":"page"},{"location":"Hecke/manual/number_fields/internal/","page":"Internals","title":"Internals","text":"Internally, simple fields are essentially just (univariate) polynomial quotients in a dense representation, while non-simple fields are multivariate quotient rings, thus have a sparse presentation. In general, simple fields allow much faster arithmetic, while the non-simple fields give easy access to large degree fields.","category":"page"},{"location":"Hecke/manual/number_fields/internal/#Absolute-simple-fields","page":"Internals","title":"Absolute simple fields","text":"","category":"section"},{"location":"Hecke/manual/number_fields/internal/","page":"Internals","title":"Internals","text":"The most basic number field type is that of AbsSimpleNumField. Internally this is essentially represented as a unvariate quotient with the arithmetic provided by the C-library antic with the binding provided by Nemo.","category":"page"},{"location":"Rings/integer/","page":"Integers","title":"Integers","text":"CurrentModule = Oscar\nDocTestSetup = Oscar.doctestsetup()","category":"page"},{"location":"Rings/integer/#Integers","page":"Integers","title":"Integers","text":"","category":"section"},{"location":"Rings/integer/","page":"Integers","title":"Integers","text":"An important design decision in Oscar.jl is to use Julia as the user language by default. This means that integers typed at the REPL are Julia integers. However, for performance reasons, OSCAR has its own integer format.","category":"page"},{"location":"Rings/integer/","page":"Integers","title":"Integers","text":"Julia has a number of different integer types, but the two that are most relevant here are Int and BigInt. All the Julia integer types belong to Integer.","category":"page"},{"location":"Rings/integer/","page":"Integers","title":"Integers","text":"The Int type is for machine integers which are highly efficient, but can only represent integers up to a certain size, and most basic arithmetic operations are performed unchecked, that is, they can silently overflow. The Int type is the type of literal input such as 12, and should be used for loop control flow, array indices, and other situations where the overflow can be provably avoided.","category":"page"},{"location":"Rings/integer/","page":"Integers","title":"Integers","text":"The BigInt type is backed by GMP multiprecision integers and can represent integers whose size is usually only limited by available memory. While the BigInt type avoids overflow problems, it can be relatively slow in the Int range.","category":"page"},{"location":"Rings/integer/","page":"Integers","title":"Integers","text":"OSCAR currently has the integer type ZZRingElem, which for performance reasons scales internally from machine integers to GMP multiprecision integers.","category":"page"},{"location":"Rings/integer/#The-ring-of-integers","page":"Integers","title":"The ring of integers","text":"","category":"section"},{"location":"Rings/integer/","page":"Integers","title":"Integers","text":"Every object in OSCAR representing a mathematical element has a parent. This is an object encoding information about where that element belongs.","category":"page"},{"location":"Rings/integer/","page":"Integers","title":"Integers","text":"The parent of an OSCAR integer is the ring of integers ZZ.","category":"page"},{"location":"Rings/integer/","page":"Integers","title":"Integers","text":"julia> ZZ\nInteger ring\n","category":"page"},{"location":"Rings/integer/#Integer-constructors","page":"Integers","title":"Integer constructors","text":"","category":"section"},{"location":"Rings/integer/","page":"Integers","title":"Integers","text":"OSCAR integers are created using ZZ:","category":"page"},{"location":"Rings/integer/","page":"Integers","title":"Integers","text":"julia> ZZ(2)^100\n1267650600228229401496703205376\n\njulia> ZZ(618970019642690137449562111)\n618970019642690137449562111\n","category":"page"},{"location":"Rings/integer/","page":"Integers","title":"Integers","text":"One can also construct the integer 0 with the empty constructor:","category":"page"},{"location":"Rings/integer/","page":"Integers","title":"Integers","text":"julia> ZZ()\n0\n","category":"page"},{"location":"Rings/integer/","page":"Integers","title":"Integers","text":"The following special constructors are also provided:","category":"page"},{"location":"Rings/integer/","page":"Integers","title":"Integers","text":"zero(ZZ)\none(ZZ)","category":"page"},{"location":"Rings/integer/","page":"Integers","title":"Integers","text":"julia> zero(ZZ)\n0\n\njulia> one(ZZ)\n1\n","category":"page"},{"location":"Rings/integer/","page":"Integers","title":"Integers","text":"Note that ZZ is not a Julia type, but the above methods of constructing OSCAR integers are similar to the way that Julia integer types can be used to construct Julia integers.","category":"page"},{"location":"Rings/integer/","page":"Integers","title":"Integers","text":"julia> Int(123)\n123\n\njulia> BigInt(123456343567843598776327698374259876295438725)\n123456343567843598776327698374259876295438725\n\njulia> zero(BigInt)\n0\n\njulia> one(Int)\n1\n","category":"page"},{"location":"Rings/integer/#Limitations","page":"Integers","title":"Limitations","text":"","category":"section"},{"location":"Rings/integer/","page":"Integers","title":"Integers","text":"OSCAR integers have the same limitations as GMP multiprecision integers, namely that they are limited by the available memory on the machine and in any case to signed integers whose absolute value does not exceed 2^37 bits.","category":"page"},{"location":"Rings/integer/","page":"Integers","title":"Integers","text":"note: Note\nThe Julia Int type is either a 32 or 64 bit integer, depending on the machine architecture (usually 64 bits on most modern machines). The range of values is machine dependent, but can be found by typing typemin(Int) and typemax(Int) in Julia.","category":"page"},{"location":"Rings/integer/#Julia-integers-in-OSCAR-functions","page":"Integers","title":"Julia integers in OSCAR functions","text":"","category":"section"},{"location":"Rings/integer/","page":"Integers","title":"Integers","text":"For convenience, all basic arithmetic and exact division functions in OSCAR also accept Julia integers. If all of the arguments to an OSCAR function are julia integers, the resulting integers should be julia integers. However, once at least one of the arguments is an ZZRingElem, the function will generally behave as if all integer arguments were promoted to the type ZZRingElem, and the integers in the return generally should also be of type ZZRingElem. For example:","category":"page"},{"location":"Rings/integer/","page":"Integers","title":"Integers","text":"julia> divexact(ZZ(234), 2)\n117\n\njulia> typeof(gcd(4, 6))\nInt64\n\njulia> typeof(gcdx(4, 6))\nTuple{Int64, Int64, Int64}\n\njulia> typeof(gcd(4, ZZ(6)))\nZZRingElem\n\njulia> typeof(gcdx(4, ZZ(6)))\nTuple{ZZRingElem, ZZRingElem, ZZRingElem}\n\njulia> typeof(jacobi_symbol(ZZ(2), ZZ(3)))\nInt64\n","category":"page"},{"location":"Rings/integer/","page":"Integers","title":"Integers","text":"In the first example, 2 is a Julia integer but is still valid in the call to the OSCAR function divexact. In the last example, the exceptional function jacobi_symbol returns an Int as this will always be able to hold the three possible return values of -1, 0, or 1.","category":"page"},{"location":"Rings/integer/#Predicates","page":"Integers","title":"Predicates","text":"","category":"section"},{"location":"Rings/integer/","page":"Integers","title":"Integers","text":"iszero(n::ZZRingElem) -> Bool\nisone(n::ZZRingElem) -> Bool\nis_unit(n::ZZRingElem) -> Bool\nisodd(n::ZZRingElem) -> Bool\niseven(n::ZZRingElem) -> Bool\nis_square(n::ZZRingElem) -> Bool\nis_prime(n::ZZRingElem) -> Bool\nis_probable_prime(n::ZZRingElem) -> Bool","category":"page"},{"location":"Rings/integer/","page":"Integers","title":"Integers","text":"The is_prime predicate will prove primality, whereas is_probable_prime may declare a composite number to be prime with very low probability.","category":"page"},{"location":"Rings/integer/","page":"Integers","title":"Integers","text":"Negative numbers, 0 and 1 are not considered prime by is_prime and is_probable_prime.","category":"page"},{"location":"Rings/integer/","page":"Integers","title":"Integers","text":"julia> isone(ZZ(1))\ntrue\n\njulia> is_unit(ZZ(-1))\ntrue\n\njulia> is_square(ZZ(16))\ntrue\n\njulia> is_probable_prime(ZZ(23))\ntrue\n","category":"page"},{"location":"Rings/integer/#Properties","page":"Integers","title":"Properties","text":"","category":"section"},{"location":"Rings/integer/","page":"Integers","title":"Integers","text":"sign(n::ZZRingElem) -> ZZRingElem","category":"page"},{"location":"Rings/integer/","page":"Integers","title":"Integers","text":"Return the sign of n, i.e. nn if n neq 0, or 0 otherwise.","category":"page"},{"location":"Rings/integer/","page":"Integers","title":"Integers","text":"julia> sign(ZZ(23))\n1\n\njulia> sign(ZZ(0))\n0\n\njulia> sign(ZZ(-1))\n-1\n","category":"page"},{"location":"Rings/integer/","page":"Integers","title":"Integers","text":"abs(n::ZZRingElem) -> ZZRingElem","category":"page"},{"location":"Rings/integer/","page":"Integers","title":"Integers","text":"Return the absolute value of n, i.e. n if n geq 0 and -n otherwise","category":"page"},{"location":"Rings/integer/","page":"Integers","title":"Integers","text":"julia> abs(ZZ(-3))\n3\n","category":"page"},{"location":"Rings/integer/#Basic-arithmetic","page":"Integers","title":"Basic arithmetic","text":"","category":"section"},{"location":"Rings/integer/","page":"Integers","title":"Integers","text":"OSCAR provides the basic arithmetic operations +, - and * and comparison operators ==, !=, <, <=, >, >=, including mixed operations between Julia and OSCAR integers. It also provides division and powering as described below.","category":"page"},{"location":"Rings/integer/#Division-in-OSCAR","page":"Integers","title":"Division in OSCAR","text":"","category":"section"},{"location":"Rings/integer/","page":"Integers","title":"Integers","text":"OSCAR distinguishes a number of different kinds of division:","category":"page"},{"location":"Rings/integer/","page":"Integers","title":"Integers","text":"Exact division (divexact)\nEuclidean division (div, rem, divrem and mod)\nConstruction of fractions (a//b)\nFloating point division (a/b)\nDivisibility testing (divides)","category":"page"},{"location":"Rings/integer/","page":"Integers","title":"Integers","text":"These choices have been made for maximum parsimony with the Julia language.","category":"page"},{"location":"Rings/integer/","page":"Integers","title":"Integers","text":"note: Note\nIt is a common error to enter 1/2 for the fraction 'one half' in Julia. This expression is reserved for floating point division. Instead, the double slash operator // should be used for fractions.","category":"page"},{"location":"Rings/integer/#integer_exact_division","page":"Integers","title":"Exact Division","text":"","category":"section"},{"location":"Rings/integer/","page":"Integers","title":"Integers","text":"divexact(a::ZZRingElem, b::ZZRingElem) -> ZZRingElem","category":"page"},{"location":"Rings/integer/","page":"Integers","title":"Integers","text":"Return the quotient of a by b. The result of the exact division of two integers will always be another integer. Exact division raises an exception if the division is not exact, or if division by zero is attempted.","category":"page"},{"location":"Rings/integer/","page":"Integers","title":"Integers","text":"julia> divexact(ZZ(6), ZZ(3))\n2\n\njulia> divexact(ZZ(6), ZZ(0))\nERROR: DivideError: integer division error\n\njulia> divexact(ZZ(6), ZZ(5))\nERROR: ArgumentError: Not an exact division\n\njulia> divexact(ZZ(6), 2)\n3\n","category":"page"},{"location":"Rings/integer/#Powering","page":"Integers","title":"Powering","text":"","category":"section"},{"location":"Rings/integer/","page":"Integers","title":"Integers","text":"^(a::ZZRingElem, b::Int) -> ZZRingElem","category":"page"},{"location":"Rings/integer/","page":"Integers","title":"Integers","text":"Return the result of powering a by b.","category":"page"},{"location":"Rings/integer/","page":"Integers","title":"Integers","text":"julia> ZZ(37)^37\n10555134955777783414078330085995832946127396083370199442517\n\njulia> ZZ(1)^(-2)\n1\n","category":"page"},{"location":"Rings/integer/","page":"Integers","title":"Integers","text":"note: Note\nAn exception will be raised if an integer other than -1 or 1 is raised to a negative exponent.","category":"page"},{"location":"Rings/integer/","page":"Integers","title":"Integers","text":"note: Note\nIn Julia 2^-2 is called a literal power. The value returned is a floating point value. To get behavior that agrees with OSCAR, one can write 2^Int(-2).","category":"page"},{"location":"Rings/integer/","page":"Integers","title":"Integers","text":"The following is allowed for convenience.","category":"page"},{"location":"Rings/integer/","page":"Integers","title":"Integers","text":"julia> ZZ(0)^0\n1\n","category":"page"},{"location":"Rings/integer/","page":"Integers","title":"Integers","text":"note: Note\nIn Julia, 2^64 will return zero, as the Julia integer 2 is a machine integer. In OSCAR, the expression ZZ(2)^64 will return the expected result, just as the Julia equivalent BigInt(2)^64 does.","category":"page"},{"location":"Rings/integer/#integer_euclidean_division","page":"Integers","title":"Euclidean division","text":"","category":"section"},{"location":"Rings/integer/","page":"Integers","title":"Integers","text":"The ring of integers is a Euclidean domain and OSCAR provides Euclidean division through the functions divrem, div and rem.","category":"page"},{"location":"Rings/integer/","page":"Integers","title":"Integers","text":"Integer Euclidean division of a by b computes a quotient and remainder such that","category":"page"},{"location":"Rings/integer/","page":"Integers","title":"Integers","text":"a = qb + r","category":"page"},{"location":"Rings/integer/","page":"Integers","title":"Integers","text":"with r  b.","category":"page"},{"location":"Rings/integer/#Division-with-remainder","page":"Integers","title":"Division with remainder","text":"","category":"section"},{"location":"Rings/integer/","page":"Integers","title":"Integers","text":"divrem(a::ZZRingElem, b::ZZRingElem) -> (ZZRingElem, ZZRingElem) : division with remainder\ndiv(a::ZZRingElem, b::ZZRingElem) -> ZZRingElem : quotient only\nrem(a::ZZRingElem, b::ZZRingElem) -> ZZRingElem : remainder only","category":"page"},{"location":"Rings/integer/","page":"Integers","title":"Integers","text":"Both rem and divrem compute the remainder r such that when r neq 0 the sign of r is the same as the sign of a.","category":"page"},{"location":"Rings/integer/","page":"Integers","title":"Integers","text":"All three functions raise an exception if the modulus b is zero.","category":"page"},{"location":"Rings/integer/","page":"Integers","title":"Integers","text":"julia> divrem(ZZ(5), ZZ(3))\n(1, 2)\n\njulia> div(ZZ(7), ZZ(2))\n3\n\njulia> rem(ZZ(4), ZZ(3))\n1\n\njulia> div(ZZ(2), ZZ(0))\nERROR: DivideError: integer division error\n","category":"page"},{"location":"Rings/integer/","page":"Integers","title":"Integers","text":"note: Note\nThe rem function does not provide a minimal set of representatives, e.g. rem(-2, 3) = -2 but rem(1, 3) = 1.","category":"page"},{"location":"Rings/integer/#Modular-arithmetic","page":"Integers","title":"Modular arithmetic","text":"","category":"section"},{"location":"Rings/integer/#Modular-reduction","page":"Integers","title":"Modular reduction","text":"","category":"section"},{"location":"Rings/integer/","page":"Integers","title":"Integers","text":"mod(a::ZZRingElem, b::ZZRingElem) -> ZZRingElem : remainder only","category":"page"},{"location":"Rings/integer/","page":"Integers","title":"Integers","text":"The mod function computes a remainder r such that when r neq 0 the sign of r is the same as the sign of b. Thus, if b  0 then mod(a, b) will be in the range 0 b). An exception is raised if the modulus b is zero. This is summarised in the following table.","category":"page"},{"location":"Rings/integer/","page":"Integers","title":"Integers","text":"remainder division sign rounding\nrem div/divrem same as dividend towards zero\nmod  same as divisor towards -infty","category":"page"},{"location":"Rings/integer/","page":"Integers","title":"Integers","text":"There is no function implemented to compute the quotient corresponding to the remainder given by mod.","category":"page"},{"location":"Rings/integer/","page":"Integers","title":"Integers","text":"julia> mod(ZZ(4), ZZ(3))\n1\n\njulia> mod(ZZ(2), ZZ(0))\nERROR: DivideError: integer division error\n","category":"page"},{"location":"Rings/integer/#integer_divisibility_testing","page":"Integers","title":"Divisibility testing","text":"","category":"section"},{"location":"Rings/integer/","page":"Integers","title":"Integers","text":"divides(a::ZZRingElem, b::ZZRingElem) -> (Bool, ZZRingElem)","category":"page"},{"location":"Rings/integer/","page":"Integers","title":"Integers","text":"In OSCAR, we say that b divides a if there exists c in the same ring such that a = bc.","category":"page"},{"location":"Rings/integer/","page":"Integers","title":"Integers","text":"The call divides(a, b) returns a tuple (flag, q) where flag is either true if b divides a in which case q will be a quotient, or flag is false if b does not divide a in which case q will be an integer whose value is not defined.","category":"page"},{"location":"Rings/integer/","page":"Integers","title":"Integers","text":"julia> divides(ZZ(6), ZZ(3))\n(true, 2)\n\njulia> divides(ZZ(5), ZZ(2))\n(false, 0)\n","category":"page"},{"location":"Rings/integer/","page":"Integers","title":"Integers","text":"Note that for convenience we define:","category":"page"},{"location":"Rings/integer/","page":"Integers","title":"Integers","text":"julia> divides(ZZ(0), ZZ(0))\n(true, 0)\n","category":"page"},{"location":"Rings/integer/#Greatest-common-divisor","page":"Integers","title":"Greatest common divisor","text":"","category":"section"},{"location":"Rings/integer/#Greatest-common-divisor-2","page":"Integers","title":"Greatest common divisor","text":"","category":"section"},{"location":"Rings/integer/","page":"Integers","title":"Integers","text":"gcd(a::ZZRingElem, b::ZZRingElem) -> ZZRingElem","category":"page"},{"location":"Rings/integer/","page":"Integers","title":"Integers","text":"Return the greatest common divisor of its inputs, which is by definition the largest integer dividing the two inputs, unless both inputs are zero in which case it returns zero. The result will always be non-negative and will only be zero if both inputs are zero.","category":"page"},{"location":"Rings/integer/","page":"Integers","title":"Integers","text":"julia> gcd(ZZ(34), ZZ(17))\n17\n\njulia> gcd(ZZ(3), ZZ(0))\n3\n","category":"page"},{"location":"Rings/integer/#Extended-GCD","page":"Integers","title":"Extended GCD","text":"","category":"section"},{"location":"Rings/integer/","page":"Integers","title":"Integers","text":"gcdx(a::ZZRingElem, b::ZZRingElem) -> (ZZRingElem, ZZRingElem, ZZRingElem)","category":"page"},{"location":"Rings/integer/","page":"Integers","title":"Integers","text":"Return a tuple (g s t) such that g is the greatest common divisor of a and b and g = as + bt. Normally s and t are chosen so that s  b(2g) and t  a(2g), where this uniquely defines s and t. The following cases are handled specially:","category":"page"},{"location":"Rings/integer/","page":"Integers","title":"Integers","text":"if a = b then t = bb\nif b = 0 or b = 2g then s = aa\nif a = 0 or a = 2g then t = bb","category":"page"},{"location":"Rings/integer/#Least-common-multiple","page":"Integers","title":"Least common multiple","text":"","category":"section"},{"location":"Rings/integer/","page":"Integers","title":"Integers","text":"lcm(a::ZZRingElem, b::ZZRingElem) -> ZZRingElem","category":"page"},{"location":"Rings/integer/","page":"Integers","title":"Integers","text":"Return the least common multiple of a and b. This is the least positive multiple of a and b, unless a = 0 or b = 0 which case we define the least common multiple to be zero.","category":"page"},{"location":"Rings/integer/","page":"Integers","title":"Integers","text":"julia> lcm(ZZ(6), ZZ(21))\n42\n\njulia> lcm(ZZ(0), ZZ(0))\n0\n","category":"page"},{"location":"Rings/integer/#Roots","page":"Integers","title":"Roots","text":"","category":"section"},{"location":"Rings/integer/#Square-roots","page":"Integers","title":"Square roots","text":"","category":"section"},{"location":"Rings/integer/","page":"Integers","title":"Integers","text":"Julia and OSCAR distinguish two kinds of square root:","category":"page"},{"location":"Rings/integer/","page":"Integers","title":"Integers","text":"Integer square root (isqrt)\nFloating point square root (sqrt)","category":"page"},{"location":"Rings/integer/","page":"Integers","title":"Integers","text":"We describe only the first of these here.","category":"page"},{"location":"Rings/integer/","page":"Integers","title":"Integers","text":"isqrt(n::ZZRingElem) -> ZZRingElem","category":"page"},{"location":"Rings/integer/","page":"Integers","title":"Integers","text":"Return the floor of the square root of its argument, i.e. the largest integer whose square does not exceed its input. An exception is raised if a negative input is passed.","category":"page"},{"location":"Rings/integer/","page":"Integers","title":"Integers","text":"julia> isqrt(ZZ(16))\n4\n\njulia> isqrt(ZZ(0))\n0\n\njulia> isqrt(ZZ(5))\n2\n\njulia> isqrt(ZZ(-3))\nERROR: DomainError with -3:\nArgument must be non-negative\n","category":"page"},{"location":"Rings/integer/","page":"Integers","title":"Integers","text":"isqrtrem(n::ZZRingElem) -> (ZZRingElem, ZZRingElem)","category":"page"},{"location":"Rings/integer/","page":"Integers","title":"Integers","text":"Return the tuple (s, r) such that s is equal to isqrt(n) and n = s^2 + r.","category":"page"},{"location":"Rings/integer/","page":"Integers","title":"Integers","text":"julia> isqrtrem(ZZ(16))\n(4, 0)\n\njulia> isqrtrem(ZZ(5))\n(2, 1)\n","category":"page"},{"location":"Rings/integer/#General-roots","page":"Integers","title":"General roots","text":"","category":"section"},{"location":"Rings/integer/","page":"Integers","title":"Integers","text":"root(a::ZZRingElem, n::Int) -> ZZRingElem","category":"page"},{"location":"Rings/integer/","page":"Integers","title":"Integers","text":"Return an n-th root of a or throw an error if it does not exist.","category":"page"},{"location":"Rings/integer/","page":"Integers","title":"Integers","text":"When n is even, the non-negative root is always returned. An exception is raised if n leq 0 or if n is even and a  0.","category":"page"},{"location":"Rings/integer/","page":"Integers","title":"Integers","text":"julia> root(ZZ(16), 4)\n2\n\njulia> root(ZZ(-5), 2)\nERROR: DomainError with (-5, 2):\nArgument `x` must be positive if exponent `n` is even\n\njulia> root(ZZ(12), -2)\nERROR: DomainError with -2:\nExponent must be positive","category":"page"},{"location":"Rings/integer/#Conversions","page":"Integers","title":"Conversions","text":"","category":"section"},{"location":"Rings/integer/","page":"Integers","title":"Integers","text":"Int(n::ZZRingElem) -> Int\nBigInt(n::ZZRingElem) -> BigInt","category":"page"},{"location":"Rings/integer/","page":"Integers","title":"Integers","text":"Convert the OSCAR integer to the respective Julia integer.","category":"page"},{"location":"Rings/integer/","page":"Integers","title":"Integers","text":"julia> n = ZZ(123)\n123\n\njulia> Int(n)\n123\n\njulia> BigInt(n)\n123\n","category":"page"},{"location":"Rings/integer/","page":"Integers","title":"Integers","text":"In the case of Int, if the OSCAR integer is too large to fit, an exception is raised.","category":"page"},{"location":"Rings/integer/","page":"Integers","title":"Integers","text":"julia> Int(ZZ(12348732648732648763274868732687324))\nERROR: InexactError: convert(Int64, 12348732648732648763274868732687324)\n","category":"page"},{"location":"Rings/integer/","page":"Integers","title":"Integers","text":"fits(::Type{Int}, n::ZZRingElem) -> Bool","category":"page"},{"location":"Rings/integer/","page":"Integers","title":"Integers","text":"Return true if the OSCAR integer will fit in an Int.","category":"page"},{"location":"Rings/integer/","page":"Integers","title":"Integers","text":"julia> fits(Int, ZZ(123))\ntrue\n\njulia> fits(Int, ZZ(12348732648732648763274868732687324))\nfalse\n","category":"page"},{"location":"Rings/integer/#Factorisation","page":"Integers","title":"Factorisation","text":"","category":"section"},{"location":"Rings/integer/","page":"Integers","title":"Integers","text":"factor(n::ZZRingElem) -> Fac{ZZRingElem}","category":"page"},{"location":"Rings/integer/","page":"Integers","title":"Integers","text":"Return a factorisation of the given integer. The return value is a special factorisation struct which can be manipulated using the functions below.","category":"page"},{"location":"Rings/integer/","page":"Integers","title":"Integers","text":"julia> factor(ZZ(-6000361807272228723606))\n-1 * 2 * 229^3 * 43669^3 * 3\n\njulia> factor(ZZ(0))\nERROR: ArgumentError: Argument is not non-zero\n","category":"page"},{"location":"Rings/integer/","page":"Integers","title":"Integers","text":"unit(F::Fac) -> ZZRingElem","category":"page"},{"location":"Rings/integer/","page":"Integers","title":"Integers","text":"julia> F = factor(ZZ(-12))\n-1 * 2^2 * 3\n\njulia> unit(F)\n-1\n","category":"page"},{"location":"Rings/integer/#Factorisation-are-iterable","page":"Integers","title":"Factorisation are iterable","text":"","category":"section"},{"location":"Rings/integer/","page":"Integers","title":"Integers","text":"Once created, a factorisation is iterable:","category":"page"},{"location":"Rings/integer/","page":"Integers","title":"Integers","text":"julia> F = factor(ZZ(-60))\n-1 * 5 * 2^2 * 3\n\njulia> for (p, e) in F; println(\"$p^$e\"); end\n5^1\n2^2\n3^1\n","category":"page"},{"location":"Rings/integer/","page":"Integers","title":"Integers","text":"The pairs (p, e) in a factorisation represent the prime power factors p^e of the non-unit part of the factorisation. They can be placed in an array using collect:","category":"page"},{"location":"Rings/integer/","page":"Integers","title":"Integers","text":"julia> F = factor(ZZ(-60))\n-1 * 5 * 2^2 * 3\n\njulia> collect(F)\n3-element Vector{Pair{ZZRingElem, Int64}}:\n 5 => 1\n 2 => 2\n 3 => 1\n","category":"page"},{"location":"Rings/integer/#Accessing-exponents-in-a-factorisation","page":"Integers","title":"Accessing exponents in a factorisation","text":"","category":"section"},{"location":"Rings/integer/","page":"Integers","title":"Integers","text":"One can also determine whether a given prime is in the non-unit part of a factorisation and if so return its exponent. If the exponent of a prime that is not in a factorisation is requested, an exception is raised.","category":"page"},{"location":"Rings/integer/","page":"Integers","title":"Integers","text":"For convenience, a Int can be used instead of an OSCAR integer for this functionality.","category":"page"},{"location":"Rings/integer/","page":"Integers","title":"Integers","text":"julia> F = factor(ZZ(-60))\n-1 * 5 * 2^2 * 3\n\njulia> 5 in F\ntrue\n\njulia> ZZ(3) in F\ntrue\n\njulia> 7 in F\nfalse\n\njulia> F[3]\n1\n\njulia> F[ZZ(7)]\nERROR: 7 is not a factor of -1 * 5 * 2^2 * 3\n","category":"page"},{"location":"Rings/integer/#Combinatorial-functions","page":"Integers","title":"Combinatorial functions","text":"","category":"section"},{"location":"Rings/integer/","page":"Integers","title":"Integers","text":"note: Note\nThe functions in this section that take Int arguments will return an Int, which may overflow or throw an error. Use the ZZRingElem versions if this is not the desired behavior.","category":"page"},{"location":"Rings/integer/#Factorial","page":"Integers","title":"Factorial","text":"","category":"section"},{"location":"Rings/integer/","page":"Integers","title":"Integers","text":"factorial(n::ZZRingElem) -> ZZRingElem","category":"page"},{"location":"Rings/integer/","page":"Integers","title":"Integers","text":"Return the factorial of n, i.e. n. An exception is raised if n  0. We define 0 = 1.","category":"page"},{"location":"Rings/integer/","page":"Integers","title":"Integers","text":"rising_factorial(x::Int, n::Int) -> Int\nrising_factorial(x::ZZRingElem, n::Int) -> ZZRingElem\nrising_factorial(x::ZZRingElem, n::ZZRingElem) -> ZZRingElem","category":"page"},{"location":"Rings/integer/","page":"Integers","title":"Integers","text":"Return x(x + 1)(x + 2)ldots(x + n - 1). An exception is raised if n  0. We define rising_factorial(x, 0) to be 1.","category":"page"},{"location":"Rings/integer/","page":"Integers","title":"Integers","text":"julia> factorial(ZZ(30))\n265252859812191058636308480000000\n\njulia> rising_factorial(ZZ(-30), 3)\n-24360\n","category":"page"},{"location":"Rings/integer/#Primorial","page":"Integers","title":"Primorial","text":"","category":"section"},{"location":"Rings/integer/","page":"Integers","title":"Integers","text":"primorial(n::Int) -> Int\nprimorial(n::ZZRingElem) -> ZZRingElem","category":"page"},{"location":"Rings/integer/","page":"Integers","title":"Integers","text":"Return the primorial P(n), i.e. the product of all primes less than or equal to n. An exception is raised if n  0. We define P(0) = P(1) = 1.","category":"page"},{"location":"Rings/integer/","page":"Integers","title":"Integers","text":"julia> primorial(ZZ(100))\n2305567963945518424753102147331756070\n","category":"page"},{"location":"Rings/integer/#Bell-numbers","page":"Integers","title":"Bell numbers","text":"","category":"section"},{"location":"Rings/integer/","page":"Integers","title":"Integers","text":"bell(n::Int) -> Int\nbell(n::ZZRingElem) -> ZZRingElem","category":"page"},{"location":"Rings/integer/","page":"Integers","title":"Integers","text":"Return the n-th Bell number B(n), i.e. the number of ways of partitioning a set of n elements. An exception is raised if n  0.","category":"page"},{"location":"Rings/integer/","page":"Integers","title":"Integers","text":"julia> bell(ZZ(20))\n51724158235372\n","category":"page"},{"location":"Rings/integer/#Binomial-coefficients","page":"Integers","title":"Binomial coefficients","text":"","category":"section"},{"location":"Rings/integer/","page":"Integers","title":"Integers","text":"binomial(n::ZZRingElem, k::ZZRingElem) -> ZZRingElem","category":"page"},{"location":"Rings/integer/","page":"Integers","title":"Integers","text":"Return the binomial coefficient fracn (n-1) cdots (n-k+1)k for k ge 0 and returns 0 for k < 0.","category":"page"},{"location":"Rings/integer/","page":"Integers","title":"Integers","text":"note: Note\nJulia already defines the binomial function for Int, which throws an error on overflow.","category":"page"},{"location":"Rings/integer/","page":"Integers","title":"Integers","text":"julia> binomial(ZZ(72), ZZ(15))\n1155454041309504\n","category":"page"},{"location":"Rings/integer/#Integer-partitions","page":"Integers","title":"Integer partitions","text":"","category":"section"},{"location":"Rings/integer/","page":"Integers","title":"Integers","text":"number_of_partitions(n::Int) -> ZZRingElem\nnumber_of_partitions(n::ZZRingElem) -> ZZRingElem","category":"page"},{"location":"Rings/integer/","page":"Integers","title":"Integers","text":"Return the number of integer partitions p(n) of n, i.e. the number of distinct ways to write n as a sum of positive integers. Note that p(0) = 1, as the empty sum is counted. For n  0 we return zero.","category":"page"},{"location":"Rings/integer/","page":"Integers","title":"Integers","text":"julia> number_of_partitions(ZZ(10^6))\n1471684986358223398631004760609895943484030484439142125334612747351666117418918618276330148873983597555842015374130600288095929387347128232270327849578001932784396072064228659048713020170971840761025676479860846908142829356706929785991290519899445490672219997823452874982974022288229850136767566294781887494687879003824699988197729200632068668735996662273816798266213482417208446631027428001918132198177180646511234542595026728424452592296781193448139994664730105742564359154794989181485285351370551399476719981691459022015599101959601417474075715430750022184895815209339012481734469448319323280150665384042994054179587751761294916248142479998802936507195257074485047571662771763903391442495113823298195263008336489826045837712202455304996382144601028531832004519046591968302787537418118486000612016852593542741980215046267245473237321845833427512524227465399130174076941280847400831542217999286071108336303316298289102444649696805395416791875480010852636774022023128467646919775022348562520747741843343657801534130704761975530375169707999287040285677841619347472368171772154046664303121315630003467104673818\n","category":"page"},{"location":"Rings/integer/#Fibonacci-sequence","page":"Integers","title":"Fibonacci sequence","text":"","category":"section"},{"location":"Rings/integer/","page":"Integers","title":"Integers","text":"fibonacci(n::Int) -> Int\nfibonacci(n::ZZRingElem) -> ZZRingElem","category":"page"},{"location":"Rings/integer/","page":"Integers","title":"Integers","text":"Return the n-th Fibonacci number F(n), defined by the recurrence relation F(1) = 1, F(2) = 1 and F(n) = F(n - 1) + F(n - 2) for n geq 3. We define F(0) = 0 and for n  0 we have F(-n) = (-1)^n+1F(n).","category":"page"},{"location":"Rings/integer/","page":"Integers","title":"Integers","text":"julia> fibonacci(ZZ(100))\n354224848179261915075\n\njulia> fibonacci(-2)\n-1\n","category":"page"},{"location":"Rings/integer/#Number-theoretic-functionality","page":"Integers","title":"Number theoretic functionality","text":"","category":"section"},{"location":"Rings/integer/","page":"Integers","title":"Integers","text":"note: Note\nThe functions in this section that take Int arguments will return a Int, which may overflow or throw an error. Use the ZZRingElem versions if this is not the desired behavior.","category":"page"},{"location":"Rings/integer/#Moebius-mu-function","page":"Integers","title":"Moebius mu function","text":"","category":"section"},{"location":"Rings/integer/","page":"Integers","title":"Integers","text":"moebius_mu(n::Int) -> Int\nmoebius_mu(n::ZZRingElem) -> Int ","category":"page"},{"location":"Rings/integer/","page":"Integers","title":"Integers","text":"Return the Moebius function mu(n), which is defined to be 0 if n is not squarefree and otherwise is defined to be +1 or -1 if n has an even or odd number of prime factors, respectively. Alternatively, mu(n) can be defined to be the sum of the primitive n-th roots of unity. An exception is raised if n leq 0.","category":"page"},{"location":"Rings/integer/","page":"Integers","title":"Integers","text":"julia> moebius_mu(30)\n-1\n","category":"page"},{"location":"Rings/integer/#Jacobi-symbols","page":"Integers","title":"Jacobi symbols","text":"","category":"section"},{"location":"Rings/integer/","page":"Integers","title":"Integers","text":"jacobi_symbol(m::Int, n::Int) -> Int\njacobi_symbol(m::ZZRingElem, n::ZZRingElem) -> Int","category":"page"},{"location":"Rings/integer/","page":"Integers","title":"Integers","text":"Return the Jacobi symbol left(fracmnright), which is defined for integers m and odd, positive integers n. If the factorisation of n is n = p_1^i_1p_2^i_2ldots p_r^i_r then we define","category":"page"},{"location":"Rings/integer/","page":"Integers","title":"Integers","text":"left(fracmnright) = left(fracmp_1right)^i_1left(fracmp_2right)^i_2ldots left(fracmp_rright)^i_r","category":"page"},{"location":"Rings/integer/","page":"Integers","title":"Integers","text":"where left(fracmpright) on the right hand side is the Legendre symbol, which is defined for an odd prime number p to be 0 if p divides m and otherwise +1 or -1 depending on whether m is a square modulo p or not. An exception is raised if n is even or if n leq 0.","category":"page"},{"location":"Rings/integer/","page":"Integers","title":"Integers","text":"julia> jacobi_symbol(3, 37)\n1\n","category":"page"},{"location":"Rings/integer/#Sigma-function","page":"Integers","title":"Sigma function","text":"","category":"section"},{"location":"Rings/integer/","page":"Integers","title":"Integers","text":"divisor_sigma(m::Int, n::Int) -> Int\ndivisor_sigma(m::ZZRingElem, n::Int) -> ZZRingElem\ndivisor_sigma(m::ZZRingElem, n::ZZRingElem) -> ZZRingElem","category":"page"},{"location":"Rings/integer/","page":"Integers","title":"Integers","text":"Return the sum of the n-th powers of the divisors of m","category":"page"},{"location":"Rings/integer/","page":"Integers","title":"Integers","text":"sigma(m n) = sum_dm d^n","category":"page"},{"location":"Rings/integer/","page":"Integers","title":"Integers","text":"If m leq 0 or n  0 we raise an exception.","category":"page"},{"location":"Rings/integer/","page":"Integers","title":"Integers","text":"julia> divisor_sigma(60, 5)\n806220408\n","category":"page"},{"location":"Rings/integer/#Euler-totient-function","page":"Integers","title":"Euler totient function","text":"","category":"section"},{"location":"Rings/integer/","page":"Integers","title":"Integers","text":"euler_phi(n::Int) -> Int\neuler_phi(n::ZZRingElem) -> ZZRingElem","category":"page"},{"location":"Rings/integer/","page":"Integers","title":"Integers","text":"Return the Euler totient function varphi(n), i.e. the number of positive integers 1 leq x leq n which are coprime to n. Note that varphi(1) = 1. We raise an exception if n leq 0.","category":"page"},{"location":"Rings/integer/","page":"Integers","title":"Integers","text":"julia> euler_phi(200)\n80\n","category":"page"},{"location":"Groups/fpgroup/","page":"Finitely presented groups","title":"Finitely presented groups","text":"CurrentModule = Oscar\nDocTestSetup = Oscar.doctestsetup()","category":"page"},{"location":"Groups/fpgroup/#Finitely-presented-groups","page":"Finitely presented groups","title":"Finitely presented groups","text":"","category":"section"},{"location":"Groups/fpgroup/","page":"Finitely presented groups","title":"Finitely presented groups","text":"FPGroup\nFPGroupElem\nSubFPGroup\nSubFPGroupElem\nfree_group\n@free_group\nfull_group(G::Union{SubFPGroup, SubPcGroup})\nrelators(G::FPGroup)\nlength(g::Union{FPGroupElem, SubFPGroupElem})\nmap_word(g::Union{FPGroupElem, SubFPGroupElem}, genimgs::Vector; genimgs_inv::Vector = Vector(undef, length(genimgs)), init = nothing)","category":"page"},{"location":"Groups/fpgroup/#FPGroup","page":"Finitely presented groups","title":"FPGroup","text":"FPGroup\n\nFinitely presented group. Such groups can be constructed a factors of free groups, see free_group.\n\nFor a group G of type FPGroup, the elements in gens(G) satisfy the relators of the underlying presentation.\n\nFunctions that compute subgroups of G return groups of type SubFPGroup.\n\n\n\n\n\n","category":"type"},{"location":"Groups/fpgroup/#FPGroupElem","page":"Finitely presented groups","title":"FPGroupElem","text":"FPGroupElem\n\nElement of a finitely presented group.\n\nThe generators of a finitely presented group are displayed as f1, f2, f3, etc., and every element of a finitely presented group is displayed as product of the generators.\n\n\n\n\n\n","category":"type"},{"location":"Groups/fpgroup/#SubFPGroup","page":"Finitely presented groups","title":"SubFPGroup","text":"SubFPGroup\n\nSubgroup of a finitely presented group, a group that is defined by generators that are elements of a group G of type FPGroup.\n\nOperations for computing subgroups of a group of type FPGroup or SubFPGroup, such as derived_subgroup and sylow_subgroup, return groups of type SubFPGroup.\n\nNote that functions such as relators do not make sense for proper subgroups of a finitely presented group.\n\n\n\n\n\n","category":"type"},{"location":"Groups/fpgroup/#SubFPGroupElem","page":"Finitely presented groups","title":"SubFPGroupElem","text":"SubFPGroupElem\n\nElement of a subgroup of a finitely presented group.\n\nThe elements are displayed in the same way as the elements of full finitely presented groups, see FPGroupElem.\n\n\n\n\n\n","category":"type"},{"location":"Groups/fpgroup/#free_group","page":"Finitely presented groups","title":"free_group","text":"free_group(n::Int, s::VarName = :f; eltype::Symbol = :letter) -> FPGroup\nfree_group(L::VarName... ; eltype::Symbol = :letter) -> FPGroup\nfree_group(varnames_specifiers... ; eltype::Symbol = :letter) -> FPGroup\n\nReturn a free group.\n\nThe first form returns a free group of rank n, where the generators are printed as \"$s1\", \"$s2\", ..., the default being f1, f2, ...\n\nThe second form returns a free group of rank n, where n is the length of L, and L consists of strings, symbols or characters giving the variable names.\n\nIn the final form, the argument list consists of a sequence of one or more of the following:\n\nA vector L of variable names.\nA pair of the form A => B, where A is a VarName (so a string, symbol or character) and B is a range or more generally an AbstractVector. Then length(B) generators are defined whose names derive from a combination of A and the respective element of B. For example :x => 1:3 defines three generators x[1], x[2], x[3].\nA pair of the form A => C, where A is again a VarName, and C is a tuple of ranges or v. For example \"a\" => (1:2, 1:2) defines four generators a[1, 1], a[2, 1], a[1, 2], a[2, 2].\n\nFor the second and third type, optionally the A part can contain the placeholder # to modify where the indices are inserted. For example \"a#\" => (1:2, 1:2) defines four generators a11, a21, a12, a22.\n\nAlso, instead of a range, any vector can be used. For example \"#\" => ([:x,:y], [:A, :B]) defines four generators xA, yA, xB, yB.\n\nIn all variants, if the optional keyword argument eltype is given and has the value :syllable then each element in the free group is internally represented by a vector of syllables, whereas a representation by a vector of integers is chosen in the default case of eltype == :letter.\n\nwarning: Warning\nJulia variables named like the group generators are not created by this function. However, the macro @free_group does just that.\n\nExamples\n\njulia> F = free_group(:a, :b)\nFree group of rank 2\n\njulia> w = F[1]^3 * F[2]^F[1] * F[-2]^2\na^2*b*a*b^-2\n\nHere we show some of the different ways to create a free group.\n\njulia> gens(free_group(2))\n2-element Vector{FPGroupElem}:\n f1\n f2\n\njulia> gens(free_group(2, :a))\n2-element Vector{FPGroupElem}:\n a1\n a2\n\njulia> gens(free_group(:u, :v))\n2-element Vector{FPGroupElem}:\n u\n v\n\njulia> gens(free_group([:a, :b], \"x\" => 1:2, 'y' => (1:2, 1:2)))\n8-element Vector{FPGroupElem}:\n a\n b\n x[1]\n x[2]\n y[1, 1]\n y[2, 1]\n y[1, 2]\n y[2, 2]\n\n\n\n\n\n","category":"function"},{"location":"Groups/fpgroup/#@free_group","page":"Finitely presented groups","title":"@free_group","text":"@free_group(args...)\n\nReturn the free group obtained from free_group(args...) and introduce its generators as Julia variables into the current scope.\n\nExamples\n\njulia> F = @free_group(:a, :b)\nFree group of rank 2\n\njulia> a^2*b*a*b^-2\na^2*b*a*b^-2\n\nNote that the varname => vector syntax for specifying a vector or matrix or general array of variables behaves slightly differently compared to free_group, as the following example demonstrates.\n\njulia> U1 = free_group(\"x\" => 1:3); gens(U1)\n3-element Vector{FPGroupElem}:\n x[1]\n x[2]\n x[3]\n\njulia> U2 = @free_group(\"x\" => 1:3); gens(U2)\n3-element Vector{FPGroupElem}:\n x1\n x2\n x3\n\njulia> (x2^x1)^-1\nx1^-1*x2^-1*x1\n\n\n\n\n\n","category":"macro"},{"location":"Groups/fpgroup/#full_group-Tuple{Union{SubFPGroup, SubPcGroup}}","page":"Finitely presented groups","title":"full_group","text":"full_group(G::T) where T <: Union{SubFPGroup, SubPcGroup}\nfull_group(G::T) where T <: Union{FPGroup, PcGroup}\n\nReturn F, emb where F is the full pc group of f.p. group of which G is a subgroup, and emb is an embedding of G into F.\n\nExamples\n\njulia> G = perfect_group(FPGroup, 60, 1);\n\njulia> H = sylow_subgroup(G, 2)[1];\n\njulia> full_group(H)[1] == G\ntrue\n\njulia> full_group(G)[1] == G\ntrue\n\n\n\n\n\n","category":"method"},{"location":"Groups/fpgroup/#relators-Tuple{FPGroup}","page":"Finitely presented groups","title":"relators","text":"relators(G::FPGroup)\n\nReturn a vector of relators for the full finitely presented group G, i.e., elements w_1 w_2 ldots w_n in F = free_group(ngens(G)) such that G is isomorphic with Fw_1 w_2 ldots w_n.\n\nExamples\n\njulia> f = @free_group(:x, :y);\n\njulia> q = quo(f, [x^2, y^2, comm(x, y)])[1];  relators(q)\n3-element Vector{FPGroupElem}:\n x^2\n y^2\n x^-1*y^-1*x*y\n\n\n\n\n\n","category":"method"},{"location":"Groups/fpgroup/#length-Tuple{Union{FPGroupElem, SubFPGroupElem}}","page":"Finitely presented groups","title":"length","text":"length(g::Union{FPGroupElem, SubFPGroupElem})\n\nReturn the length of g as a word in terms of the generators of its parent or of the full group of its parent if g is an element of a free group, otherwise an exception is thrown.\n\nExamples\n\njulia> F = @free_group(:F1, :F2);\n\njulia> length(F1*F2^-2)\n3\n\njulia> length(one(F))\n0\n\njulia> length(one(quo(F, [F1])[1]))\nERROR: ArgumentError: the element does not lie in a free group\n\n\n\n\n\n","category":"method"},{"location":"Groups/fpgroup/#map_word-Tuple{Union{FPGroupElem, SubFPGroupElem}, Vector}","page":"Finitely presented groups","title":"map_word","text":"map_word(g::Union{FPGroupElem, SubFPGroupElem}, genimgs::Vector; genimgs_inv::Vector = Vector(undef, length(genimgs)), init = nothing)\nmap_word(v::Vector{Union{Int, Pair{Int, Int}}}, genimgs::Vector; genimgs_inv::Vector = Vector(undef, length(genimgs)), init = nothing)\n\nReturn the product R_1 R_2 cdots R_n that is described by g or v, respectively.\n\nIf g is an element of a free group G, say, then the rank of G must be equal to the length of genimgs, g is a product of the form g_i_1^e_1 g_i_2^e_2 cdots g_i_n^e_n where g_i is the i-th generator of G and the e_i are nonzero integers, and R_j = imgs[i_j]^e_j.\n\nIf g is an element of (a subgroup of) a finitely presented group then the result is defined as map_word applied to a representing element of the underlying free group of full_group(parent(g)). In particular, genimgs are interpreted as the images of the generators of this free group, not of gens(parent(g)).\n\nIf the first argument is a vector v of integers k_i or pairs k_i => e_i, respectively, then the absolute values of the k_i must be at most the length of genimgs, and R_j = imgs[k_i]^epsilon_i where epsilon_i is the sign of k_i (times e_i).\n\nIf a vector genimgs_inv is given then its assigned entries are expected to be the inverses of the corresponding entries in genimgs, and the function will use (and set) these entries in order to avoid calling inv (more than once) for entries of genimgs.\n\nIf init is different from nothing then the product gets initialized with init.\n\nIf v has length zero then init is returned if also genimgs has length zero, otherwise one(genimgs[1]) is returned. Thus the intended value for the empty word must be specified as init whenever it is possible that the elements in genimgs do not support one.\n\nExamples\n\njulia> F = @free_group(:F1, :F2);\n\njulia> imgs = gens(symmetric_group(4))\n2-element Vector{PermGroupElem}:\n (1,2,3,4)\n (1,2)\n\njulia> map_word(F1^2, imgs)\n(1,3)(2,4)\n\njulia> map_word(F2, imgs)\n(1,2)\n\njulia> map_word(one(F), imgs)\n()\n\njulia> map_word(one(F), imgs, init = imgs[1])\n(1,2,3,4)\n\njulia> invs = Vector(undef, 2);\n\njulia> map_word(F1^-2*F2, imgs, genimgs_inv = invs)\n(1,3,2,4)\n\njulia> invs\n2-element Vector{Any}:\n    (1,4,3,2)\n #undef\n\n\n\n\n\n","category":"method"},{"location":"AlgebraicGeometry/Curves/AffinePlaneCurves/","page":"Affine plane curves","title":"Affine plane curves","text":"CurrentModule = Oscar","category":"page"},{"location":"AlgebraicGeometry/Curves/AffinePlaneCurves/#Affine-plane-curves","page":"Affine plane curves","title":"Affine plane curves","text":"","category":"section"},{"location":"AlgebraicGeometry/Curves/AffinePlaneCurves/","page":"Affine plane curves","title":"Affine plane curves","text":"AffinePlaneCurve\ndefining_equation(C::AffinePlaneCurve{S, MPolyQuoRing{E}}) where {S, E}\ncommon_components(C::S, D::S) where {S<:AffinePlaneCurve}\nmultiplicity(C::AffinePlaneCurve, P::AbsAffineRationalPoint)\ntangent_lines(C::AffinePlaneCurve, P::AbsAffineRationalPoint)\nintersection_multiplicity(C::AffinePlaneCurve, D::AffinePlaneCurve, P::AbsAffineRationalPoint)\nis_transverse_intersection(C::AffinePlaneCurve, D::AffinePlaneCurve, P::AbsAffineRationalPoint)\nprojective_closure(C::AffinePlaneCurve)","category":"page"},{"location":"AlgebraicGeometry/Curves/AffinePlaneCurves/#AffinePlaneCurve","page":"Affine plane curves","title":"AffinePlaneCurve","text":"AffinePlaneCurve{BaseField<:Field, RingType<:Ring} <: AbsAffineCurve{BaseField, RingType}\n\nType for reduced affine plane curves.\n\nExamples\n\njulia> R, (x, y) = polynomial_ring(QQ, [:x, :y]);\n\njulia> F = y^3*x^6 - y^6*x^2;\n\njulia> C = plane_curve(F)\nAffine plane curve\n  defined by 0 = x^5*y - x*y^4\n\n\n\n\n\n\n","category":"type"},{"location":"AlgebraicGeometry/Curves/AffinePlaneCurves/#defining_equation-Union{Tuple{AffinePlaneCurve{S, MPolyQuoRing{E}}}, Tuple{E}, Tuple{S}} where {S, E}","page":"Affine plane curves","title":"defining_equation","text":"defining_equation(C::AffinePlaneCurve)\n\nReturn the defining equation of C.\n\n\n\n\n\ndefining_equation(C::ProjectivePlaneCurve)\n\nReturn the defining equation of the (reduced) plane curve C.\n\n\n\n\n\n","category":"method"},{"location":"AlgebraicGeometry/Curves/AffinePlaneCurves/#common_components-Union{Tuple{S}, Tuple{S, S}} where S<:AffinePlaneCurve","page":"Affine plane curves","title":"common_components","text":"common_components(C::AffinePlaneCurve, D::AffinePlaneCurve)\n\nReturn the affine plane curve consisting of the common components of C and D, or an empty vector if they do not have a common component. This component can be reducible.\n\nExamples\n\njulia> R, (x, y) = polynomial_ring(QQ, [:x, :y]);\n\njulia> C = plane_curve(x*(x+y)*(x^2 + x + 1));\n\njulia> D = plane_curve(x*(x+y)*(x-y));\n\njulia> common_components(C, D)\n1-element Vector{AffinePlaneCurve{QQField, MPolyQuoRing{QQMPolyRingElem}}}:\n scheme(x^2 + x*y)\n\n\n\n\n\n\n","category":"method"},{"location":"AlgebraicGeometry/Curves/AffinePlaneCurves/#multiplicity-Tuple{AffinePlaneCurve, AbsAffineRationalPoint}","page":"Affine plane curves","title":"multiplicity","text":"multiplicity(C::AffinePlaneCurve, P::AbsAffineRationalPoint)\n\nReturn the multiplicity of C at P.\n\nExamples\n\njulia> R, (x, y) = polynomial_ring(QQ, [:x, :y]);\n\njulia> C = plane_curve(x^2*(x+y)*(y^3-x^2));\n\njulia> P = C([2,-2])\nRational point\n  of scheme(-x^4 - x^3*y + x^2*y^3 + x*y^4)\nwith coordinates (2, -2)\n\njulia> multiplicity(C, P)\n1\n\n\n\n\n\n\n","category":"method"},{"location":"AlgebraicGeometry/Curves/AffinePlaneCurves/#tangent_lines-Tuple{AffinePlaneCurve, AbsAffineRationalPoint}","page":"Affine plane curves","title":"tangent_lines","text":"tangent_lines(C::AffinePlaneCurve, P::AbsAffineRationalPoint)\n\nReturn the tangent lines at P to C with their multiplicity.\n\nExamples\n\njulia> R, (x, y) = polynomial_ring(QQ, [:x, :y]);\n\njulia> C = plane_curve(x^2*(x+y)*(y^3-x^2));\n\njulia> P = C([0, 0])\nRational point\n  of scheme(-x^4 - x^3*y + x^2*y^3 + x*y^4)\nwith coordinates (0, 0)\n\njulia> tangent_lines(C, P)\nDict{AffinePlaneCurve{QQField, MPolyQuoRing{QQMPolyRingElem}}, Int64} with 2 entries:\n  scheme(x)     => 3\n  scheme(x + y) => 1\n\n\n\n\n\n\n","category":"method"},{"location":"AlgebraicGeometry/Curves/AffinePlaneCurves/#intersection_multiplicity-Tuple{AffinePlaneCurve, AffinePlaneCurve, AbsAffineRationalPoint}","page":"Affine plane curves","title":"intersection_multiplicity","text":"intersection_multiplicity(C::AffinePlaneCurve, D::AffinePlaneCurve, P::AbsAffineRationalPoint)\n\nReturn the intersection multiplicity of C and D at P.\n\nExamples\n\njulia> R, (x, y) = polynomial_ring(QQ, [:x, :y]);\n\njulia> C = plane_curve((x^2+y^2)*(x^2 + y^2 + 2*y))\nAffine plane curve\n  defined by 0 = x^4 + 2*x^2*y^2 + 2*x^2*y + y^4 + 2*y^3\n\njulia> D = plane_curve((x^2+y^2)*(y^3*x^6 - y^6*x^2))\nAffine plane curve\n  defined by 0 = x^7*y + x^5*y^3 - x^3*y^4 - x*y^6\n\njulia> Q = D([0, -2]);\n\njulia> intersection_multiplicity(C, D, Q)\n1\n\n\n\n\n\n\n","category":"method"},{"location":"AlgebraicGeometry/Curves/AffinePlaneCurves/#is_transverse_intersection-Tuple{AffinePlaneCurve, AffinePlaneCurve, AbsAffineRationalPoint}","page":"Affine plane curves","title":"is_transverse_intersection","text":"is_transverse_intersection(C::AffinePlaneCurve, D::AffinePlaneCurve, P::AbsAffineRationalPoint)\n\nReturn true if C and D intersect transversally at P and false otherwise.\n\nExamples\n\njulia> R, (x, y) = polynomial_ring(QQ, [:x, :y])\n(Multivariate polynomial ring in 2 variables over QQ, QQMPolyRingElem[x, y])\n\njulia> C = plane_curve(x*(x+y))\nAffine plane curve\n  defined by 0 = x^2 + x*y\n\njulia> D = plane_curve((x-y)*(x-2))\nAffine plane curve\n  defined by 0 = x^2 - x*y - 2*x + 2*y\n\njulia> P = C([QQ(0), QQ(0)])\nRational point\n  of scheme(x^2 + x*y)\nwith coordinates (0, 0)\n\njulia> Q = C([QQ(2), QQ(-2)])\nRational point\n  of scheme(x^2 + x*y)\nwith coordinates (2, -2)\n\njulia> is_transverse_intersection(C, D, P)\nfalse\n\njulia> is_transverse_intersection(C, D, Q)\ntrue\n\n\n\n\n\n\n","category":"method"},{"location":"AlgebraicGeometry/Curves/AffinePlaneCurves/#projective_closure-Tuple{AffinePlaneCurve}","page":"Affine plane curves","title":"projective_closure","text":"projective_closure(C::AffinePlaneCurve) -> ProjectivePlaneCurve\n\nReturn the projective closure of C.\n\n\n\n\n\n","category":"method"},{"location":"NoncommutativeAlgebra/free_associative_algebra/","page":"Free Associative Algebras","title":"Free Associative Algebras","text":"CurrentModule = Oscar","category":"page"},{"location":"NoncommutativeAlgebra/free_associative_algebra/#Free-Associative-Algebras","page":"Free Associative Algebras","title":"Free Associative Algebras","text":"","category":"section"},{"location":"NoncommutativeAlgebra/free_associative_algebra/#Two-sided-ideals","page":"Free Associative Algebras","title":"Two-sided ideals","text":"","category":"section"},{"location":"NoncommutativeAlgebra/free_associative_algebra/#Types","page":"Free Associative Algebras","title":"Types","text":"","category":"section"},{"location":"NoncommutativeAlgebra/free_associative_algebra/","page":"Free Associative Algebras","title":"Free Associative Algebras","text":"The OSCAR type for two-sided ideals in a free associative algebra is FreeAssociativeAlgebraIdeal{T}, where T is the element type of the algebra.","category":"page"},{"location":"NoncommutativeAlgebra/free_associative_algebra/#Constructors","page":"Free Associative Algebras","title":"Constructors","text":"","category":"section"},{"location":"NoncommutativeAlgebra/free_associative_algebra/","page":"Free Associative Algebras","title":"Free Associative Algebras","text":"ideal(R::FreeAssociativeAlgebra, g::Vector{T}) where T <: FreeAssociativeAlgebraElem\nideal(g::Vector{T}) where T <: FreeAssociativeAlgebraElem","category":"page"},{"location":"NoncommutativeAlgebra/free_associative_algebra/#Ideal-Membership","page":"Free Associative Algebras","title":"Ideal Membership","text":"","category":"section"},{"location":"NoncommutativeAlgebra/free_associative_algebra/","page":"Free Associative Algebras","title":"Free Associative Algebras","text":"Non-commutative polynomial rings are not Noetherian.  Hence, in general, Groebner bases do not exist.  Hence calling the functions below may not terminate.  Picking suitable term orders is difficult in the noncommutative case.  Therefore, we fix the term order to be degree reverse lexicographic.","category":"page"},{"location":"NoncommutativeAlgebra/free_associative_algebra/","page":"Free Associative Algebras","title":"Free Associative Algebras","text":"Setting the parameter deg_bound to a positive value yields the truncation of the Groebner bases to a fixed degree.  Such a truncation is always finite.","category":"page"},{"location":"NoncommutativeAlgebra/free_associative_algebra/","page":"Free Associative Algebras","title":"Free Associative Algebras","text":"groebner_basis(I::FreeAssociativeAlgebraIdeal, deg_bound::Int=-1; protocol::Bool=false)","category":"page"},{"location":"NoncommutativeAlgebra/free_associative_algebra/#groebner_basis","page":"Free Associative Algebras","title":"groebner_basis","text":"groebner_basis(I::FreeAssociativeAlgebraIdeal, deg_bound::Int=-1; protocol::Bool=false)\n\nReturn the Groebner basis of I with respect to the degree bound deg_bound. If protocol is true, the protocol of the computation is also returned. The default value of deg_bound is -1, which means that no degree bound is imposed, resulting in a computation that is usually slower, but will return a full Groebner basis if there exists a finite one.\n\njulia> free, (x,y,z) = free_associative_algebra(QQ, [:x, :y, :z]);\n\njulia> f1 = x*y + y*z;\n\njulia> f2 = x^2 + y^2;\n\njulia> I = ideal([f1, f2]);\n\njulia> gb = groebner_basis(I, 3; protocol=false)\nIdeal generating system with elements\n  1: x*y + y*z\n  2: x^2 + y^2\n  3: y^3 + y*z^2\n  4: y^2*x + y*z*y\n\n\n\n\n\n","category":"function"},{"location":"NoncommutativeAlgebra/free_associative_algebra/","page":"Free Associative Algebras","title":"Free Associative Algebras","text":"If a finite Gröbner basis exists, it solves the ideal membership problem.","category":"page"},{"location":"NoncommutativeAlgebra/free_associative_algebra/","page":"Free Associative Algebras","title":"Free Associative Algebras","text":"ideal_membership(a::FreeAssociativeAlgebraElem, I::FreeAssociativeAlgebraIdeal, deg_bound::Int)","category":"page"},{"location":"NoncommutativeAlgebra/free_associative_algebra/#ideal_membership-Tuple{FreeAssociativeAlgebraElem, Oscar.FreeAssociativeAlgebraIdeal, Int64}","page":"Free Associative Algebras","title":"ideal_membership","text":"ideal_membership(a::FreeAssociativeAlgebraElem, I::FreeAssociativeAlgebraIdeal, deg_bound::Int)\n\nReturns true if intermediate degree calculations bounded by deg_bound prove that a is in I. Otherwise, returning false indicates an inconclusive answer, but larger deg_bounds give more confidence in a negative answer.  If deg_bound is not specified, the default value is -1, which means that no degree bound is imposed, resulting in a calculation using a much slower algorithm that may not terminate, but will return a full Groebner basis if it does.\n\njulia> free, (x,y,z) = free_associative_algebra(QQ, [:x, :y, :z]);\n\njulia> f1 = x*y + y*z;\n\njulia> I = ideal([f1]);\n\njulia> ideal_membership(f1, I, 4)\ntrue\n\n\n\n\n\n","category":"method"},{"location":"AlgebraicGeometry/Schemes/ProjectiveSchemes/","page":"Projective schemes","title":"Projective schemes","text":"CurrentModule = Oscar","category":"page"},{"location":"AlgebraicGeometry/Schemes/ProjectiveSchemes/#Projective-schemes","page":"Projective schemes","title":"Projective schemes","text":"","category":"section"},{"location":"AlgebraicGeometry/Schemes/ProjectiveSchemes/","page":"Projective schemes","title":"Projective schemes","text":"Let A be a commutative noetherian base ring and S = Ax_0dots x_n the standard graded polynomial ring over A. Then X = mathrmProj(S) = mathbb P^n_A is a (relative) projective scheme over mathrmSpec(A). Similarly, for a homogeneous ideal I subset S we have X = mathrmProj(SI) subset mathbb P^n_A a (relative) projective scheme over mathrmSpec(A) which is a closed subscheme of mathbb P^n_A in a natural way. The majority of applications will be in the setting where A = mathbb k is a field, but be aware that we also support different base rings such as the usual four MPolyRing, MPolyQuoRing, MPolyLocRing, and MPolyQuoLocRing.","category":"page"},{"location":"AlgebraicGeometry/Schemes/ProjectiveSchemes/#Abstract-types-and-basic-interface","page":"Projective schemes","title":"Abstract types and basic interface","text":"","category":"section"},{"location":"AlgebraicGeometry/Schemes/ProjectiveSchemes/","page":"Projective schemes","title":"Projective schemes","text":"The abstract type for such projective schemes is","category":"page"},{"location":"AlgebraicGeometry/Schemes/ProjectiveSchemes/","page":"Projective schemes","title":"Projective schemes","text":"AbsProjectiveScheme{CoeffRingType, RingType} where {CoeffRingType<:Ring}","category":"page"},{"location":"AlgebraicGeometry/Schemes/ProjectiveSchemes/","page":"Projective schemes","title":"Projective schemes","text":"where, in the above notation, CoeffRingType denotes the type of A and RingType the type of either S or S/I, respectively. The abstract type comes with the following interface:","category":"page"},{"location":"AlgebraicGeometry/Schemes/ProjectiveSchemes/","page":"Projective schemes","title":"Projective schemes","text":"base_ring(X::AbsProjectiveScheme)\nbase_scheme(X::AbsProjectiveScheme)\nhomogeneous_coordinate_ring(P::AbsProjectiveScheme)\nrelative_ambient_dimension(X::AbsProjectiveScheme)\nambient_coordinate_ring(P::AbsProjectiveScheme)\nambient_space(P::AbsProjectiveScheme)\ndefining_ideal(X::AbsProjectiveScheme)\naffine_cone(X::AbsProjectiveScheme)\nhomogeneous_coordinates_on_affine_cone(X::AbsProjectiveScheme)\ncovered_scheme(P::AbsProjectiveScheme)","category":"page"},{"location":"AlgebraicGeometry/Schemes/ProjectiveSchemes/#base_ring-Tuple{AbsProjectiveScheme}","page":"Projective schemes","title":"base_ring","text":"base_ring(X::AbsProjectiveScheme)\n\nOn X  ℙʳ_A this returns A.\n\n\n\n\n\n","category":"method"},{"location":"AlgebraicGeometry/Schemes/ProjectiveSchemes/#base_scheme-Tuple{AbsProjectiveScheme}","page":"Projective schemes","title":"base_scheme","text":"base_scheme(X::AbsProjectiveScheme)\n\nReturn the base scheme Y for X  ℙʳₖ Y  Y with Y defined over a field 𝕜.\n\n\n\n\n\n","category":"method"},{"location":"AlgebraicGeometry/Schemes/ProjectiveSchemes/#homogeneous_coordinate_ring-Tuple{AbsProjectiveScheme}","page":"Projective schemes","title":"homogeneous_coordinate_ring","text":"homogeneous_coordinate_ring(P::AbsProjectiveScheme)\n\nOn a projective scheme P = Proj(S) for a standard graded finitely generated algebra S this returns S.\n\nExamples\n\njulia> S, _ = grade(QQ[:x, :y, :z][1]);\n\njulia> I = ideal(S, S[1] + S[2]);\n\njulia> X = proj(S, I)\nProjective scheme\n  over rational field\ndefined by ideal (x + y)\n\njulia> homogeneous_coordinate_ring(X)\nQuotient\n  of multivariate polynomial ring in 3 variables over QQ graded by\n    x -> [1]\n    y -> [1]\n    z -> [1]\n  by ideal (x + y)\n\n\n\n\n\n","category":"method"},{"location":"AlgebraicGeometry/Schemes/ProjectiveSchemes/#relative_ambient_dimension-Tuple{AbsProjectiveScheme}","page":"Projective schemes","title":"relative_ambient_dimension","text":"relative_ambient_dimension(X::AbsProjectiveScheme)\n\nOn X  ℙʳ_A this returns r.\n\nExamples\n\njulia> S, _ = grade(QQ[:x, :y, :z][1]);\n\njulia> I = ideal(S, S[1] + S[2])\nIdeal generated by\n  x + y\n\njulia> X = proj(S, I)\nProjective scheme\n  over rational field\ndefined by ideal (x + y)\n\njulia> relative_ambient_dimension(X)\n2\n\njulia> dim(X)\n1\n\n\n\n\n\n","category":"method"},{"location":"AlgebraicGeometry/Schemes/ProjectiveSchemes/#ambient_coordinate_ring-Tuple{AbsProjectiveScheme}","page":"Projective schemes","title":"ambient_coordinate_ring","text":"ambient_coordinate_ring(P::AbsProjectiveScheme)\n\nOn a projective scheme P = Proj(S) with S = PI for a standard graded polynomial ring P and a homogeneous ideal I this returns P.\n\nExamples\n\njulia> S, _ = grade(QQ[:x, :y, :z][1])\n(Graded multivariate polynomial ring in 3 variables over QQ, MPolyDecRingElem{QQFieldElem, QQMPolyRingElem}[x, y, z])\n\njulia> I = ideal(S, S[1] + S[2])\nIdeal generated by\n  x + y\n\njulia> X = proj(S, I)\nProjective scheme\n  over rational field\ndefined by ideal (x + y)\n\njulia> homogeneous_coordinate_ring(X)\nQuotient\n  of multivariate polynomial ring in 3 variables over QQ graded by\n    x -> [1]\n    y -> [1]\n    z -> [1]\n  by ideal (x + y)\n\njulia> ambient_coordinate_ring(X) === S\ntrue\n\njulia> ambient_coordinate_ring(X) === homogeneous_coordinate_ring(X)\nfalse\n\n\n\n\n\n","category":"method"},{"location":"AlgebraicGeometry/Schemes/ProjectiveSchemes/#ambient_space-Tuple{AbsProjectiveScheme}","page":"Projective schemes","title":"ambient_space","text":"ambient_space(X::AbsProjectiveScheme)\n\nOn X  ℙʳ_A this returns ℙʳ_A.\n\nExamples\n\njulia> S, _ = grade(QQ[:x, :y, :z][1]);\n\njulia> I = ideal(S, S[1] + S[2]);\n\njulia> X = proj(S, I)\nProjective scheme\n  over rational field\ndefined by ideal (x + y)\n\njulia> P = ambient_space(X)\nProjective space of dimension 2\n  over rational field\nwith homogeneous coordinates [x, y, z]\n\n\n\n\n\n","category":"method"},{"location":"AlgebraicGeometry/Schemes/ProjectiveSchemes/#defining_ideal-Tuple{AbsProjectiveScheme}","page":"Projective schemes","title":"defining_ideal","text":"defining_ideal(X::AbsProjectiveScheme)\n\nOn X  ℙʳ_A this returns the homogeneous ideal I  As₀sᵣ defining X.\n\nExamples\n\njulia> R, (u, v) = QQ[:u, :v];\n\njulia> Q, _ = quo(R, ideal(R, u^2 + v^2));\n\njulia> S, _ = grade(Q[:x, :y, :z][1]);\n\njulia> P = proj(S)\nProjective space of dimension 2\n  over quotient of multivariate polynomial ring by ideal (u^2 + v^2)\nwith homogeneous coordinates [x, y, z]\n\njulia> defining_ideal(P)\nIdeal with 0 generators\n\n\n\n\n\n","category":"method"},{"location":"AlgebraicGeometry/Schemes/ProjectiveSchemes/#affine_cone-Tuple{AbsProjectiveScheme}","page":"Projective schemes","title":"affine_cone","text":"affine_cone(X::AbsProjectiveScheme)\n\nOn X = Proj(S)  ℙʳ_𝕜 this returns a pair (C, f) where C = C(X)  𝕜ʳ¹ is the affine cone of X and f  S  𝒪(C) is the morphism of rings from the homogeneous_coordinate_ring to the coordinate_ring of the affine cone.\n\nNote that if the base scheme is not affine, then the affine cone is not affine.\n\nExamples\n\njulia> R, (u, v) = QQ[:u, :v];\n\njulia> Q, _ = quo(R, ideal(R, u^2 + v^2));\n\njulia> S, _ = grade(Q[:x, :y, :z][1]);\n\njulia> P = proj(S)\nProjective space of dimension 2\n  over quotient of multivariate polynomial ring by ideal (u^2 + v^2)\nwith homogeneous coordinates [x, y, z]\n\njulia> affine_cone(P)\n(scheme(u^2 + v^2), Map: S -> quotient of multivariate polynomial ring)\n\n\n\n\n\n","category":"method"},{"location":"AlgebraicGeometry/Schemes/ProjectiveSchemes/#homogeneous_coordinates_on_affine_cone-Tuple{AbsProjectiveScheme}","page":"Projective schemes","title":"homogeneous_coordinates_on_affine_cone","text":"homogeneous_coordinates_on_affine_cone(X::AbsProjectiveScheme)\n\nOn X  ℙʳ_A this returns a vector with the homogeneous coordinates s₀sᵣ as entries where each one of the sᵢ is a function on the affine cone of X.\n\nExamples\n\njulia> R, (u, v) = QQ[:u, :v];\n\njulia> Q, _ = quo(R, ideal(R, u^2 + v^2));\n\njulia> S, _ = grade(Q[:x, :y, :z][1]);\n\njulia> P = proj(S)\nProjective space of dimension 2\n  over quotient of multivariate polynomial ring by ideal (u^2 + v^2)\nwith homogeneous coordinates [x, y, z]\n\njulia> Oscar.homogeneous_coordinates_on_affine_cone(P)\n3-element Vector{MPolyQuoRingElem{MPolyDecRingElem{QQFieldElem, QQMPolyRingElem}}}:\n x\n y\n z\n\njulia> gens(OO(affine_cone(P)[1])) # all coordinates on the affine cone\n5-element Vector{MPolyQuoRingElem{MPolyDecRingElem{QQFieldElem, QQMPolyRingElem}}}:\n x\n y\n z\n u\n v\n\n\n\n\n\n","category":"method"},{"location":"AlgebraicGeometry/Schemes/ProjectiveSchemes/#covered_scheme-Tuple{AbsProjectiveScheme}","page":"Projective schemes","title":"covered_scheme","text":"covered_scheme(P::AbsProjectiveScheme)\n\nReturn a CoveredScheme X isomorphic to P with standard affine charts given by dehomogenization.\n\nUse dehomogenization_map with U one of the affine_charts of X to obtain the dehomogenization map from the homogeneous_coordinate_ring of P to the coordinate_ring of U.\n\nExamples\n\njulia> P = projective_space(QQ, 2);\n\njulia> Pcov = covered_scheme(P)\nScheme\n  over rational field\nwith default covering\n  described by patches\n    1: affine 2-space\n    2: affine 2-space\n    3: affine 2-space\n  in the coordinate(s)\n    1: [(s1//s0), (s2//s0)]\n    2: [(s0//s1), (s2//s1)]\n    3: [(s0//s2), (s1//s2)]\n\n\n\n\n\n","category":"method"},{"location":"AlgebraicGeometry/Schemes/ProjectiveSchemes/","page":"Projective schemes","title":"Projective schemes","text":"The minimal concrete type realizing this interface is","category":"page"},{"location":"AlgebraicGeometry/Schemes/ProjectiveSchemes/","page":"Projective schemes","title":"Projective schemes","text":"ProjectiveScheme{CoeffRingType, RingType} <: AbsProjectiveScheme{CoeffRingType, RingType}","category":"page"},{"location":"AlgebraicGeometry/Schemes/ProjectiveSchemes/#Constructors","page":"Projective schemes","title":"Constructors","text":"","category":"section"},{"location":"AlgebraicGeometry/Schemes/ProjectiveSchemes/","page":"Projective schemes","title":"Projective schemes","text":"Besides proj(S) for some graded polynomial ring or a graded affine algebra S, we provide the following constructors:","category":"page"},{"location":"AlgebraicGeometry/Schemes/ProjectiveSchemes/","page":"Projective schemes","title":"Projective schemes","text":"proj(S::MPolyDecRing)\nproj(S::MPolyDecRing, I::MPolyIdeal{T}) where {T<:MPolyDecRingElem}\nproj(I::MPolyIdeal{<:MPolyDecRingElem})\nproj(Q::MPolyQuoRing{<:MPolyDecRingElem})","category":"page"},{"location":"AlgebraicGeometry/Schemes/ProjectiveSchemes/","page":"Projective schemes","title":"Projective schemes","text":"Subschemes defined by homogeneous ideals, ring elements, or lists of elements can be created via the respective methods of the subscheme(P::AbsProjectiveScheme, ...) function. Special constructors are provided for projective space itself via the function projective_space and its various methods.","category":"page"},{"location":"AlgebraicGeometry/Schemes/ProjectiveSchemes/","page":"Projective schemes","title":"Projective schemes","text":"projective_space(A::Ring, var_symb::Vector{VarName})\nprojective_space(A::Ring, r::Int; var_name::VarName=:s)","category":"page"},{"location":"AlgebraicGeometry/Schemes/ProjectiveSchemes/#projective_space-Tuple{Ring, Vector{Union{Char, AbstractString, Symbol}}}","page":"Projective schemes","title":"projective_space","text":"projective_space(A::Ring, var_symb::Vector{VarName})\n\nCreate the (relative) projective space Proj(A[x₀,…,xₙ]) over A where x₀,…,xₙ is a list of variable names.\n\nExamples\n\njulia> projective_space(QQ, [:x, :PPP, :?])\nProjective space of dimension 2\n  over rational field\nwith homogeneous coordinates [x, PPP, ?]\n\njulia> homogeneous_coordinate_ring(ans)\nMultivariate polynomial ring in 3 variables over QQ graded by\n  x -> [1]\n  PPP -> [1]\n  ? -> [1]\n\n\n\n\n\n","category":"method"},{"location":"AlgebraicGeometry/Schemes/ProjectiveSchemes/#projective_space-Tuple{Ring, Int64}","page":"Projective schemes","title":"projective_space","text":"projective_space(A::Ring, r::Int; var_name::VarName=:s)\n\nCreate the (relative) projective space Proj(A[s₀,…,sᵣ]) over A where s is a string for the variable names.\n\n\n\n\n\n","category":"method"},{"location":"AlgebraicGeometry/Schemes/ProjectiveSchemes/#Attributes","page":"Projective schemes","title":"Attributes","text":"","category":"section"},{"location":"AlgebraicGeometry/Schemes/ProjectiveSchemes/","page":"Projective schemes","title":"Projective schemes","text":"Besides those attributes already covered by the above general interface we have the following (self-explanatory) ones for projective schemes over a field.","category":"page"},{"location":"AlgebraicGeometry/Schemes/ProjectiveSchemes/","page":"Projective schemes","title":"Projective schemes","text":"dim(P::AbsProjectiveScheme{<:Field})\nhilbert_polynomial(P::AbsProjectiveScheme{<:Field})\ndegree(P::AbsProjectiveScheme{<:Field})","category":"page"},{"location":"AlgebraicGeometry/Schemes/ProjectiveSchemes/","page":"Projective schemes","title":"Projective schemes","text":"arithmetic_genus(P::AbsProjectiveScheme{<:Field})","category":"page"},{"location":"AlgebraicGeometry/Schemes/ProjectiveSchemes/#arithmetic_genus-Tuple{AbsProjectiveScheme{<:Field}}","page":"Projective schemes","title":"arithmetic_genus","text":"arithmetic_genus(X::AbsProjectiveScheme{<:Field}) -> Int\n\nReturn the arithmetic genus of X, i.e. the integer (-1)^n (h_X(0) - 1) where h_X is the Hilbert polynomial of X and n its dimension.\n\n\n\n\n\n","category":"method"},{"location":"AlgebraicGeometry/Schemes/ProjectiveSchemes/#Methods","page":"Projective schemes","title":"Methods","text":"","category":"section"},{"location":"AlgebraicGeometry/Schemes/ProjectiveSchemes/","page":"Projective schemes","title":"Projective schemes","text":"To facilitate the interplay between an AbsProjectiveScheme and the affine charts of its covered_scheme we provide the following methods:","category":"page"},{"location":"AlgebraicGeometry/Schemes/ProjectiveSchemes/","page":"Projective schemes","title":"Projective schemes","text":"dehomogenization_map(X::AbsProjectiveScheme, U::AbsAffineScheme)\nhomogenization_map(P::AbsProjectiveScheme, U::AbsAffineScheme)","category":"page"},{"location":"AlgebraicGeometry/Schemes/ProjectiveSchemes/#dehomogenization_map-Tuple{AbsProjectiveScheme, AbsAffineScheme}","page":"Projective schemes","title":"dehomogenization_map","text":"dehomogenization_map(X::AbsProjectiveScheme, U::AbsAffineScheme)\n\nReturn the restriction morphism from the graded coordinate ring of X to 𝒪(U).\n\nExamples\n\njulia> P = projective_space(QQ, [\"x0\", \"x1\", \"x2\"])\nProjective space of dimension 2\n  over rational field\nwith homogeneous coordinates [x0, x1, x2]\n\njulia> X = covered_scheme(P);\n\njulia> U = first(affine_charts(X))\nSpectrum\n  of multivariate polynomial ring in 2 variables (x1//x0), (x2//x0)\n    over rational field\n\njulia> phi = dehomogenization_map(P, U);\n\njulia> S = homogeneous_coordinate_ring(P);\n\njulia> phi(S[2])\n(x1//x0)\n\n\n\n\n\n\n","category":"method"},{"location":"AlgebraicGeometry/Schemes/ProjectiveSchemes/#homogenization_map-Tuple{AbsProjectiveScheme, AbsAffineScheme}","page":"Projective schemes","title":"homogenization_map","text":"homogenization_map(P::AbsProjectiveScheme, U::AbsAffineScheme)\n\nGiven an affine chart U  P of an AbsProjectiveScheme P, return a method h for the homogenization of elements a  𝒪(U).\n\nThis means that h(a) returns a pair (p q) representing a fraction pq  S of the ambient_coordinate_ring of P such that a is the dehomogenization of pq.\n\nNote: For the time being, this only works for affine charts which are of the standard form sᵢ  0 for sᵢ S one of the homogeneous coordinates of P.\n\nNote: Since this map returns representatives only, it is not a mathematical morphism and, hence, in particular not an instance of Map.\n\nExamples\n\njulia> A, _ = QQ[:u, :v];\n\njulia> P = projective_space(A, [\"x0\", \"x1\", \"x2\"])\nProjective space of dimension 2\n  over multivariate polynomial ring in 2 variables over QQ\nwith homogeneous coordinates [x0, x1, x2]\n\njulia> X = covered_scheme(P)\nScheme\n  over rational field\nwith default covering\n  described by patches\n    1: affine 4-space\n    2: affine 4-space\n    3: affine 4-space\n  in the coordinate(s)\n    1: [(x1//x0), (x2//x0), u, v]\n    2: [(x0//x1), (x2//x1), u, v]\n    3: [(x0//x2), (x1//x2), u, v]\n\njulia> U = first(affine_charts(X))\nSpectrum\n  of multivariate polynomial ring in 4 variables (x1//x0), (x2//x0), u, v\n    over rational field\n\njulia> phi = homogenization_map(P, U);\n\njulia> R = OO(U);\n\njulia> phi.(gens(R))\n4-element Vector{Tuple{MPolyDecRingElem{QQMPolyRingElem, AbstractAlgebra.Generic.MPoly{QQMPolyRingElem}}, MPolyDecRingElem{QQMPolyRingElem, AbstractAlgebra.Generic.MPoly{QQMPolyRingElem}}}}:\n (x1, x0)\n (x2, x0)\n (u, 1)\n (v, 1)\n\n\n\n\n\n","category":"method"},{"location":"AlgebraicGeometry/Schemes/ProjectiveSchemes/#Properties","page":"Projective schemes","title":"Properties","text":"","category":"section"},{"location":"AlgebraicGeometry/Schemes/ProjectiveSchemes/","page":"Projective schemes","title":"Projective schemes","text":"Further properties of projective schemes:","category":"page"},{"location":"AlgebraicGeometry/Schemes/ProjectiveSchemes/","page":"Projective schemes","title":"Projective schemes","text":"is_smooth(P::AbsProjectiveScheme{<:Any, <:MPolyQuoRing}; algorithm=:default)","category":"page"},{"location":"AlgebraicGeometry/Schemes/ProjectiveSchemes/#is_smooth-Tuple{AbsProjectiveScheme{<:Any, <:MPolyQuoRing}}","page":"Projective schemes","title":"is_smooth","text":"is_smooth(P::AbsProjectiveScheme; algorithm::Symbol=:default) -> Bool\n\nCheck whether the scheme P is smooth.\n\nAlgorithms\n\nThere are three possible algorithms for checking smoothness, determined by the value of the keyword argument algorithm:\n\n:projective_jacobian - uses the Jacobian criterion for projective schemes, see Exercise 4.2.10 of [Liu06],\n:covered_jacobian - uses covered version of the Jacobian criterion,\n:affine_cone - checks that the affine cone is smooth outside the origin.\n\nThe :projective_jacobian and the :covered algorithms only work for equidimensional schemes. The algorithms first check for equidimensionality, which can be expensive. If you already know that the scheme is equidimensional, then you can avoid recomputing that by writing   set_attribute!(P, :is_equidimensional, true) before checking for smoothness.\n\nThe algorithms :covered_jacobian and :affine_cone only work when the base ring is a field.\n\nThe default algorithm is :projective_jacobian if the scheme is equidimensional, otherwise it is :affine_cone.\n\nExamples\n\njulia> A, (x, y, z) = grade(QQ[:x, :y, :z][1]);\n\njulia> B, _ = quo(A, ideal(A, [x^2 + y^2]));\n\njulia> C = proj(B)\nProjective scheme\n  over rational field\ndefined by ideal (x^2 + y^2)\n\njulia> is_smooth(C)\nfalse\n\njulia> is_smooth(C; algorithm=:covered_jacobian)\nfalse\n\n\n\n\n\n","category":"method"},{"location":"AlgebraicGeometry/Schemes/ProjectiveSchemes/","page":"Projective schemes","title":"Projective schemes","text":"is_empty(P::AbsProjectiveScheme{<:Field})\nis_irreducible(P::AbsProjectiveScheme)\nis_reduced(P::AbsProjectiveScheme)\nis_geometrically_reduced(P::AbsProjectiveScheme{<:Field})\nis_geometrically_irreducible(P::AbsProjectiveScheme{<:Field})\nis_integral(X::AbsProjectiveScheme{<:Field})\nis_geometrically_integral(X::AbsProjectiveScheme{<:Field})","category":"page"},{"location":"AbstractAlgebra/direct_sum/","page":"Direct Sums","title":"Direct Sums","text":"CurrentModule = AbstractAlgebra\nDocTestSetup = AbstractAlgebra.doctestsetup()","category":"page"},{"location":"AbstractAlgebra/direct_sum/#Direct-Sums","page":"Direct Sums","title":"Direct Sums","text":"","category":"section"},{"location":"AbstractAlgebra/direct_sum/","page":"Direct Sums","title":"Direct Sums","text":"AbstractAlgebra allows the construction of the external direct sum of any nonempty vector of finitely presented modules.","category":"page"},{"location":"AbstractAlgebra/direct_sum/","page":"Direct Sums","title":"Direct Sums","text":"Note that external direct sums are considered equal iff they are the same object.","category":"page"},{"location":"AbstractAlgebra/direct_sum/#Generic-direct-sum-type","page":"Direct Sums","title":"Generic direct sum type","text":"","category":"section"},{"location":"AbstractAlgebra/direct_sum/","page":"Direct Sums","title":"Direct Sums","text":"AbstractAlgebra provides a generic direct sum type Generic.DirectSumModule{T} where T is the element type of the base ring. The implementation is in src/generic/DirectSum.jl","category":"page"},{"location":"AbstractAlgebra/direct_sum/","page":"Direct Sums","title":"Direct Sums","text":"Elements of direct sum modules have type Generic.DirectSumModuleElem{T}.","category":"page"},{"location":"AbstractAlgebra/direct_sum/#Abstract-types","page":"Direct Sums","title":"Abstract types","text":"","category":"section"},{"location":"AbstractAlgebra/direct_sum/","page":"Direct Sums","title":"Direct Sums","text":"Direct sum module types belong to the abstract type FPModule{T} and their elements to FPModuleElem{T}.","category":"page"},{"location":"AbstractAlgebra/direct_sum/#Constructors","page":"Direct Sums","title":"Constructors","text":"","category":"section"},{"location":"AbstractAlgebra/direct_sum/","page":"Direct Sums","title":"Direct Sums","text":"direct_sum","category":"page"},{"location":"AbstractAlgebra/direct_sum/#direct_sum","page":"Direct Sums","title":"direct_sum","text":"direct_sum(m::Vector{<:FPModule{T}}) where T <: RingElement\ndirect_sum(vals::FPModule{T}...) where T <: RingElement\n\nReturn a tuple M f g consisting of M the direct sum of the modules m (supplied as a vector of modules), a vector f of the injections of the mi into M and a vector g of the projections from M onto the mi.\n\n\n\n\n\ndirect_sum(G::FinGenAbGroup...) -> FinGenAbGroup, Vector{FinGenAbGroupHom}\n\nReturn the direct sum D of the (finitely many) abelian groups G_i, together with the injections G_i to D.\n\nFor finite abelian groups, finite direct sums and finite direct products agree and they are therefore called biproducts. If one wants to obtain D as a direct product together with the projections D to G_i, one should call direct_product(G...). If one wants to obtain D as a biproduct together with the projections and the injections, one should call biproduct(G...).\n\nOtherwise, one could also call canonical_injections(D) or canonical_projections(D) later on.\n\n\n\n\n\ndirect_sum(x::Vararg{T}) where T <: AbstractSpace -> T, Vector{AbstractSpaceMor}\ndirect_sum(x::Vector{T}) where T <: AbstractSpace -> T, Vector{AbstractSpaceMor}\n\nGiven a collection of quadratic or hermitian spaces V_1 ldots V_n, return their direct sum V = V_1 oplus ldots oplus V_n, together with the injections V_i to V.\n\nFor objects of type AbstractSpace, finite direct sums and finite direct products agree and they are therefore called biproducts. If one wants to obtain V as a direct product with the projections V to V_i, one should call direct_product(x). If one wants to obtain V as a biproduct with the injections V_i to V and the projections V to V_i, one should call biproduct(x).\n\n\n\n\n\ndirect_sum(x::Vararg{T}) where T <: AbstractLat -> T, Vector{AbstractSpaceMor}\ndirect_sum(x::Vector{T}) where T <: AbstractLat -> T, Vector{AbstractSpaceMor}\n\nGiven a collection of quadratic or hermitian lattices L_1 ldots L_n, return their direct sum L = L_1 oplus ldots oplus L_n, together with the injections L_i to L (seen as maps between the corresponding ambient spaces).\n\nFor objects of type AbstractLat, finite direct sums and finite direct products agree and they are therefore called biproducts. If one wants to obtain L as a direct product with the projections L to L_i, one should call direct_product(x). If one wants to obtain L as a biproduct with the injections L_i to L and the projections L to L_i, one should call biproduct(x).\n\n\n\n\n\ndirect_sum(x::Vararg{TorQuadModule}) -> TorQuadModule, Vector{TorQuadModuleMap}\ndirect_sum(x::Vector{TorQuadModule}) -> TorQuadModule, Vector{TorQuadModuleMap}\n\nGiven a collection of torsion quadratic modules T_1 ldots T_n, return their direct sum T = T_1oplus ldots oplus T_n, together with the injections T_i to T.\n\nFor objects of type TorQuadModule, finite direct sums and finite direct products agree and they are therefore called biproducts. If one wants to obtain T as a direct product with the projections T to T_i, one should call direct_product(x). If one wants to obtain T as a biproduct with the injections T_i to T and the projections T to T_i, one should call biproduct(x).\n\n\n\n\n\ndirect_sum(g1::QuadSpaceCls, g2::QuadSpaceCls) -> QuadSpaceCls\n\nReturn the isometry class of the direct sum of two representatives.\n\n\n\n\n\ndirect_sum(x::Vararg{ZZLat}) -> ZZLat, Vector{AbstractSpaceMor}\ndirect_sum(x::Vector{ZZLat}) -> ZZLat, Vector{AbstractSpaceMor}\n\nGiven a collection of mathbb Z-lattices L_1 ldots L_n, return their direct sum L = L_1 oplus ldots oplus L_n, together with the injections L_i to L. (seen as maps between the corresponding ambient spaces).\n\nFor objects of type ZZLat, finite direct sums and finite direct products agree and they are therefore called biproducts. If one wants to obtain L as a direct product with the projections L to L_i, one should call direct_product(x). If one wants to obtain L as a biproduct with the injections L_i to L and the projections L to L_i, one should call biproduct(x).\n\n\n\n\n\ndirect_sum(S1::ZZLocalGenus, S2::ZZLocalGenus) -> ZZLocalGenus\n\nReturn the local genus of the direct sum of two representatives.\n\n\n\n\n\ndirect_sum(G1::ZZGenus, G2::ZZGenus) -> ZZGenus\n\nReturn the genus of the direct sum of G1 and G2.\n\nThe direct sum is defined via representatives.\n\n\n\n\n\ndirect_sum(g1::HermLocalGenus, g2::HermLocalGenus) -> HermLocalGenus\n\nGiven two local genus symbols g1 and g2 for hermitian lattices over EK at the same prime ideal mathfrak p of mathcal O_K, return their direct sum. It corresponds to the local genus symbol of the mathfrak p-adic completion of the direct sum of respective representatives of g1 and g2.\n\n\n\n\n\ndirect_sum(G1::HermGenus, G2::HermGenus) -> HermGenus\n\nGiven two global genus symbols G1 and G2 for hermitian lattices over EK, return their direct sum. It corresponds to the global genus symbol of the direct sum of respective representatives of G1 and G2.\n\n\n\n\n\ndirect_sum(M::ModuleFP{T}...; task::Symbol = :sum) where T\n\nGiven modules M_1dots M_n, say, return the direct sum bigoplus_i=1^n M_i.  \n\nAdditionally, return \n\na vector containing the canonical injections  M_itobigoplus_i=1^n M_i if task = :sum (default),\na vector containing the canonical projections  bigoplus_i=1^n M_ito M_i if task = :prod,\ntwo vectors containing the canonical injections and projections, respectively, if task = :both,\nnone of the above maps if task = :none.\n\n\n\n\n\ndirect_sum(M::Matroid, N::Matroid)\n\nThe direct sum of the matroids M and N. Optionally one can also pass a vector of matroids.\n\nSee Section 4.2 of [Oxl11].\n\nTo obtain the direct sum of the Fano and a uniform matroid type:\n\nExamples\n\njulia> direct_sum(fano_matroid(), uniform_matroid(2,4))\nMatroid of rank 5 on 11 elements\n\nTo take the sum of three uniform matroids use:\n\nExamples\n\njulia> matroids = Vector([uniform_matroid(2,4), uniform_matroid(1,3), uniform_matroid(3,4)]);\n\njulia> M = direct_sum(matroids)\nMatroid of rank 6 on 11 elements\n\n\n\n\n\ndirect_sum(x::Vector{QuadSpaceWithIsom}) -> QuadSpaceWithIsom, Vector{AbstractSpaceMor}\ndirect_sum(x::Vararg{QuadSpaceWithIsom}) -> QuadSpaceWithIsom, Vector{AbstractSpaceMor}\n\nGiven a collection of quadratic spaces with isometries (V_1 f_1) ldots (V_n f_n), return the quadratic space with isometry (V f) together with the injections V_i to V, where V is the direct sum V = V_1 oplus ldots oplus V_n and f is the isometry of V induced by the diagonal actions of the f_i's.\n\nFor objects of type QuadSpaceWithIsom, finite direct sums and finite direct products agree and they are therefore called biproducts. If one wants to obtain (V f) as a direct product with the projections V to V_i, one should call direct_product(x). If one wants to obtain (V f) as a biproduct with the injections V_i to V and the projections V to V_i, one should call biproduct(x).\n\nExamples\n\njulia> V1 = quadratic_space(QQ, QQ[2 5;\n                                   5 6])\nQuadratic space of dimension 2\n  over rational field\nwith gram matrix\n[2   5]\n[5   6]\n\njulia> Vf1 = quadratic_space_with_isometry(V1, neg=true)\nQuadratic space of dimension 2\n  with isometry of finite order 2\n  given by\n  [-1    0]\n  [ 0   -1]\n\njulia> V2 = quadratic_space(QQ, QQ[ 2 -1;\n                                   -1  2])\nQuadratic space of dimension 2\n  over rational field\nwith gram matrix\n[ 2   -1]\n[-1    2]\n\njulia> f = matrix(QQ, 2, 2, [1  1;\n                             0 -1])\n[1    1]\n[0   -1]\n\njulia> Vf2 = quadratic_space_with_isometry(V2, f)\nQuadratic space of dimension 2\n  with isometry of finite order 2\n  given by\n  [1    1]\n  [0   -1]\n\njulia> Vf3, inj = direct_sum(Vf1, Vf2)\n(Quadratic space with isometry of finite order 2, AbstractSpaceMor[Map: quadratic space -> quadratic space, Map: quadratic space -> quadratic space])\n\njulia> Vf3\nQuadratic space of dimension 4\n  with isometry of finite order 2\n  given by\n  [-1    0   0    0]\n  [ 0   -1   0    0]\n  [ 0    0   1    1]\n  [ 0    0   0   -1]\n\njulia> space(Vf3)\nQuadratic space of dimension 4\n  over rational field\nwith gram matrix\n[2   5    0    0]\n[5   6    0    0]\n[0   0    2   -1]\n[0   0   -1    2]\n\nwarning: Experimental\nThis function is part of the experimental code in Oscar. Please read here for more details.\n\n\n\n\n\ndirect_sum(x::Vector{ZZLatWithIsom}) -> ZZLatWithIsom,\n                                                   Vector{AbstractSpaceMor}\ndirect_sum(x::Vararg{ZZLatWithIsom}) -> ZZLatWithIsom,\n                                                   Vector{AbstractSpaceMor}\n\nGiven a collection of lattices with isometries (L_1 f_1) ldots (L_n f_n), return the lattice with isometry (L f) together with the injections L_i to L, where L is the direct sum L = L_1 oplus ldots oplus L_n and f is the isometry of L induced by the diagonal actions of the f_i's.\n\nFor objects of type ZZLatWithIsom, finite direct sums and finite direct products agree and they are therefore called biproducts. If one wants to obtain (L f) as a direct product with the projections L to L_i, one should call direct_product(x). If one wants to obtain (L f) as a biproduct with the injections L_i to L and the projections L to L_i, one should call biproduct(x).\n\nExamples\n\njulia> L = root_lattice(:A,5);\n\njulia> f = matrix(QQ, 5, 5, [ 1  0  0  0  0;\n                             -1 -1 -1 -1 -1;\n                              0  0  0  0  1;\n                              0  0  0  1  0;\n                              0  0  1  0  0]);\n\njulia> g = matrix(QQ, 5, 5, [1  1  1  1  1;\n                             0 -1 -1 -1 -1;\n                             0  1  0  0  0;\n                             0  0  1  0  0;\n                             0  0  0  1  0]);\n\njulia> Lf = integer_lattice_with_isometry(L, f)\nInteger lattice of rank 5 and degree 5\n  with isometry of finite order 2\n  given by\n  [ 1    0    0    0    0]\n  [-1   -1   -1   -1   -1]\n  [ 0    0    0    0    1]\n  [ 0    0    0    1    0]\n  [ 0    0    1    0    0]\n\njulia> Lg = integer_lattice_with_isometry(L, g)\nInteger lattice of rank 5 and degree 5\n  with isometry of finite order 5\n  given by\n  [1    1    1    1    1]\n  [0   -1   -1   -1   -1]\n  [0    1    0    0    0]\n  [0    0    1    0    0]\n  [0    0    0    1    0]\n\njulia> Lh, inj = direct_sum(Lf, Lg)\n(Integer lattice with isometry of finite order 10, AbstractSpaceMor[Map: quadratic space -> quadratic space, Map: quadratic space -> quadratic space])\n\njulia> Lh\nInteger lattice of rank 10 and degree 10\n  with isometry of finite order 10\n  given by\n  [ 1    0    0    0    0   0    0    0    0    0]\n  [-1   -1   -1   -1   -1   0    0    0    0    0]\n  [ 0    0    0    0    1   0    0    0    0    0]\n  [ 0    0    0    1    0   0    0    0    0    0]\n  [ 0    0    1    0    0   0    0    0    0    0]\n  [ 0    0    0    0    0   1    1    1    1    1]\n  [ 0    0    0    0    0   0   -1   -1   -1   -1]\n  [ 0    0    0    0    0   0    1    0    0    0]\n  [ 0    0    0    0    0   0    0    1    0    0]\n  [ 0    0    0    0    0   0    0    0    1    0]\n\nwarning: Experimental\nThis function is part of the experimental code in Oscar. Please read here for more details.\n\n\n\n\n\nFor a vector of maps   fi : M -> Ni compute the map   f : M -> prod Ni : m -> (fi(m))_i\n\nwarning: Experimental\nThis function is part of the experimental code in Oscar. Please read here for more details.\n\n\n\n\n\ndirect_sum(V::LieAlgebraModule{C}...) -> LieAlgebraModule{C}\n⊕(V::LieAlgebraModule{C}...) -> LieAlgebraModule{C}\n\nConstruct the direct sum of the modules V....\n\nExamples\n\njulia> L = special_linear_lie_algebra(QQ, 3);\n\njulia> V1 = exterior_power(standard_module(L), 2)[1]; # some module\n\njulia> V2 = symmetric_power(standard_module(L), 3)[1]; # some module\n\njulia> direct_sum(V1, V2)\nDirect sum module\n  of dimension 13\n  direct sum with direct summands\n    2nd exterior power of\n      standard module\n    3rd symmetric power of\n      standard module\nover special linear Lie algebra of degree 3 over QQ\n\nwarning: Experimental\nThis function is part of the experimental code in Oscar. Please read here for more details.\n\n\n\n\n\n","category":"function"},{"location":"AbstractAlgebra/direct_sum/","page":"Direct Sums","title":"Direct Sums","text":"Examples","category":"page"},{"location":"AbstractAlgebra/direct_sum/","page":"Direct Sums","title":"Direct Sums","text":"julia> F = free_module(ZZ, 5)\nFree module of rank 5 over integers\n\njulia> m1 = F(BigInt[4, 7, 8, 2, 6])\n(4, 7, 8, 2, 6)\n\njulia> m2 = F(BigInt[9, 7, -2, 2, -4])\n(9, 7, -2, 2, -4)\n\njulia> S1, f1 = sub(F, [m1, m2])\n(Submodule over integers with 2 generators and no relations, Hom: S1 -> F)\n\njulia> m1 = F(BigInt[3, 1, 7, 7, -7])\n(3, 1, 7, 7, -7)\n\njulia> m2 = F(BigInt[-8, 6, 10, -1, 1])\n(-8, 6, 10, -1, 1)\n\njulia> S2, f2 = sub(F, [m1, m2])\n(Submodule over integers with 2 generators and no relations, Hom: S2 -> F)\n\njulia> m1 = F(BigInt[2, 4, 2, -3, -10])\n(2, 4, 2, -3, -10)\n\njulia> m2 = F(BigInt[5, 7, -6, 9, -5])\n(5, 7, -6, 9, -5)\n\njulia> S3, f3 = sub(F, [m1, m2])\n(Submodule over integers with 2 generators and no relations, Hom: S3 -> F)\n\njulia> D, f = direct_sum(S1, S2, S3)\n(DirectSumModule over integers, AbstractAlgebra.Generic.ModuleHomomorphism{BigInt}[Hom: S1 -> D, Hom: S2 -> D, Hom: S3 -> D], AbstractAlgebra.Generic.ModuleHomomorphism{BigInt}[Hom: D -> S1, Hom: D -> S2, Hom: D -> S3])","category":"page"},{"location":"AbstractAlgebra/direct_sum/#Functionality-for-direct-sums","page":"Direct Sums","title":"Functionality for direct sums","text":"","category":"section"},{"location":"AbstractAlgebra/direct_sum/","page":"Direct Sums","title":"Direct Sums","text":"In addition to the Module interface, AbstractAlgebra direct sums implement the following functionality.","category":"page"},{"location":"AbstractAlgebra/direct_sum/#Basic-manipulation","page":"Direct Sums","title":"Basic manipulation","text":"","category":"section"},{"location":"AbstractAlgebra/direct_sum/","page":"Direct Sums","title":"Direct Sums","text":"summands(::Generic.DirectSumModule{T}) where T <: RingElement","category":"page"},{"location":"AbstractAlgebra/direct_sum/#summands-Union{Tuple{AbstractAlgebra.Generic.DirectSumModule{T}}, Tuple{T}} where T<:RingElement","page":"Direct Sums","title":"summands","text":"summands(M::DirectSumModule{T}) where T <: RingElement\n\nReturn the modules that this module is a direct sum of.\n\n\n\n\n\n","category":"method"},{"location":"AbstractAlgebra/direct_sum/","page":"Direct Sums","title":"Direct Sums","text":"Examples","category":"page"},{"location":"AbstractAlgebra/direct_sum/","page":"Direct Sums","title":"Direct Sums","text":"julia> F = free_module(ZZ, 5)\nFree module of rank 5 over integers\n\njulia> m1 = F(BigInt[4, 7, 8, 2, 6])\n(4, 7, 8, 2, 6)\n\njulia> m2 = F(BigInt[9, 7, -2, 2, -4])\n(9, 7, -2, 2, -4)\n\njulia> S1, f1 = sub(F, [m1, m2])\n(Submodule over integers with 2 generators and no relations, Hom: S1 -> F)\n\njulia> m1 = F(BigInt[3, 1, 7, 7, -7])\n(3, 1, 7, 7, -7)\n\njulia> m2 = F(BigInt[-8, 6, 10, -1, 1])\n(-8, 6, 10, -1, 1)\n\njulia> S2, f2 = sub(F, [m1, m2])\n(Submodule over integers with 2 generators and no relations, Hom: S2 -> F)\n\njulia> m1 = F(BigInt[2, 4, 2, -3, -10])\n(2, 4, 2, -3, -10)\n\njulia> m2 = F(BigInt[5, 7, -6, 9, -5])\n(5, 7, -6, 9, -5)\n\njulia> S3, f3 = sub(F, [m1, m2])\n(Submodule over integers with 2 generators and no relations, Hom: S3 -> F)\n\njulia> D, f = direct_sum(S1, S2, S3)\n(DirectSumModule over integers, AbstractAlgebra.Generic.ModuleHomomorphism{BigInt}[Hom: S1 -> D, Hom: S2 -> D, Hom: S3 -> D], AbstractAlgebra.Generic.ModuleHomomorphism{BigInt}[Hom: D -> S1, Hom: D -> S2, Hom: D -> S3])\n\njulia> summands(D)\n3-element Vector{AbstractAlgebra.Generic.Submodule{BigInt}}:\n Submodule over integers with 2 generators and no relations\n Submodule over integers with 2 generators and no relations\n Submodule over integers with 2 generators and no relations","category":"page"},{"location":"AbstractAlgebra/direct_sum/","page":"Direct Sums","title":"Direct Sums","text":"    (D::DirectSumModule{T}(::Vector{<:FPModuleElem{T}}) where T <: RingElement","category":"page"},{"location":"AbstractAlgebra/direct_sum/","page":"Direct Sums","title":"Direct Sums","text":"Given a vector (or 1-dim array) of module elements, where the i-th entry has to be an element of the i-summand of D, create the corresponding element in D.","category":"page"},{"location":"AbstractAlgebra/direct_sum/","page":"Direct Sums","title":"Direct Sums","text":"Examples","category":"page"},{"location":"AbstractAlgebra/direct_sum/","page":"Direct Sums","title":"Direct Sums","text":"julia> N = free_module(QQ, 1);\n\njulia> M = free_module(QQ, 2);\n\njulia> D, _ = direct_sum(M, N, M);\n\njulia> D([gen(M, 1), gen(N, 1), gen(M, 2)])\n(1//1, 0//1, 1//1, 0//1, 1//1)","category":"page"},{"location":"AbstractAlgebra/direct_sum/#Special-Homomorphisms","page":"Direct Sums","title":"Special Homomorphisms","text":"","category":"section"},{"location":"AbstractAlgebra/direct_sum/","page":"Direct Sums","title":"Direct Sums","text":"Due to the special structure as direct sums, homomorphisms can be created by specifying homomorphisms for all summands. In case of the codmain being a direct sum as well, any homomorphism may be thought of as a matrix containing maps from the i-th source summand to the j-th target module:","category":"page"},{"location":"AbstractAlgebra/direct_sum/","page":"Direct Sums","title":"Direct Sums","text":"ModuleHomomorphism(D::DirectSumModule{T}, S::DirectSumModule{T}, m::Matrix{Any}) where T <: RingElement","category":"page"},{"location":"AbstractAlgebra/direct_sum/","page":"Direct Sums","title":"Direct Sums","text":"Given a matrix m such that the (ij)-th entry is either 0 (Int(0)) or a ModuleHomomorphism from the i-th summand of D to the j-th summand of S, construct the corresponding homomorphism.","category":"page"},{"location":"AbstractAlgebra/direct_sum/","page":"Direct Sums","title":"Direct Sums","text":"ModuleHomomorphism(D::DirectSumModule{T}, S::FPModuleElem{T}, m::Vector{ModuleHomomorphism})","category":"page"},{"location":"AbstractAlgebra/direct_sum/","page":"Direct Sums","title":"Direct Sums","text":"Given an array a of ModuleHomomorphism such that a_i, the i-th entry of a is a ModuleHomomorphism from the i-th summand of D into S, construct the direct sum of the components.","category":"page"},{"location":"AbstractAlgebra/direct_sum/","page":"Direct Sums","title":"Direct Sums","text":"Given a matrix m such that the (ij)-th entry is either 0 (Int(0)) or a ModuleHomomorphism from the i-th summand of D to the j-th summand of S, construct the corresponding homomorphism.","category":"page"},{"location":"AbstractAlgebra/direct_sum/","page":"Direct Sums","title":"Direct Sums","text":"Examples","category":"page"},{"location":"AbstractAlgebra/direct_sum/","page":"Direct Sums","title":"Direct Sums","text":"julia> N = free_module(QQ, 2);\n\njulia> D, _ = direct_sum(N, N);\n\njulia> p = ModuleHomomorphism(N, N, [3,4] .* basis(N));\n\njulia> q = ModuleHomomorphism(N, N, [5,7] .* basis(N));\n\njulia> phi = ModuleHomomorphism(D, D, [p 0; 0 q])\nModule homomorphism\n  from DirectSumModule over rationals\n  to DirectSumModule over rationals\n\njulia> r = ModuleHomomorphism(N, D, [2,3] .* gens(D)[1:2])\nModule homomorphism\n  from vector space of dimension 2 over rationals\n  to DirectSumModule over rationals\n\njulia> psi = ModuleHomomorphism(D, D, [r, r])\nModule homomorphism\n  from DirectSumModule over rationals\n  to DirectSumModule over rationals","category":"page"},{"location":"CommutativeAlgebra/Miscellaneous/binomial_ideals/","page":"Binomial Primary Decomposition","title":"Binomial Primary Decomposition","text":"CurrentModule = Oscar\nDocTestSetup = Oscar.doctestsetup()","category":"page"},{"location":"CommutativeAlgebra/Miscellaneous/binomial_ideals/#Binomial-Primary-Decomposition","page":"Binomial Primary Decomposition","title":"Binomial Primary Decomposition","text":"","category":"section"},{"location":"CommutativeAlgebra/Miscellaneous/binomial_ideals/#Introduction","page":"Binomial Primary Decomposition","title":"Introduction","text":"","category":"section"},{"location":"CommutativeAlgebra/Miscellaneous/binomial_ideals/","page":"Binomial Primary Decomposition","title":"Binomial Primary Decomposition","text":"A binomial is a polynomial consisting of at most two terms. A binomial ideal is an ideal which can be generated by binomials. A binomial primary decomposition is a primary decomposition of a binomial ideal into primary ideals which are binomial as well. In this section, focusing on polynomial rings over fields, we discuss functionality for computing such decompositions.","category":"page"},{"location":"CommutativeAlgebra/Miscellaneous/binomial_ideals/","page":"Binomial Primary Decomposition","title":"Binomial Primary Decomposition","text":"We begin by recalling that a proper ideal I of a polynomial ring Kx_1 dots x_n over a field K is called cellular if each variable x_i is either a nonzerodivisor or nilpotent modulo I. In this case, we refer to the nonzerodivisors among the variables as the cell variables with respect to I. A cellular decomposition of a proper binomial ideal I of Kx_1 dots x_n is a decomposition of I into cellular binomial ideals. Using Noetherian induction, it is not too difficult to show that such decompositions exist. ","category":"page"},{"location":"CommutativeAlgebra/Miscellaneous/binomial_ideals/","page":"Binomial Primary Decomposition","title":"Binomial Primary Decomposition","text":"With this notation, the algorithms for computing binomial primary decompositions proceed in two main steps:","category":"page"},{"location":"CommutativeAlgebra/Miscellaneous/binomial_ideals/","page":"Binomial Primary Decomposition","title":"Binomial Primary Decomposition","text":"First, compute a cellular decomposition of the given binomial ideal.\nThen, decompose each cellular component into primary binomial ideals.","category":"page"},{"location":"CommutativeAlgebra/Miscellaneous/binomial_ideals/","page":"Binomial Primary Decomposition","title":"Binomial Primary Decomposition","text":"While the first step can be performed over any ground field for which Gröbner bases are implemented, the second step may require a field extension: From a theoretical point of view, the existence of binomial primary decompositions is only guaranteed if the ground field is algebraically closed.","category":"page"},{"location":"CommutativeAlgebra/Miscellaneous/binomial_ideals/","page":"Binomial Primary Decomposition","title":"Binomial Primary Decomposition","text":"note: Note\nA pure difference binomial is a binomial which is the difference of two monomials. A unital binomial ideal is an ideal which can be generated by pure difference binomials and monomials. Note that cellular components of unital binomial ideals are unital as well. For unital binomial ideals in mathbb Qx_1 dots x_n, binomial primary decompositions exist already over cyclotomic extensions of mathbb Q. In particular, any such ideal can be decomposed over the abelian closure mathbb Q^textab of mathbb Q. While OSCAR offers functionality for doing this, computing  binomial primary decompositions  in other cases is not yet supported. See the number theory chapter for how to deal with mathbb Q^textab.","category":"page"},{"location":"CommutativeAlgebra/Miscellaneous/binomial_ideals/","page":"Binomial Primary Decomposition","title":"Binomial Primary Decomposition","text":"note: Note\nBinomial primary decompositions computed with OSCAR are not necessarily minimal.","category":"page"},{"location":"CommutativeAlgebra/Miscellaneous/binomial_ideals/","page":"Binomial Primary Decomposition","title":"Binomial Primary Decomposition","text":"Papers offering details on theory and algorithms as well as examples include:","category":"page"},{"location":"CommutativeAlgebra/Miscellaneous/binomial_ideals/","page":"Binomial Primary Decomposition","title":"Binomial Primary Decomposition","text":"[ES96]\n[OMdCS00]\n[Kah10]\n[EM16]\n[EM19]","category":"page"},{"location":"CommutativeAlgebra/Miscellaneous/binomial_ideals/#Basic-Tests","page":"Binomial Primary Decomposition","title":"Basic Tests","text":"","category":"section"},{"location":"CommutativeAlgebra/Miscellaneous/binomial_ideals/#Binomiality-Test","page":"Binomial Primary Decomposition","title":"Binomiality Test","text":"","category":"section"},{"location":"CommutativeAlgebra/Miscellaneous/binomial_ideals/","page":"Binomial Primary Decomposition","title":"Binomial Primary Decomposition","text":"is_binomial(f::MPolyRingElem)\nis_binomial(I::MPolyIdeal)","category":"page"},{"location":"CommutativeAlgebra/Miscellaneous/binomial_ideals/#is_binomial-Tuple{MPolyRingElem}","page":"Binomial Primary Decomposition","title":"is_binomial","text":"is_binomial(f::MPolyRingElem)\n\nReturn true if f consists of at most 2 terms, false otherwise.\n\n\n\n\n\n","category":"method"},{"location":"CommutativeAlgebra/Miscellaneous/binomial_ideals/#is_binomial-Tuple{MPolyIdeal}","page":"Binomial Primary Decomposition","title":"is_binomial","text":"is_binomial(I::MPolyIdeal)\n\nReturn true if I can be generated by polynomials consisting of at most 2 terms, false otherwise.\n\n\n\n\n\n","category":"method"},{"location":"CommutativeAlgebra/Miscellaneous/binomial_ideals/","page":"Binomial Primary Decomposition","title":"Binomial Primary Decomposition","text":"julia> R, (x, y, z) = polynomial_ring(QQ, [:x, :y, :z])\n(Multivariate polynomial ring in 3 variables over QQ, QQMPolyRingElem[x, y, z])\n\njulia> f = 2*x+y\n2*x + y\n\njulia> is_binomial(f)\ntrue\n\njulia> J = ideal(R, [x^2-y^3, z^2])\nIdeal generated by\n  x^2 - y^3\n  z^2\n\njulia> is_binomial(J)\ntrue\n","category":"page"},{"location":"CommutativeAlgebra/Miscellaneous/binomial_ideals/#Cellularity-Test","page":"Binomial Primary Decomposition","title":"Cellularity Test","text":"","category":"section"},{"location":"CommutativeAlgebra/Miscellaneous/binomial_ideals/","page":"Binomial Primary Decomposition","title":"Binomial Primary Decomposition","text":"is_cellular(I::MPolyIdeal)","category":"page"},{"location":"CommutativeAlgebra/Miscellaneous/binomial_ideals/#is_cellular-Tuple{MPolyIdeal}","page":"Binomial Primary Decomposition","title":"is_cellular","text":"is_cellular(I::MPolyIdeal)\n\nGiven a binomial ideal  I, return true together with the indices of the cell variables if I is cellular. Return false together with the index of a variable which is a zerodivisor but not nilpotent modulo I, otherwise (return (false, [-1]) if I is not proper).\n\nExamples\n\njulia> R, x = polynomial_ring(QQ, :x => 1:6)\n(Multivariate polynomial ring in 6 variables over QQ, QQMPolyRingElem[x[1], x[2], x[3], x[4], x[5], x[6]])\n\njulia> I = ideal(R, [x[5]*(x[1]^3-x[2]^3), x[6]*(x[3]-x[4]), x[5]^2, x[6]^2, x[5]*x[6]])\nIdeal generated by\n  x[1]^3*x[5] - x[2]^3*x[5]\n  x[3]*x[6] - x[4]*x[6]\n  x[5]^2\n  x[6]^2\n  x[5]*x[6]\n\njulia> is_cellular(I)\n(true, [1, 2, 3, 4])\n\njulia> R, (x,y,z) = polynomial_ring(QQ, [:x, :y, :z])\n(Multivariate polynomial ring in 3 variables over QQ, QQMPolyRingElem[x, y, z])\n\njulia> I = ideal(R, [x-y,x^3-1,z*y^2-z])\nIdeal generated by\n  x - y\n  x^3 - 1\n  y^2*z - z\n\njulia> is_cellular(I)\n(false, [3])\n\n\n\n\n\n","category":"method"},{"location":"CommutativeAlgebra/Miscellaneous/binomial_ideals/#Unitality-Test","page":"Binomial Primary Decomposition","title":"Unitality Test","text":"","category":"section"},{"location":"CommutativeAlgebra/Miscellaneous/binomial_ideals/","page":"Binomial Primary Decomposition","title":"Binomial Primary Decomposition","text":"is_unital(I::MPolyIdeal)","category":"page"},{"location":"CommutativeAlgebra/Miscellaneous/binomial_ideals/#is_unital-Tuple{MPolyIdeal}","page":"Binomial Primary Decomposition","title":"is_unital","text":"is_unital(I::MPolyIdeal)\n\nGiven a binomial ideal I, return true if I can be generated by differences of monomials and monomials.\n\nExamples\n\njulia> R, (x, y, z) = polynomial_ring(QQ, [:x, :y, :z])\n(Multivariate polynomial ring in 3 variables over QQ, QQMPolyRingElem[x, y, z])\n\njulia> I = ideal(R, [x+y])\nIdeal generated by\n  x + y\n\njulia> is_unital(I)\nfalse\n\njulia> J = ideal(R, [x^2-y^3, z^2])\nIdeal generated by\n  x^2 - y^3\n  z^2\n\njulia> is_unital(J)\ntrue\n\n\n\n\n\n","category":"method"},{"location":"CommutativeAlgebra/Miscellaneous/binomial_ideals/#Cellular-Decomposition","page":"Binomial Primary Decomposition","title":"Cellular Decomposition","text":"","category":"section"},{"location":"CommutativeAlgebra/Miscellaneous/binomial_ideals/","page":"Binomial Primary Decomposition","title":"Binomial Primary Decomposition","text":"cellular_decomposition(I::MPolyIdeal)","category":"page"},{"location":"CommutativeAlgebra/Miscellaneous/binomial_ideals/#cellular_decomposition-Tuple{MPolyIdeal}","page":"Binomial Primary Decomposition","title":"cellular_decomposition","text":"cellular_decomposition(I::MPolyIdeal)\n\nGiven a binomial ideal I, return a cellular decomposition of I.\n\nExamples\n\njulia> R, (x,y,z) =  polynomial_ring(QQ, [:x, :y, :z])\n(Multivariate polynomial ring in 3 variables over QQ, QQMPolyRingElem[x, y, z])\n\njulia> I = ideal(R, [x-y,x^3-1,z*y^2-z])\nIdeal generated by\n  x - y\n  x^3 - 1\n  y^2*z - z\n\njulia> cellular_decomposition(I)\n2-element Vector{MPolyIdeal{QQMPolyRingElem}}:\n Ideal (y - 1, x - 1)\n Ideal (x - y, x^3 - 1, y^2*z - z, z)\n\n\n\n\n\n","category":"method"},{"location":"CommutativeAlgebra/Miscellaneous/binomial_ideals/#Primary-Decomposition-of-Cellular-Ideals","page":"Binomial Primary Decomposition","title":"Primary Decomposition of Cellular Ideals","text":"","category":"section"},{"location":"CommutativeAlgebra/Miscellaneous/binomial_ideals/","page":"Binomial Primary Decomposition","title":"Binomial Primary Decomposition","text":"cellular_hull(I::MPolyIdeal{QQMPolyRingElem})\ncellular_associated_primes(I::MPolyIdeal{QQMPolyRingElem})\ncellular_minimal_associated_primes(I::MPolyIdeal{QQMPolyRingElem})\ncellular_primary_decomposition(I::MPolyIdeal{QQMPolyRingElem})","category":"page"},{"location":"CommutativeAlgebra/Miscellaneous/binomial_ideals/#cellular_hull-Tuple{MPolyIdeal{QQMPolyRingElem}}","page":"Binomial Primary Decomposition","title":"cellular_hull","text":"cellular_hull(I::MPolyIdeal{QQMPolyRingElem})\n\nGiven a cellular binomial ideal I, return the intersection  of the minimal primary components of I.\n\nExamples\n\njulia> R, x = polynomial_ring(QQ, :x => 1:6)\n(Multivariate polynomial ring in 6 variables over QQ, QQMPolyRingElem[x[1], x[2], x[3], x[4], x[5], x[6]])\n\njulia> I = ideal(R, [x[5]*(x[1]^3-x[2]^3), x[6]*(x[3]-x[4]), x[5]^2, x[6]^2, x[5]*x[6]])\nIdeal generated by\n  x[1]^3*x[5] - x[2]^3*x[5]\n  x[3]*x[6] - x[4]*x[6]\n  x[5]^2\n  x[6]^2\n  x[5]*x[6]\n\njulia> is_cellular(I)\n(true, [1, 2, 3, 4])\n\njulia> cellular_hull(I)\nIdeal generated by\n  x[6]\n  x[5]\n\n\n\n\n\n","category":"method"},{"location":"CommutativeAlgebra/Miscellaneous/binomial_ideals/#cellular_associated_primes-Tuple{MPolyIdeal{QQMPolyRingElem}}","page":"Binomial Primary Decomposition","title":"cellular_associated_primes","text":"cellular_associated_primes(I::MPolyIdeal{QQMPolyRingElem})\n\nGiven a cellular binomial ideal I, return the associated primes of I.\n\nThe result is defined over the abelian closure of mathbb Q. In the output, if needed, the generator for roots of unities is denoted by zeta. So zeta(3), for example, stands for a primitive third root of unity.\n\nExamples\n\njulia> R, x = polynomial_ring(QQ, :x => 1:6)\n(Multivariate polynomial ring in 6 variables over QQ, QQMPolyRingElem[x[1], x[2], x[3], x[4], x[5], x[6]])\n\njulia> I = ideal(R, [x[5]*(x[1]^3-x[2]^3), x[6]*(x[3]-x[4]), x[5]^2, x[6]^2, x[5]*x[6]])\nIdeal generated by\n  x[1]^3*x[5] - x[2]^3*x[5]\n  x[3]*x[6] - x[4]*x[6]\n  x[5]^2\n  x[6]^2\n  x[5]*x[6]\n\njulia> cellular_associated_primes(I)\n5-element Vector{MPolyIdeal{AbstractAlgebra.Generic.MPoly{QQAbFieldElem{AbsSimpleNumFieldElem}}}}:\n Ideal (x[5], x[6])\n Ideal (x[1] - x[2], x[5], x[6])\n Ideal (x[1] - zeta(3)*x[2], x[5], x[6])\n Ideal (x[1] + (zeta(3) + 1)*x[2], x[5], x[6])\n Ideal (x[3] - x[4], x[5], x[6])\n\n\n\n\n\n","category":"method"},{"location":"CommutativeAlgebra/Miscellaneous/binomial_ideals/#cellular_minimal_associated_primes-Tuple{MPolyIdeal{QQMPolyRingElem}}","page":"Binomial Primary Decomposition","title":"cellular_minimal_associated_primes","text":"cellular_minimal_associated_primes(I::MPolyIdeal{QQMPolyRingElem})\n\nGiven a cellular binomial ideal I, return the minimal associated primes of I.\n\nThe result is defined over the abelian closure of mathbb Q. In the output, if needed, the generator for roots of unities is denoted by zeta. So zeta(3), for example, stands for a primitive third root of unity.\n\nExamples\n\njulia> R, x = polynomial_ring(QQ, :x => 1:6)\n(Multivariate polynomial ring in 6 variables over QQ, QQMPolyRingElem[x[1], x[2], x[3], x[4], x[5], x[6]])\n\njulia> I = ideal(R, [x[5]*(x[1]^3-x[2]^3), x[6]*(x[3]-x[4]), x[5]^2, x[6]^2, x[5]*x[6]])\nIdeal generated by\n  x[1]^3*x[5] - x[2]^3*x[5]\n  x[3]*x[6] - x[4]*x[6]\n  x[5]^2\n  x[6]^2\n  x[5]*x[6]\n\njulia> cellular_minimal_associated_primes(I::MPolyIdeal{QQMPolyRingElem})\n1-element Vector{MPolyIdeal{AbstractAlgebra.Generic.MPoly{QQAbFieldElem{AbsSimpleNumFieldElem}}}}:\n Ideal (x[5], x[6])\n\n\n\n\n\n","category":"method"},{"location":"CommutativeAlgebra/Miscellaneous/binomial_ideals/#cellular_primary_decomposition-Tuple{MPolyIdeal{QQMPolyRingElem}}","page":"Binomial Primary Decomposition","title":"cellular_primary_decomposition","text":"cellular_primary_decomposition(I::MPolyIdeal{QQMPolyRingElem})\n\nGiven a cellular binomial ideal I, return a binomial primary decomposition of I.\n\nThe result is defined over the abelian closure of mathbb Q. In the output, if needed, the generator for roots of unities is denoted by zeta. So zeta(3), for example, stands for a primitive third root of unity.\n\nExamples\n\njulia> R, x = polynomial_ring(QQ, :x => 1:6)\n(Multivariate polynomial ring in 6 variables over QQ, QQMPolyRingElem[x[1], x[2], x[3], x[4], x[5], x[6]])\n\njulia> I = ideal(R, [x[5]*(x[1]^3-x[2]^3), x[6]*(x[3]-x[4]), x[5]^2, x[6]^2, x[5]*x[6]])\nIdeal generated by\n  x[1]^3*x[5] - x[2]^3*x[5]\n  x[3]*x[6] - x[4]*x[6]\n  x[5]^2\n  x[6]^2\n  x[5]*x[6]\n\njulia> cellular_primary_decomposition(I)\n5-element Vector{Tuple{MPolyIdeal{AbstractAlgebra.Generic.MPoly{QQAbFieldElem{AbsSimpleNumFieldElem}}}, MPolyIdeal{AbstractAlgebra.Generic.MPoly{QQAbFieldElem{AbsSimpleNumFieldElem}}}}}:\n (Ideal (x[6], x[5]), Ideal (x[5], x[6]))\n (Ideal (x[6], x[1] - x[2], x[5]^2), Ideal (x[1] - x[2], x[5], x[6]))\n (Ideal (x[6], x[1] - zeta(3)*x[2], x[5]^2), Ideal (x[1] - zeta(3)*x[2], x[5], x[6]))\n (Ideal (x[6], x[1] + (zeta(3) + 1)*x[2], x[5]^2), Ideal (x[1] + (zeta(3) + 1)*x[2], x[5], x[6]))\n (Ideal (x[5], x[3] - x[4], x[6]^2), Ideal (x[3] - x[4], x[5], x[6]))\n\n\n\n\n\n","category":"method"},{"location":"CommutativeAlgebra/Miscellaneous/binomial_ideals/#Primary-Decomposition-of-Binomial-Ideals","page":"Binomial Primary Decomposition","title":"Primary Decomposition of Binomial  Ideals","text":"","category":"section"},{"location":"CommutativeAlgebra/Miscellaneous/binomial_ideals/","page":"Binomial Primary Decomposition","title":"Binomial Primary Decomposition","text":"binomial_primary_decomposition(I::MPolyIdeal{QQMPolyRingElem})","category":"page"},{"location":"CommutativeAlgebra/Miscellaneous/binomial_ideals/#binomial_primary_decomposition-Tuple{MPolyIdeal{QQMPolyRingElem}}","page":"Binomial Primary Decomposition","title":"binomial_primary_decomposition","text":"binomial_primary_decomposition(I::MPolyIdeal{QQMPolyRingElem})\n\nGiven a binomial ideal I, return a binomial primary decomposition of I.\n\nThe result is defined over the abelian closure of mathbb Q. In the output, if needed, the generator for roots of unities is denoted by zeta. So zeta(3), for example, stands for a primitive third root of unity.\n\nExamples\n\njulia> R, (x,y,z) =  polynomial_ring(QQ, [:x, :y, :z])\n(Multivariate polynomial ring in 3 variables over QQ, QQMPolyRingElem[x, y, z])\n\njulia> I = ideal(R, [x-y,x^3-1,z*y^2-z])\nIdeal generated by\n  x - y\n  x^3 - 1\n  y^2*z - z\n\njulia> binomial_primary_decomposition(I)\n3-element Vector{Tuple{MPolyIdeal{AbstractAlgebra.Generic.MPoly{QQAbFieldElem{AbsSimpleNumFieldElem}}}, MPolyIdeal{AbstractAlgebra.Generic.MPoly{QQAbFieldElem{AbsSimpleNumFieldElem}}}}}:\n (Ideal (z, y - zeta(3), x - zeta(3)), Ideal (y - zeta(3), x - zeta(3), z))\n (Ideal (z, y + zeta(3) + 1, x + zeta(3) + 1), Ideal (y + zeta(3) + 1, x + zeta(3) + 1, z))\n (Ideal (y - 1, x - 1), Ideal (y - 1, x - 1, x*y - 1))\n\n\n\n\n\n","category":"method"},{"location":"AlgebraicGeometry/AlgebraicSets/ProjectiveAlgebraicSet/","page":"Projective Algebraic Sets","title":"Projective Algebraic Sets","text":"CurrentModule = Oscar\nDocTestSetup = Oscar.doctestsetup()","category":"page"},{"location":"AlgebraicGeometry/AlgebraicSets/ProjectiveAlgebraicSet/#Projective-Algebraic-Sets","page":"Projective Algebraic Sets","title":"Projective Algebraic Sets","text":"","category":"section"},{"location":"AlgebraicGeometry/AlgebraicSets/ProjectiveAlgebraicSet/","page":"Projective Algebraic Sets","title":"Projective Algebraic Sets","text":"For finitely many homogeneous polynomials f_1dots f_r in kx_0dots x_n, and I=(f_1dots  f_n) leq kx_0dots x_n the homogeneous ideal they generate, we denote by X = V(I) subseteq mathbbP^n the projective algebraic set defined by I and call k its base field.","category":"page"},{"location":"AlgebraicGeometry/AlgebraicSets/ProjectiveAlgebraicSet/","page":"Projective Algebraic Sets","title":"Projective Algebraic Sets","text":"Let mathbbP^n(k)=(k^n+1setminus0)k^* be the set of k-points of projective space of dimension n. If k subseteq K is any field extension, we denote the set of K-points of X by","category":"page"},{"location":"AlgebraicGeometry/AlgebraicSets/ProjectiveAlgebraicSet/","page":"Projective Algebraic Sets","title":"Projective Algebraic Sets","text":"beginalignedX(K) =  P in mathbbP^n(K) mid f_1(P)=dots = f_n(P)=0\n=P in mathbbP^n(K) mid forall fin I  f(P)=0endaligned","category":"page"},{"location":"AlgebraicGeometry/AlgebraicSets/ProjectiveAlgebraicSet/","page":"Projective Algebraic Sets","title":"Projective Algebraic Sets","text":"Most properties of the projective variety X refer to X(K) where K is an algebraically closed field. Just like for affine schemes there are a few exceptions to this rule, for instance, whether X is irreducible or not depends on its base field. See is_irreducible(X::AbsProjectiveScheme) for details. Further exceptions are documented in the individual methods.","category":"page"},{"location":"AlgebraicGeometry/AlgebraicSets/ProjectiveAlgebraicSet/#Relation-to-schemes","page":"Projective Algebraic Sets","title":"Relation to schemes","text":"","category":"section"},{"location":"AlgebraicGeometry/AlgebraicSets/ProjectiveAlgebraicSet/","page":"Projective Algebraic Sets","title":"Projective Algebraic Sets","text":"One can view a projective algebraic set as a scheme. See Projective schemes.","category":"page"},{"location":"AlgebraicGeometry/AlgebraicSets/ProjectiveAlgebraicSet/","page":"Projective Algebraic Sets","title":"Projective Algebraic Sets","text":"More formally we define a projective algebraic set as follows:","category":"page"},{"location":"AlgebraicGeometry/AlgebraicSets/ProjectiveAlgebraicSet/","page":"Projective Algebraic Sets","title":"Projective Algebraic Sets","text":"AbsProjectiveAlgebraicSet","category":"page"},{"location":"AlgebraicGeometry/AlgebraicSets/ProjectiveAlgebraicSet/#AbsProjectiveAlgebraicSet","page":"Projective Algebraic Sets","title":"AbsProjectiveAlgebraicSet","text":"AbsProjectiveAlgebraicSet <: AbsProjectiveScheme\n\nA projective, geometrically reduced scheme of finite type over a field.\n\n\n\n\n\n","category":"type"},{"location":"AlgebraicGeometry/AlgebraicSets/ProjectiveAlgebraicSet/#Constructors","page":"Projective Algebraic Sets","title":"Constructors","text":"","category":"section"},{"location":"AlgebraicGeometry/AlgebraicSets/ProjectiveAlgebraicSet/","page":"Projective Algebraic Sets","title":"Projective Algebraic Sets","text":"Projective algebraic sets can be created from homogeneous polynomials and homogeneous ideals in standard graded rings.","category":"page"},{"location":"AlgebraicGeometry/AlgebraicSets/ProjectiveAlgebraicSet/","page":"Projective Algebraic Sets","title":"Projective Algebraic Sets","text":"algebraic_set(I::MPolyIdeal{<:MPolyDecRingElem}; check::Bool=true)\nalgebraic_set(p::MPolyDecRingElem; check::Bool=true)","category":"page"},{"location":"AlgebraicGeometry/AlgebraicSets/ProjectiveAlgebraicSet/#algebraic_set-Tuple{MPolyIdeal{<:MPolyDecRingElem}}","page":"Projective Algebraic Sets","title":"algebraic_set","text":"algebraic_set(I::MPolyIdeal{MPolyDecRingElem})\n\nReturn the projrective algebraic set defined by the homogeneous ideal I.\n\njulia> P,(x0,x1) = graded_polynomial_ring(QQ,[:x0,:x1]);\n\njulia> algebraic_set(ideal([x0,x1]))\nProjective algebraic set\n  in projective 1-space over QQ with coordinates [x0, x1]\ndefined by ideal (x0, x1)\n\n\n\n\n\n\n","category":"method"},{"location":"AlgebraicGeometry/AlgebraicSets/ProjectiveAlgebraicSet/#algebraic_set-Tuple{MPolyDecRingElem}","page":"Projective Algebraic Sets","title":"algebraic_set","text":"algebraic_set(p::MPolyDecRingElem; check::Bool=true)\n\nReturn the projective algebraic set defined by the homogeneous polynomial p.\n\n\n\n\n\n","category":"method"},{"location":"AlgebraicGeometry/AlgebraicSets/ProjectiveAlgebraicSet/","page":"Projective Algebraic Sets","title":"Projective Algebraic Sets","text":"Algebraic sets can also be constructed from projective schemes.","category":"page"},{"location":"AlgebraicGeometry/AlgebraicSets/ProjectiveAlgebraicSet/","page":"Projective Algebraic Sets","title":"Projective Algebraic Sets","text":"algebraic_set(X::AbsProjectiveScheme; check::Bool=true)","category":"page"},{"location":"AlgebraicGeometry/AlgebraicSets/ProjectiveAlgebraicSet/#algebraic_set-Tuple{AbsProjectiveScheme}","page":"Projective Algebraic Sets","title":"algebraic_set","text":"algebraic_set(X::AbsProjectiveScheme; is_reduced::Bool=false, check::Bool=true) -> ProjectiveAlgebraicSet\n\nConvert X to a ProjectiveAlgebraicSet by considering its underlying reduced scheme.\n\nIf is_reduced is true assume that X is already reduced.\n\njulia> P, (x0, x1, x2) = graded_polynomial_ring(QQ,[:x0,:x1,:x2]);\n\njulia> X = proj(ideal([x0*x1^2, x2]))\nProjective scheme\n  over rational field\ndefined by ideal (x0*x1^2, x2)\n\njulia> Y = algebraic_set(X)\nProjective algebraic set\n  in projective 2-space over QQ with coordinates [x0, x1, x2]\ndefined by ideal (x0*x1^2, x2)\n\n\n\n\n\n\n","category":"method"},{"location":"AlgebraicGeometry/AlgebraicSets/ProjectiveAlgebraicSet/","page":"Projective Algebraic Sets","title":"Projective Algebraic Sets","text":"set_theoretic_intersection(X::AbsProjectiveAlgebraicSet, Y::AbsProjectiveAlgebraicSet)\nirreducible_components(X::AbsProjectiveAlgebraicSet)\ngeometric_irreducible_components(X::AbsProjectiveAlgebraicSet)","category":"page"},{"location":"AlgebraicGeometry/AlgebraicSets/ProjectiveAlgebraicSet/#set_theoretic_intersection-Tuple{AbsProjectiveAlgebraicSet, AbsProjectiveAlgebraicSet}","page":"Projective Algebraic Sets","title":"set_theoretic_intersection","text":"set_theoretic_intersection(X::AbsProjectiveAlgebraicSet, Y::AbsProjectiveAlgebraicSet) -> AbsProjectiveAlgebraicSet\n\nReturn the set theoretic intersection of X and Y as as algebraic sets in projective space.\n\nThis is the reduced subscheme of the scheme theoretic intersection.\n\n\n\n\n\n","category":"method"},{"location":"AlgebraicGeometry/AlgebraicSets/ProjectiveAlgebraicSet/#irreducible_components-Tuple{AbsProjectiveAlgebraicSet}","page":"Projective Algebraic Sets","title":"irreducible_components","text":"irreducible_components(X::AbsProjectiveAlgebraicSet) -> Vector{ProjectiveVariety}\n\nReturn the irreducible components of X defined over the base field of X.\n\nNote that even if X is irreducible, there may be several geometrically irreducible components.\n\njulia> P1 = projective_space(QQ,1)\nProjective space of dimension 1\n  over rational field\nwith homogeneous coordinates [s0, s1]\n\njulia> (s0,s1) = homogeneous_coordinates(P1);\n\njulia> X = algebraic_set((s0^2+s1^2)*s1)\nProjective algebraic set\n  in projective 1-space over QQ with coordinates [s0, s1]\ndefined by ideal (s0^2*s1 + s1^3)\n\njulia> (X1,X2) = irreducible_components(X)\n2-element Vector{ProjectiveAlgebraicSet{QQField, MPolyQuoRing{MPolyDecRingElem{QQFieldElem, QQMPolyRingElem}}}}:\n V(s0^2 + s1^2)\n V(s1)\n\njulia> X1  # irreducible but not geometrically irreducible\nProjective algebraic set\n  in projective 1-space over QQ with coordinates [s0, s1]\ndefined by ideal (s0^2 + s1^2)\n\n\n\n\n\n\n","category":"method"},{"location":"AlgebraicGeometry/AlgebraicSets/ProjectiveAlgebraicSet/#geometric_irreducible_components-Tuple{AbsProjectiveAlgebraicSet}","page":"Projective Algebraic Sets","title":"geometric_irreducible_components","text":"geometric_irreducible_components(X::AbsProjectiveAlgebraicSet) -> Vector{ProjectiveVariety}\n\nReturn the geometrically irreducible components of X.\n\nThey are the irreducible components of X seen over an algebraically closed field.\n\nThis is expensive and involves taking field extensions.\n\n\n\n\n\n","category":"method"},{"location":"AlgebraicGeometry/AlgebraicSets/ProjectiveAlgebraicSet/#Attributes","page":"Projective Algebraic Sets","title":"Attributes","text":"","category":"section"},{"location":"AlgebraicGeometry/AlgebraicSets/ProjectiveAlgebraicSet/","page":"Projective Algebraic Sets","title":"Projective Algebraic Sets","text":"In addition to the attributes inherited from Projective schemes the following are available.","category":"page"},{"location":"AlgebraicGeometry/AlgebraicSets/ProjectiveAlgebraicSet/","page":"Projective Algebraic Sets","title":"Projective Algebraic Sets","text":"vanishing_ideal(X::AbsProjectiveAlgebraicSet)\nfat_ideal(X::AbsProjectiveAlgebraicSet)","category":"page"},{"location":"AlgebraicGeometry/AlgebraicSets/ProjectiveAlgebraicSet/#vanishing_ideal-Tuple{AbsProjectiveAlgebraicSet}","page":"Projective Algebraic Sets","title":"vanishing_ideal","text":"vanishing_ideal(X::AbsProjectiveAlgebraicSet) -> Ideal\n\nReturn the ideal of all homogeneous polynomials vanishing in X.\n\n\n\n\n\n","category":"method"},{"location":"AlgebraicGeometry/AlgebraicSets/ProjectiveAlgebraicSet/#fat_ideal-Tuple{AbsProjectiveAlgebraicSet}","page":"Projective Algebraic Sets","title":"fat_ideal","text":"fat_ideal(X::AbsProjectiveAlgebraicSet) -> Ideal\n\nReturn a homogeneous ideal whose radical is the vanishing ideal of X.\n\n\n\n\n\n","category":"method"},{"location":"AlgebraicGeometry/AlgebraicSets/ProjectiveAlgebraicSet/#Methods","page":"Projective Algebraic Sets","title":"Methods","text":"","category":"section"},{"location":"AlgebraicGeometry/AlgebraicSets/ProjectiveAlgebraicSet/","page":"Projective Algebraic Sets","title":"Projective Algebraic Sets","text":"Inherited from Projective schemes","category":"page"},{"location":"AlgebraicGeometry/AlgebraicSets/ProjectiveAlgebraicSet/#Properties","page":"Projective Algebraic Sets","title":"Properties","text":"","category":"section"},{"location":"AlgebraicGeometry/AlgebraicSets/ProjectiveAlgebraicSet/","page":"Projective Algebraic Sets","title":"Projective Algebraic Sets","text":"Inherited from Projective schemes","category":"page"},{"location":"Hecke/manual/orders/frac_ideals/#Fractional-ideals","page":"Fractional ideals","title":"Fractional ideals","text":"","category":"section"},{"location":"Hecke/manual/orders/frac_ideals/","page":"Fractional ideals","title":"Fractional ideals","text":"CurrentModule = Hecke","category":"page"},{"location":"Hecke/manual/orders/frac_ideals/","page":"Fractional ideals","title":"Fractional ideals","text":"A fractional ideal in the number field K is a Z_K-module A such that there exists an integer d0 which dA is an (integral) ideal in Z_K. Due to the Dedekind property of Z_K, the ideals for a multiplicative group.","category":"page"},{"location":"Hecke/manual/orders/frac_ideals/","page":"Fractional ideals","title":"Fractional ideals","text":"Fractional ideals are represented as an integral ideal and an additional denominator. They are of type AbsSimpleNumFieldOrderFractionalIdeal.","category":"page"},{"location":"Hecke/manual/orders/frac_ideals/#Creation","page":"Fractional ideals","title":"Creation","text":"","category":"section"},{"location":"Hecke/manual/orders/frac_ideals/","page":"Fractional ideals","title":"Fractional ideals","text":"fractional_ideal(::AbsSimpleNumFieldOrder, ::ZZMatrix)\nfractional_ideal(::AbsSimpleNumFieldOrder, ::ZZMatrix, ::ZZRingElem)\nfractional_ideal(::AbsSimpleNumFieldOrder, ::QQMatrix)\nfractional_ideal(::AbsSimpleNumFieldOrder, ::AbsNumFieldOrderIdeal{AbsSimpleNumField, AbsSimpleNumFieldElem})\nfractional_ideal(::AbsSimpleNumFieldOrder, ::AbsNumFieldOrderIdeal{AbsSimpleNumField, AbsSimpleNumFieldElem}, ::ZZRingElem)\nfractional_ideal(::AbsSimpleNumFieldOrder, ::AbsSimpleNumFieldElem)\nfractional_ideal(::AbsSimpleNumFieldOrder, ::AbsSimpleNumFieldOrderElem)\ninv(::AbsNumFieldOrderIdeal{AbsSimpleNumField, AbsSimpleNumFieldElem})","category":"page"},{"location":"Hecke/manual/orders/frac_ideals/#fractional_ideal-Tuple{AbsSimpleNumFieldOrder, ZZMatrix}","page":"Fractional ideals","title":"fractional_ideal","text":"fractional_ideal(O::AbsNumFieldOrder, M::ZZMatrix, b::ZZRingElem; M_in_hnf::Bool = false) -> AbsNumFieldOrderFractionalIdeal\n\nCreates the fractional ideal of mathcal O with basis matrix Mb. If M_in_hnf is set, then it is assumed that A is already in lower left HNF.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/orders/frac_ideals/#fractional_ideal-Tuple{AbsSimpleNumFieldOrder, ZZMatrix, ZZRingElem}","page":"Fractional ideals","title":"fractional_ideal","text":"fractional_ideal(O::AbsNumFieldOrder, M::ZZMatrix, b::ZZRingElem; M_in_hnf::Bool = false) -> AbsNumFieldOrderFractionalIdeal\n\nCreates the fractional ideal of mathcal O with basis matrix Mb. If M_in_hnf is set, then it is assumed that A is already in lower left HNF.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/orders/frac_ideals/#fractional_ideal-Tuple{AbsSimpleNumFieldOrder, QQMatrix}","page":"Fractional ideals","title":"fractional_ideal","text":"fractional_ideal(O::AbsNumFieldOrder, M::QQMatrix) -> AbsNumFieldOrderFractionalIdeal\n\nCreates the fractional ideal of mathcal O generated by the elements corresponding to the rows of M.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/orders/frac_ideals/#fractional_ideal-Tuple{AbsSimpleNumFieldOrder, AbsSimpleNumFieldOrderIdeal}","page":"Fractional ideals","title":"fractional_ideal","text":"fractional_ideal(O::AbsSimpleNumFieldOrder, I::AbsNumFieldOrderIdeal) -> AbsSimpleNumFieldOrderFractionalIdeal\n\nThe fractional ideal of O generated by a Z-basis of I.\n\n\n\n\n\nfractional_ideal(O::AbsNumFieldOrder, I::AbsNumFieldOrderIdeal) -> AbsNumFieldOrderFractionalIdeal\n\nTurns the ideal I into a fractional ideal of mathcal O.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/orders/frac_ideals/#fractional_ideal-Tuple{AbsSimpleNumFieldOrder, AbsSimpleNumFieldOrderIdeal, ZZRingElem}","page":"Fractional ideals","title":"fractional_ideal","text":"fractional_ideal(O::AbsNumFieldOrder, I::AbsNumFieldOrderIdeal, b::ZZRingElem) -> AbsNumFieldOrderFractionalIdeal\n\nCreates the fractional ideal Ib of mathcal O.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/orders/frac_ideals/#fractional_ideal-Tuple{AbsSimpleNumFieldOrder, AbsSimpleNumFieldElem}","page":"Fractional ideals","title":"fractional_ideal","text":"fractional_ideal(O::AbsNumFieldOrder, a::AbsSimpleNumFieldElem) -> AbsNumFieldOrderFractionalIdeal\n\nCreates the principal fractional ideal (a) of mathcal O.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/orders/frac_ideals/#fractional_ideal-Tuple{AbsSimpleNumFieldOrder, AbsSimpleNumFieldOrderElem}","page":"Fractional ideals","title":"fractional_ideal","text":"fractional_ideal(O::AbsNumFieldOrder, a::AbsNumFieldOrderElem) -> AbsNumFieldOrderFractionalIdeal\n\nCreates the principal fractional ideal (a) of mathcal O.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/orders/frac_ideals/#inv-Tuple{AbsSimpleNumFieldOrderIdeal}","page":"Fractional ideals","title":"inv","text":"inv(A::AbsNumFieldOrderIdeal) -> AbsSimpleNumFieldOrderFractionalIdeal\n\nComputes the inverse of A, that is, the fractional ideal B such that AB = mathcal O_K.\n\n\n\n\n\n inv(a::LocalizedEuclideanRingElem{T}, checked::Bool = true)  where {T <: RingElem}\n\nReturns the inverse element of a if a is a unit. If 'checked = false' the invertibility of a is not checked and the corresponding inverse element of the Fraction Field is returned.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/orders/frac_ideals/#Arithmetic","page":"Fractional ideals","title":"Arithmetic","text":"","category":"section"},{"location":"Hecke/manual/orders/frac_ideals/","page":"Fractional ideals","title":"Fractional ideals","text":"All the normal operations are provided as well.","category":"page"},{"location":"Hecke/manual/orders/frac_ideals/","page":"Fractional ideals","title":"Fractional ideals","text":"inv(::AbsSimpleNumFieldOrderFractionalIdeal)\nintegral_split(::AbsSimpleNumFieldOrderFractionalIdeal)\nnumerator(::RelNumFieldOrderFractionalIdeal)\ndenominator(::RelNumFieldOrderFractionalIdeal)","category":"page"},{"location":"Hecke/manual/orders/frac_ideals/#inv-Tuple{AbsSimpleNumFieldOrderFractionalIdeal}","page":"Fractional ideals","title":"inv","text":"inv(A::AbsNumFieldOrderFractionalIdeal) -> AbsNumFieldOrderFractionalIdeal\n\nReturns the fractional ideal B such that AB = mathcal O.\n\n\n\n\n\n inv(a::LocalizedEuclideanRingElem{T}, checked::Bool = true)  where {T <: RingElem}\n\nReturns the inverse element of a if a is a unit. If 'checked = false' the invertibility of a is not checked and the corresponding inverse element of the Fraction Field is returned.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/orders/frac_ideals/#integral_split-Tuple{AbsSimpleNumFieldOrderFractionalIdeal}","page":"Fractional ideals","title":"integral_split","text":"integral_split(A::AbsNumFieldOrderFractionalIdeal) -> AbsNumFieldOrderIdeal, AbsNumFieldOrderIdeal\n\nComputes the unique coprime integral ideals N and D s.th. A = ND^-1\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/orders/frac_ideals/#numerator-Tuple{Hecke.RelNumFieldOrderFractionalIdeal}","page":"Fractional ideals","title":"numerator","text":"numerator(a::RelNumFieldOrderFractionalIdeal) -> RelNumFieldOrderIdeal\n\nReturns the ideal d*a where d is the denominator of a.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/orders/frac_ideals/#denominator-Tuple{Hecke.RelNumFieldOrderFractionalIdeal}","page":"Fractional ideals","title":"denominator","text":"denominator(a::RelNumFieldOrderFractionalIdeal) -> ZZRingElem\n\nReturns the smallest positive integer d such that da is contained in the order of a.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/orders/frac_ideals/#Miscaellenous","page":"Fractional ideals","title":"Miscaellenous","text":"","category":"section"},{"location":"Hecke/manual/orders/frac_ideals/","page":"Fractional ideals","title":"Fractional ideals","text":"order(::AbsSimpleNumFieldOrderFractionalIdeal)\nbasis_matrix(::AbsSimpleNumFieldOrderFractionalIdeal)\nbasis_mat_inv(::AbsSimpleNumFieldOrderFractionalIdeal)\nbasis(::AbsSimpleNumFieldOrderFractionalIdeal)\nnorm(::AbsSimpleNumFieldOrderFractionalIdeal)","category":"page"},{"location":"Hecke/manual/orders/frac_ideals/#order-Tuple{AbsSimpleNumFieldOrderFractionalIdeal}","page":"Fractional ideals","title":"order","text":"order(::Type{T} = BigInt, G::Group) where T\n\nReturn the order of G as an instance of T. If G is of infinite order, an InfiniteOrderError exception will be thrown. Use is_finite(G) to avoid this kind of exception. If the order does not fit into type T, an InexactError exception will be thrown.\n\n\n\n\n\norder(::Type{T} = BigInt, g::GroupElem) where T\n\nReturn the order of g as an instance of T. If g is of infinite order, an InfiniteOrderError exception will be thrown. Use is_finite_order(G) to avoid this kind of exception. If the order does not fit into type T, an InexactError exception will be thrown.\n\n\n\n\n\norder(a::AbsNumFieldOrderFractionalIdeal) -> AbsNumFieldOrder\n\nThe order that was used to define the ideal a.\n\n\n\n\n\norder(::Type{T} = ZZRingElem, c::CycleType) where T <: IntegerUnion\n\nReturn the order of the permutations with cycle structure c.\n\nExamples\n\njulia> g = symmetric_group(3);\n\njulia> all(x -> order(cycle_structure(x)) == order(x), gens(g))\ntrue\n\n\n\n\n\norder(W::WeylGroup) -> ZZRingELem\norder(::Type{T}, W::WeylGroup) where {T} -> T\n\nReturn the order of W.\n\nIf W is infinite, an InfiniteOrderError exception will be thrown.\n\nwarning: Experimental\nThis function is part of the experimental code in Oscar. Please read here for more details.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/orders/frac_ideals/#basis_matrix-Tuple{AbsSimpleNumFieldOrderFractionalIdeal}","page":"Fractional ideals","title":"basis_matrix","text":"basis_matrix(I::AbsNumFieldOrderFractionalIdeal) -> FakeFmpqMat\n\nReturns the basis matrix of I with respect to the basis of the order.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/orders/frac_ideals/#basis_mat_inv-Tuple{AbsSimpleNumFieldOrderFractionalIdeal}","page":"Fractional ideals","title":"basis_mat_inv","text":"basis_mat_inv(A::GenOrdIdl) -> FakeFracFldMat\n\nReturn the inverse of the basis matrix of A.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/orders/frac_ideals/#basis-Tuple{AbsSimpleNumFieldOrderFractionalIdeal}","page":"Fractional ideals","title":"basis","text":"basis(I::AbsNumFieldOrderFractionalIdeal) -> Vector{AbsSimpleNumFieldElem}\n\nReturns the mathbf Z-basis of I.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/orders/frac_ideals/#norm-Tuple{AbsSimpleNumFieldOrderFractionalIdeal}","page":"Fractional ideals","title":"norm","text":"norm(I::AbsNumFieldOrderFractionalIdeal) -> QQFieldElem\n\nReturns the norm of I.\n\n\n\n\n\nnorm(a::RelNumFieldOrderIdeal) -> AbsNumFieldOrderIdeal{AbsSimpleNumField, AbsSimpleNumFieldElem}\n\nReturns the norm of a.\n\n\n\n\n\nnorm(a::RelNumFieldOrderFractionalIdeal{T, S}) -> S\n\nReturns the norm of a.\n\n\n\n\n\nnorm(a::AlgAssAbsOrdIdl, O::AlgAssAbsOrd; copy::Bool = true) -> QQFieldElem\n\nReturns the norm of a considered as an (possibly fractional) ideal of O.\n\n\n\n\n\nnorm(a::AlgAssRelOrdIdl{S, T, U}, O::AlgAssRelOrd{S, T, U}; copy::Bool = true)\n  where { S, T, U } -> T\n\nReturns the norm of a considered as an (possibly fractional) ideal of O.\n\n\n\n\n\n","category":"method"},{"location":"AlgebraicGeometry/ToricVarieties/ToricIdealSheaves/","page":"Toric Ideal Sheaves (Experimental)","title":"Toric Ideal Sheaves (Experimental)","text":"CurrentModule = Oscar","category":"page"},{"location":"AlgebraicGeometry/ToricVarieties/ToricIdealSheaves/#Toric-Ideal-Sheaves-(Experimental)","page":"Toric Ideal Sheaves (Experimental)","title":"Toric Ideal Sheaves (Experimental)","text":"","category":"section"},{"location":"AlgebraicGeometry/ToricVarieties/ToricIdealSheaves/","page":"Toric Ideal Sheaves (Experimental)","title":"Toric Ideal Sheaves (Experimental)","text":"Ideal sheaves on toric varieties are currently in experimental state. Currently, we support the following functionality. Note that, as of October 2023, this is limited to smooth toric varieties.","category":"page"},{"location":"AlgebraicGeometry/ToricVarieties/ToricIdealSheaves/","page":"Toric Ideal Sheaves (Experimental)","title":"Toric Ideal Sheaves (Experimental)","text":"ideal_sheaf(td::ToricDivisor)\nideal_sheaf(X::NormalToricVariety, I::MPolyIdeal)","category":"page"},{"location":"AlgebraicGeometry/ToricVarieties/ToricIdealSheaves/#ideal_sheaf-Tuple{ToricDivisor}","page":"Toric Ideal Sheaves (Experimental)","title":"ideal_sheaf","text":"ideal_sheaf(td::ToricDivisor)\n\nReturn the ideal sheaf corresponding to a toric divisor.\n\nExamples\n\njulia> P3 = projective_space(NormalToricVariety, 3)\nNormal toric variety\n\njulia> td = toric_divisor(P3, [0, 1, 0, 0])\nTorus-invariant, prime divisor on a normal toric variety\n\njulia> ideal_sheaf(td)\nSheaf of ideals\n  on normal, smooth toric variety\nwith restrictions\n  1: Ideal (x_2_1)\n  2: Ideal (x_2_2)\n  3: Ideal (1)\n  4: Ideal (x_2_4)\n\nwarning: Experimental\nThis function is part of the experimental code in Oscar. Please read here for more details.\n\n\n\n\n\n","category":"method"},{"location":"AlgebraicGeometry/ToricVarieties/ToricIdealSheaves/#ideal_sheaf-Tuple{NormalToricVariety, MPolyIdeal}","page":"Toric Ideal Sheaves (Experimental)","title":"ideal_sheaf","text":"ideal_sheaf(X::NormalToricVariety, I::MPolyIdeal)\n\nCreate a sheaf of ideals on a toric variety X from a homogeneous ideal  I in its cox_ring.\n\nExamples\n\njulia> P3 = projective_space(NormalToricVariety, 3)\nNormal toric variety\n\njulia> (x1,x2,x3,x4) = gens(cox_ring(P3));\n\njulia> I = ideal([x2,x3])\nIdeal generated by\n  x2\n  x3\n\njulia> IdealSheaf(P3, I);\n\nwarning: Experimental\nThis function is part of the experimental code in Oscar. Please read here for more details.\n\n\n\n\n\n","category":"method"},{"location":"StraightLinePrograms/abstractalgebra/#AbstractAlgebra's-polynomial-interface","page":"AbstractAlgebra's polynomial interface","title":"AbstractAlgebra's polynomial interface","text":"","category":"section"},{"location":"StraightLinePrograms/abstractalgebra/","page":"AbstractAlgebra's polynomial interface","title":"AbstractAlgebra's polynomial interface","text":"This is the initial API of SLPs which hasn't been updated in a while and might not work as-is with the current state of the package.","category":"page"},{"location":"StraightLinePrograms/abstractalgebra/","page":"AbstractAlgebra's polynomial interface","title":"AbstractAlgebra's polynomial interface","text":"Currently, SLPs have a polynomial interface (SLPoly).","category":"page"},{"location":"StraightLinePrograms/abstractalgebra/#Examples","page":"AbstractAlgebra's polynomial interface","title":"Examples","text":"","category":"section"},{"location":"StraightLinePrograms/abstractalgebra/","page":"AbstractAlgebra's polynomial interface","title":"AbstractAlgebra's polynomial interface","text":"julia> using AbstractAlgebra, StraightLinePrograms, BenchmarkTools;\n\njulia> S = SLPolyRing(zz, [:x, :y]); x, y = gens(S)\n2-element Vector{SLPoly{Int64,SLPolyRing{Int64,AbstractAlgebra.Integers{Int64}}}}:\n x\n y\n\njulia> p = 3 + 2x * y^2 # each line of the SLP is shown with current value\n  #1 = * 2 x    ==>     (2x)\n  #2 = ^ y 2    ==>     y^2\n  #3 = * #1 #2  ==>     (2xy^2)\n  #4 = + 3 #3   ==>     (3 + (2xy^2))\n\njulia> p.cs # constants used in the program\n2-element Vector{Int64}:\n 3\n 2\n\njulia> p.lines # each line is a UInt64 encoding an opcode and 2 arguments\n Line(0x0500000028000001)\n Line(0x8780000020000002)\n Line(0x0500000030000004)\n Line(0x0300000010000005)\n\njulia> SLP.evaluate(p, [2, 3])\n39\n\njulia> p2 = (p*(x*y))^6\n#1 = *  2  x  ==>  (2x)\n#2 = ^  y  2  ==>  y^2\n#3 = * #1 #2  ==>  (2xy^2)\n#4 = +  3 #3  ==>  (3 + (2xy^2))\n#5 = *  x  y  ==>  (xy)\n#6 = * #4 #5  ==>  ((3 + (2xy^2))xy)\n#7 = ^ #6  6  ==>  ((3 + (2xy^2))xy)^6\n\njulia> R, (x1, y1) = polynomial_ring(zz, [:x, :y]); R\nMultivariate Polynomial Ring in x, y over Integers\n\njulia> q = convert(R, p2)\n64*x^12*y^18+576*x^11*y^16+2160*x^10*y^14+4320*x^9*y^12+4860*x^8*y^10+2916*x^7*y^8+729*x^6*y^6\n\njulia> v = [3, 5]; @btime SLP.evaluate($q, $v)\n  32.101 μs (634 allocations: 45.45 KiB)\n-1458502820125772303\n\njulia> @btime SLP.evaluate($p2, $v)\n  270.341 ns (4 allocations: 352 bytes)\n-1458502820125772303\n\njulia> res = Int[]; @btime StraightLinePrograms.evaluate!($res, $p2, $v)\n  171.013 ns (0 allocations: 0 bytes)\n-1458502820125772303\n\njulia> res # intermediate computations (first 2 elements are constants)\n9-element Vector{Int64}:\n                    3\n                    2\n                    6\n                   25\n                  150\n                  153\n                   15\n                 2295\n -1458502820125772303\n\njulia> f2 = StraightLinePrograms.compile!(p2) # compile to machine code\n#3 (generic function with 1 method)\n\njulia> @btime SLP.evaluate($p2, $v)\n  31.153 ns (1 allocation: 16 bytes)\n-1458502820125772303\n\njulia> @btime $f2($v) # use a function barrier for last bit of efficiency\n 7.980 ns (0 allocations: 0 bytes)\n-1458502820125772303\n\njulia> q\n64*x^12*y^18+576*x^11*y^16+2160*x^10*y^14+4320*x^9*y^12+4860*x^8*y^10+2916*x^7*y^8+729*x^6*y^6\n\njulia> p3 = convert(S, q) # convert back q::Mpoly to an SLPoly\n #1 = ^    x   6  ==>  x^6\n #2 = ^    x   7  ==>  x^7\n #3 = ^    x   8  ==>  x^8\n #4 = ^    x   9  ==>  x^9\n #5 = ^    x  10  ==>  x^10\n #6 = ^    x  11  ==>  x^11\n #7 = ^    x  12  ==>  x^12\n #8 = ^    y   6  ==>  y^6\n #9 = ^    y   8  ==>  y^8\n#10 = ^    y  10  ==>  y^10\n#11 = ^    y  12  ==>  y^12\n#12 = ^    y  14  ==>  y^14\n#13 = ^    y  16  ==>  y^16\n#14 = ^    y  18  ==>  y^18\n#15 = *   64  #7  ==>  (64x^12)\n#16 = *  #15 #14  ==>  (64x^12y^18)\n#17 = *  576  #6  ==>  (576x^11)\n#18 = *  #17 #13  ==>  (576x^11y^16)\n#19 = +  #16 #18  ==>  ((64x^12y^18) + (576x^11y^16))\n#20 = * 2160  #5  ==>  (2160x^10)\n#21 = *  #20 #12  ==>  (2160x^10y^14)\n#22 = +  #19 #21  ==>  ((64x^12y^18) + (576x^11y^16) + (2160x^10y^14))\n#23 = * 4320  #4  ==>  (4320x^9)\n#24 = *  #23 #11  ==>  (4320x^9y^12)\n#25 = +  #22 #24  ==>  ((64x^12y^18) + (576x^11y^16) + (2160x^10y^14) + (4320x^9y^12))\n#26 = * 4860  #3  ==>  (4860x^8)\n#27 = *  #26 #10  ==>  (4860x^8y^10)\n#28 = +  #25 #27  ==>  ((64x^12y^18) + (576x^11y^16) + (2160x^10y^14) + (4320x^9y^12) + (4860x^8y^10))\n#29 = * 2916  #2  ==>  (2916x^7)\n#30 = *  #29  #9  ==>  (2916x^7y^8)\n#31 = +  #28 #30  ==>  ((64x^12y^18) + (576x^11y^16) + (2160x^10y^14) + (4320x^9y^12) + (4860x^8y^10) + (2916x^7y^8))\n#32 = *  729  #1  ==>  (729x^6)\n#33 = *  #32  #8  ==>  (729x^6y^6)\n#34 = +  #31 #33  ==>  ((64x^12y^18) + (576x^11y^16) + (2160x^10y^14) + (4320x^9y^12) + (4860x^8y^10) + (2916x^7y^8) + (729x^6y^6))\n\njulia> @btime SLP.evaluate($p3, $v)\n  699.465 ns (5 allocations: 1008 bytes)\n-1458502820125772303\n\njulia> @time f3 = StraightLinePrograms.compile!(p3);\n  0.002830 seconds (1.40 k allocations: 90.930 KiB)\n\njulia> @btime $f3($v)\n 80.229 ns (0 allocations: 0 bytes)\n-1458502820125772303\n\njulia> p4 = convert(S, q, limit_exp=true); # use different encoding\n\njulia> @btime SLP.evaluate($p4, $v)\n  766.864 ns (5 allocations: 1008 bytes)\n-1458502820125772303\n\njulia> @time f4 = StraightLinePrograms.compile!(p4);\n  0.002731 seconds (1.74 k allocations: 108.676 KiB)\n\njulia> @btime $f4($v)\n  11.781 ns (0 allocations: 0 bytes)\n-1458502820125772303","category":"page"},{"location":"AlgebraicGeometry/Surfaces/duValSing/","page":"Classifier/identifier specifically for du Val singularities","title":"Classifier/identifier specifically for du Val singularities","text":"CurrentModule = Oscar","category":"page"},{"location":"AlgebraicGeometry/Surfaces/duValSing/#Classifier/identifier-specifically-for-du-Val-singularities","page":"Classifier/identifier specifically for du Val singularities","title":"Classifier/identifier specifically for du Val singularities","text":"","category":"section"},{"location":"AlgebraicGeometry/Surfaces/duValSing/","page":"Classifier/identifier specifically for du Val singularities","title":"Classifier/identifier specifically for du Val singularities","text":"has_du_val_singularities\nis_du_val_singularity\ndecide_du_val_singularity","category":"page"},{"location":"AlgebraicGeometry/Surfaces/duValSing/#has_du_val_singularities","page":"Classifier/identifier specifically for du Val singularities","title":"has_du_val_singularities","text":"has_du_val_singularities(X::Scheme)\n\nReturn whether the given X has at most du Val (surface) singularities.\n\nExamples\n\njulia> R,(x,y,z,w) = QQ[:x, :y, :z, :w]\n(Multivariate polynomial ring in 4 variables over QQ, QQMPolyRingElem[x, y, z, w])\n\njulia> I = ideal(R,[w,x^2+y^3+z^4])\nIdeal generated by\n  w\n  x^2 + y^3 + z^4\n\njulia> Rq, _ = quo(R,I)\n(Quotient of multivariate polynomial ring by ideal (w, x^2 + y^3 + z^4), Map: R -> Rq)\n\njulia> X = spec(Rq)\nSpectrum\n  of quotient\n    of multivariate polynomial ring in 4 variables x, y, z, w\n      over rational field\n    by ideal (w, x^2 + y^3 + z^4)\n\njulia> has_du_val_singularities(X)\ntrue\n\n\n\n\n\n\n","category":"function"},{"location":"AlgebraicGeometry/Surfaces/duValSing/#is_du_val_singularity","page":"Classifier/identifier specifically for du Val singularities","title":"is_du_val_singularity","text":"is_du_val_singularity(P::AbsAffineRationalPoint{<:Field})\n\nReturn whether the ambient scheme of P has at most a Du Val singularity at P.\n\nNote that this includes the case that P is a smooth point.\n\n\n\n\n\nis_du_val_singularity(X::AbsAffineScheme, I::Ideal)\n\nReturn whether the given X has at most du Val (surface) singularities at the geometric points specified by the ideal I.\n\nNote: For the ideal I in a ring R, dim(R/I) = 0 is asserted\n\nExamples\n\njulia> R,(x,y,z,w) = QQ[:x, :y, :z, :w]\n(Multivariate polynomial ring in 4 variables over QQ, QQMPolyRingElem[x, y, z, w])\n\njulia> I = ideal(R,[w,x^2+y^3+z^4])\nIdeal generated by\n  w\n  x^2 + y^3 + z^4\n\njulia> Rq, _ = quo(R,I)\n(Quotient of multivariate polynomial ring by ideal (w, x^2 + y^3 + z^4), Map: R -> Rq)\n\njulia> J = ideal(R,[x,y,z,w])\nIdeal generated by\n  x\n  y\n  z\n  w\n\njulia> X = spec(Rq)\nSpectrum\n  of quotient\n    of multivariate polynomial ring in 4 variables x, y, z, w\n      over rational field\n    by ideal (w, x^2 + y^3 + z^4)\n\njulia> is_du_val_singularity(X,J)\ntrue\n\n\n\n\n\n\n","category":"function"},{"location":"AlgebraicGeometry/Surfaces/duValSing/#decide_du_val_singularity","page":"Classifier/identifier specifically for du Val singularities","title":"decide_du_val_singularity","text":"decide_du_val_singularity(P::AbsAffineRationalPoint{<:Field})\n\nReturn whether the ambient scheme of P has a Du Val singularity at P.\n\nExamples\n\njulia> A3 = affine_space(QQ, [:x, :y, :z]);\n\njulia> (x, y, z) = ambient_coordinates(A3);\n\njulia> X = subscheme(A3, ideal([x^2+y^2-z^2]));\n\njulia> Oscar.decide_du_val_singularity(X([0,0,0]))\n(true, (:A, 1))\n\n\n\n\n\n\ndecide_du_val_singularity(X::AbsAffineScheme, I::Ideal)\n\nReturn a vector of tuples T with the following data:\n\nT[1]::Bool answers whether X has at most du Val (surface) singularities at the geometric points specified by the ideal I.\nT[2]::Ideal is I_P the associated prime of I (possibly over a suitable field extension) describing some geometrically irreducible point\nT[3]::Tuple contains the type of the singularity at P  e.g. (:A, 3)\nT[4]::Int number of conjugate points\n\nIf X has a least one singularity which is not du Val, the returned vector contains a single tuple T, with the following values:\n\nT[1]  is false\nT[2] represents a point at which some non-du-Val singularity is present\nT[3] is the empty tuple\nT[4] = 1\n\nNote: For the ideal I in a ring R, dim(R/I) = 0 is asserted\n\nExamples\n\njulia> R,(x,y,z,w) = QQ[:x, :y, :z, :w]\n(Multivariate polynomial ring in 4 variables over QQ, QQMPolyRingElem[x, y, z, w])\n\njulia> I = ideal(R,[w,x^2+y^3+z^4])\nIdeal generated by\n  w\n  x^2 + y^3 + z^4\n\njulia> Rq, _ = quo(R,I)\n(Quotient of multivariate polynomial ring by ideal (w, x^2 + y^3 + z^4), Map: R -> Rq)\n\njulia> J = ideal(R,[x,y,z,w])\nIdeal generated by\n  x\n  y\n  z\n  w\n\njulia> X = spec(Rq)\nSpectrum\n  of quotient\n    of multivariate polynomial ring in 4 variables x, y, z, w\n      over rational field\n    by ideal (w, x^2 + y^3 + z^4)\n\njulia> decide_du_val_singularity(X,J)\n1-element Vector{Any}:\n (true, Ideal (w, z, y, x), (:E, 6), 1)\n\n\n\n\n\n","category":"function"},{"location":"Hecke/manual/orders/orders/#Orders","page":"Orders","title":"Orders","text":"","category":"section"},{"location":"Hecke/manual/orders/orders/","page":"Orders","title":"Orders","text":"CurrentModule = Hecke","category":"page"},{"location":"Hecke/manual/orders/orders/","page":"Orders","title":"Orders","text":"Orders, that is, unitary subrings that are free mathbfZ-modules of rank equal to the degree of the number field, are at the core of the arithmetic of number fields. In Hecke, orders are always represented using the module structure, be it the mathbfZ-module structure for orders of absolute numbers fields, or the structure as a module over the maximal order of the base field in the case of relative number fields. In this chapter we mainly deal with orders of absolute fields. However, many functions apply in same way to relative extensions. There are more general definitions of orders in number fields available, but those are (currently) not implemented in Hecke.","category":"page"},{"location":"Hecke/manual/orders/orders/","page":"Orders","title":"Orders","text":"Among all orders in a fixed field, there is a unique maximal order, called the maximal order, or ring of integers of the number field. It is well known that this is the only order that is a Dedekind domain, hence has a rich ideal structure as well. The maximal order is also the integral closure of mathbfZ in the number field and can also be interpreted as a normalization of any other order.","category":"page"},{"location":"Hecke/manual/orders/orders/#Creation-and-basic-properties","page":"Orders","title":"Creation and basic properties","text":"","category":"section"},{"location":"Hecke/manual/orders/orders/","page":"Orders","title":"Orders","text":"Order(::AbsSimpleNumField, ::Vector{AbsSimpleNumFieldElem})\nOrder(::AbsSimpleNumField, ::QQMatrix)\nOrder(::AbsSimpleNumFieldOrderFractionalIdeal)\nEquationOrder(::AbsSimpleNumField)\nMaximalOrder(::AbsSimpleNumField)\nMaximalOrder(::AbsSimpleNumFieldOrder)\nlll(::AbsSimpleNumFieldOrder)\nany_order(K::AbsSimpleNumField)","category":"page"},{"location":"Hecke/manual/orders/orders/#Order-Tuple{AbsSimpleNumField, Vector{AbsSimpleNumFieldElem}}","page":"Orders","title":"Order","text":"Order(a::Vector{AbsSimpleNumFieldElem}; check::Bool = true, cached::Bool = true, isbasis::Bool = false) -> AbsSimpleNumFieldOrder\nOrder(K::AbsSimpleNumField, a::Vector{AbsSimpleNumFieldElem}; check::Bool = true, cached::Bool = true, isbasis::Bool = false) -> AbsSimpleNumFieldOrder\n\nReturns the order generated by a. If check is set, it is checked whether a defines an order, in particular the integrality of the elements is checked by computing minimal polynomials. If isbasis is set, then elements are assumed to form a mathbfZ-basis. If cached is set, then the constructed order is cached for future use.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/orders/orders/#Order-Tuple{AbsSimpleNumField, QQMatrix}","page":"Orders","title":"Order","text":"Order(K::AbsSimpleNumField, A::QQMatrix; check::Bool = true) -> AbsSimpleNumFieldOrder\n\nReturns the order which has basis matrix A with respect to the power basis of K. If check is set, it is checked whether A defines an order.\n\n\n\n\n\nOrder(K::AbsSimpleNumField, A::QQMatrix; check::Bool = true) -> AbsSimpleNumFieldOrder\n\nReturns the order which has basis matrix A with respect to the power basis of K. If check is set, it is checked whether A defines an order.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/orders/orders/#Order-Tuple{AbsSimpleNumFieldOrderFractionalIdeal}","page":"Orders","title":"Order","text":"Order(K::AbsSimpleNumField, A::ZZMatrix, check::Bool = true) -> AbsSimpleNumFieldOrder\n\nReturns the order which has basis matrix A with respect to the power basis of K. If check is set, it is checked whether A defines an order.\n\n\n\n\n\nOrder(A::AbstractAssociativeAlgebra{<: NumFieldElem}, M::PMat{<: NumFieldElem, T})\n  -> AlgAssRelOrd\n\nReturns the order of A with basis pseudo-matrix M.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/orders/orders/#EquationOrder-Tuple{AbsSimpleNumField}","page":"Orders","title":"EquationOrder","text":"EquationOrder(K::number_field) -> NumFieldOrder\nequation_order(K::number_field) -> NumFieldOrder\n\nReturns the equation order of the number field K.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/orders/orders/#MaximalOrder-Tuple{AbsSimpleNumField}","page":"Orders","title":"MaximalOrder","text":"MaximalOrder(K::NumField{QQFieldElem}; discriminant::ZZRingElem, ramified_primes::Vector{ZZRingElem}) -> AbsNumFieldOrder\n\nReturns the maximal order of K. Additional information can be supplied if they are already known, as the ramified primes or the discriminant of the maximal order.\n\nExample\n\njulia> Qx, x = QQ[\"x\"];\njulia> K, a = number_field(x^3 + 2, \"a\");\njulia> O = MaximalOrder(K);\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/orders/orders/#MaximalOrder-Tuple{AbsSimpleNumFieldOrder}","page":"Orders","title":"MaximalOrder","text":"MaximalOrder(O::AbsNumFieldOrder; index_divisors::Vector{ZZRingElem}, discriminant::ZZRingElem, ramified_primes::Vector{ZZRingElem}) -> AbsNumFieldOrder\n\nReturns the maximal order of the number field that contains O. Additional information can be supplied if they are already known, as the ramified primes, the discriminant of the maximal order or a set of integers dividing the index of O in the maximal order.\n\n\n\n\n\nMaximalOrder(O::AlgAssAbsOrd)\n\nGiven an order O, this function returns a maximal order containing O.\n\n\n\n\n\nMaximalOrder(A::AbstractAssociativeAlgebra{QQFieldElem}) -> AlgAssAbsOrd\n\nReturns a maximal order of A.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/orders/orders/#lll-Tuple{AbsSimpleNumFieldOrder}","page":"Orders","title":"lll","text":"lll(M::AbsNumFieldOrder) -> AbsNumFieldOrder\n\nThe same order, but with the basis now being LLL reduced wrt. the Minkowski metric.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/orders/orders/#any_order-Tuple{AbsSimpleNumField}","page":"Orders","title":"any_order","text":"any_order(K::number_field)\n\nReturn some order in K. In case the defining polynomial for K is monic and integral, this just returns the equation order. In the other case mathbb Zalphacap mathbb Z1alpha is returned.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/orders/orders/#Example","page":"Orders","title":"Example","text":"","category":"section"},{"location":"Hecke/manual/orders/orders/","page":"Orders","title":"Orders","text":"using Hecke; # hide\nQx, x = polynomial_ring(QQ, \"x\");\nK, a = number_field(x^2 - 2, \"a\");\nO = EquationOrder(K)","category":"page"},{"location":"Hecke/manual/orders/orders/","page":"Orders","title":"Orders","text":"parent(::AbsSimpleNumFieldOrder)\nsignature(::AbsSimpleNumFieldOrder)\nnf(::AbsSimpleNumFieldOrder)\nbasis(::AbsSimpleNumFieldOrder)\nlll_basis(::AbsSimpleNumFieldOrder)\nbasis(::AbsSimpleNumFieldOrder, ::AbsSimpleNumField)\npseudo_basis(::RelNumFieldOrder)\nbasis_pmatrix(::RelNumFieldOrder)\nbasis_nf(::RelNumFieldOrder)\ninv_coeff_ideals(::RelNumFieldOrder)\nbasis_matrix(::AbsNumFieldOrder)\nbasis_mat_inv(::AbsSimpleNumFieldOrder)\ngen_index(::AbsSimpleNumFieldOrder)\nis_index_divisor(::AbsSimpleNumFieldOrder, ::ZZRingElem)\nminkowski_matrix(::AbsSimpleNumFieldOrder, ::Int)\nin(::AbsSimpleNumFieldElem, ::AbsSimpleNumFieldOrder)\nnorm_change_const(::AbsSimpleNumFieldOrder)\ntrace_matrix(::AbsSimpleNumFieldOrder)\n+(::AbsNumFieldOrder, ::AbsNumFieldOrder)\npoverorder(::AbsSimpleNumFieldOrder, ::ZZRingElem)\npoverorders(::AbsSimpleNumFieldOrder, ::ZZRingElem)\npmaximal_overorder(::AbsSimpleNumFieldOrder, ::ZZRingElem)\npradical(::AbsNumFieldOrder, ::Union{Integer, ZZRingElem})\npradical(::RelNumFieldOrder, ::Union{Hecke.RelNumFieldOrderIdeal, AbsNumFieldOrderIdeal{AbsSimpleNumField, AbsSimpleNumFieldElem}})\nring_of_multipliers(::AbsNumFieldOrderIdeal)\n","category":"page"},{"location":"Hecke/manual/orders/orders/#parent-Tuple{AbsSimpleNumFieldOrder}","page":"Orders","title":"parent","text":"parent(O::AbsNumFieldOrder) -> AbsNumFieldOrderSet\n\nReturns the parent of mathcal O, that is, the set of orders of the ambient number field.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/orders/orders/#signature-Tuple{AbsSimpleNumFieldOrder}","page":"Orders","title":"signature","text":"signature(O::NumFieldOrder) -> Tuple{Int, Int}\n\nReturns the signature of the ambient number field of mathcal O.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/orders/orders/#nf-Tuple{AbsSimpleNumFieldOrder}","page":"Orders","title":"nf","text":"nf(O::NumFieldOrder) -> NumField\n\nReturns the ambient number field of mathcal O.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/orders/orders/#basis-Tuple{AbsSimpleNumFieldOrder}","page":"Orders","title":"basis","text":"basis(O::AbsNumFieldOrder) -> Vector{AbsNumFieldOrderElem}\n\nReturns the mathbf Z-basis of mathcal O.\n\n\n\n\n\nbasis(I::AbsNumFieldOrderFractionalIdeal) -> Vector{AbsSimpleNumFieldElem}\n\nReturns the mathbf Z-basis of I.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/orders/orders/#lll_basis-Tuple{AbsSimpleNumFieldOrder}","page":"Orders","title":"lll_basis","text":"lll_basis(M::NumFieldOrder) -> Vector{NumFieldElem}\n\nA basis for M that is reduced using the LLL algorithm for the Minkowski metric.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/orders/orders/#basis-Tuple{AbsSimpleNumFieldOrder, AbsSimpleNumField}","page":"Orders","title":"basis","text":"basis(O::AbsSimpleNumFieldOrder, K::AbsSimpleNumField) -> Vector{AbsSimpleNumFieldElem}\n\nReturns the mathbf Z-basis elements of mathcal O as elements of the ambient number field.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/orders/orders/#pseudo_basis-Tuple{Hecke.RelNumFieldOrder}","page":"Orders","title":"pseudo_basis","text":"  pseudo_basis(O::RelNumFieldOrder{T, S}) -> Vector{Tuple{NumFieldElem{T}, S}}\n\nReturns the pseudo-basis of mathcal O.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/orders/orders/#basis_pmatrix-Tuple{Hecke.RelNumFieldOrder}","page":"Orders","title":"basis_pmatrix","text":"  basis_pmatrix(O::RelNumFieldOrder) -> PMat\n\nReturns the basis pseudo-matrix of mathcal O with respect to the power basis of the ambient number field.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/orders/orders/#basis_nf-Tuple{Hecke.RelNumFieldOrder}","page":"Orders","title":"basis_nf","text":"  basis_nf(O::RelNumFieldOrder) -> Vector{NumFieldElem}\n\nReturns the elements of the pseudo-basis of mathcal O as elements of the ambient number field.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/orders/orders/#inv_coeff_ideals-Tuple{Hecke.RelNumFieldOrder}","page":"Orders","title":"inv_coeff_ideals","text":"  inv_coeff_ideals(O::RelNumFieldOrder{T, S}) -> Vector{S}\n\nReturns the inverses of the coefficient ideals of the pseudo basis of O.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/orders/orders/#basis_matrix-Tuple{AbsNumFieldOrder}","page":"Orders","title":"basis_matrix","text":"basis_matrix(O::AbsNumFieldOrder) -> QQMatrix\n\nReturns the basis matrix of mathcal O with respect to the basis of the ambient number field.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/orders/orders/#basis_mat_inv-Tuple{AbsSimpleNumFieldOrder}","page":"Orders","title":"basis_mat_inv","text":"basis_mat_inv(A::GenOrdIdl) -> FakeFracFldMat\n\nReturn the inverse of the basis matrix of A.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/orders/orders/#gen_index-Tuple{AbsSimpleNumFieldOrder}","page":"Orders","title":"gen_index","text":"gen_index(O::AbsSimpleNumFieldOrder) -> QQFieldElem\n\nReturns the generalized index of mathcal O with respect to the equation order of the ambient number field.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/orders/orders/#is_index_divisor-Tuple{AbsSimpleNumFieldOrder, ZZRingElem}","page":"Orders","title":"is_index_divisor","text":"is_index_divisor(O::AbsSimpleNumFieldOrder, d::ZZRingElem) -> Bool\nis_index_divisor(O::AbsSimpleNumFieldOrder, d::Int) -> Bool\n\nReturns whether d is a divisor of the index of mathcal O. It is assumed that mathcal O contains the equation order of the ambient number field.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/orders/orders/#minkowski_matrix-Tuple{AbsSimpleNumFieldOrder, Int64}","page":"Orders","title":"minkowski_matrix","text":"minkowski_matrix(O::AbsNumFieldOrder, abs_tol::Int = 64) -> ArbMatrix\n\nReturns the Minkowski matrix of mathcal O.  Thus if mathcal O has degree d, then the result is a matrix in operatornameMat_dtimes d(mathbf R). The entries of the matrix are real balls of type ArbFieldElem with radius less then 2^-abs_tol.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/orders/orders/#in-Tuple{AbsSimpleNumFieldElem, AbsSimpleNumFieldOrder}","page":"Orders","title":"in","text":"in(a::NumFieldElem, O::NumFieldOrder) -> Bool\n\nChecks whether a lies in mathcal O.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/orders/orders/#norm_change_const-Tuple{AbsSimpleNumFieldOrder}","page":"Orders","title":"norm_change_const","text":"norm_change_const(O::AbsSimpleNumFieldOrder) -> (Float64, Float64)\n\nReturns (c_1 c_2) in mathbf R_0^2 such that for all x = sum_i=1^d x_i omega_i in mathcal O we have T_2(x) leq c_1 cdot sum_i^d x_i^2 and sum_i^d x_i^2 leq c_2 cdot T_2(x), where (omega_i)_i is the mathbf Z-basis of mathcal O.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/orders/orders/#trace_matrix-Tuple{AbsSimpleNumFieldOrder}","page":"Orders","title":"trace_matrix","text":"trace_matrix(O::AbsNumFieldOrder) -> ZZMatrix\n\nReturns the trace matrix of mathcal O, that is, the matrix (operatornametr_Kmathbf Q(b_i cdot b_j))_1 leq i j leq d.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/orders/orders/#+-Tuple{AbsNumFieldOrder, AbsNumFieldOrder}","page":"Orders","title":"+","text":"+(R::AbsSimpleNumFieldOrder, S::AbsSimpleNumFieldOrder) -> AbsSimpleNumFieldOrder\n\nGiven two orders R, S of K, this function returns the smallest order containing both R and S. It is assumed that R, S contain the ambient equation order and have coprime index.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/orders/orders/#poverorder-Tuple{AbsSimpleNumFieldOrder, ZZRingElem}","page":"Orders","title":"poverorder","text":"poverorder(O::AbsSimpleNumFieldOrder, p::ZZRingElem) -> AbsSimpleNumFieldOrder\npoverorder(O::AbsSimpleNumFieldOrder, p::Integer) -> AbsSimpleNumFieldOrder\n\nThis function tries to find an order that is locally larger than mathcal O at the prime p: If p divides the index  mathcal O_K  mathcal O, this function will return an order R such that v_p( mathcal O_K  R)  v_p( mathcal O_K  mathcal O). Otherwise mathcal O is returned.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/orders/orders/#poverorders-Tuple{AbsSimpleNumFieldOrder, ZZRingElem}","page":"Orders","title":"poverorders","text":"poverorders(O, p) -> Vector{Ord}\n\nReturns all p-overorders of O, that is all overorders M, such that the index of O in M is a p-power.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/orders/orders/#pmaximal_overorder-Tuple{AbsSimpleNumFieldOrder, ZZRingElem}","page":"Orders","title":"pmaximal_overorder","text":"pmaximal_overorder(O::AbsSimpleNumFieldOrder, p::ZZRingElem) -> AbsSimpleNumFieldOrder\npmaximal_overorder(O::AbsSimpleNumFieldOrder, p::Integer) -> AbsSimpleNumFieldOrder\n\nThis function finds a p-maximal order R containing mathcal O. That is, the index  mathcal O_K  R is not divisible by p.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/orders/orders/#pradical-Tuple{AbsNumFieldOrder, Union{Integer, ZZRingElem}}","page":"Orders","title":"pradical","text":"pradical(O::AbsSimpleNumFieldOrder, p::{ZZRingElem|Integer}) -> AbsNumFieldOrderIdeal\n\nGiven a prime number p, this function returns the p-radical sqrtpmathcal O of mathcal O, which is just  x in mathcal O mid exists k in mathbf Z_geq 0 colon x^k in pmathcal O . It is not checked that p is prime.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/orders/orders/#pradical-Tuple{Hecke.RelNumFieldOrder, Union{Hecke.RelNumFieldOrderIdeal, AbsSimpleNumFieldOrderIdeal}}","page":"Orders","title":"pradical","text":"  pradical(O::RelNumFieldOrder, P::AbsNumFieldOrderIdeal{AbsSimpleNumField, AbsSimpleNumFieldElem}) -> RelNumFieldOrderIdeal\n\nGiven a prime ideal P, this function returns the P-radical sqrtPmathcal O of mathcal O, which is just  x in mathcal O mid exists k in mathbf Z_geq 0 colon x^k in Pmathcal O . It is not checked that P is prime.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/orders/orders/#ring_of_multipliers-Tuple{AbsNumFieldOrderIdeal}","page":"Orders","title":"ring_of_multipliers","text":"ring_of_multipliers(I::AbsNumFieldOrderIdeal) -> AbsNumFieldOrder\n\nComputes the order (I  I), which is the set of all x in K with xI subseteq I.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/orders/orders/#Invariants","page":"Orders","title":"Invariants","text":"","category":"section"},{"location":"Hecke/manual/orders/orders/","page":"Orders","title":"Orders","text":"discriminant(::AbsNumFieldOrder)\nreduced_discriminant(::AbsSimpleNumFieldOrder)\ndegree(::AbsSimpleNumFieldOrder)\nindex(::AbsSimpleNumFieldOrder)\ndifferent(::AbsSimpleNumFieldOrder)\ncodifferent(::AbsSimpleNumFieldOrder)\nis_gorenstein(::AbsSimpleNumFieldOrder)\nis_bass(::AbsSimpleNumFieldOrder)\nis_equation_order(::AbsSimpleNumFieldOrder)\nzeta_log_residue(::AbsSimpleNumFieldOrder, ::Float64)\nramified_primes(::AbsSimpleNumFieldOrder)","category":"page"},{"location":"Hecke/manual/orders/orders/#discriminant-Tuple{AbsNumFieldOrder}","page":"Orders","title":"discriminant","text":"discriminant(O::AbsSimpleNumFieldOrder) -> ZZRingElem\n\nReturns the discriminant of mathcal O.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/orders/orders/#reduced_discriminant-Tuple{AbsSimpleNumFieldOrder}","page":"Orders","title":"reduced_discriminant","text":"reduced_discriminant(O::AbsSimpleNumFieldOrder) -> ZZRingElem\n\nReturns the reduced discriminant, that is, the largest elementary divisor of the trace matrix of mathcal O.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/orders/orders/#degree-Tuple{AbsSimpleNumFieldOrder}","page":"Orders","title":"degree","text":"degree(O::NumFieldOrder) -> Int\n\nReturns the degree of mathcal O.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/orders/orders/#index-Tuple{AbsSimpleNumFieldOrder}","page":"Orders","title":"index","text":"index(O::AbsSimpleNumFieldOrder) -> ZZRingElem\n\nAssuming that the order mathcal O contains the equation order mathbf Zalpha of the ambient number field, this function returns the index  mathcal O  mathbf Z.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/orders/orders/#different-Tuple{AbsSimpleNumFieldOrder}","page":"Orders","title":"different","text":"different(R::AbsNumFieldOrder) -> AbsNumFieldOrderIdeal\n\nThe different ideal of R, that is, the ideal generated by all differents of elements in R. For Gorenstein orders, this is also the inverse ideal of the co-different.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/orders/orders/#codifferent-Tuple{AbsSimpleNumFieldOrder}","page":"Orders","title":"codifferent","text":"codifferent(R::AbsNumFieldOrder) -> AbsNumFieldOrderIdeal{AbsSimpleNumField, AbsSimpleNumFieldElem}\n\nThe codifferent ideal of R, i.e. the trace-dual of R.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/orders/orders/#is_gorenstein-Tuple{AbsSimpleNumFieldOrder}","page":"Orders","title":"is_gorenstein","text":"is_gorenstein(O::AbsSimpleNumFieldOrder) -> Bool\n\nReturn whether the order \\mathcal{O} is Gorenstein.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/orders/orders/#is_bass-Tuple{AbsSimpleNumFieldOrder}","page":"Orders","title":"is_bass","text":"is_bass(O::AbsSimpleNumFieldOrder) -> Bool\n\nReturn whether the order \\mathcal{O} is Bass.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/orders/orders/#is_equation_order-Tuple{AbsSimpleNumFieldOrder}","page":"Orders","title":"is_equation_order","text":"is_equation_order(O::NumFieldOrder) -> Bool\n\nReturns whether mathcal O is the equation order of the ambient number field K.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/orders/orders/#zeta_log_residue-Tuple{AbsSimpleNumFieldOrder, Float64}","page":"Orders","title":"zeta_log_residue","text":"zeta_log_residue(O::AbsSimpleNumFieldOrder, error::Float64) -> ArbFieldElem\n\nComputes the residue of the zeta function of mathcal O at 1. The output will be an element of type ArbFieldElem with radius less then error.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/orders/orders/#ramified_primes-Tuple{AbsSimpleNumFieldOrder}","page":"Orders","title":"ramified_primes","text":"ramified_primes(O::AbsNumFieldOrder) -> Vector{ZZRingElem}\n\nReturns the list of prime numbers that divide operatornamedisc(mathcal O).\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/orders/orders/#Arithmetic","page":"Orders","title":"Arithmetic","text":"","category":"section"},{"location":"Hecke/manual/orders/orders/","page":"Orders","title":"Orders","text":"Progress and intermediate results of the functions mentioned here can be obtained via verbose_level, supported are","category":"page"},{"location":"Hecke/manual/orders/orders/","page":"Orders","title":"Orders","text":"ClassGroup\nUnitGroup","category":"page"},{"location":"Hecke/manual/orders/orders/","page":"Orders","title":"Orders","text":"All of the functions have a very similar interface: they return an abelian group and a map converting elements of the group into the objects required. The maps also allow a point-wise inverse to server as the discrete logarithm map. For more information on abelian groups, see here, for ideals, here.","category":"page"},{"location":"Hecke/manual/orders/orders/","page":"Orders","title":"Orders","text":"torsion_unit_group(::AbsSimpleNumFieldOrder)\nunit_group(::AbsSimpleNumFieldOrder)\nunit_group_fac_elem(::AbsSimpleNumFieldOrder)\nsunit_group(::Vector{AbsNumFieldOrderIdeal{AbsSimpleNumField, AbsSimpleNumFieldElem}})\nsunit_group_fac_elem(::Vector{AbsNumFieldOrderIdeal{AbsSimpleNumField, AbsSimpleNumFieldElem}})\nsunit_mod_units_group_fac_elem(::Vector{AbsNumFieldOrderIdeal{AbsSimpleNumField, AbsSimpleNumFieldElem}})\nclass_group(::AbsSimpleNumFieldOrder)\npicard_group(::AbsSimpleNumFieldOrder)\nnarrow_class_group(::AbsSimpleNumFieldOrder)","category":"page"},{"location":"Hecke/manual/orders/orders/","page":"Orders","title":"Orders","text":"For the processing of units, there are a couple of helper functions also available:","category":"page"},{"location":"Hecke/manual/orders/orders/","page":"Orders","title":"Orders","text":"is_independent","category":"page"},{"location":"Hecke/manual/orders/orders/#is_independent","page":"Orders","title":"is_independent","text":"is_independent{T}(x::Vector{T})\n\nGiven an array of non-zero units in a number field, returns whether they are multiplicatively independent.\n\n\n\n\n\n","category":"function"},{"location":"Hecke/manual/orders/orders/#Predicates","page":"Orders","title":"Predicates","text":"","category":"section"},{"location":"Hecke/manual/orders/orders/","page":"Orders","title":"Orders","text":"Hecke.is_contained(::AbsNumFieldOrder, ::AbsNumFieldOrder)\nis_maximal(::AbsNumFieldOrder)","category":"page"},{"location":"Hecke/manual/orders/orders/#is_contained-Tuple{AbsNumFieldOrder, AbsNumFieldOrder}","page":"Orders","title":"is_contained","text":"is_contained(R::AbsNumFieldOrder, S::AbsNumFieldOrder) -> Bool\n\nChecks if R is contained in S.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/orders/orders/#is_maximal-Tuple{AbsNumFieldOrder}","page":"Orders","title":"is_maximal","text":"is_maximal(R::AbsNumFieldOrder) -> Bool\n\nTests if the order R is maximal. This might trigger the computation of the maximal order.\n\n\n\n\n\n","category":"method"},{"location":"Combinatorics/EnumerativeCombinatorics/compositions/#Compositions","page":"Compositions","title":"Compositions","text":"","category":"section"},{"location":"Combinatorics/EnumerativeCombinatorics/compositions/","page":"Compositions","title":"Compositions","text":"A weak composition of a non-negative integer n is a sequence lambda_1dotslambda_k of non-negative integers lambda_i such that n = lambda_1 + dots + lambda_k. A composition of n is a weak composition consisting of positive integers. The lambda_i are called the parts of the (weak) composition.","category":"page"},{"location":"Combinatorics/EnumerativeCombinatorics/compositions/","page":"Compositions","title":"Compositions","text":"weak_composition\ncomposition","category":"page"},{"location":"Combinatorics/EnumerativeCombinatorics/compositions/#weak_composition","page":"Compositions","title":"weak_composition","text":"weak_composition(parts::Vector{T}; check::Bool = true) where T <: IntegerUnion\n\nReturn the weak composition given by the integer sequence parts as an object of type WeakComposition{T}.\n\nIf check is true (default), it is checked whether the given sequence defines a weak composition, that is, whether all elements of parts are non-negative.\n\nExamples\n\njulia> W = weak_composition([6, 0, 2, 3]) # the weak composition 6, 0, 2, 3 of 11\n[6, 0, 2, 3]\n\njulia> W = weak_composition(Int8[6, 0, 2, 3]) # save the elements in 8-bit integers\nInt8[6, 0, 2, 3]\n\n\n\n\n\n","category":"function"},{"location":"Combinatorics/EnumerativeCombinatorics/compositions/#composition","page":"Compositions","title":"composition","text":"composition(parts::Vector{T}; check::Bool = true) where T <: IntegerUnion\n\nReturn the composition given by the integer sequence parts as an object of type Composition{T}.\n\nIf check is true (default), it is checked whether the given sequence defines a composition, that is, whether all elements of parts are positive.\n\nExamples\n\njulia> C = composition([6, 1, 2, 3]) # the composition 6, 1, 2, 3 of 12\n[6, 1, 2, 3]\n\njulia> C = composition(Int8[6, 1, 2, 3]) # save the elements in 8-bit integers\nInt8[6, 1, 2, 3]\n\n\n\n\n\n","category":"function"},{"location":"Combinatorics/EnumerativeCombinatorics/compositions/#Generating-and-counting","page":"Compositions","title":"Generating and counting","text":"","category":"section"},{"location":"Combinatorics/EnumerativeCombinatorics/compositions/#Unrestricted-compositions","page":"Compositions","title":"Unrestricted compositions","text":"","category":"section"},{"location":"Combinatorics/EnumerativeCombinatorics/compositions/","page":"Compositions","title":"Compositions","text":"compositions(::Oscar.IntegerUnion)\nnumber_of_compositions(::Oscar.IntegerUnion)","category":"page"},{"location":"Combinatorics/EnumerativeCombinatorics/compositions/#compositions-Tuple{Union{Integer, ZZRingElem}}","page":"Compositions","title":"compositions","text":"compositions(n::IntegerUnion)\n\nReturn an iterator over all compositions of a non-negative integer n.\n\nBy a composition of n we mean a sequence of positive integers whose sum is n.\n\nExamples\n\njulia> C = compositions(4)\nIterator over the compositions of 4\n\njulia> collect(C)\n8-element Vector{Composition{Int64}}:\n [4]\n [3, 1]\n [2, 2]\n [1, 3]\n [2, 1, 1]\n [1, 2, 1]\n [1, 1, 2]\n [1, 1, 1, 1]\n\n\n\n\n\n","category":"method"},{"location":"Combinatorics/EnumerativeCombinatorics/compositions/#number_of_compositions-Tuple{Union{Integer, ZZRingElem}}","page":"Compositions","title":"number_of_compositions","text":"number_of_compositions(n::IntegerUnion)\n\nReturn the number of compositions of the non-negative integer n. For n < 0, return 0.\n\n\n\n\n\n","category":"method"},{"location":"Combinatorics/EnumerativeCombinatorics/compositions/","page":"Compositions","title":"Compositions","text":"Note that an integer n has infinitely many weak compositions as one may always append zeros to the end of a given weak composition. Without restrictions on the number of parts, we can hence only generate compositions, but not weak compositions.","category":"page"},{"location":"Combinatorics/EnumerativeCombinatorics/compositions/#Restricted-compositions","page":"Compositions","title":"Restricted compositions","text":"","category":"section"},{"location":"Combinatorics/EnumerativeCombinatorics/compositions/","page":"Compositions","title":"Compositions","text":"compositions(::Oscar.IntegerUnion, ::Oscar.IntegerUnion)\nnumber_of_compositions(::Oscar.IntegerUnion, ::Oscar.IntegerUnion)","category":"page"},{"location":"Combinatorics/EnumerativeCombinatorics/compositions/#compositions-Tuple{Union{Integer, ZZRingElem}, Union{Integer, ZZRingElem}}","page":"Compositions","title":"compositions","text":"compositions(n::IntegerUnion, k::IntegerUnion)\n\nReturn an iterator over all compositions of a non-negative integer n into k parts, produced in lexicographically descending order.\n\nBy a composition of n into k parts we mean a sequence of k positive integers whose sum is n.\n\nExamples\n\njulia> C = compositions(4, 2)\nIterator over the compositions of 4 into 2 parts\n\njulia> collect(C)\n3-element Vector{Composition{Int64}}:\n [3, 1]\n [2, 2]\n [1, 3]\n\n\n\n\n\n","category":"method"},{"location":"Combinatorics/EnumerativeCombinatorics/compositions/#number_of_compositions-Tuple{Union{Integer, ZZRingElem}, Union{Integer, ZZRingElem}}","page":"Compositions","title":"number_of_compositions","text":"number_of_compositions(n::IntegerUnion, k::IntegerUnion)\n\nReturn the number of compositions of the non-negative integer n into k >= 0 parts. If n < 0 or k < 0, return 0.\n\n\n\n\n\n","category":"method"},{"location":"Combinatorics/EnumerativeCombinatorics/compositions/#Restricted-weak-compositions","page":"Compositions","title":"Restricted weak compositions","text":"","category":"section"},{"location":"Combinatorics/EnumerativeCombinatorics/compositions/","page":"Compositions","title":"Compositions","text":"weak_compositions\nnumber_of_weak_compositions(::Oscar.IntegerUnion, ::Oscar.IntegerUnion)","category":"page"},{"location":"Combinatorics/EnumerativeCombinatorics/compositions/#weak_compositions","page":"Compositions","title":"weak_compositions","text":"weak_compositions(n::IntegerUnion, k::IntegerUnion)\n\nReturn an iterator over all weak compositions of a non-negative integer n into k parts, produced in lexicographically descending order. Using a smaller integer type for n (e.g. Int8) may increase performance.\n\nBy a weak composition of n into k parts we mean a sequence of k non-negative integers whose sum is n.\n\nExamples\n\njulia> W = weak_compositions(3, 2)\nIterator over the weak compositions of 3 into 2 parts\n\njulia> length(W)\n4\n\njulia> collect(W)\n4-element Vector{WeakComposition{Int64}}:\n [3, 0]\n [2, 1]\n [1, 2]\n [0, 3]\n\n\n\n\n\n","category":"function"},{"location":"Combinatorics/EnumerativeCombinatorics/compositions/#number_of_weak_compositions-Tuple{Union{Integer, ZZRingElem}, Union{Integer, ZZRingElem}}","page":"Compositions","title":"number_of_weak_compositions","text":"number_of_weak_compositions(n::IntegerUnion, k::IntegerUnion)\n\nReturn the number of weak compositions of the non-negative integer n into k >= 0 parts. If n < 0 or k < 0, return 0.\n\n\n\n\n\n","category":"method"},{"location":"Combinatorics/EnumerativeCombinatorics/compositions/#Ascending-compositions","page":"Compositions","title":"Ascending compositions","text":"","category":"section"},{"location":"Combinatorics/EnumerativeCombinatorics/compositions/","page":"Compositions","title":"Compositions","text":"ascending_compositions","category":"page"},{"location":"Combinatorics/EnumerativeCombinatorics/compositions/#ascending_compositions","page":"Compositions","title":"ascending_compositions","text":"ascending_compositions(n::IntegerUnion)\n\nReturn an iterator over all ascending compositions of a non-negative integer n.\n\nBy a ascending composition of n we mean a non-decreasing sequence of positive integers whose sum is n.\n\nThe implemented algorithm is \"AccelAsc\" (Algorithm 4.1) in [KO14].\n\nExamples\n\njulia> C = ascending_compositions(4)\nIterator over the ascending compositions of 4\n\njulia> collect(C)\n5-element Vector{Composition{Int64}}:\n [1, 1, 1, 1]\n [1, 1, 2]\n [1, 3]\n [2, 2]\n [4]\n\n\n\n\n\n","category":"function"},{"location":"Combinatorics/EnumerativeCombinatorics/compositions/","page":"Compositions","title":"Compositions","text":"The number of ascending compositions of n coincides with the number of partitions of n.","category":"page"},{"location":"Hecke/manual/number_fields/class_fields/#Class-Field-Theory","page":"Class Field Theory","title":"Class Field Theory","text":"","category":"section"},{"location":"Hecke/manual/number_fields/class_fields/","page":"Class Field Theory","title":"Class Field Theory","text":"CurrentModule = Hecke","category":"page"},{"location":"Hecke/manual/number_fields/class_fields/#Introduction","page":"Class Field Theory","title":"Introduction","text":"","category":"section"},{"location":"Hecke/manual/number_fields/class_fields/","page":"Class Field Theory","title":"Class Field Theory","text":"This chapter deals with abelian extensions of number fields and the rational numbers.","category":"page"},{"location":"Hecke/manual/number_fields/class_fields/","page":"Class Field Theory","title":"Class Field Theory","text":"Class Field Theory, here specifically, class field theory of global number fields, deals with abelian extension, ie. fields where the group of automorphisms is abelian. For extensions of mathbb Q, the famous Kronnecker-Weber theorem classifies all such fields: a field is abelian if and only if it is contained in some cyclotomic field. For general number fields this is more involved and even for extensions of mathbb Q is is not practical.","category":"page"},{"location":"Hecke/manual/number_fields/class_fields/","page":"Class Field Theory","title":"Class Field Theory","text":"In Hecke, abelian extensions are parametrized by quotients of so called ray class groups. The language of ray class groups while dated is more applicable to algorithms than the modern language of idel class groups and quotients.","category":"page"},{"location":"Hecke/manual/number_fields/class_fields/#Ray-Class-Groups","page":"Class Field Theory","title":"Ray Class Groups","text":"","category":"section"},{"location":"Hecke/manual/number_fields/class_fields/","page":"Class Field Theory","title":"Class Field Theory","text":"Given an integral ideal m_0 le Z_K and a list of real places m_infty, the ray class group modulo (m_0 m_infty), C(m) is defined as the group of ideals coprime to m_0 modulo the elements ain K^* s.th. v_p(a-1) ge v_p(m_0) and for all vin m_infty, a^(v) 0. This is a finite abelian group. For m_0 = Z_K and m_infty =  we get C() is the class group, if m_infty contains all real places, we obtain the narrow class group, or strict class group.","category":"page"},{"location":"Hecke/manual/number_fields/class_fields/","page":"Class Field Theory","title":"Class Field Theory","text":"ray_class_group(m::Hecke.AbsNumFieldOrderIdeal{Nemo.AbsSimpleNumField,Nemo.AbsSimpleNumFieldElem}, inf_plc::Vector{Hecke.InfPlc}; p_part, n_quo)\nclass_group(K::Nemo.AbsSimpleNumField)\nnorm_group(f::Nemo.PolyRingElem, mR::Hecke.MapRayClassGrp, is_abelian::Bool)\nnorm_group(K::RelSimpleNumField{AbsSimpleNumFieldElem}, mR::Hecke.MapRayClassGrp, is_abelian::Bool)","category":"page"},{"location":"Hecke/manual/number_fields/class_fields/#ray_class_group-Tuple{AbsSimpleNumFieldOrderIdeal, Vector{InfPlc}}","page":"Class Field Theory","title":"ray_class_group","text":"ray_class_group(m::AbsNumFieldOrderIdeal{AbsSimpleNumField, AbsSimpleNumFieldElem}, inf_plc::Vector{InfPlc}; n_quo::Int, lp::Dict{AbsNumFieldOrderIdeal{AbsSimpleNumField, AbsSimpleNumFieldElem}, Int}) -> FinGenAbGroup, MapRayClassGrp\n\nGiven an ideal m and a set of infinite places of K, this function returns the corresponding ray class group as an abstract group mathcal Cl_m and a map going from the group into the group of ideals of K that are coprime to m. If n_quo is set, it will return the group modulo n_quo. The factorization of m can be given with the keyword argument lp.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/number_fields/class_fields/#class_group-Tuple{AbsSimpleNumField}","page":"Class Field Theory","title":"class_group","text":"class_group(K::AbsSimpleNumField) -> FinGenAbGroup, Map\n\nShortcut for class_group(maximal_order(K)): returns the class group as an abelian group and a map from this group to the set of ideals of the maximal order.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/number_fields/class_fields/#norm_group-Tuple{PolyRingElem, MapRayClassGrp, Bool}","page":"Class Field Theory","title":"norm_group","text":"norm_group(f::Nemo.PolyRingElem, mR::Hecke.MapRayClassGrp, is_abelian::Bool = true; of_closure::Bool = false) -> Hecke.FinGenGrpAb, Hecke.FinGenGrpAbMap\n\nnorm_group(f::Array{PolyRingElem{AbsSimpleNumFieldElem}}, mR::Hecke.MapRayClassGrp, is_abelian::Bool = true; of_closure::Bool = false) -> Hecke.FinGenGrpAb, Hecke.FinGenGrpAbMap\n\nComputes the subgroup of the Ray Class Group R given by the norm of the extension generated by a/the roots of f. If is_abelian is set to true, then the code assumes the field to be abelian, hence the algorithm stops when the quotient by the norm group has the correct order. Even though the algorithm is probabilistic by nature, in this case the result is guaranteed. If of_closure is given, then the norm group of the splitting field of the polynomial(s) is computed. It is the callers responsibility to ensure that the ray class group passed in is large enough.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/number_fields/class_fields/#norm_group-Tuple{Hecke.RelSimpleNumField{AbsSimpleNumFieldElem}, MapRayClassGrp, Bool}","page":"Class Field Theory","title":"norm_group","text":"norm_group(K::RelSimpleNumField{AbsSimpleNumFieldElem}, mR::Hecke.MapRayClassGrp) -> Hecke.FinGenGrpAb, Hecke.FinGenGrpAbMap\n\nnorm_group(K::RelNonSimpleNumField{AbsSimpleNumFieldElem}, mR::Hecke.MapRayClassGrp) -> Hecke.FinGenGrpAb, Hecke.FinGenGrpAbMap\n\nComputes the subgroup of the Ray Class Group R given by the norm of the extension.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/number_fields/class_fields/#Ray-Class-Fields","page":"Class Field Theory","title":"Ray Class Fields","text":"","category":"section"},{"location":"Hecke/manual/number_fields/class_fields/","page":"Class Field Theory","title":"Class Field Theory","text":"In general, the construction of a class field starts with a (ray) class group. Each quotient of a ray class group then defines a ray class field, the defining property is that the (relative) automorphism group is canonically isomorphic to the quotient of the ray class group where the isomorphism is given by the Artin (or Frobenius) map. Since, in Hecke, the (ray) class groups have no link to the field, actually this has to be specified using the maps.","category":"page"},{"location":"Hecke/manual/number_fields/class_fields/","page":"Class Field Theory","title":"Class Field Theory","text":"It should be noted that this is a lazy construction: nothing is computed at this point.","category":"page"},{"location":"Hecke/manual/number_fields/class_fields/","page":"Class Field Theory","title":"Class Field Theory","text":"ray_class_field(m::Union{Hecke.MapClassGrp, Hecke.MapRayClassGrp})\nray_class_field(m::Union{Hecke.MapClassGrp, Hecke.MapRayClassGrp}, quomap::Hecke.FinGenAbGroupHom)\nray_class_field(I::Hecke.AbsNumFieldOrderIdeal; n_quo, p_part)\nray_class_field(I::Hecke.AbsNumFieldOrderIdeal, ::Vector{InfPlc}; n_quo, p_part)\nhilbert_class_field(k::AbsSimpleNumField)\nring_class_field(::AbsNumFieldOrder)","category":"page"},{"location":"Hecke/manual/number_fields/class_fields/#ray_class_field-Tuple{Union{Hecke.MapClassGrp, MapRayClassGrp}}","page":"Class Field Theory","title":"ray_class_field","text":"ray_class_field(m::MapClassGrp) -> ClassField\nray_class_field(m::MapRayClassGrp) -> ClassField\n\nCreates the (formal) abelian extension defined by the map m A to I where I is the set of ideals coprime to the modulus defining m and A is a quotient of the ray class group (or class group). The map m must be the map returned from a call to {classgroup} or {rayclass_group}.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/number_fields/class_fields/#ray_class_field-Tuple{Union{Hecke.MapClassGrp, MapRayClassGrp}, FinGenAbGroupHom}","page":"Class Field Theory","title":"ray_class_field","text":"ray_class_field(m::Union{MapClassGrp, MapRayClassGrp}, quomap::FinGenAbGroupHom) -> ClassField\n\nFor m a map computed by either {rayclassgroup} or {class_group} and q a canonical projection (quotient map) as returned by {quo} for q quotient of the domain of m and a subgroup of m, create the (formal) abelian extension where the (relative) automorphism group is canonically isomorphic to the codomain of q.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/number_fields/class_fields/#ray_class_field-Tuple{AbsNumFieldOrderIdeal}","page":"Class Field Theory","title":"ray_class_field","text":"ray_class_field(I::AbsNumFieldOrderIdeal; n_quo = 0) -> ClassField\n\nThe ray class field modulo I. If n_quo is given, then the largest subfield of exponent n is computed.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/number_fields/class_fields/#ray_class_field-Tuple{AbsNumFieldOrderIdeal, Vector{InfPlc}}","page":"Class Field Theory","title":"ray_class_field","text":"ray_class_field(I::AbsNumFieldOrderIdeal, inf::Vector{InfPlc}; n_quo = 0) -> ClassField\n\nThe ray class field modulo I and the infinite places given. If n_quo is given, then the largest subfield of exponent n is computed.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/number_fields/class_fields/#hilbert_class_field-Tuple{AbsSimpleNumField}","page":"Class Field Theory","title":"hilbert_class_field","text":"hilbert_class_field(k::AbsSimpleNumField) -> ClassField\n\nThe Hilbert class field of k as a formal (ray-) class field.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/number_fields/class_fields/#ring_class_field-Tuple{AbsNumFieldOrder}","page":"Class Field Theory","title":"ring_class_field","text":"ring_class_field(O::AbsNumFieldOrder) -> ClassField\n\nThe ring class field of O, i.e. the maximal abelian extension ramified only at primes dividing the conductor with the automorphism group isomorphic to the Picard group.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/number_fields/class_fields/#Example","page":"Class Field Theory","title":"Example","text":"","category":"section"},{"location":"Hecke/manual/number_fields/class_fields/","page":"Class Field Theory","title":"Class Field Theory","text":"using Hecke # hide\nQx, x = polynomial_ring(QQ, \"x\");\nK, a = number_field(x^2 - 10, \"a\");\nc, mc = class_group(K)\nA = ray_class_field(mc)","category":"page"},{"location":"Hecke/manual/number_fields/class_fields/#Conversions","page":"Class Field Theory","title":"Conversions","text":"","category":"section"},{"location":"Hecke/manual/number_fields/class_fields/","page":"Class Field Theory","title":"Class Field Theory","text":"Given a ray class field, it is possible to actually compute defining equation(s) for this field. In general, the number field constructed this way will be non-simple by type and is defined by a polynomial for each maximal cyclic quotient of prime power order in the defining group.","category":"page"},{"location":"Hecke/manual/number_fields/class_fields/","page":"Class Field Theory","title":"Class Field Theory","text":"The algorithm employed is based on Kummer-theory and requires the addition of a suitable root of unity. Progress can be monitored by setting set_verbose_level(:ClassField, n) where 0le nle 3","category":"page"},{"location":"Hecke/manual/number_fields/class_fields/","page":"Class Field Theory","title":"Class Field Theory","text":"number_field(C::ClassField)","category":"page"},{"location":"Hecke/manual/number_fields/class_fields/#number_field-Tuple{ClassField}","page":"Class Field Theory","title":"number_field","text":"number_field(CF::ClassField) -> RelNonSimpleNumField{AbsSimpleNumFieldElem}\n\nGiven a (formal) abelian extension, compute the class field by finding defining polynomials for all prime power cyclic subfields.\n\nNote, the return type is always a non-simple extension.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/number_fields/class_fields/","page":"Class Field Theory","title":"Class Field Theory","text":"using Hecke; # hide\nQx, x = polynomial_ring(QQ, \"x\");\nk, a = number_field(x^2 - 10, \"a\");\nc, mc = class_group(k);\nA = ray_class_field(mc)\nK = number_field(A)\nZK = maximal_order(K)\nisone(discriminant(ZK))","category":"page"},{"location":"Hecke/manual/number_fields/class_fields/","page":"Class Field Theory","title":"Class Field Theory","text":"ray_class_field(K::RelSimpleNumField{AbsSimpleNumFieldElem})\ngenus_field(A::ClassField, k::AbsSimpleNumField)\nmaximal_abelian_subfield(A::ClassField, k::AbsSimpleNumField)\nmaximal_abelian_subfield(K::RelSimpleNumField{AbsSimpleNumFieldElem})","category":"page"},{"location":"Hecke/manual/number_fields/class_fields/#ray_class_field-Tuple{Hecke.RelSimpleNumField{AbsSimpleNumFieldElem}}","page":"Class Field Theory","title":"ray_class_field","text":"ray_class_field(K::RelSimpleNumField{AbsSimpleNumFieldElem}) -> ClassField\nray_class_field(K::AbsSimpleNumField) -> ClassField\n\nFor a (relative) abelian extension, compute an abstract representation as a class field.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/number_fields/class_fields/#genus_field-Tuple{ClassField, AbsSimpleNumField}","page":"Class Field Theory","title":"genus_field","text":"genus_field(A::ClassField, k::AbsSimpleNumField) -> ClassField\n\nThe maximal extension contained in A that is the compositum of K with an abelian extension of k.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/number_fields/class_fields/#maximal_abelian_subfield-Tuple{ClassField, AbsSimpleNumField}","page":"Class Field Theory","title":"maximal_abelian_subfield","text":"maximal_abelian_subfield(A::ClassField, k::AbsSimpleNumField) -> ClassField\n\nThe maximal abelian extension of k contained in A. k must be a subfield of the base field of A.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/number_fields/class_fields/#maximal_abelian_subfield-Tuple{Hecke.RelSimpleNumField{AbsSimpleNumFieldElem}}","page":"Class Field Theory","title":"maximal_abelian_subfield","text":"maximal_abelian_subfield(K::RelSimpleNumField{AbsSimpleNumFieldElem}; of_closure::Bool = false) -> ClassField\n\nUsing a probabilistic algorithm for the norm group computation, determine the maximal abelian subfield in K over its base field. If of_closure is set to true, then the algorithm is applied to the normal closure of K (without computing it).\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/number_fields/class_fields/#Invariants","page":"Class Field Theory","title":"Invariants","text":"","category":"section"},{"location":"Hecke/manual/number_fields/class_fields/","page":"Class Field Theory","title":"Class Field Theory","text":"degree(C::ClassField)\nbase_ring(A::Hecke.ClassField)\nbase_field(A::Hecke.ClassField)\ndiscriminant(C::Hecke.ClassField)\nconductor(C::Hecke.ClassField)\ndefining_modulus(C::ClassField)\nis_cyclic(C::ClassField)\nis_conductor(C::Hecke.ClassField, m::AbsNumFieldOrderIdeal{AbsSimpleNumField, AbsSimpleNumFieldElem}, inf_plc::Vector{InfPlc})\nis_normal(C::ClassField)\nis_central(C::ClassField)","category":"page"},{"location":"Hecke/manual/number_fields/class_fields/#degree-Tuple{ClassField}","page":"Class Field Theory","title":"degree","text":"degree(A::ClassField)\n\nThe degree of A over its base field, i.e. the size of the defining ideal group.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/number_fields/class_fields/#base_ring-Tuple{ClassField}","page":"Class Field Theory","title":"base_ring","text":"base_ring(A::ClassField)\n\nThe maximal order of the field that A is defined over.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/number_fields/class_fields/#base_field-Tuple{ClassField}","page":"Class Field Theory","title":"base_field","text":"base_field(A::ClassField)\n\nThe number field that A is defined over.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/number_fields/class_fields/#discriminant-Tuple{ClassField}","page":"Class Field Theory","title":"discriminant","text":"discriminant(C::ClassField) -> AbsNumFieldOrderIdeal{AbsSimpleNumField, AbsSimpleNumFieldElem}\n\nUsing the conductor-discriminant formula, compute the (relative) discriminant of C. This does not use the defining equations.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/number_fields/class_fields/#conductor-Tuple{ClassField}","page":"Class Field Theory","title":"conductor","text":"conductor(C::ClassField) -> AbsNumFieldOrderIdeal{AbsSimpleNumField, AbsSimpleNumFieldElem}, Vector{InfPlc}\n\nReturn the conductor of the abelian extension corresponding to C.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/number_fields/class_fields/#defining_modulus-Tuple{ClassField}","page":"Class Field Theory","title":"defining_modulus","text":"defining_modulus(CF::ClassField)\n\nThe modulus, i.e. an ideal of the set of real places, used to create the class field.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/number_fields/class_fields/#is_cyclic-Tuple{ClassField}","page":"Class Field Theory","title":"is_cyclic","text":"is_cyclic(C::ClassField)\n\nTests if the (relative) automorphism group of C is cyclic (by checking the defining ideal group).\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/number_fields/class_fields/#is_conductor-Tuple{ClassField, AbsSimpleNumFieldOrderIdeal, Vector{InfPlc}}","page":"Class Field Theory","title":"is_conductor","text":"is_conductor(C::Hecke.ClassField, m::AbsNumFieldOrderIdeal{AbsSimpleNumField, AbsSimpleNumFieldElem}, inf_plc::Vector{InfPlc}=InfPlc[]; check) -> AbsNumFieldOrderIdeal{AbsSimpleNumField, AbsSimpleNumFieldElem}, Vector{InfPlc}\n\nChecks if (m, inf_plc) is the conductor of the abelian extension corresponding to C. If check is false, it assumes that the given modulus is a multiple of the conductor. This is usually faster than computing the conductor.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/number_fields/class_fields/#is_normal-Tuple{ClassField}","page":"Class Field Theory","title":"is_normal","text":"is_normal(C::ClassField) -> Bool\n\nFor a class field C defined over a normal base field k, decide if C is normal over Q.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/number_fields/class_fields/#is_central-Tuple{ClassField}","page":"Class Field Theory","title":"is_central","text":"is_central(C::ClassField) -> Bool\n\nFor a class field C defined over a normal base field k, decide if C is central over Q.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/number_fields/class_fields/#Operations","page":"Class Field Theory","title":"Operations","text":"","category":"section"},{"location":"Hecke/manual/number_fields/class_fields/","page":"Class Field Theory","title":"Class Field Theory","text":"*(a::Hecke.ClassField, b::Hecke.ClassField)\ncompositum(a::Hecke.ClassField, b::Hecke.ClassField)\n==(a::Hecke.ClassField, b::Hecke.ClassField)\nintersect(a::Hecke.ClassField, b::Hecke.ClassField)\nprime_decomposition_type(C::Hecke.ClassField, p::Hecke.AbsNumFieldOrderIdeal)\nHecke.is_subfield(a::ClassField, b::ClassField)\nHecke.is_local_norm(r::Hecke.ClassField, a::Hecke.AbsNumFieldOrderElem)\nHecke.is_local_norm(r::Hecke.ClassField, a::Hecke.AbsNumFieldOrderElem, p::Hecke.AbsNumFieldOrderIdeal)\nHecke.normal_closure(r::Hecke.ClassField)\nsubfields(r::ClassField)","category":"page"},{"location":"Hecke/manual/number_fields/class_fields/#*-Tuple{ClassField, ClassField}","page":"Class Field Theory","title":"*","text":"*(A::ClassField, B::ClassField) -> ClassField\n\nThe compositum of a and b as a (formal) class field.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/number_fields/class_fields/#compositum-Tuple{ClassField, ClassField}","page":"Class Field Theory","title":"compositum","text":"compositum(a::ClassField, b::ClassField) -> ClassField\n\nThe compositum of a and b as a (formal) class field.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/number_fields/class_fields/#==-Tuple{ClassField, ClassField}","page":"Class Field Theory","title":"==","text":"==(a::ClassField, b::ClassField)\n\nTests if a and b are equal.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/number_fields/class_fields/#intersect-Tuple{ClassField, ClassField}","page":"Class Field Theory","title":"intersect","text":"intersect(a::ClassField, b::ClassField) -> ClassField\n\nThe intersection of a and b as a class field.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/number_fields/class_fields/#prime_decomposition_type-Tuple{ClassField, AbsNumFieldOrderIdeal}","page":"Class Field Theory","title":"prime_decomposition_type","text":"prime_decomposition_type(C::ClassField, p::AbsNumFieldOrderIdeal) -> (Int, Int, Int)\n\nFor a prime p in the base ring of r, determine the splitting type of p in r. ie. the tuple (e f g) giving the ramification degree, the inertia and the number of primes above p.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/number_fields/class_fields/#is_subfield-Tuple{ClassField, ClassField}","page":"Class Field Theory","title":"is_subfield","text":"is_subfield(a::ClassField, b::ClassField) -> Bool\n\nDetermines if a is a subfield of b.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/number_fields/class_fields/#is_local_norm-Tuple{ClassField, AbsNumFieldOrderElem}","page":"Class Field Theory","title":"is_local_norm","text":"is_local_norm(r::ClassField, a::AbsNumFieldOrderElem) -> Bool\n\nTests if a is a local norm at all finite places in the extension implicitly given by r.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/number_fields/class_fields/#is_local_norm-Tuple{ClassField, AbsNumFieldOrderElem, AbsNumFieldOrderIdeal}","page":"Class Field Theory","title":"is_local_norm","text":"is_local_norm(r::ClassField, a::AbsNumFieldOrderElem, p::AbsNumFieldOrderIdeal) -> Bool\n\nTests if a is a local norm at p in the extension implicitly given by r. Currently the conductor cannot have infinite places.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/number_fields/class_fields/#normal_closure-Tuple{ClassField}","page":"Class Field Theory","title":"normal_closure","text":"normal_closure(C::ClassField) -> ClassField\n\nFor a ray class field C extending a normal base field k, compute the normal closure over Q.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/number_fields/class_fields/#subfields-Tuple{ClassField}","page":"Class Field Theory","title":"subfields","text":"subfields(C::ClassField; degree::Int, is_normal, type) -> Vector{ClassField}\n\nFind all subfields of C over the base field.\n\nIf the optional keyword argument degree is positive, then only those with prescribed degree will be returned.\n\nIf the optional keyword is_normal is given, then only those that are normal over the field fixed by the automorphisms is returned. For normal base fields, this amounts to extensions that are normal over Q.\n\nIf the optional keyword is_normal is set to a list of automorphisms, then only those wil be considered.\n\ntype can be set to the desired relative Galois group, given as a vector of integers descibing the structure.\n\nnote: Note\nThis will not find all subfields over mathbfQ, but only the ones sharing the same base field.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/orders/introduction/#Introduction","page":"Introduction","title":"Introduction","text":"","category":"section"},{"location":"Hecke/manual/orders/introduction/","page":"Introduction","title":"Introduction","text":"CurrentModule = Hecke","category":"page"},{"location":"Hecke/manual/orders/introduction/","page":"Introduction","title":"Introduction","text":"This chapter deals with number fields and orders there of. We follow the common terminology and conventions as e.g. used in [Coh93], [Coh00], [PZ97] or [Mar18].","category":"page"},{"location":"Hecke/manual/orders/introduction/","page":"Introduction","title":"Introduction","text":"If K is a number field, then an order mathcal O of K is a subring of the ring of integers mathcal O_K of K, which is free of rank K  mathbf Q as a mathbf Z-module. Depending on whether K is an absolute field or relative field, orders are treated differently. As far as possible, the interaction and the interface for orders of absolute number fields and of relative number fields is the same.","category":"page"},{"location":"Hecke/manual/orders/introduction/#Orders-of-absolute-number-fields","page":"Introduction","title":"Orders of absolute number fields","text":"","category":"section"},{"location":"Hecke/manual/orders/introduction/","page":"Introduction","title":"Introduction","text":"Assume that K is defined as an absolute field. An order mathcal O of such a field are constructed (implicitly) by specifying a mathbf Z-basis, which is referred to as the basis of mathcal O. If (omega_1dotscomega_d) is the basis of mathcal O and (alpha_1dotscalpha_d) the basis of K, then the matrix B in operatornameMat_d times d(mathbf Q) with","category":"page"},{"location":"Hecke/manual/orders/introduction/","page":"Introduction","title":"Introduction","text":"beginpmatrix omega_1  vdots  omega_d endpmatrix = B beginpmatrix alpha_1  vdots  alpha_d endpmatrix","category":"page"},{"location":"Hecke/manual/orders/introduction/","page":"Introduction","title":"Introduction","text":"is the basis matrix of K. If K = mathbfQ(alpha) = mathbfQx(f) is simple with f in mathbfZx, then natural order mathbf Zalpha = mathbfZx(f) is called the equation order of K.","category":"page"},{"location":"Hecke/manual/orders/introduction/#Orders-of-relative-number-fields","page":"Introduction","title":"Orders of relative number fields","text":"","category":"section"},{"location":"Hecke/manual/orders/introduction/","page":"Introduction","title":"Introduction","text":"Orders in non-absolute number fields, that is, relative extensions, are represented differently. Let LK be a finite extension of number fields, then currently we require any order in L to contain mathcal O_K, the ring of integers of K. In this case, an order mathcal O in L is a finitly generated torsion-free module over the Dedekind domain mathcal O_K. As a ring, the order mathcal O is unitary and has L as a fraction field. Due to mathcal O_K in general not being a principal ideal domain, the module structure is more complicated and requires so called pseudo-matrices. See here for details on pseudo-matrices, or [Coh00], Chapter 1 for an introduction.","category":"page"},{"location":"Hecke/manual/orders/introduction/","page":"Introduction","title":"Introduction","text":"In short, mathcal O is represented as sum mathfrak a_i omega_i with fractional mathcal O_K ideals mathfrak a_isubset K and K-linear independent elements omega_iin L. In general it is impossible to have both mathfrak a_i integral and omega_i in mathcal O, thus coefficients will not be integral and/or generators not in the structure.","category":"page"},{"location":"Hecke/manual/orders/introduction/#Examples","page":"Introduction","title":"Examples","text":"","category":"section"},{"location":"Hecke/manual/orders/introduction/","page":"Introduction","title":"Introduction","text":"Usually, to create an order, one starts with a field (or a polynomial):","category":"page"},{"location":"Hecke/manual/orders/introduction/","page":"Introduction","title":"Introduction","text":"using Hecke; # hide\nQx, x = polynomial_ring(QQ, \"x\");\nK, a = number_field(x^2 - 10, \"a\");\nE = equation_order(K)\nZ_K = maximal_order(K)\nconductor(E)\nE == Z_K","category":"page"},{"location":"Hecke/manual/orders/introduction/","page":"Introduction","title":"Introduction","text":"Once orders are created, we can play with elements and ideals:","category":"page"},{"location":"Hecke/manual/orders/introduction/","page":"Introduction","title":"Introduction","text":"lp = prime_decomposition(Z_K, 2)\np = lp[1][1]\nis_principal(p)\nfl, alpha = is_principal_with_data(p^2)\nnorm(alpha)","category":"page"},{"location":"Hecke/manual/orders/introduction/","page":"Introduction","title":"Introduction","text":"It is possible to work with residue fields as well:","category":"page"},{"location":"Hecke/manual/orders/introduction/","page":"Introduction","title":"Introduction","text":"Fp, mFp = residue_field(Z_K, p)\n[ mFp(x) for x = basis(Z_K)]","category":"page"},{"location":"AbstractAlgebra/series/","page":"Power series","title":"Power series","text":"CurrentModule = AbstractAlgebra\nDocTestSetup = AbstractAlgebra.doctestsetup()","category":"page"},{"location":"AbstractAlgebra/series/#Power-series","page":"Power series","title":"Power series","text":"","category":"section"},{"location":"AbstractAlgebra/series/","page":"Power series","title":"Power series","text":"AbstractAlgebra.jl allows the creation of capped relative and absolute power series over any computable commutative ring R.","category":"page"},{"location":"AbstractAlgebra/series/","page":"Power series","title":"Power series","text":"Capped relative power series are power series of the form a_jx^j + a_j+1x^j+1 + cdots + a_k-1x^k-1 + O(x^k) where a_j in R and the relative precision k - j is at most equal to some specified precision n.","category":"page"},{"location":"AbstractAlgebra/series/","page":"Power series","title":"Power series","text":"Capped absolute power series are power series of the form a_jx^j + a_j+1x^j+1 + cdots + a_n-1x^n-1 + O(x^n) where j geq 0, a_j in R and the precision n is fixed.","category":"page"},{"location":"AbstractAlgebra/series/","page":"Power series","title":"Power series","text":"There are two implementations of relative series: relative power series, implemented in src/RelSeries.jl for which j  0 in the above description, and Laurent series where j can be negative, implemented in src/Laurent.jl. Note that there are two implementations for Laurent series, one over rings and one over fields, though in practice most of the implementation uses the same code in both cases.","category":"page"},{"location":"AbstractAlgebra/series/","page":"Power series","title":"Power series","text":"There is a single implementation of absolute series: absolute power series, implemented in src/AbsSeries.jl.","category":"page"},{"location":"AbstractAlgebra/series/#Generic-power-series-types","page":"Power series","title":"Generic power series types","text":"","category":"section"},{"location":"AbstractAlgebra/series/","page":"Power series","title":"Power series","text":"AbstractAlgebra.jl provides generic series types implemented in src/generic/AbsSeries.jl, src/generic/RelSeries.jl and src/generic/LaurentSeries.jl which implement the Series interface.","category":"page"},{"location":"AbstractAlgebra/series/","page":"Power series","title":"Power series","text":"These generic series have types Generic.RelSeries{T}, Generic.AbsSeries{T}, Generic.LaurentSeriesRingElem{T} and Generic.LaurentSeriesFieldElem{T}. See the file src/generic/GenericTypes.jl for details.","category":"page"},{"location":"AbstractAlgebra/series/","page":"Power series","title":"Power series","text":"The parent objects have types Generic.AbsPowerSeriesRing{T} and Generic.RelPowerSeriesRing{T} and Generic.LaurentSeriesRing{T} respectively.","category":"page"},{"location":"AbstractAlgebra/series/","page":"Power series","title":"Power series","text":"The default precision, string representation of the variable and base ring R of a generic power series are stored in its parent object.","category":"page"},{"location":"AbstractAlgebra/series/#Abstract-types","page":"Power series","title":"Abstract types","text":"","category":"section"},{"location":"AbstractAlgebra/series/","page":"Power series","title":"Power series","text":"Relative power series elements belong to the abstract type RelPowerSeriesRingElem.","category":"page"},{"location":"AbstractAlgebra/series/","page":"Power series","title":"Power series","text":"Laurent series elements belong directly to either RingElem or FieldElem since it is more useful to be able to distinguish whether they belong to a ring or field than it is to distinguish that they are relative series.","category":"page"},{"location":"AbstractAlgebra/series/","page":"Power series","title":"Power series","text":"Absolute power series elements belong to AbsPowerSeriesRingElem.","category":"page"},{"location":"AbstractAlgebra/series/","page":"Power series","title":"Power series","text":"The parent types for relative and absolute power series, Generic.RelPowerSeriesRing{T} and Generic.AbsPowerSeriesRing{T} respectively, belong to SeriesRing{T}.","category":"page"},{"location":"AbstractAlgebra/series/","page":"Power series","title":"Power series","text":"The parent types of Laurent series belong directly to Ring and Field respectively.","category":"page"},{"location":"AbstractAlgebra/series/#Series-ring-constructors","page":"Power series","title":"Series ring constructors","text":"","category":"section"},{"location":"AbstractAlgebra/series/","page":"Power series","title":"Power series","text":"In order to construct series in AbstractAlgebra.jl, one must first construct the ring itself. This is accomplished with any of the following constructors.","category":"page"},{"location":"AbstractAlgebra/series/","page":"Power series","title":"Power series","text":"power_series_ring(R::Ring, prec_max::Int, s::VarName; cached::Bool = true, model::Symbol=:capped_relative)","category":"page"},{"location":"AbstractAlgebra/series/","page":"Power series","title":"Power series","text":"laurent_series_ring(R::Ring, prec_max::Int, s::VarName; cached::Bool = true)","category":"page"},{"location":"AbstractAlgebra/series/","page":"Power series","title":"Power series","text":"laurent_series_ring(R::Field, prec_max::Int, s::VarName; cached::Bool = true)","category":"page"},{"location":"AbstractAlgebra/series/","page":"Power series","title":"Power series","text":"Given a base ring R, a maximum precision (relative or absolute, depending on the model) and a string s specifying how the generator (variable) should be printed, return a tuple S, x representing the series ring and its generator.","category":"page"},{"location":"AbstractAlgebra/series/","page":"Power series","title":"Power series","text":"By default, S will depend only on S, x and the maximum precision and will be cached. Setting the optional argument cached to false will prevent this.","category":"page"},{"location":"AbstractAlgebra/series/","page":"Power series","title":"Power series","text":"In the case of power series, the optional argument model can be set to either :capped_absolute or :capped_relative, depending on which power series model is required.","category":"page"},{"location":"AbstractAlgebra/series/","page":"Power series","title":"Power series","text":"It is also possible to construct absolute and relative power series with a default variable. These are lightweight constructors and should be used in generic algorithms wherever possible when creating series rings where the symbol does not matter.","category":"page"},{"location":"AbstractAlgebra/series/","page":"Power series","title":"Power series","text":"AbsPowerSeriesRing(R::Ring, prec::Int)\nRelPowerSeriesRing(R::Ring, prec::Int)","category":"page"},{"location":"AbstractAlgebra/series/","page":"Power series","title":"Power series","text":"Return the absolute or relative power series ring over the given base ring R and with precision cap given by prec. Note that a tuple is not returned, only the power series ring itself, not a generator.","category":"page"},{"location":"AbstractAlgebra/series/","page":"Power series","title":"Power series","text":"Here are some examples of constructing various kinds of series rings and coercing various elements into those rings.","category":"page"},{"location":"AbstractAlgebra/series/","page":"Power series","title":"Power series","text":"Examples","category":"page"},{"location":"AbstractAlgebra/series/","page":"Power series","title":"Power series","text":"julia> R, x = power_series_ring(ZZ, 10, :x)\n(Univariate power series ring over integers, x + O(x^11))\n\njulia> S, y = power_series_ring(ZZ, 10, :y; model=:capped_absolute)\n(Univariate power series ring over integers, y + O(y^10))\n\njulia> T, z = laurent_series_ring(ZZ, 10, :z)\n(Laurent series ring in z over integers, z + O(z^11))\n\njulia> U, w = laurent_series_field(QQ, 10, :w)\n(Laurent series field in w over rationals, w + O(w^11))\n\njulia> f = R()\nO(x^10)\n\njulia> g = S(123)\n123 + O(y^10)\n\njulia> h = U(BigInt(1234))\n1234 + O(w^10)\n\njulia> k = T(z + 1)\n1 + z + O(z^10)\n\njulia> V = AbsPowerSeriesRing(ZZ, 10)\nUnivariate power series ring in x with precision 10\n  over integers","category":"page"},{"location":"AbstractAlgebra/series/#Power-series-constructors","page":"Power series","title":"Power series constructors","text":"","category":"section"},{"location":"AbstractAlgebra/series/","page":"Power series","title":"Power series","text":"Series can be constructed using arithmetic operators using the generator of the series. Also see the big-oh notation below for specifying the precision.","category":"page"},{"location":"AbstractAlgebra/series/","page":"Power series","title":"Power series","text":"All of the standard ring constructors can also be used to construct power series.","category":"page"},{"location":"AbstractAlgebra/series/","page":"Power series","title":"Power series","text":"(R::SeriesRing)() # constructs zero\n(R::SeriesRing)(c::Integer)\n(R::SeriesRing)(c::elem_type(R))\n(R::SeriesRing{T})(a::T) where T <: RingElement","category":"page"},{"location":"AbstractAlgebra/series/","page":"Power series","title":"Power series","text":"In addition, the following constructors that are specific to power series are provided. They take an array of coefficients, a length, precision and valuation. Coefficients will be coerced into the coefficient ring if they are not already in that ring.","category":"page"},{"location":"AbstractAlgebra/series/","page":"Power series","title":"Power series","text":"For relative series we have:","category":"page"},{"location":"AbstractAlgebra/series/","page":"Power series","title":"Power series","text":"(S::SeriesRing{T})(A::Vector{T}, len::Int, prec::Int, val::Int) where T <: RingElem\n(S::SeriesRing{T})(A::Vector{U}, len::Int, prec::Int, val::Int) where {T <: RingElem, U <: RingElem}\n(S::SeriesRing{T})(A::Vector{U}, len::Int, prec::Int, val::Int) where {T <: RingElem, U <: Integer}","category":"page"},{"location":"AbstractAlgebra/series/","page":"Power series","title":"Power series","text":"And for absolute series:","category":"page"},{"location":"AbstractAlgebra/series/","page":"Power series","title":"Power series","text":"(S::SeriesRing{T})(A::Vector{T}, len::Int, prec::Int) where T <: RingElem","category":"page"},{"location":"AbstractAlgebra/series/","page":"Power series","title":"Power series","text":"It is also possible to create series directly without having to create the corresponding series ring.","category":"page"},{"location":"AbstractAlgebra/series/","page":"Power series","title":"Power series","text":"abs_series(R::Ring, arr::Vector{T}, len::Int, prec::Int, var::VarName=:x; max_precision::Int=prec, cached::Bool=true) where T\nrel_series(R::Ring, arr::Vector{T}, len::Int, prec::Int, val::Int, var::VarName=:x; max_precision::Int=prec, cached::Bool=true) where T\nlaurent_series(R::Ring, arr::Vector{T}, len::Int, prec::Int, val::Int, scale::Int, var::VarName=:x; max_precision::Int=prec, cached::Bool=true) where T","category":"page"},{"location":"AbstractAlgebra/series/","page":"Power series","title":"Power series","text":"Examples","category":"page"},{"location":"AbstractAlgebra/series/","page":"Power series","title":"Power series","text":"julia> S, x = power_series_ring(QQ, 10, :x; model=:capped_absolute)\n(Univariate power series ring over rationals, x + O(x^10))\n\njulia> f = S(Rational{BigInt}[0, 2, 3, 1], 4, 6)\n2*x + 3*x^2 + x^3 + O(x^6)\n\njulia> f = abs_series(ZZ, [1, 2, 3], 3, 5, :y)\n1 + 2*y + 3*y^2 + O(y^5)\n\njulia> g = rel_series(ZZ, [1, 2, 3], 3, 7, 4)\nx^4 + 2*x^5 + 3*x^6 + O(x^7)\n\njulia> k = abs_series(ZZ, [1, 2, 3], 1, 6, cached=false)\n1 + O(x^6)\n\njulia> p = rel_series(ZZ, BigInt[], 0, 3, 1)\nO(x^3)\n\njulia> q = abs_series(ZZ, [], 0, 6)\nO(x^6)\n\njulia> s = abs_series(ZZ, [1, 2, 3], 3, 5; max_precision=10)\n1 + 2*x + 3*x^2 + O(x^5)\n\njulia> s = laurent_series(ZZ, [1, 2, 3], 3, 5, 0, 2; max_precision=10)\n1 + 2*x^2 + 3*x^4 + O(x^5)","category":"page"},{"location":"AbstractAlgebra/series/#Big-oh-notation","page":"Power series","title":"Big-oh notation","text":"","category":"section"},{"location":"AbstractAlgebra/series/","page":"Power series","title":"Power series","text":"Series elements can be given a precision using the big-oh notation. This is provided by a function of the following form, (or something equivalent for Laurent series):","category":"page"},{"location":"AbstractAlgebra/series/","page":"Power series","title":"Power series","text":"O(x::SeriesElem)","category":"page"},{"location":"AbstractAlgebra/series/","page":"Power series","title":"Power series","text":"Examples","category":"page"},{"location":"AbstractAlgebra/series/","page":"Power series","title":"Power series","text":"julia> R, x = power_series_ring(ZZ, 10, :x)\n(Univariate power series ring over integers, x + O(x^11))\n\njulia> S, y = laurent_series_ring(ZZ, 10, :y)\n(Laurent series ring in y over integers, y + O(y^11))\n\njulia> f = 1 + 2x + O(x^5)\n1 + 2*x + O(x^5)\n\njulia> g = 2y + 7y^2 + O(y^7)\n2*y + 7*y^2 + O(y^7)","category":"page"},{"location":"AbstractAlgebra/series/","page":"Power series","title":"Power series","text":"What is happening here in practice is that O(x^n) is creating the series 0 + O(x^n) and the rules for addition of series dictate that if this is added to a series of greater precision, then the lower of the two precisions must be used.","category":"page"},{"location":"AbstractAlgebra/series/","page":"Power series","title":"Power series","text":"Of course it may be that the precision of the series that O(x^n) is added to is already lower than n, in which case adding O(x^n) has no effect. This is the case if the default precision is too low, since x on its own has the default precision.","category":"page"},{"location":"AbstractAlgebra/series/#Power-series-models","page":"Power series","title":"Power series models","text":"","category":"section"},{"location":"AbstractAlgebra/series/","page":"Power series","title":"Power series","text":"Capped relative power series have their maximum relative precision capped at some value prec_max. This means that if the leading term of a nonzero power series element is c_ax^a and the precision is b then the power series is of the form  c_ax^a + c_a+1x^a+1 + ldots + O(x^a + b).","category":"page"},{"location":"AbstractAlgebra/series/","page":"Power series","title":"Power series","text":"The zero power series is simply taken to be 0 + O(x^b).","category":"page"},{"location":"AbstractAlgebra/series/","page":"Power series","title":"Power series","text":"The capped relative model has the advantage that power series are stable multiplicatively. In other words, for nonzero power series f and g we have that divexact(f*g), g) == f.","category":"page"},{"location":"AbstractAlgebra/series/","page":"Power series","title":"Power series","text":"However, capped relative power series are not additively stable, i.e. we do not always have (f + g) - g = f.","category":"page"},{"location":"AbstractAlgebra/series/","page":"Power series","title":"Power series","text":"Similar comments apply to Laurent series.","category":"page"},{"location":"AbstractAlgebra/series/","page":"Power series","title":"Power series","text":"On the other hand, capped absolute power series have their absolute precision capped. This means that if the leading term of a nonzero power series element is c_ax^a and the precision is b then the power series is of the form c_ax^a + c_a+1x^a+1 + ldots + O(x^b).","category":"page"},{"location":"AbstractAlgebra/series/","page":"Power series","title":"Power series","text":"Capped absolute series are additively stable, but not necessarily multiplicatively stable.","category":"page"},{"location":"AbstractAlgebra/series/","page":"Power series","title":"Power series","text":"For all models, the maximum precision is also used as a default precision in the case of coercing coefficients into the ring and for any computation where the result could mathematically be given to infinite precision.","category":"page"},{"location":"AbstractAlgebra/series/","page":"Power series","title":"Power series","text":"In all models we say that two power series are equal if they agree up to the minimum absolute precision of the two power series.","category":"page"},{"location":"AbstractAlgebra/series/","page":"Power series","title":"Power series","text":"Thus, for example, x^5 + O(x^10) == 0 + O(x^5), since the minimum absolute precision is 5.","category":"page"},{"location":"AbstractAlgebra/series/","page":"Power series","title":"Power series","text":"During computations, it is possible for power series to lose relative precision due to cancellation. For example if f = x^3 + x^5 + O(x^8) and g = x^3 + x^6 + O(x^8) then f - g = x^5 - x^6 + O(x^8) which now has relative precision 3 instead of relative precision 5.","category":"page"},{"location":"AbstractAlgebra/series/","page":"Power series","title":"Power series","text":"Amongst other things, this means that equality is not transitive. For example x^6 + O(x^11) == 0 + O(x^5) and x^7 + O(x^12) == 0 + O(x^5) but x^6 + O(x^11) neq x^7 + O(x^12).","category":"page"},{"location":"AbstractAlgebra/series/","page":"Power series","title":"Power series","text":"Sometimes it is necessary to compare power series not just for arithmetic equality, as above, but to see if they have precisely the same precision and terms. For this purpose we introduce the isequal function.","category":"page"},{"location":"AbstractAlgebra/series/","page":"Power series","title":"Power series","text":"For example, if f = x^2 + O(x^7) and g = x^2 + O(x^8) and h = 0 + O(x^2) then f == g, f == h and g == h, but isequal(f, g), isequal(f, h) and isequal(g, h) would all return false. However, if k = x^2 + O(x^7) then isequal(f, k) would return true.","category":"page"},{"location":"AbstractAlgebra/series/","page":"Power series","title":"Power series","text":"There are further difficulties if we construct polynomial over power series. For example, consider the polynomial in y over the power series ring in x over the rationals. Normalisation of such polynomials is problematic. For instance, what is the leading coefficient of (0 + O(x^10))y + (1 + O(x^10))?","category":"page"},{"location":"AbstractAlgebra/series/","page":"Power series","title":"Power series","text":"If one takes it to be (0 + O(x^10)) then some functions may not terminate due to the fact that algorithms may require the degree of polynomials to decrease with each iteration. Instead, the degree may remain constant and simply accumulate leading terms which are arithmetically zero but not identically zero.","category":"page"},{"location":"AbstractAlgebra/series/","page":"Power series","title":"Power series","text":"On the other hand, when constructing power series over other power series, if we simply throw away terms which are arithmetically equal to zero, our computations may have different output depending on the order in which the power series are added!","category":"page"},{"location":"AbstractAlgebra/series/","page":"Power series","title":"Power series","text":"One should be aware of these difficulties when working with power series. Power series, as represented on a computer, simply don't satisfy the axioms of a ring. They must be used with care in order to approximate operations in a mathematical power series ring.","category":"page"},{"location":"AbstractAlgebra/series/","page":"Power series","title":"Power series","text":"Simply increasing the precision will not necessarily give a \"more correct\" answer and some computations may not even terminate due to the presence of arithmetic zeroes!","category":"page"},{"location":"AbstractAlgebra/series/","page":"Power series","title":"Power series","text":"An absolute power series ring over a ring R with precision p behaves very much like the quotient Rx(x^p) of the polynomial ring over R. Therefore one can often treat absolute power series rings as though they were rings. However, this depends on all series being given a precision equal to the specified maximum precision and not a lower precision.","category":"page"},{"location":"AbstractAlgebra/series/#Functions-for-types-and-parents-of-series-rings","page":"Power series","title":"Functions for types and parents of series rings","text":"","category":"section"},{"location":"AbstractAlgebra/series/","page":"Power series","title":"Power series","text":"base_ring(R::SeriesRing)\nbase_ring(a::SeriesElem)","category":"page"},{"location":"AbstractAlgebra/series/","page":"Power series","title":"Power series","text":"Return the coefficient ring of the given series ring or series.","category":"page"},{"location":"AbstractAlgebra/series/","page":"Power series","title":"Power series","text":"parent(a::SeriesElem)","category":"page"},{"location":"AbstractAlgebra/series/","page":"Power series","title":"Power series","text":"Return the parent of the given series.","category":"page"},{"location":"AbstractAlgebra/series/","page":"Power series","title":"Power series","text":"characteristic(R::SeriesRing)","category":"page"},{"location":"AbstractAlgebra/series/","page":"Power series","title":"Power series","text":"Return the characteristic of the given series ring. If the characteristic is not known, an exception is raised.","category":"page"},{"location":"AbstractAlgebra/series/#Series-functions","page":"Power series","title":"Series functions","text":"","category":"section"},{"location":"AbstractAlgebra/series/","page":"Power series","title":"Power series","text":"Unless otherwise noted, the functions below are available for all series models, including Laurent series. We denote this by using the abstract type RelPowerSeriesRingElem, even though absolute series and Laurent series types do not belong to this abstract type.","category":"page"},{"location":"AbstractAlgebra/series/#Basic-functionality","page":"Power series","title":"Basic functionality","text":"","category":"section"},{"location":"AbstractAlgebra/series/","page":"Power series","title":"Power series","text":"Series implement the Ring Interface","category":"page"},{"location":"AbstractAlgebra/series/","page":"Power series","title":"Power series","text":"zero(R::SeriesRing)\none(R::SeriesRing)\niszero(a::SeriesElem)\nisone(a::SeriesElem)","category":"page"},{"location":"AbstractAlgebra/series/","page":"Power series","title":"Power series","text":"divexact(a::T, b::T) where T <: SeriesElem\ninv(a::SeriesElem) ","category":"page"},{"location":"AbstractAlgebra/series/","page":"Power series","title":"Power series","text":"Series also implement the Series Interface, the most important basic functions being the following.","category":"page"},{"location":"AbstractAlgebra/series/","page":"Power series","title":"Power series","text":"var(S::SeriesRing)","category":"page"},{"location":"AbstractAlgebra/series/","page":"Power series","title":"Power series","text":"Return a symbol for the variable of the given series ring.","category":"page"},{"location":"AbstractAlgebra/series/","page":"Power series","title":"Power series","text":"max_precision(S::SeriesRing)","category":"page"},{"location":"AbstractAlgebra/series/","page":"Power series","title":"Power series","text":"Return the precision cap of the given series ring.","category":"page"},{"location":"AbstractAlgebra/series/","page":"Power series","title":"Power series","text":"precision(f::SeriesElem)\nvaluation(f::SeriesElem)","category":"page"},{"location":"AbstractAlgebra/series/","page":"Power series","title":"Power series","text":"gen(R::SeriesRing)","category":"page"},{"location":"AbstractAlgebra/series/","page":"Power series","title":"Power series","text":"The following functions are also provided for all series.","category":"page"},{"location":"AbstractAlgebra/series/","page":"Power series","title":"Power series","text":"coeff(a::SeriesElem, n::Int)","category":"page"},{"location":"AbstractAlgebra/series/","page":"Power series","title":"Power series","text":"Return the degree n coefficient of the given power series. Note coefficients are numbered from n = 0 for the constant coefficient. If n exceeds the current precision of the power series, the function returns a zero coefficient.","category":"page"},{"location":"AbstractAlgebra/series/","page":"Power series","title":"Power series","text":"For power series types, n must be non-negative. Laurent series do not have this restriction.","category":"page"},{"location":"AbstractAlgebra/series/","page":"Power series","title":"Power series","text":"modulus{T <: ResElem}(::SeriesElem{T})","category":"page"},{"location":"AbstractAlgebra/series/#modulus-Union{Tuple{SeriesElem{T}}, Tuple{T}} where T<:ResElem","page":"Power series","title":"modulus","text":"modulus(a::SeriesElem{T}) where {T <: ResElem}\n\nReturn the modulus of the coefficients of the given power series.\n\n\n\n\n\n","category":"method"},{"location":"AbstractAlgebra/series/","page":"Power series","title":"Power series","text":"is_gen(::RelPowerSeriesRingElem)","category":"page"},{"location":"AbstractAlgebra/series/#is_gen-Tuple{RelPowerSeriesRingElem}","page":"Power series","title":"is_gen","text":"is_gen(a::RelPowerSeriesRingElem)\n\nReturn true if the given power series is arithmetically equal to the generator of its power series ring to its current precision, otherwise return false.\n\n\n\n\n\n","category":"method"},{"location":"AbstractAlgebra/series/","page":"Power series","title":"Power series","text":"Examples","category":"page"},{"location":"AbstractAlgebra/series/","page":"Power series","title":"Power series","text":"julia> S, x = power_series_ring(ZZ, 10, :x)\n(Univariate power series ring over integers, x + O(x^11))\n\njulia> f = 1 + 3x + x^3 + O(x^10)\n1 + 3*x + x^3 + O(x^10)\n\njulia> g = 1 + 2x + x^2 + O(x^10)\n1 + 2*x + x^2 + O(x^10)\n\njulia> h = zero(S)\nO(x^10)\n\njulia> k = one(S)\n1 + O(x^10)\n\njulia> isone(k)\ntrue\n\njulia> iszero(f)\nfalse\n\njulia> n = pol_length(f)\n4\n\njulia> c = polcoeff(f, 3)\n1\n\njulia> U = base_ring(S)\nIntegers\n\njulia> v = var(S)\n:x\n\njulia> max_precision(S) == 10\ntrue\n\njulia> T = parent(x + 1)\nUnivariate power series ring in x with precision 10\n  over integers\n\njulia> g == deepcopy(g)\ntrue\n\njulia> t = divexact(2g, 2)\n1 + 2*x + x^2 + O(x^10)\n\njulia> p = precision(f)\n10\n\njulia> R, t = power_series_ring(QQ, 10, :t)\n(Univariate power series ring over rationals, t + O(t^11))\n\njulia> S, x = power_series_ring(R, 30, :x)\n(Univariate power series ring over R, x + O(x^31))\n\njulia> a = O(x^4)\nO(x^4)\n\njulia> b = (t + 3)*x + (t^2 + 1)*x^2 + O(x^4)\n(3 + t + O(t^10))*x + (1 + t^2 + O(t^10))*x^2 + O(x^4)\n\njulia> k = is_gen(gen(R))\ntrue\n\njulia> m = is_unit(-1 + x + 2x^2)\ntrue\n\njulia> n = valuation(a)\n4\n\njulia> p = valuation(b)\n1\n\njulia> c = coeff(b, 2)\n1 + t^2 + O(t^10)\n\njulia> S, x = power_series_ring(ZZ, 10, :x)\n(Univariate power series ring over integers, x + O(x^11))\n\njulia> f = 1 + 3x + x^3 + O(x^5)\n1 + 3*x + x^3 + O(x^5)\n\njulia> g = S(BigInt[1, 2, 0, 1, 0, 0, 0], 4, 10, 3);\n\njulia> set_length!(g, 3)\nx^3 + 2*x^4 + O(x^10)\n\njulia> g = setcoeff!(g, 2, BigInt(11))\nx^3 + 2*x^4 + 11*x^5 + O(x^10)\n\njulia> fit!(g, 8)\n\njulia> g = setcoeff!(g, 7, BigInt(4))\nx^3 + 2*x^4 + 11*x^5 + O(x^10)","category":"page"},{"location":"AbstractAlgebra/series/#Change-base-ring","page":"Power series","title":"Change base ring","text":"","category":"section"},{"location":"AbstractAlgebra/series/","page":"Power series","title":"Power series","text":"map_coefficients(::Any, ::AbsPowerSeriesRingElem{<:RingElem})\nchange_base_ring(::Ring, ::AbsPowerSeriesRingElem{<:RingElem})","category":"page"},{"location":"AbstractAlgebra/series/#map_coefficients-Tuple{Any, AbsPowerSeriesRingElem{<:RingElem}}","page":"Power series","title":"map_coefficients","text":"map_coefficients(f, p::SeriesElem{<: RingElement}; cached::Bool=true, parent::PolyRing)\n\nTransform the series p by applying f on each non-zero coefficient.\n\nIf the optional parent keyword is provided, the polynomial will be an element of parent. The caching of the parent object can be controlled via the cached keyword argument.\n\n\n\n\n\n","category":"method"},{"location":"AbstractAlgebra/series/#change_base_ring-Tuple{Ring, AbsPowerSeriesRingElem{<:RingElem}}","page":"Power series","title":"change_base_ring","text":"change_base_ring(R::Ring, p::SeriesElem{<: RingElement}; parent::PolyRing)\n\nReturn the series obtained by coercing the non-zero coefficients of p into R.\n\nIf the optional parent keyword is provided, the series will be an element of parent. The caching of the parent object can be controlled via the cached keyword argument.\n\n\n\n\n\n","category":"method"},{"location":"AbstractAlgebra/series/","page":"Power series","title":"Power series","text":"Examples","category":"page"},{"location":"AbstractAlgebra/series/","page":"Power series","title":"Power series","text":"julia> R, x = power_series_ring(ZZ, 10, :x)\n(Univariate power series ring over integers, x + O(x^11))\n\njulia> f = 4*x^6 + x^7 + 9*x^8 + 16*x^9 + 25*x^10 + O(x^11)\n4*x^6 + x^7 + 9*x^8 + 16*x^9 + 25*x^10 + O(x^11)\n\njulia> map_coefficients(AbstractAlgebra.sqrt, f)\n2*x^6 + x^7 + 3*x^8 + 4*x^9 + 5*x^10 + O(x^11)\n\njulia> change_base_ring(QQ, f)\n4*x^6 + x^7 + 9*x^8 + 16*x^9 + 25*x^10 + O(x^11)","category":"page"},{"location":"AbstractAlgebra/series/#Shifting","page":"Power series","title":"Shifting","text":"","category":"section"},{"location":"AbstractAlgebra/series/","page":"Power series","title":"Power series","text":"shift_left{T <: RingElem}(::RelPowerSeriesRingElem{T}, ::Int)","category":"page"},{"location":"AbstractAlgebra/series/#shift_left-Union{Tuple{T}, Tuple{RelPowerSeriesRingElem{T}, Int64}} where T<:RingElem","page":"Power series","title":"shift_left","text":"shift_left(x::RelPowerSeriesRingElem{T}, n::Int) where T <: RingElement\n\nReturn the power series x shifted left by n terms, i.e. multiplied by x^n.\n\n\n\n\n\n","category":"method"},{"location":"AbstractAlgebra/series/","page":"Power series","title":"Power series","text":"shift_right{T <: RingElem}(::RelPowerSeriesRingElem{T}, ::Int)","category":"page"},{"location":"AbstractAlgebra/series/#shift_right-Union{Tuple{T}, Tuple{RelPowerSeriesRingElem{T}, Int64}} where T<:RingElem","page":"Power series","title":"shift_right","text":"shift_right(x::RelPowerSeriesRingElem{T}, n::Int) where T <: RingElement\n\nReturn the power series x shifted right by n terms, i.e. divided by x^n.\n\n\n\n\n\n","category":"method"},{"location":"AbstractAlgebra/series/","page":"Power series","title":"Power series","text":"Examples","category":"page"},{"location":"AbstractAlgebra/series/","page":"Power series","title":"Power series","text":"julia> R, t = polynomial_ring(QQ, :t)\n(Univariate polynomial ring in t over rationals, t)\n\njulia> S, x = power_series_ring(R, 30, :x)\n(Univariate power series ring over R, x + O(x^31))\n\njulia> a = 2x + x^3\n2*x + x^3 + O(x^31)\n\njulia> b = O(x^4)\nO(x^4)\n\njulia> c = 1 + x + 2x^2 + O(x^5)\n1 + x + 2*x^2 + O(x^5)\n\njulia> d = 2x + x^3 + O(x^4)\n2*x + x^3 + O(x^4)\n\njulia> f = shift_left(a, 2)\n2*x^3 + x^5 + O(x^33)\n\njulia> g = shift_left(b, 2)\nO(x^6)\n\njulia> h = shift_right(c, 1)\n1 + 2*x + O(x^4)\n\njulia> k = shift_right(d, 3)\n1 + O(x^1)\n","category":"page"},{"location":"AbstractAlgebra/series/#Truncation","page":"Power series","title":"Truncation","text":"","category":"section"},{"location":"AbstractAlgebra/series/","page":"Power series","title":"Power series","text":"truncate{T <: RingElem}(::RelPowerSeriesRingElem{T}, ::Int)","category":"page"},{"location":"AbstractAlgebra/series/#truncate-Union{Tuple{T}, Tuple{RelPowerSeriesRingElem{T}, Int64}} where T<:RingElem","page":"Power series","title":"truncate","text":"truncate(a::RelPowerSeriesRingElem{T}, n::Int) where T <: RingElement\n\nReturn a truncated to (absolute) precision n.\n\n\n\n\n\n","category":"method"},{"location":"AbstractAlgebra/series/","page":"Power series","title":"Power series","text":"Examples","category":"page"},{"location":"AbstractAlgebra/series/","page":"Power series","title":"Power series","text":"julia> R, t = polynomial_ring(QQ, :t)\n(Univariate polynomial ring in t over rationals, t)\n\njulia> S, x = power_series_ring(R, 30, :x)\n(Univariate power series ring over R, x + O(x^31))\n\njulia> a = 2x + x^3\n2*x + x^3 + O(x^31)\n\njulia> b = O(x^4)\nO(x^4)\n\njulia> c = 1 + x + 2x^2 + O(x^5)\n1 + x + 2*x^2 + O(x^5)\n\njulia> d = 2x + x^3 + O(x^4)\n2*x + x^3 + O(x^4)\n\njulia> f = truncate(a, 3)\n2*x + O(x^3)\n\njulia> g = truncate(b, 2)\nO(x^2)\n\njulia> h = truncate(c, 7)\n1 + x + 2*x^2 + O(x^5)\n\njulia> k = truncate(d, 5)\n2*x + x^3 + O(x^4)\n","category":"page"},{"location":"AbstractAlgebra/series/#Division","page":"Power series","title":"Division","text":"","category":"section"},{"location":"AbstractAlgebra/series/","page":"Power series","title":"Power series","text":"Base.inv(::RelPowerSeriesRingElem)","category":"page"},{"location":"AbstractAlgebra/series/#inv-Tuple{RelPowerSeriesRingElem}","page":"Power series","title":"inv","text":"Base.inv(a::RelPowerSeriesRingElem)\n\nReturn the inverse of the power series a, i.e. 1a.\n\n\n\n\n\n","category":"method"},{"location":"AbstractAlgebra/series/","page":"Power series","title":"Power series","text":"Examples","category":"page"},{"location":"AbstractAlgebra/series/","page":"Power series","title":"Power series","text":"julia> R, t = polynomial_ring(QQ, :t)\n(Univariate polynomial ring in t over rationals, t)\n\njulia> S, x = power_series_ring(R, 30, :x)\n(Univariate power series ring over R, x + O(x^31))\n\njulia> a = 1 + x + 2x^2 + O(x^5)\n1 + x + 2*x^2 + O(x^5)\n\njulia> b = S(-1)\n-1 + O(x^30)\n\njulia> c = inv(a)\n1 - x - x^2 + 3*x^3 - x^4 + O(x^5)\n\njulia> d = inv(b)\n-1 + O(x^30)\n","category":"page"},{"location":"AbstractAlgebra/series/#Composition","page":"Power series","title":"Composition","text":"","category":"section"},{"location":"AbstractAlgebra/series/","page":"Power series","title":"Power series","text":"compose(a::RelPowerSeriesRingElem, b::RelPowerSeriesRingElem)","category":"page"},{"location":"AbstractAlgebra/series/#compose-Tuple{RelPowerSeriesRingElem, RelPowerSeriesRingElem}","page":"Power series","title":"compose","text":"compose(f::RelPowerSeriesRingElem, g::RelPowerSeriesRingElem; inner)\n\nCompose the series a with the series b and return the result.\n\nIf inner = :second, then f(g) is returned and g must have positive valuation.\nIf inner = :first, then g(f) is returned and f must have positive valuation.\n\n\n\n\n\n","category":"method"},{"location":"AbstractAlgebra/series/","page":"Power series","title":"Power series","text":"Note that subst can be used instead of compose, however the provided functionality is the same. General series substitution is not well-defined.","category":"page"},{"location":"AbstractAlgebra/series/#Derivative-and-integral","page":"Power series","title":"Derivative and integral","text":"","category":"section"},{"location":"AbstractAlgebra/series/","page":"Power series","title":"Power series","text":"derivative(a::RelPowerSeriesRingElem)","category":"page"},{"location":"AbstractAlgebra/series/#derivative-Tuple{RelPowerSeriesRingElem}","page":"Power series","title":"derivative","text":"derivative(f::AbsPowerSeriesRingElem{T})\n\nReturn the derivative of the power series f.\n\n\n\n\n\nderivative(f::RelPowerSeriesRingElem{T})\n\nReturn the derivative of the power series f.\n\njulia> R, x = power_series_ring(QQ, 10, :x)\n(Univariate power series ring in x over Rationals, x + O(x^11))\n\njulia> f = 2 + x + 3x^3\n2 + x + 3*x^3 + O(x^10)\n\njulia> derivative(f)\n1 + 9*x^2 + O(x^9)\n\n\n\n\n\nderivative(f::MPolyRingElem{T}, j::Int) where {T <: RingElement}\n\nReturn the partial derivative of f with respect to j-th variable of the polynomial ring.\n\n\n\n\n\nderivative(f::MPolyRingElem{T}, x::MPolyRingElem{T}) where T <: RingElement\n\nReturn the partial derivative of f with respect to x. The value x must be a generator of the polynomial ring of f.\n\n\n\n\n\nderivative(x::spoly{T}, n::Int) where T <: Nemo.RingElem\n\nReturn the derivative of x with respect to the variable of index n.\n\n\n\n\n\nderivative(x::spoly{T}, v::spoly{T}) where T <: Nemo.RingElem\n\nReturn the derivative of x with respect to the variable v.\n\n\n\n\n\nderivative(a::Generic.PuiseuxSeriesElem{T}) where T <: RingElement\n\nReturn the derivative of the given Puiseux series a.\n\n\n\n\n\n","category":"method"},{"location":"AbstractAlgebra/series/","page":"Power series","title":"Power series","text":"integral(a::RelPowerSeriesRingElem)","category":"page"},{"location":"AbstractAlgebra/series/#integral-Tuple{RelPowerSeriesRingElem}","page":"Power series","title":"integral","text":"integral(f::AbsPowerSeriesRingElem{T})\n\nReturn the integral of the power series f.\n\n\n\n\n\nintegral(f::RelPowerSeriesRingElem{T})\n\nReturn the integral of the power series f.\n\njulia> R, x = power_series_ring(QQ, 10, :x)\n(Univariate power series ring in x over Rationals, x + O(x^11))\n\njulia> f = 2 + x + 3x^3\n2 + x + 3*x^3 + O(x^10)\n\njulia> integral(f)\n2*x + 1//2*x^2 + 3//4*x^4 + O(x^11)\n\n\n\n\n\nintegral(f::RelPowerSeriesRingElem{T}) -> RelPowerSeriesRingElem\n\nReturn the integral of the power series f.\n\n\n\n\n\nintegral(a::Generic.PuiseuxSeriesElem{T}) where T <: RingElement\n\nReturn the integral of the given Puiseux series a.\n\n\n\n\n\n","category":"method"},{"location":"AbstractAlgebra/series/#Special-functions","page":"Power series","title":"Special functions","text":"","category":"section"},{"location":"AbstractAlgebra/series/","page":"Power series","title":"Power series","text":"Base.log(a::SeriesElem{T}) where T <: FieldElem","category":"page"},{"location":"AbstractAlgebra/series/#log-Union{Tuple{SeriesElem{T}}, Tuple{T}} where T<:FieldElem","page":"Power series","title":"log","text":"log(a::SeriesElem{T}) where T <: FieldElement\n\nReturn the logarithm of the power series a.\n\n\n\n\n\nlog(a::Generic.PuiseuxSeriesElem{T}) where T <: RingElement\n\nReturn the logarithm of the given Puiseux series a.\n\n\n\n\n\n","category":"method"},{"location":"AbstractAlgebra/series/","page":"Power series","title":"Power series","text":"Base.exp(a::RelPowerSeriesRingElem)","category":"page"},{"location":"AbstractAlgebra/series/#exp-Tuple{RelPowerSeriesRingElem}","page":"Power series","title":"exp","text":"exp(a::AbsPowerSeriesRingElem)\n\nReturn the exponential of the power series a.\n\n\n\n\n\nexp(a::RelPowerSeriesRingElem)\n\nReturn the exponential of the power series a.\n\n\n\n\n\nexp(a::Generic.LaurentSeriesElem)\n\nReturn the exponential of the power series a.\n\n\n\n\n\nexp(a::Generic.PuiseuxSeriesElem{T}) where T <: RingElement\n\nReturn the exponential of the given Puiseux series a.\n\n\n\n\n\n","category":"method"},{"location":"AbstractAlgebra/series/","page":"Power series","title":"Power series","text":"Base.sqrt(a::RelPowerSeriesRingElem)","category":"page"},{"location":"AbstractAlgebra/series/#sqrt-Tuple{RelPowerSeriesRingElem}","page":"Power series","title":"sqrt","text":"sqrt(a::RelPowerSeriesRingElem)\n\nReturn the square root of the power series a. By default the function raises an exception if the input is not a square. If check=false this check is omitted.\n\n\n\n\n\n","category":"method"},{"location":"AbstractAlgebra/series/","page":"Power series","title":"Power series","text":"Examples","category":"page"},{"location":"AbstractAlgebra/series/","page":"Power series","title":"Power series","text":"julia> R, t = polynomial_ring(QQ, :t)\n(Univariate polynomial ring in t over rationals, t)\n\njulia> S, x = power_series_ring(R, 30, :x)\n(Univariate power series ring over R, x + O(x^31))\n\njulia> T, z = power_series_ring(QQ, 30, :z)\n(Univariate power series ring over rationals, z + O(z^31))\n\njulia> a = 1 + z + 3z^2 + O(z^5)\n1 + z + 3*z^2 + O(z^5)\n\njulia> b = z + 2z^2 + 5z^3 + O(z^5)\nz + 2*z^2 + 5*z^3 + O(z^5)\n\njulia> c = exp(x + O(x^40))\n1 + x + 1//2*x^2 + 1//6*x^3 + 1//24*x^4 + 1//120*x^5 + 1//720*x^6 + 1//5040*x^7 + 1//40320*x^8 + 1//362880*x^9 + 1//3628800*x^10 + 1//39916800*x^11 + 1//479001600*x^12 + 1//6227020800*x^13 + 1//87178291200*x^14 + 1//1307674368000*x^15 + 1//20922789888000*x^16 + 1//355687428096000*x^17 + 1//6402373705728000*x^18 + 1//121645100408832000*x^19 + 1//2432902008176640000*x^20 + 1//51090942171709440000*x^21 + 1//1124000727777607680000*x^22 + 1//25852016738884976640000*x^23 + 1//620448401733239439360000*x^24 + 1//15511210043330985984000000*x^25 + 1//403291461126605635584000000*x^26 + 1//10888869450418352160768000000*x^27 + 1//304888344611713860501504000000*x^28 + 1//8841761993739701954543616000000*x^29 + 1//265252859812191058636308480000000*x^30 + O(x^31)\n\njulia> d = divexact(x, exp(x + O(x^40)) - 1)\n1 - 1//2*x + 1//12*x^2 - 1//720*x^4 + 1//30240*x^6 - 1//1209600*x^8 + 1//47900160*x^10 - 691//1307674368000*x^12 + 1//74724249600*x^14 - 3617//10670622842880000*x^16 + 43867//5109094217170944000*x^18 - 174611//802857662698291200000*x^20 + 77683//14101100039391805440000*x^22 - 236364091//1693824136731743669452800000*x^24 + 657931//186134520519971831808000000*x^26 - 3392780147//37893265687455865519472640000000*x^28 + O(x^29)\n\njulia> f = exp(b)\n1 + z + 5//2*z^2 + 43//6*z^3 + 193//24*z^4 + O(z^5)\n\njulia> log(exp(b)) == b\ntrue\n\njulia> h = sqrt(a)\n1 + 1//2*z + 11//8*z^2 - 11//16*z^3 - 77//128*z^4 + O(z^5)\n","category":"page"},{"location":"AbstractAlgebra/series/#Random-generation","page":"Power series","title":"Random generation","text":"","category":"section"},{"location":"AbstractAlgebra/series/","page":"Power series","title":"Power series","text":"Random series can be constructed using the rand function. A range of possible valuations is provided. The maximum precision of the ring is used as a bound on the precision. Other parameters are used to construct random coefficients.","category":"page"},{"location":"AbstractAlgebra/series/","page":"Power series","title":"Power series","text":"rand(R::SeriesRing, val_range::AbstractUnitRange{Int}, v...)","category":"page"},{"location":"AbstractAlgebra/series/","page":"Power series","title":"Power series","text":"Examples","category":"page"},{"location":"AbstractAlgebra/series/","page":"Power series","title":"Power series","text":"julia> R, x = power_series_ring(ZZ, 10, :x)\n(Univariate power series ring over integers, x + O(x^11))\n\njulia> f = rand(R, 3:5, -10:10)\n3*x^4 - x^5 + 4*x^7 + 4*x^8 - 7*x^9 + 2*x^10 + 4*x^11 - x^12 - 4*x^13 + O(x^14)","category":"page"},{"location":"CommutativeAlgebra/ModulesOverMultivariateRings/subquotients/","page":"Subquotients","title":"Subquotients","text":"CurrentModule = Oscar\nDocTestSetup = Oscar.doctestsetup()","category":"page"},{"location":"CommutativeAlgebra/ModulesOverMultivariateRings/subquotients/#Subquotients","page":"Subquotients","title":"Subquotients","text":"","category":"section"},{"location":"CommutativeAlgebra/ModulesOverMultivariateRings/subquotients/","page":"Subquotients","title":"Subquotients","text":"A subquotient  is a submodule of a quotient of a free module. In this section, the expression subquotient refers to a subquotient over a ring of type MPolyRing, MPolyQuoRing, MPolyLocRing, or MPolyQuoLocRing. That is, given a ring R of one of these types, a subquotient M over R is a module of type","category":"page"},{"location":"CommutativeAlgebra/ModulesOverMultivariateRings/subquotients/","page":"Subquotients","title":"Subquotients","text":"M = (textim  a + textim  b)textim  b","category":"page"},{"location":"CommutativeAlgebra/ModulesOverMultivariateRings/subquotients/","page":"Subquotients","title":"Subquotients","text":"where","category":"page"},{"location":"CommutativeAlgebra/ModulesOverMultivariateRings/subquotients/","page":"Subquotients","title":"Subquotients","text":"aR^s R^p text and  bR^t R^p","category":"page"},{"location":"CommutativeAlgebra/ModulesOverMultivariateRings/subquotients/","page":"Subquotients","title":"Subquotients","text":"are two homomorphisms of free R-modules with the same codomain. We then refer to","category":"page"},{"location":"CommutativeAlgebra/ModulesOverMultivariateRings/subquotients/","page":"Subquotients","title":"Subquotients","text":"the module M as the subquotient defined by a and b,\nthe codomain R^p as the ambient free module of M,\nthe images of the canonical basis vectors of R^s in R^p as the ambient representatives of the generators of M, and\nthe images of the canonical basis vectors of R^t in R^p as the relations of M.","category":"page"},{"location":"CommutativeAlgebra/ModulesOverMultivariateRings/subquotients/","page":"Subquotients","title":"Subquotients","text":"Alternatively, we speak of the subquotient of textim  a by textim  b or the subquotient defined by A and B, where A and B are the matrices representing a and b, respectively.","category":"page"},{"location":"CommutativeAlgebra/ModulesOverMultivariateRings/subquotients/","page":"Subquotients","title":"Subquotients","text":"Finally, we refer to","category":"page"},{"location":"CommutativeAlgebra/ModulesOverMultivariateRings/subquotients/","page":"Subquotients","title":"Subquotients","text":"the quotient of R^p by the submodule generated by the relations of M as the ambient module of M,","category":"page"},{"location":"CommutativeAlgebra/ModulesOverMultivariateRings/subquotients/","page":"Subquotients","title":"Subquotients","text":"and regard M as a submodule of that ambient module, embedded in the natural way.","category":"page"},{"location":"CommutativeAlgebra/ModulesOverMultivariateRings/subquotients/","page":"Subquotients","title":"Subquotients","text":"note: Note\nRecall from the section on free modules that by a free R-module we mean a free module of type R^p , where we think of R^p as a free module with a given basis, namely the basis of standard unit vectors. Accordingly, elements of free modules are represented by coordinate vectors, and homomorphisms between free modules by matrices. Here, by convention, vectors are row vectors, and matrices operate by multiplication on the right.","category":"page"},{"location":"CommutativeAlgebra/ModulesOverMultivariateRings/subquotients/","page":"Subquotients","title":"Subquotients","text":"note: Note\nOver a graded ring R, we work with graded free modules R^s, R^p, R^t and graded homomorphisms a, b. As a consequence, every module involved in the construction of the subquotient defined by a and b carries an induced grading. In particular, the subquotient itself carries an induced grading.","category":"page"},{"location":"CommutativeAlgebra/ModulesOverMultivariateRings/subquotients/#Types","page":"Subquotients","title":"Types","text":"","category":"section"},{"location":"CommutativeAlgebra/ModulesOverMultivariateRings/subquotients/","page":"Subquotients","title":"Subquotients","text":"All OSCAR types for the finitely presented modules considered here belong to the abstract type ModuleFP{T}, where T is the element type of the underlying ring. Graded or not, the subquotients belong to the abstract subtype AbstractSubQuo{T} <: ModuleFP{T}, they are modeled as objects of the concrete type SubquoModule{T} <: AbstractSubQuo{T}.","category":"page"},{"location":"CommutativeAlgebra/ModulesOverMultivariateRings/subquotients/","page":"Subquotients","title":"Subquotients","text":"note: Note\nCanonical maps such us the canonical projection onto a quotient module arise in many  constructions in commutative algebra. The SubquoModule type is designed so that it allows for the caching of such maps when executing functions. The tensor_product function discussed in this section provides an example.","category":"page"},{"location":"CommutativeAlgebra/ModulesOverMultivariateRings/subquotients/#Constructors","page":"Subquotients","title":"Constructors","text":"","category":"section"},{"location":"CommutativeAlgebra/ModulesOverMultivariateRings/subquotients/","page":"Subquotients","title":"Subquotients","text":"subquotient(a::FreeModuleHom, b::FreeModuleHom)","category":"page"},{"location":"CommutativeAlgebra/ModulesOverMultivariateRings/subquotients/#subquotient-Tuple{FreeModuleHom, FreeModuleHom}","page":"Subquotients","title":"subquotient","text":"subquotient(a::FreeModuleHom, b::FreeModuleHom)\n\nGiven homomorphisms a and b between free modules such that  codomain(a) === codomain(b),  return (textim  a + textim  b)textim  b.\n\nsubquotient(F::FreeMod{T}, A::MatElem{T}, B::MatElem{T}) where T\n\nGiven matrices A and B with rank F columns, return   (textim  a + textim  b)textim  b, where a and b are free module homomorphisms with codomain F represented by A and B.\n\nsubquotient(A::MatElem{T}, B::MatElem{T}) where T\n\nGiven matrices A and B with the same number of columns, create a free module F whose rank  is that number, and return (textim  a + textim  b)textim  b, where a and b are  free module homomorphisms with codomain F represented by A and B.\n\nExamples\n\njulia> R, (x, y, z) = polynomial_ring(QQ, [:x, :y, :z]);\n\njulia> FR = free_module(R, 1)\nFree module of rank 1 over R\n\njulia> AR = R[x; y]\n[x]\n[y]\n\njulia> BR = R[x^2; y^3; z^4]\n[x^2]\n[y^3]\n[z^4]\n\njulia> MR = SubquoModule(FR, AR, BR)\nSubquotient of submodule with 2 generators\n  1: x*e[1]\n  2: y*e[1]\nby submodule with 3 generators\n  1: x^2*e[1]\n  2: y^3*e[1]\n  3: z^4*e[1]\n\njulia> P = ideal(R, [x, y, z]);\n\njulia> U = complement_of_prime_ideal(P);\n\njulia> RL, _ = localization(R, U);\n\njulia> FRL = free_module(RL, 1)\nFree module of rank 1 over localization of R at complement of prime ideal (x, y, z)\n\njulia> ARL = RL[x; y]\n[x]\n[y]\n\njulia> BRL = RL[x^2; y^3; z^4]\n[x^2]\n[y^3]\n[z^4]\n\njulia> MRL = SubquoModule(FRL, ARL, BRL)\nSubquotient of submodule with 2 generators\n  1: x*e[1]\n  2: y*e[1]\nby submodule with 3 generators\n  1: x^2*e[1]\n  2: y^3*e[1]\n  3: z^4*e[1]\n\njulia> RQ, _ = quo(R, ideal(R, [2*x^2-y^3, 2*x^2-y^5]));\n\njulia> FRQ = free_module(RQ, 1)\nFree module of rank 1 over RQ\n\njulia> ARQ = RQ[x; y]\n[x]\n[y]\n\njulia> BRQ = RQ[x^2; y^3; z^4]\n[x^2]\n[y^3]\n[z^4]\n\njulia> MRQ = SubquoModule(FRQ, ARQ, BRQ)\nSubquotient of submodule with 2 generators\n  1: x*e[1]\n  2: y*e[1]\nby submodule with 3 generators\n  1: x^2*e[1]\n  2: 2*x^2*e[1]\n  3: z^4*e[1]\n\njulia> RQL, _ = localization(RQ, U);\n\njulia> FRQL = free_module(RQL, 1)\nFree module of rank 1 over localization of RQ at complement of prime ideal\n\njulia> ARQL = RQL[x; y]\n[x]\n[y]\n\njulia> BRQL = RQL[x^2; y^3; z^4]\n[x^2]\n[y^3]\n[z^4]\n\njulia> MRQL = SubquoModule(FRQL, ARQL, BRQL)\nSubquotient of submodule with 2 generators\n  1: x*e[1]\n  2: y*e[1]\nby submodule with 3 generators\n  1: 0\n  2: 0\n  3: z^4*e[1]\n\njulia> Rg, (x, y, z) = graded_polynomial_ring(QQ, [:x, :y, :z]);\n\njulia> F1 = graded_free_module(Rg, [2,2,2]);\n\njulia> F2 = graded_free_module(Rg, [2]);\n\njulia> G = graded_free_module(Rg, [1,1]);\n\njulia> V1 = [y*G[1], (x+y)*G[1]+y*G[2], z*G[2]]\n3-element Vector{FreeModElem{MPolyDecRingElem{QQFieldElem, QQMPolyRingElem}}}:\n y*e[1]\n (x + y)*e[1] + y*e[2]\n z*e[2]\n\njulia> V2 = [z*G[2]+y*G[1]]\n1-element Vector{FreeModElem{MPolyDecRingElem{QQFieldElem, QQMPolyRingElem}}}:\n y*e[1] + z*e[2]\n\njulia> a1 = hom(F1, G, V1)\nHomogeneous module homomorphism\n  from F1\n  to G\ndefined by\n  e[1] -> y*e[1]\n  e[2] -> (x + y)*e[1] + y*e[2]\n  e[3] -> z*e[2]\n\njulia> a2 = hom(F2, G, V2)\nHomogeneous module homomorphism\n  from F2\n  to G\ndefined by\n  e[1] -> y*e[1] + z*e[2]\n\njulia> V = subquotient(a1,a2)\nGraded subquotient of graded submodule of G with 3 generators\n  1: y*e[1]\n  2: (x + y)*e[1] + y*e[2]\n  3: z*e[2]\nby graded submodule of G with 1 generator\n  1: y*e[1] + z*e[2]\n\njulia> A1 = Rg[x y; 2*x^2 3*y^2]\n[    x       y]\n[2*x^2   3*y^2]\n\njulia> A2 = Rg[x^3 x^2*y; (2*x^2+x*y)*x (2*y^3+y*x^2)]\n[          x^3           x^2*y]\n[2*x^3 + x^2*y   x^2*y + 2*y^3]\n\njulia> B = Rg[4*x*y^3 (2*x+y)^4]\n[4*x*y^3   16*x^4 + 32*x^3*y + 24*x^2*y^2 + 8*x*y^3 + y^4]\n\njulia> F2 = graded_free_module(Rg,[0,0])\nGraded free module Rg^2([0]) of rank 2 over Rg\n\njulia> M1 = SubquoModule(F2, A1, B)\nGraded subquotient of graded submodule of F2 with 2 generators\n  1: x*e[1] + y*e[2]\n  2: 2*x^2*e[1] + 3*y^2*e[2]\nby graded submodule of F2 with 1 generator\n  1: 4*x*y^3*e[1] + (16*x^4 + 32*x^3*y + 24*x^2*y^2 + 8*x*y^3 + y^4)*e[2]\n\n\n\n\n\n","category":"method"},{"location":"CommutativeAlgebra/ModulesOverMultivariateRings/subquotients/#Data-Associated-to-Subqotients","page":"Subquotients","title":"Data Associated to Subqotients","text":"","category":"section"},{"location":"CommutativeAlgebra/ModulesOverMultivariateRings/subquotients/","page":"Subquotients","title":"Subquotients","text":"If M is a subquotient with ambient free R-module F, then","category":"page"},{"location":"CommutativeAlgebra/ModulesOverMultivariateRings/subquotients/","page":"Subquotients","title":"Subquotients","text":"base_ring(M) refers to R,\nambient_free_module(M) to F,\ngens(M) to the generators of M, \nnumber_of_generators(M) / ngens(M) to the number of these generators, \nM[i], gen(M, i) to the ith such generator,\nambient_representatives_generators(M) to the ambient representatives of the generators of M in F,\nrelations(M) to the relations of M, and\nambient_module(M) to the ambient module of M.","category":"page"},{"location":"CommutativeAlgebra/ModulesOverMultivariateRings/subquotients/#Examples","page":"Subquotients","title":"Examples","text":"","category":"section"},{"location":"CommutativeAlgebra/ModulesOverMultivariateRings/subquotients/","page":"Subquotients","title":"Subquotients","text":"julia> R, (x, y, z) = polynomial_ring(QQ, [:x, :y, :z])\n(Multivariate polynomial ring in 3 variables over QQ, QQMPolyRingElem[x, y, z])\n\njulia> F = free_module(R, 1)\nFree module of rank 1 over R\n\njulia> A = R[x; y]\n[x]\n[y]\n\njulia> B = R[x^2; y^3; z^4]\n[x^2]\n[y^3]\n[z^4]\n\njulia> M = SubquoModule(F, A, B)\nSubquotient of submodule with 2 generators\n  1: x*e[1]\n  2: y*e[1]\nby submodule with 3 generators\n  1: x^2*e[1]\n  2: y^3*e[1]\n  3: z^4*e[1]\n\njulia> base_ring(M)\nMultivariate polynomial ring in 3 variables x, y, z\n  over rational field\n\njulia> F === ambient_free_module(M)\ntrue\n\njulia> gens(M)\n2-element Vector{SubquoModuleElem{QQMPolyRingElem}}:\n x*e[1]\n y*e[1]\n\njulia> number_of_generators(M)\n2\n\njulia> gen(M, 2)\ny*e[1]\n\njulia> ambient_representatives_generators(M)\n2-element Vector{FreeModElem{QQMPolyRingElem}}:\n x*e[1]\n y*e[1]\n\njulia> relations(M)\n3-element Vector{FreeModElem{QQMPolyRingElem}}:\n x^2*e[1]\n y^3*e[1]\n z^4*e[1]\n\njulia> ambient_module(M)\nSubquotient of submodule with 1 generator\n  1: e[1]\nby submodule with 3 generators\n  1: x^2*e[1]\n  2: y^3*e[1]\n  3: z^4*e[1]","category":"page"},{"location":"CommutativeAlgebra/ModulesOverMultivariateRings/subquotients/","page":"Subquotients","title":"Subquotients","text":"In the graded case, we also have:","category":"page"},{"location":"CommutativeAlgebra/ModulesOverMultivariateRings/subquotients/","page":"Subquotients","title":"Subquotients","text":" grading_group(M::SubquoModule)","category":"page"},{"location":"CommutativeAlgebra/ModulesOverMultivariateRings/subquotients/#grading_group-Tuple{SubquoModule}","page":"Subquotients","title":"grading_group","text":"grading_group(M::SubquoModule)\n\nReturn the grading group of base_ring(M).\n\nExamples\n\njulia> Rg, (x, y, z) = graded_polynomial_ring(QQ, [:x, :y, :z]);\n\njulia> F1 = graded_free_module(Rg, [2,2,2]);\n\njulia> F2 = graded_free_module(Rg, [2]);\n\njulia> G = graded_free_module(Rg, [1,1]);\n\njulia> V1 = [y*G[1], (x+y)*G[1]+y*G[2], z*G[2]];\n\njulia> V2 = [z*G[2]+y*G[1]];\n\njulia> a1 = hom(F1, G, V1);\n\njulia> a2 = hom(F2, G, V2);\n\njulia> M = subquotient(a1,a2);\n\njulia> grading_group(M)\nZ\n\n\n\n\n\n","category":"method"},{"location":"CommutativeAlgebra/ModulesOverMultivariateRings/subquotients/","page":"Subquotients","title":"Subquotients","text":"degrees_of_generators(M::SubquoModule)","category":"page"},{"location":"CommutativeAlgebra/ModulesOverMultivariateRings/subquotients/#degrees_of_generators-Tuple{SubquoModule}","page":"Subquotients","title":"degrees_of_generators","text":"degrees_of_generators(M::SubquoModule; check::Bool=true)\n\nReturn the degrees of the generators of M.\n\nExamples\n\njulia> Rg, (x, y, z) = graded_polynomial_ring(QQ, [:x, :y, :z]);\n\njulia> F1 = graded_free_module(Rg, [2,2,2]);\n\njulia> F2 = graded_free_module(Rg, [2]);\n\njulia> G = graded_free_module(Rg, [1,1]);\n\njulia> V1 = [y*G[1], (x+y)*G[1]+y*G[2], z*G[2]];\n\njulia> V2 = [z*G[2]+y*G[1]];\n\njulia> a1 = hom(F1, G, V1);\n\njulia> a2 = hom(F2, G, V2);\n\njulia> M = subquotient(a1,a2);\n\njulia> degrees_of_generators(M)\n3-element Vector{FinGenAbGroupElem}:\n [2]\n [2]\n [2]\n\njulia> gens(M)\n3-element Vector{SubquoModuleElem{MPolyDecRingElem{QQFieldElem, QQMPolyRingElem}}}:\n y*e[1]\n (x + y)*e[1] + y*e[2]\n z*e[2]\n\n\n\n\n\n","category":"method"},{"location":"CommutativeAlgebra/ModulesOverMultivariateRings/subquotients/#Elements-of-Subqotients","page":"Subquotients","title":"Elements of Subqotients","text":"","category":"section"},{"location":"CommutativeAlgebra/ModulesOverMultivariateRings/subquotients/","page":"Subquotients","title":"Subquotients","text":"All OSCAR types for elements of finitely presented modules considered here belong to the abstract type ModuleElemFP{T}, where T is the element type of the polynomial ring. For elements of subquotients, there  are the abstract subtype AbstractSubQuoElem{T} <: ModuleFPElem{T} and its concrete descendant SubquoModuleElem{T} which implements an element m of a subquotient M over a ring R as a sparse row, that is, as an object of type SRow{T}. This object specifies the coefficients of an R-linear combination of the generators of M giving m. To create an element, enter the coefficients as a sparse row or a vector: ","category":"page"},{"location":"CommutativeAlgebra/ModulesOverMultivariateRings/subquotients/","page":"Subquotients","title":"Subquotients","text":"(M::SubquoModule{T})(c::SRow{T}) where T","category":"page"},{"location":"CommutativeAlgebra/ModulesOverMultivariateRings/subquotients/","page":"Subquotients","title":"Subquotients","text":"(M::SubquoModule{T})(c::Vector{T}) where T","category":"page"},{"location":"CommutativeAlgebra/ModulesOverMultivariateRings/subquotients/","page":"Subquotients","title":"Subquotients","text":"Alternatively, directly write the element as an R-linear combination of generators of M.","category":"page"},{"location":"CommutativeAlgebra/ModulesOverMultivariateRings/subquotients/#Examples-2","page":"Subquotients","title":"Examples","text":"","category":"section"},{"location":"CommutativeAlgebra/ModulesOverMultivariateRings/subquotients/","page":"Subquotients","title":"Subquotients","text":"julia> R, (x, y, z) = polynomial_ring(QQ, [:x, :y, :z])\n(Multivariate polynomial ring in 3 variables over QQ, QQMPolyRingElem[x, y, z])\n\njulia> F = free_module(R, 1)\nFree module of rank 1 over R\n\njulia> A = R[x; y]\n[x]\n[y]\n\njulia> B = R[x^2; y^3; z^4]\n[x^2]\n[y^3]\n[z^4]\n\njulia> M = SubquoModule(F, A, B)\nSubquotient of submodule with 2 generators\n  1: x*e[1]\n  2: y*e[1]\nby submodule with 3 generators\n  1: x^2*e[1]\n  2: y^3*e[1]\n  3: z^4*e[1]\n\njulia> m = M(sparse_row(R, [(1,z),(2,one(R))]))\n(x*z + y)*e[1]\n\njulia> n = M([z, one(R)])\n(x*z + y)*e[1]\n\njulia> o = z*M[1] + M[2]\n(x*z + y)*e[1]\n\njulia> m == n == o\ntrue\n","category":"page"},{"location":"CommutativeAlgebra/ModulesOverMultivariateRings/subquotients/","page":"Subquotients","title":"Subquotients","text":"Given an element m of a subquotient M over a ring R with element type T,","category":"page"},{"location":"CommutativeAlgebra/ModulesOverMultivariateRings/subquotients/","page":"Subquotients","title":"Subquotients","text":"parent(m) refers to M, \ncoordinates(m) to an object of type SRow{T} specifying the coefficients of an R-linear combination of the generators of M which gives m, and\nambient_representative(m) to an element of the ambient free module of M which represents m.","category":"page"},{"location":"CommutativeAlgebra/ModulesOverMultivariateRings/subquotients/","page":"Subquotients","title":"Subquotients","text":"Given an element f of the ambient free module of a subquotient M such that f represents an element of M, the function below creates the represented element:","category":"page"},{"location":"CommutativeAlgebra/ModulesOverMultivariateRings/subquotients/","page":"Subquotients","title":"Subquotients","text":"(M::SubquoModule{T})(f::FreeModElem{T}; check::Bool = true) where T","category":"page"},{"location":"CommutativeAlgebra/ModulesOverMultivariateRings/subquotients/","page":"Subquotients","title":"Subquotients","text":"By default (check = true), it is tested whether f indeed represents an element of M. If this is already clear, it may be convenient to omit the test (check = false).","category":"page"},{"location":"CommutativeAlgebra/ModulesOverMultivariateRings/subquotients/#Examples-3","page":"Subquotients","title":"Examples","text":"","category":"section"},{"location":"CommutativeAlgebra/ModulesOverMultivariateRings/subquotients/","page":"Subquotients","title":"Subquotients","text":"julia> R, (x, y, z) = polynomial_ring(QQ, [:x, :y, :z])\n(Multivariate polynomial ring in 3 variables over QQ, QQMPolyRingElem[x, y, z])\n\njulia> F = free_module(R, 1)\nFree module of rank 1 over R\n\njulia> A = R[x; y]\n[x]\n[y]\n\njulia> B = R[x^2; y^3; z^4]\n[x^2]\n[y^3]\n[z^4]\n\njulia> M = SubquoModule(F, A, B)\nSubquotient of submodule with 2 generators\n  1: x*e[1]\n  2: y*e[1]\nby submodule with 3 generators\n  1: x^2*e[1]\n  2: y^3*e[1]\n  3: z^4*e[1]\n\njulia> m = z*M[1] + M[2]\n(x*z + y)*e[1]\n\njulia> parent(m)\nSubquotient of submodule with 2 generators\n  1: x*e[1]\n  2: y*e[1]\nby submodule with 3 generators\n  1: x^2*e[1]\n  2: y^3*e[1]\n  3: z^4*e[1]\n\njulia> coordinates(m)\nSparse row with positions [1, 2] and values QQMPolyRingElem[z, 1]\n\njulia> fm = ambient_representative(m)\n(x*z + y)*e[1]\n\njulia> typeof(m)\nSubquoModuleElem{QQMPolyRingElem}\n\njulia> typeof(fm)\nFreeModElem{QQMPolyRingElem}\n\njulia> parent(fm) === ambient_free_module(M)\ntrue\n\njulia> F = ambient_free_module(M)\nFree module of rank 1 over R\n\njulia> f = x*F[1]\nx*e[1]\n\njulia> M(f)\nx*e[1]\n\njulia> typeof(f)\nFreeModElem{QQMPolyRingElem}\n\njulia> typeof(M(f))\nSubquoModuleElem{QQMPolyRingElem}\n","category":"page"},{"location":"CommutativeAlgebra/ModulesOverMultivariateRings/subquotients/","page":"Subquotients","title":"Subquotients","text":"The zero element of a subquotient is obtained as follows:","category":"page"},{"location":"CommutativeAlgebra/ModulesOverMultivariateRings/subquotients/","page":"Subquotients","title":"Subquotients","text":"zero(M::SubquoModule)","category":"page"},{"location":"CommutativeAlgebra/ModulesOverMultivariateRings/subquotients/#zero-Tuple{SubquoModule}","page":"Subquotients","title":"zero","text":"zero(M::SubquoModule)\n\nReturn the zero element of M.\n\n\n\n\n\n","category":"method"},{"location":"CommutativeAlgebra/ModulesOverMultivariateRings/subquotients/","page":"Subquotients","title":"Subquotients","text":"Whether a given element of a subquotient is zero can be tested as follows:","category":"page"},{"location":"CommutativeAlgebra/ModulesOverMultivariateRings/subquotients/","page":"Subquotients","title":"Subquotients","text":"is_zero(m::SubquoModuleElem)","category":"page"},{"location":"CommutativeAlgebra/ModulesOverMultivariateRings/subquotients/#is_zero-Tuple{SubquoModuleElem}","page":"Subquotients","title":"is_zero","text":"is_zero(m::SubquoModuleElem)\n\nReturn true if m is zero, false otherwise.\n\nExamples\n\njulia> R, (x, y, z) = polynomial_ring(QQ, [:x, :y, :z])\n(Multivariate polynomial ring in 3 variables over QQ, QQMPolyRingElem[x, y, z])\n\njulia> F = free_module(R, 1)\nFree module of rank 1 over R\n\njulia> A = R[x; y]\n[x]\n[y]\n\njulia> B = R[x^2; y^3; z^4]\n[x^2]\n[y^3]\n[z^4]\n\njulia> M = SubquoModule(F, A, B)\nSubquotient of submodule with 2 generators\n  1: x*e[1]\n  2: y*e[1]\nby submodule with 3 generators\n  1: x^2*e[1]\n  2: y^3*e[1]\n  3: z^4*e[1]\n\njulia> is_zero(M[1])\nfalse\n\njulia> is_zero(x*M[1])\ntrue\n\njulia> Rg, (x, y, z) = graded_polynomial_ring(QQ, [:x, :y, :z]);\n\njulia> F = graded_free_module(Rg, 1)\nGraded free module Rg^1([0]) of rank 1 over Rg\n\njulia> A = Rg[x; y]\n[x]\n[y]\n\njulia> B = Rg[x^2; y^3; z^4]\n[x^2]\n[y^3]\n[z^4]\n\njulia> M = SubquoModule(F, A, B)\nGraded subquotient of graded submodule of F with 2 generators\n  1: x*e[1]\n  2: y*e[1]\nby graded submodule of F with 3 generators\n  1: x^2*e[1]\n  2: y^3*e[1]\n  3: z^4*e[1]\n\njulia> is_zero(M[1])\nfalse\n\njulia> is_zero(x*M[1])\ntrue\n\n\n\n\n\n\n","category":"method"},{"location":"CommutativeAlgebra/ModulesOverMultivariateRings/subquotients/","page":"Subquotients","title":"Subquotients","text":"In the graded case, we additionally have:","category":"page"},{"location":"CommutativeAlgebra/ModulesOverMultivariateRings/subquotients/","page":"Subquotients","title":"Subquotients","text":"is_homogeneous(m::SubquoModuleElem)","category":"page"},{"location":"CommutativeAlgebra/ModulesOverMultivariateRings/subquotients/#is_homogeneous-Tuple{SubquoModuleElem}","page":"Subquotients","title":"is_homogeneous","text":"is_homogeneous(m::SubquoModuleElem)\n\nReturn  true if m is homogeneous, false otherwise.\n\nExamples\n\njulia> Rg, (x, y, z) = graded_polynomial_ring(QQ, [:x, :y, :z]);\n\njulia> F1 = graded_free_module(Rg, [2,2,2]);\n\njulia> F2 = graded_free_module(Rg, [2]);\n\njulia> G = graded_free_module(Rg, [1,1]);\n\njulia> V1 = [y*G[1], (x+y)*G[1]+y*G[2], z*G[2]];\n\njulia> V2 = [z*G[2]+y*G[1]];\n\njulia> a1 = hom(F1, G, V1);\n\njulia> a2 = hom(F2, G, V2);\n\njulia> M = subquotient(a1,a2);\n\njulia> m1 = x*M[1]+y*M[2]+z*M[3]\n(2*x*y + y^2)*e[1] + (y^2 + z^2)*e[2]\n\njulia> is_homogeneous(m1)\ntrue\n\njulia> is_homogeneous(zero(M))\ntrue\n\njulia> m2 = M[1]+x*M[2]\n(x^2 + x*y + y)*e[1] + x*y*e[2]\n\njulia> is_homogeneous(m2)\nfalse\n\njulia> m3 = x*M[1]+M[2]+x*M[3]\n(x*y + x + y)*e[1] + (x*z + y)*e[2]\n\njulia> is_homogeneous(m3)\ntrue\n\njulia> simplify(m3)\nx*e[1] + (y - z)*e[2]\n\n\n\n\n\n","category":"method"},{"location":"CommutativeAlgebra/ModulesOverMultivariateRings/subquotients/","page":"Subquotients","title":"Subquotients","text":"degree(m::SubquoModuleElem)","category":"page"},{"location":"CommutativeAlgebra/ModulesOverMultivariateRings/subquotients/#degree-Tuple{SubquoModuleElem}","page":"Subquotients","title":"degree","text":"degree(m::SubquoModuleElem; check::Bool=true)\n\nGiven a homogeneous element m of a graded subquotient, return the degree of m.\n\ndegree(::Type{Vector{Int}}, m::SubquoModuleElem)\n\nGiven a homogeneous element m of a mathbb Z^m-graded subquotient, return the degree of m, converted to a vector of integer numbers.\n\ndegree(::Type{Int}, m::SubquoModuleElem)\n\nGiven a homogeneous element m of a mathbb Z-graded subquotient, return the degree of m, converted to an integer number.\n\nExamples\n\njulia> Rg, (x, y, z) = graded_polynomial_ring(QQ, [:x, :y, :z]);\n\njulia> F1 = graded_free_module(Rg, [2,2,2]);\n\njulia> F2 = graded_free_module(Rg, [2]);\n\njulia> G = graded_free_module(Rg, [1,1]);\n\njulia> V1 = [y*G[1], (x+y)*G[1]+y*G[2], z*G[2]];\n\njulia> V2 = [z*G[2]+y*G[1]];\n\njulia> a1 = hom(F1, G, V1);\n\njulia> a2 = hom(F2, G, V2);\n\njulia> M = subquotient(a1,a2);\n\njulia> m = x*y*z*M[1]\nx*y^2*z*e[1]\n\njulia> degree(m)\n[5]\n\njulia> degree(Int, m)\n5\n\njulia> m3 = x*M[1]+M[2]+x*M[3]\n(x*y + x + y)*e[1] + (x*z + y)*e[2]\n\njulia> degree(m3)\n[2]\n\n\n\n\n\n","category":"method"},{"location":"CommutativeAlgebra/ModulesOverMultivariateRings/subquotients/#Tests-on-Subqotients","page":"Subquotients","title":"Tests on Subqotients","text":"","category":"section"},{"location":"CommutativeAlgebra/ModulesOverMultivariateRings/subquotients/","page":"Subquotients","title":"Subquotients","text":"The functions is_graded, is_standard_graded, is_z_graded, and is_zm_graded carry over analogously to subquotients. They return true if the respective property is satisfied, and false otherwise. In addition, we have:","category":"page"},{"location":"CommutativeAlgebra/ModulesOverMultivariateRings/subquotients/","page":"Subquotients","title":"Subquotients","text":"==(M::SubquoModule{T}, N::SubquoModule{T}) where T","category":"page"},{"location":"CommutativeAlgebra/ModulesOverMultivariateRings/subquotients/#==-Union{Tuple{T}, Tuple{SubquoModule{T}, SubquoModule{T}}} where T","page":"Subquotients","title":"==","text":"==(M::SubquoModule{T}, N::SubquoModule{T}) where {T}\n\nGiven subquotients M and N such that ambient_module(M) == ambient_module(N), return true if M equals N, where M and N are regarded as submodules  of the common ambient module.\n\nHere, ambient_module(M) == ambient_module(N) if\n\nambient_free_module(M) === ambient_free_module(N), and\nthe submodules of the common ambient free module generated by the relations of M and N, respectively, are equal.\n\nExamples\n\njulia> R, (x, y, z) = polynomial_ring(QQ, [:x, :y, :z])\n(Multivariate polynomial ring in 3 variables over QQ, QQMPolyRingElem[x, y, z])\n\njulia> F = free_module(R, 1)\nFree module of rank 1 over R\n\njulia> AM = R[x;]\n[x]\n\njulia> BM = R[x^2; y^3; z^4]\n[x^2]\n[y^3]\n[z^4]\n\njulia> M = SubquoModule(F, AM, BM)\nSubquotient of submodule with 1 generator\n  1: x*e[1]\nby submodule with 3 generators\n  1: x^2*e[1]\n  2: y^3*e[1]\n  3: z^4*e[1]\n\njulia> AN = R[x; y]\n[x]\n[y]\n\njulia> BN = R[x^2+y^4; y^3; z^4]\n[x^2 + y^4]\n[      y^3]\n[      z^4]\n\njulia> N = SubquoModule(F, AN, BN)\nSubquotient of submodule with 2 generators\n  1: x*e[1]\n  2: y*e[1]\nby submodule with 3 generators\n  1: (x^2 + y^4)*e[1]\n  2: y^3*e[1]\n  3: z^4*e[1]\n\njulia> M == N\nfalse\n\njulia> Rg, (x, y, z) = graded_polynomial_ring(QQ, [:x, :y, :z]);\n\njulia> F = graded_free_module(Rg, 2);\n\njulia> O1 = [x*F[1]+y*F[2],y*F[2]];\n\njulia> O1a = [x*F[1],y*F[2]];\n\njulia> O2 = [x^2*F[1]+y^2*F[2],y^2*F[2]];\n\njulia> M1 = SubquoModule(F, O1, O2)\nGraded subquotient of graded submodule of F with 2 generators\n  1: x*e[1] + y*e[2]\n  2: y*e[2]\nby graded submodule of F with 2 generators\n  1: x^2*e[1] + y^2*e[2]\n  2: y^2*e[2]\n\njulia> M2 = SubquoModule(F, O1a, O2)\nGraded subquotient of graded submodule of F with 2 generators\n  1: x*e[1]\n  2: y*e[2]\nby graded submodule of F with 2 generators\n  1: x^2*e[1] + y^2*e[2]\n  2: y^2*e[2]\n\njulia> M1 == M2\ntrue\n\n\n\n\n\n","category":"method"},{"location":"CommutativeAlgebra/ModulesOverMultivariateRings/subquotients/","page":"Subquotients","title":"Subquotients","text":"is_subset(M::SubquoModule{T}, N::SubquoModule{T}) where T","category":"page"},{"location":"CommutativeAlgebra/ModulesOverMultivariateRings/subquotients/#is_subset-Union{Tuple{T}, Tuple{SubquoModule{T}, SubquoModule{T}}} where T","page":"Subquotients","title":"is_subset","text":"is_subset(M::SubquoModule{T}, N::SubquoModule{T}) where T\n\nGiven subquotients M and N such that ambient_module(M) == ambient_module(N), return true if M is contained in N, where M and N are regarded as submodules  of the common ambient module.\n\nExamples\n\njulia> R, (x, y, z) = polynomial_ring(QQ, [:x, :y, :z])\n(Multivariate polynomial ring in 3 variables over QQ, QQMPolyRingElem[x, y, z])\n\njulia> F = free_module(R, 1)\nFree module of rank 1 over R\n\njulia> AM = R[x;]\n[x]\n\njulia> BM = R[x^2; y^3; z^4]\n[x^2]\n[y^3]\n[z^4]\n\njulia> M = SubquoModule(F, AM, BM)\nSubquotient of submodule with 1 generator\n  1: x*e[1]\nby submodule with 3 generators\n  1: x^2*e[1]\n  2: y^3*e[1]\n  3: z^4*e[1]\n\njulia> AN = R[x; y]\n[x]\n[y]\n\njulia> BN = R[x^2+y^4; y^3; z^4]\n[x^2 + y^4]\n[      y^3]\n[      z^4]\n\njulia> N = SubquoModule(F, AN, BN)\nSubquotient of submodule with 2 generators\n  1: x*e[1]\n  2: y*e[1]\nby submodule with 3 generators\n  1: (x^2 + y^4)*e[1]\n  2: y^3*e[1]\n  3: z^4*e[1]\n\njulia> is_subset(M, N)\ntrue\n\njulia> Rg, (x, y, z) = graded_polynomial_ring(QQ, [:x, :y, :z]);\n\njulia> F = graded_free_module(Rg, 2);\n\njulia> O1 = [x*F[1]+y*F[2],y*F[2]];\n\njulia> O1a = [x*F[1],y*F[2]];\n\njulia> O2 = [x^2*F[1]+y^2*F[2],y^2*F[2]];\n\njulia> M1 = SubquoModule(F, O1, O2)\nGraded subquotient of graded submodule of F with 2 generators\n  1: x*e[1] + y*e[2]\n  2: y*e[2]\nby graded submodule of F with 2 generators\n  1: x^2*e[1] + y^2*e[2]\n  2: y^2*e[2]\n\njulia> M2 = SubquoModule(F, O1a, O2)\nGraded subquotient of graded submodule of F with 2 generators\n  1: x*e[1]\n  2: y*e[2]\nby graded submodule of F with 2 generators\n  1: x^2*e[1] + y^2*e[2]\n  2: y^2*e[2]\n\njulia> is_subset(M1,M2)\ntrue\n\njulia> is_subset(M2,M1)\ntrue\n\njulia> M1 == M2\ntrue\n\n\n\n\n\n","category":"method"},{"location":"CommutativeAlgebra/ModulesOverMultivariateRings/subquotients/","page":"Subquotients","title":"Subquotients","text":"is_zero(M::SubquoModule)","category":"page"},{"location":"CommutativeAlgebra/ModulesOverMultivariateRings/subquotients/#is_zero-Tuple{SubquoModule}","page":"Subquotients","title":"is_zero","text":"is_zero(M::SubquoModule)\n\nReturn true if M is the zero module, false otherwise.\n\nExamples\n\njulia> R, (x, y, z) = polynomial_ring(QQ, [:x, :y, :z])\n(Multivariate polynomial ring in 3 variables over QQ, QQMPolyRingElem[x, y, z])\n\njulia> F = free_module(R, 1)\nFree module of rank 1 over R\n\njulia> A = R[x^2+y^2;]\n[x^2 + y^2]\n\njulia> B = R[x^2; y^3; z^4]\n[x^2]\n[y^3]\n[z^4]\n\njulia> M = SubquoModule(F, A, B)\nSubquotient of submodule with 1 generator\n  1: (x^2 + y^2)*e[1]\nby submodule with 3 generators\n  1: x^2*e[1]\n  2: y^3*e[1]\n  3: z^4*e[1]\n\njulia> is_zero(M)\nfalse\n\n\n\n\n\n","category":"method"},{"location":"CommutativeAlgebra/ModulesOverMultivariateRings/subquotients/#Basic-Operations-on-Subquotients","page":"Subquotients","title":"Basic Operations on Subquotients","text":"","category":"section"},{"location":"CommutativeAlgebra/ModulesOverMultivariateRings/subquotients/","page":"Subquotients","title":"Subquotients","text":":+(M::SubquoModule{T},N::SubquoModule{T}) where T","category":"page"},{"location":"CommutativeAlgebra/ModulesOverMultivariateRings/subquotients/#+-Union{Tuple{T}, Tuple{SubquoModule{T}, SubquoModule{T}}} where T","page":"Subquotients","title":"+","text":"+(M::SubquoModule{T},N::SubquoModule{T}) where T\n\nGiven subquotients M and N such that ambient_module(M) == ambient_module(N), return the sum of M and N regarded as submodules of the common ambient module. \n\nExamples\n\njulia> R, (x, y, z) = polynomial_ring(QQ, [:x, :y, :z])\n(Multivariate polynomial ring in 3 variables over QQ, QQMPolyRingElem[x, y, z])\n\njulia> F = free_module(R, 1)\nFree module of rank 1 over R\n\njulia> AM = R[x;]\n[x]\n\njulia> BM = R[x^2; y^3; z^4]\n[x^2]\n[y^3]\n[z^4]\n\njulia> M = SubquoModule(F, AM, BM)\nSubquotient of submodule with 1 generator\n  1: x*e[1]\nby submodule with 3 generators\n  1: x^2*e[1]\n  2: y^3*e[1]\n  3: z^4*e[1]\n\njulia> AN = R[y;]\n[y]\n\njulia> BN = R[x^2; y^3; z^4]\n[x^2]\n[y^3]\n[z^4]\n\njulia> N = SubquoModule(F, AN, BN)\nSubquotient of submodule with 1 generator\n  1: y*e[1]\nby submodule with 3 generators\n  1: x^2*e[1]\n  2: y^3*e[1]\n  3: z^4*e[1]\n\njulia> O = M + N\nSubquotient of submodule with 2 generators\n  1: x*e[1]\n  2: y*e[1]\nby submodule with 3 generators\n  1: x^2*e[1]\n  2: y^3*e[1]\n  3: z^4*e[1]\n\njulia> Rg, (x, y, z) = graded_polynomial_ring(QQ, [:x, :y, :z]);\n\njulia> F = graded_free_module(Rg, 1);\n\njulia> AM = Rg[x;];\n\njulia> BM = Rg[x^2; y^3; z^4];\n\njulia> M = SubquoModule(F, AM, BM)\nGraded subquotient of graded submodule of F with 1 generator\n  1: x*e[1]\nby graded submodule of F with 3 generators\n  1: x^2*e[1]\n  2: y^3*e[1]\n  3: z^4*e[1]\n\njulia> AN = Rg[y;];\n\njulia> BN = Rg[x^2; y^3; z^4];\n\njulia> N = SubquoModule(F, AN, BN)\nGraded subquotient of graded submodule of F with 1 generator\n  1: y*e[1]\nby graded submodule of F with 3 generators\n  1: x^2*e[1]\n  2: y^3*e[1]\n  3: z^4*e[1]\n\njulia> M + N\nGraded subquotient of graded submodule of F with 2 generators\n  1: x*e[1]\n  2: y*e[1]\nby graded submodule of F with 3 generators\n  1: x^2*e[1]\n  2: y^3*e[1]\n  3: z^4*e[1]\n\n\n\n\n\n\n","category":"method"},{"location":"CommutativeAlgebra/ModulesOverMultivariateRings/subquotients/","page":"Subquotients","title":"Subquotients","text":"sum(M::SubquoModule{T},N::SubquoModule{T}) where T","category":"page"},{"location":"CommutativeAlgebra/ModulesOverMultivariateRings/subquotients/#sum-Union{Tuple{T}, Tuple{SubquoModule{T}, SubquoModule{T}}} where T","page":"Subquotients","title":"sum","text":"sum(M::SubquoModule{T},N::SubquoModule{T}) where T\n\nGiven subquotients M and N such that ambient_module(M) == ambient_module(N), return the sum of M and N regarded as submodules of the common ambient module.\n\nAdditionally, return the inclusion maps M to M + N and N to M + N.\n\nExamples\n\njulia> R, (x, y, z) = polynomial_ring(QQ, [:x, :y, :z])\n(Multivariate polynomial ring in 3 variables over QQ, QQMPolyRingElem[x, y, z])\n\njulia> F = free_module(R, 1)\nFree module of rank 1 over R\n\njulia> AM = R[x;]\n[x]\n\njulia> BM = R[x^2; y^3; z^4]\n[x^2]\n[y^3]\n[z^4]\n\njulia> M = SubquoModule(F, AM, BM)\nSubquotient of submodule with 1 generator\n  1: x*e[1]\nby submodule with 3 generators\n  1: x^2*e[1]\n  2: y^3*e[1]\n  3: z^4*e[1]\n\njulia> AN = R[y;]\n[y]\n\njulia> BN = R[x^2; y^3; z^4]\n[x^2]\n[y^3]\n[z^4]\n\njulia> N = SubquoModule(F, AN, BN)\nSubquotient of submodule with 1 generator\n  1: y*e[1]\nby submodule with 3 generators\n  1: x^2*e[1]\n  2: y^3*e[1]\n  3: z^4*e[1]\n\njulia> O = sum(M, N);\n\njulia> O[1]\nSubquotient of submodule with 2 generators\n  1: x*e[1]\n  2: y*e[1]\nby submodule with 3 generators\n  1: x^2*e[1]\n  2: y^3*e[1]\n  3: z^4*e[1]\n\njulia> O[2]\nModule homomorphism\n  from M\n  to subquotient of submodule with 2 generators\n    1: x*e[1]\n    2: y*e[1]\n  by submodule with 3 generators\n    1: x^2*e[1]\n    2: y^3*e[1]\n    3: z^4*e[1]\n\njulia> O[3]\nModule homomorphism\n  from N\n  to subquotient of submodule with 2 generators\n    1: x*e[1]\n    2: y*e[1]\n  by submodule with 3 generators\n    1: x^2*e[1]\n    2: y^3*e[1]\n    3: z^4*e[1]\n\njulia> Rg, (x, y, z) = graded_polynomial_ring(QQ, [:x, :y, :z]);\n\njulia> F = graded_free_module(Rg, 1);\n\njulia> AM = Rg[x;];\n\njulia> BM = Rg[x^2; y^3; z^4];\n\njulia> M = SubquoModule(F, AM, BM)\nGraded subquotient of graded submodule of F with 1 generator\n  1: x*e[1]\nby graded submodule of F with 3 generators\n  1: x^2*e[1]\n  2: y^3*e[1]\n  3: z^4*e[1]\n\njulia> AN = Rg[y;];\n\njulia> BN = Rg[x^2; y^3; z^4];\n\njulia> N = SubquoModule(F, AN, BN)\nGraded subquotient of graded submodule of F with 1 generator\n  1: y*e[1]\nby graded submodule of F with 3 generators\n  1: x^2*e[1]\n  2: y^3*e[1]\n  3: z^4*e[1]\n\njulia> sum(M, N)\n(Graded subquotient of graded submodule of F with 2 generators\n  1: x*e[1]\n  2: y*e[1]\nby graded submodule of F with 3 generators\n  1: x^2*e[1]\n  2: y^3*e[1]\n  3: z^4*e[1], Hom: M -> graded subquotient of graded submodule of F with 2 generators\n  1: x*e[1]\n  2: y*e[1]\nby graded submodule of F with 3 generators\n  1: x^2*e[1]\n  2: y^3*e[1]\n  3: z^4*e[1], Hom: N -> graded subquotient of graded submodule of F with 2 generators\n  1: x*e[1]\n  2: y*e[1]\nby graded submodule of F with 3 generators\n  1: x^2*e[1]\n  2: y^3*e[1]\n  3: z^4*e[1])\n\n\n\n\n\n\n","category":"method"},{"location":"CommutativeAlgebra/ModulesOverMultivariateRings/subquotients/","page":"Subquotients","title":"Subquotients","text":"intersect(M::SubquoModule{T}, N::SubquoModule{T}) where T","category":"page"},{"location":"CommutativeAlgebra/ModulesOverMultivariateRings/subquotients/#intersect-Union{Tuple{T}, Tuple{SubquoModule{T}, SubquoModule{T}}} where T","page":"Subquotients","title":"intersect","text":"intersect(M::SubquoModule{T}, N::SubquoModule{T}) where T\n\nGiven subquotients M and N such that ambient_module(M) == ambient_module(N), return the intersection of M and N regarded as submodules of the common ambient module.\n\nAdditionally, return the inclusion maps M cap N to M and M cap N to N.\n\nExamples\n\njulia> R, (x, y, z) = polynomial_ring(QQ, [:x, :y, :z])\n(Multivariate polynomial ring in 3 variables over QQ, QQMPolyRingElem[x, y, z])\n\njulia> F = free_module(R, 1)\nFree module of rank 1 over R\n\njulia> AM = R[x;]\n[x]\n\njulia> BM = R[x^2; y^3; z^4]\n[x^2]\n[y^3]\n[z^4]\n\njulia> M = SubquoModule(F, AM, BM)\nSubquotient of submodule with 1 generator\n  1: x*e[1]\nby submodule with 3 generators\n  1: x^2*e[1]\n  2: y^3*e[1]\n  3: z^4*e[1]\n\njulia> AN = R[y;]\n[y]\n\njulia> BN = R[x^2; y^3; z^4]\n[x^2]\n[y^3]\n[z^4]\n\njulia> N = SubquoModule(F, AN, BN)\nSubquotient of submodule with 1 generator\n  1: y*e[1]\nby submodule with 3 generators\n  1: x^2*e[1]\n  2: y^3*e[1]\n  3: z^4*e[1]\n\njulia> intersect(M, N)\n(Subquotient of submodule with 2 generators\n  1: -x*y*e[1]\n  2: x*z^4*e[1]\nby submodule with 3 generators\n  1: x^2*e[1]\n  2: y^3*e[1]\n  3: z^4*e[1], Hom: subquotient of submodule with 2 generators\n  1: -x*y*e[1]\n  2: x*z^4*e[1]\nby submodule with 3 generators\n  1: x^2*e[1]\n  2: y^3*e[1]\n  3: z^4*e[1] -> M, Hom: subquotient of submodule with 2 generators\n  1: -x*y*e[1]\n  2: x*z^4*e[1]\nby submodule with 3 generators\n  1: x^2*e[1]\n  2: y^3*e[1]\n  3: z^4*e[1] -> N)\n\njulia> Rg, (x, y, z) = graded_polynomial_ring(QQ, [:x, :y, :z]);\n\njulia> F = graded_free_module(Rg, 1);\n\njulia> AM = Rg[x;];\n\njulia> BM = Rg[x^2; y^3; z^4];\n\njulia> M = SubquoModule(F, AM, BM)\nGraded subquotient of graded submodule of F with 1 generator\n  1: x*e[1]\nby graded submodule of F with 3 generators\n  1: x^2*e[1]\n  2: y^3*e[1]\n  3: z^4*e[1]\n\njulia> AN = Rg[y;];\n\njulia> BN = Rg[x^2; y^3; z^4];\n\njulia> N = SubquoModule(F, AN, BN)\nGraded subquotient of graded submodule of F with 1 generator\n  1: y*e[1]\nby graded submodule of F with 3 generators\n  1: x^2*e[1]\n  2: y^3*e[1]\n  3: z^4*e[1]\n\njulia> intersect(M, N)\n(Graded subquotient of graded submodule of F with 2 generators\n  1: -x*y*e[1]\n  2: x*z^4*e[1]\nby graded submodule of F with 3 generators\n  1: x^2*e[1]\n  2: y^3*e[1]\n  3: z^4*e[1], Hom: graded subquotient of graded submodule of F with 2 generators\n  1: -x*y*e[1]\n  2: x*z^4*e[1]\nby graded submodule of F with 3 generators\n  1: x^2*e[1]\n  2: y^3*e[1]\n  3: z^4*e[1] -> M, Hom: graded subquotient of graded submodule of F with 2 generators\n  1: -x*y*e[1]\n  2: x*z^4*e[1]\nby graded submodule of F with 3 generators\n  1: x^2*e[1]\n  2: y^3*e[1]\n  3: z^4*e[1] -> N)\n\n\n\n\n\n\n","category":"method"},{"location":"CommutativeAlgebra/ModulesOverMultivariateRings/subquotients/","page":"Subquotients","title":"Subquotients","text":"annihilator(N::SubquoModule{T}) where T","category":"page"},{"location":"CommutativeAlgebra/ModulesOverMultivariateRings/subquotients/#annihilator-Union{Tuple{SubquoModule{T}}, Tuple{T}} where T","page":"Subquotients","title":"annihilator","text":" annihilator(N::SubquoModule{T}) where T\n\nReturn the annihilator of N.\n\nnote: Note\nBy definition, the annihilator of N is the ideal 0N = a in R mid aN = 0.  Here, R = base_ring(N).\n\nExamples\n\njulia> R, (x, y, z) = polynomial_ring(QQ, [:x, :y, :z]);\n\njulia> F = free_module(R, 1);\n\njulia> AN = R[y;];\n\njulia> BN = R[x^2; y^3; z^4];\n\njulia> N = SubquoModule(F, AN, BN)\nSubquotient of submodule with 1 generator\n  1: y*e[1]\nby submodule with 3 generators\n  1: x^2*e[1]\n  2: y^3*e[1]\n  3: z^4*e[1]\n\njulia> J = annihilator(N)\nIdeal generated by\n  y^2\n  x^2\n  z^4\n\n\njulia> S, (x, y, z) = polynomial_ring(QQ, [:x, :y, :z]);\n\njulia> I = ideal(S, [x*y*z])\nIdeal generated by\n  x*y*z\n\njulia> R, _ = quo(S, I)\n(Quotient of multivariate polynomial ring by ideal (x*y*z), Map: S -> R)\n\njulia> F = free_module(R, 1);\n\njulia> AN = R[y;];\n\njulia> BN = R[x^2; y^3; z^4];\n\njulia> N = SubquoModule(F, AN, BN)\nSubquotient of submodule with 1 generator\n  1: y*e[1]\nby submodule with 3 generators\n  1: x^2*e[1]\n  2: y^3*e[1]\n  3: z^4*e[1]\n\njulia> J = annihilator(N)\nIdeal generated by\n  x*z\n  y^2\n  x^2\n  z^4\n\n\n\n\n\n","category":"method"},{"location":"CommutativeAlgebra/ModulesOverMultivariateRings/subquotients/","page":"Subquotients","title":"Subquotients","text":"quotient(M::SubquoModule{T}, N::SubquoModule{T}) where T","category":"page"},{"location":"CommutativeAlgebra/ModulesOverMultivariateRings/subquotients/#quotient-Union{Tuple{T}, Tuple{SubquoModule{T}, SubquoModule{T}}} where T","page":"Subquotients","title":"quotient","text":"quotient(M::SubquoModule{T}, N::SubquoModule{T}) where T\n\nGiven subquotients M and N such that ambient_module(M) == ambient_module(N), return the module quotient of M by N regarded as submodules of the common ambient module.\n\nAlternatively, use M:N.\n\nnote: Note\nBy definition, MN = a in R mid aN subset M. Here, R = base_ring(M) = base_ring(N).\n\nExamples\n\njulia> R, (x, y, z) = graded_polynomial_ring(QQ, [:x, :y, :z]);\n\njulia> F = graded_free_module(R, 1);\n\njulia> B = R[x^2; y^3; z^4];\n\njulia> AM = R[x;];\n\njulia> M = SubquoModule(F, AM, B)\nGraded subquotient of graded submodule of F with 1 generator\n  1: x*e[1]\nby graded submodule of F with 3 generators\n  1: x^2*e[1]\n  2: y^3*e[1]\n  3: z^4*e[1]\n\njulia> AN = R[y;];\n\njulia> N = SubquoModule(F, AN, B)\nGraded subquotient of graded submodule of F with 1 generator\n  1: y*e[1]\nby graded submodule of F with 3 generators\n  1: x^2*e[1]\n  2: y^3*e[1]\n  3: z^4*e[1]\n\njulia> L = quotient(M, N)\nIdeal generated by\n  x\n  y^2\n  z^4\n\n\n\n\n\n\n","category":"method"},{"location":"CommutativeAlgebra/ModulesOverMultivariateRings/subquotients/","page":"Subquotients","title":"Subquotients","text":"quotient(M::SubquoModule, J::Ideal)","category":"page"},{"location":"CommutativeAlgebra/ModulesOverMultivariateRings/subquotients/#quotient-Tuple{SubquoModule, Ideal}","page":"Subquotients","title":"quotient","text":" quotient(M::SubquoModule, J::Ideal)\n\nReturn the quotient of M by J.\n\nAlternatively, use M:J.\n\nnote: Note\nBy definition, MJ = a in A mid Ja subset M. Here, A is the ambient module of M.\n\nExamples\n\njulia> R, (x, y, z) = polynomial_ring(QQ, [:x, :y, :z]);\n\njulia> F = free_module(R, 1);\n\njulia> AM = R[x;];\n\njulia> BM = R[x^2; y^3; z^4];\n\njulia> M = SubquoModule(F, AM, BM)\nSubquotient of submodule with 1 generator\n  1: x*e[1]\nby submodule with 3 generators\n  1: x^2*e[1]\n  2: y^3*e[1]\n  3: z^4*e[1]\n\njulia> J = ideal(R, [x, y, z])^2\nIdeal generated by\n  x^2\n  x*y\n  x*z\n  y^2\n  y*z\n  z^2\n\njulia> L = quotient(M, J)\nSubquotient of submodule with 3 generators\n  1: x*e[1]\n  2: y*z^3*e[1]\n  3: y^2*z^2*e[1]\nby submodule with 3 generators\n  1: x^2*e[1]\n  2: y^3*e[1]\n  3: z^4*e[1]\n\njulia> ambient_free_module(L) == ambient_free_module(M)\ntrue\n\n\njulia> S, (x, y, z) = polynomial_ring(QQ, [:x, :y, :z]);\n\njulia> R, _ = quo(S, ideal(S, [x+y+z]));\n\njulia> F = free_module(R, 1);\n\njulia> AM = R[x;];\n\njulia> BM = R[x^2; y^3; z^4];\n\njulia> M = SubquoModule(F, AM, BM)\nSubquotient of submodule with 1 generator\n  1: (-y - z)*e[1]\nby submodule with 3 generators\n  1: (y^2 + 2*y*z + z^2)*e[1]\n  2: y^3*e[1]\n  3: z^4*e[1]\n\njulia> J = ideal(R, [x, y, z])^2\nIdeal generated by\n  x^2\n  x*y\n  x*z\n  y^2\n  y*z\n  z^2\n\njulia> quotient(M, J)\nSubquotient of submodule with 2 generators\n  1: z*e[1]\n  2: y*e[1]\nby submodule with 3 generators\n  1: (y^2 + 2*y*z + z^2)*e[1]\n  2: y^3*e[1]\n  3: z^4*e[1]\n\n\n\n\n\n\n","category":"method"},{"location":"CommutativeAlgebra/ModulesOverMultivariateRings/subquotients/","page":"Subquotients","title":"Subquotients","text":"saturation(M:: SubquoModule, J::Ideal)","category":"page"},{"location":"CommutativeAlgebra/ModulesOverMultivariateRings/subquotients/#saturation-Tuple{SubquoModule, Ideal}","page":"Subquotients","title":"saturation","text":" saturation(M::SubquoModule,\n           J::Ideal = ideal(base_ring(M), gens(base_ring(M)));\n           iteration::Bool = false)\n\nReturn the saturation MJ^infty of M with respect to J.\n\nIf the ideal J is not given, the ideal generated by the generators (variables) of base_ring(M) is used.\n\nSetting iteration to true only has an effect over rings of type MPolyRing or MPolyQuoRing. Over such rings, if iteration is set to true, the saturation is done by carrying out successive ideal quotient computations as suggested by the definition of saturation. Otherwise, a more sophisticated Gröbner basis approach is used which is typically faster. Applying the two approaches may lead to different generating sets of the saturation.\n\nnote: Note\nBy definition, MJ^infty =  a in A mid J^ka subset M text for some  kgeq 1  = bigcuplimits_k=1^infty (MJ^k) Here, A is the ambient module of M.\n\nExamples\n\njulia> R, (x, y, z) = polynomial_ring(QQ, [:x, :y, :z]);\n\njulia> F = free_module(R, 1);\n\njulia> AM = R[x;];\n\njulia> BM = R[x^2; y^3; z^4];\n\njulia> M = SubquoModule(F, AM, BM)\nSubquotient of submodule with 1 generator\n  1: x*e[1]\nby submodule with 3 generators\n  1: x^2*e[1]\n  2: y^3*e[1]\n  3: z^4*e[1]\n\njulia> J = ideal(R, [x, y, z])^2\nIdeal generated by\n  x^2\n  x*y\n  x*z\n  y^2\n  y*z\n  z^2\n\njulia> saturation(M, J)\nSubquotient of submodule with 1 generator\n  1: e[1]\nby submodule with 3 generators\n  1: x^2*e[1]\n  2: y^3*e[1]\n  3: z^4*e[1]\n\n\n\n\n\n\n","category":"method"},{"location":"CommutativeAlgebra/ModulesOverMultivariateRings/subquotients/","page":"Subquotients","title":"Subquotients","text":"saturation_with_index(M:: SubquoModule, J::Ideal)","category":"page"},{"location":"CommutativeAlgebra/ModulesOverMultivariateRings/subquotients/#saturation_with_index-Tuple{SubquoModule, Ideal}","page":"Subquotients","title":"saturation_with_index","text":" saturation_with_index(M::SubquoModule,\n           J::MPolyIdeal = ideal(base_ring(M), gens(base_ring(M)));\n           iteration::Bool = false)\n\nReturn the saturation MJ^infty of M with respect to J and the smallest integer k such that IJ^k = IJ^infty (saturation index).\n\nIf the ideal J is not given, the ideal generated by the generators (variables) of base_ring(M) is used.\n\nSetting iteration to true only has an effect over rings of type MPolyRing or MPolyQuoRing. Over such rings, if iteration is set to true, the saturation is done by carrying out successive module quotient computations as suggested by the definition of saturation. Otherwise, a more sophisticated Gröbner basis approach is used which is typically faster. Applying the two approaches may lead to different generating sets of the saturation.\n\nnote: Note\nBy definition, MJ^infty =  a in A mid J^ka subset M text for some  kgeq 1  = bigcuplimits_k=1^infty (MJ^k) Here, A is the ambient module of M.\n\nExamples\n\njulia> R, (x, y, z) = polynomial_ring(QQ, [:x, :y, :z]);\n\njulia> F = free_module(R, 1);\n\njulia> AM = R[x;];\n\njulia> BM = R[x^2; y^3; z^4];\n\njulia> M = SubquoModule(F, AM, BM)\nSubquotient of submodule with 1 generator\n  1: x*e[1]\nby submodule with 3 generators\n  1: x^2*e[1]\n  2: y^3*e[1]\n  3: z^4*e[1]\n\njulia> J = ideal(R, [x, y, z])^2\nIdeal generated by\n  x^2\n  x*y\n  x*z\n  y^2\n  y*z\n  z^2\n\njulia> L = saturation_with_index(M, J);\n\njulia> L[1]\nSubquotient of submodule with 1 generator\n  1: e[1]\nby submodule with 3 generators\n  1: x^2*e[1]\n  2: y^3*e[1]\n  3: z^4*e[1]\n\njulia> L[2]\n3\n\n\njulia> S, (x, y, z) = polynomial_ring(QQ, [:x, :y, :z]);\n\njulia> R, _ = quo(S, ideal(S, [x+y+z]));\n\njulia> F = free_module(R, 1);\n\njulia> AM = R[x;];\n\njulia> BM = R[x^2; y^3; z^4];\n\njulia> M = SubquoModule(F, AM, BM)\nSubquotient of submodule with 1 generator\n  1: (-y - z)*e[1]\nby submodule with 3 generators\n  1: (y^2 + 2*y*z + z^2)*e[1]\n  2: y^3*e[1]\n  3: z^4*e[1]\n\njulia> J = ideal(R, [x, y, z])^2\nIdeal generated by\n  x^2\n  x*y\n  x*z\n  y^2\n  y*z\n  z^2\n\njulia> L = saturation_with_index(M, J);\n\njulia> L[1]\nSubquotient of submodule with 1 generator\n  1: e[1]\nby submodule with 3 generators\n  1: (y^2 + 2*y*z + z^2)*e[1]\n  2: y^3*e[1]\n  3: z^4*e[1]\n\njulia> L[2]\n2\n\n\n\n\n\n\n","category":"method"},{"location":"CommutativeAlgebra/ModulesOverMultivariateRings/subquotients/#Submodules-and-Quotients","page":"Subquotients","title":"Submodules and Quotients","text":"","category":"section"},{"location":"CommutativeAlgebra/ModulesOverMultivariateRings/subquotients/","page":"Subquotients","title":"Subquotients","text":"sub(M::ModuleFP{T}, V::Vector{<:ModuleFPElem{T}}) where T","category":"page"},{"location":"CommutativeAlgebra/ModulesOverMultivariateRings/subquotients/#sub-Union{Tuple{T}, Tuple{ModuleFP{T}, Vector{<:ModuleFPElem{T}}}} where T","page":"Subquotients","title":"sub","text":"sub(M::ModuleFP{T}, V::Vector{<:ModuleFPElem{T}}; cache_morphism::Bool=false) where T\n\nGiven a vector V of (homogeneous) elements of M, return the (graded) submodule I of M generated by these elements together with its inclusion map `inc : I ↪ M.\n\nWhen cache_morphism is set to true, then inc will be cached and available for transport and friends.\n\nIf only the submodule itself is desired, use sub_object instead.\n\nExamples\n\njulia> R, (x, y, z) = polynomial_ring(QQ, [:x, :y, :z]);\n\njulia> F = free_module(R, 1);\n\njulia> V = [x^2*F[1]; y^3*F[1]; z^4*F[1]];\n\njulia> N, incl = sub(F, V);\n\njulia> N\nSubmodule with 3 generators\n  1: x^2*e[1]\n  2: y^3*e[1]\n  3: z^4*e[1]\nrepresented as subquotient with no relations\n\njulia> incl\nModule homomorphism\n  from N\n  to F\n\n\n\n\n\n","category":"method"},{"location":"CommutativeAlgebra/ModulesOverMultivariateRings/subquotients/","page":"Subquotients","title":"Subquotients","text":"quo(M::ModuleFP{T}, V::Vector{<:ModuleFPElem{T}}; cache_morphism::Bool=false) where T","category":"page"},{"location":"CommutativeAlgebra/ModulesOverMultivariateRings/subquotients/#quo-Union{Tuple{T}, Tuple{ModuleFP{T}, Vector{<:ModuleFPElem{T}}}} where T","page":"Subquotients","title":"quo","text":"quo(M::ModuleFP{T}, V::Vector{<:ModuleFPElem{T}}; cache_morphism::Bool=false) where T\n\nGiven a vector V of (homogeneous) elements of M, return a pair (N, pr) consisting of the quotient N = M/⟨V⟩ and the projection map pr : M → N.\n\nIf one is only interested in the actual object M, but not the map, use quo_object instead.\n\nIf cache_morphism is set to true, the projection is cached and available to transport and friends.\n\nExamples\n\njulia> R, (x, y, z) = polynomial_ring(QQ, [:x, :y, :z]);\n\njulia> F = free_module(R, 1);\n\njulia> V = [x^2*F[1]; y^3*F[1]; z^4*F[1]];\n\njulia> N, proj = quo(F, V);\n\njulia> N\nSubquotient of submodule with 1 generator\n  1: e[1]\nby submodule with 3 generators\n  1: x^2*e[1]\n  2: y^3*e[1]\n  3: z^4*e[1]\n\njulia> proj\nModule homomorphism\n  from F\n  to N\n\n\n\n\n\n","category":"method"},{"location":"CommutativeAlgebra/ModulesOverMultivariateRings/subquotients/#Homomorphisms-From-Subqotients","page":"Subquotients","title":"Homomorphisms From Subqotients","text":"","category":"section"},{"location":"CommutativeAlgebra/ModulesOverMultivariateRings/subquotients/","page":"Subquotients","title":"Subquotients","text":"All OSCAR types for homomorphisms of finitely presented modules considered here belong to the abstract type ModuleFPHom{T1, T2}, where T1 and T2 are the types of domain and codomain respectively. For homomorphisms from subquotients, OSCAR provides the concrete type SubQuoHom{T1, T2} <: ModuleFPHom{T1, T2} as well as the following constructors:","category":"page"},{"location":"CommutativeAlgebra/ModulesOverMultivariateRings/subquotients/","page":"Subquotients","title":"Subquotients","text":"hom(M::SubquoModule{T}, N::ModuleFP{T}, V::Vector{<:ModuleFPElem{T}}) where T","category":"page"},{"location":"CommutativeAlgebra/ModulesOverMultivariateRings/subquotients/#hom-Union{Tuple{T}, Tuple{SubquoModule{T}, ModuleFP{T}, Vector{<:ModuleFPElem{T}}}} where T","page":"Subquotients","title":"hom","text":"hom(M::SubquoModule{T}, N::ModuleFP{T}, V::Vector{<:ModuleFPElem{T}}) where T\n\nGiven a vector V of ngens(M) elements of N, return the homomorphism M to N which sends the i-th generator M[i] of M to the i-th entry of V.\n\nhom(M::SubquoModule{T}, N::ModuleFP{T},  A::MatElem{T})) where T\n\nGiven a matrix A with ngens(M) rows and ngens(N) columns, return the homomorphism M to N which sends the i-th generator M[i] of M to the linear combination sum_j Aij*Nj of the generators N[j] of N.\n\nnote: Note\nThe module N may be of type FreeMod or SubquoMod. If both modules M and N are graded, the data must define a graded module homomorphism of some degree. If this degree is the zero element of the (common) grading group, we refer to the homomorphism under consideration as a homogeneous module homomorphism.\n\nwarning: Warning\nThe functions do not check whether the resulting homomorphism is well-defined, that is, whether it sends the relations of M into the relations of N.\n\nIf you are uncertain with regard to well-definedness, use the function below. Note, however, that the check performed by the function requires a Gröbner basis computation. This may take some time.\n\nis_welldefined(a::ModuleFPHom)\n\nReturn true if a is well-defined, and false otherwise.\n\nExamples\n\njulia> R, (x, y, z) = polynomial_ring(QQ, [:x, :y, :z])\n(Multivariate polynomial ring in 3 variables over QQ, QQMPolyRingElem[x, y, z])\n\njulia> F = free_module(R, 1)\nFree module of rank 1 over R\n\njulia> A = R[x; y]\n[x]\n[y]\n\njulia> B = R[x^2; y^3; z^4]\n[x^2]\n[y^3]\n[z^4]\n\njulia> M = SubquoModule(F, A, B)\nSubquotient of submodule with 2 generators\n  1: x*e[1]\n  2: y*e[1]\nby submodule with 3 generators\n  1: x^2*e[1]\n  2: y^3*e[1]\n  3: z^4*e[1]\n\njulia> N = M;\n\njulia> V = [y^2*N[1], x*N[2]]\n2-element Vector{SubquoModuleElem{QQMPolyRingElem}}:\n x*y^2*e[1]\n x*y*e[1]\n\njulia> a = hom(M, N, V)\nModule homomorphism\n  from M\n  to M\n\njulia> is_welldefined(a)\ntrue\n\njulia> W = R[y^2 0; 0 x]\n[y^2   0]\n[  0   x]\n\njulia> b = hom(M, N, W);\n\njulia> a == b\ntrue\n\njulia> R, (x, y, z) = polynomial_ring(QQ, [:x, :y, :z])\n(Multivariate polynomial ring in 3 variables over QQ, QQMPolyRingElem[x, y, z])\n\njulia> F = free_module(R, 1)\nFree module of rank 1 over R\n\njulia> A = R[x; y];\n\njulia> B = R[x^2; y^3; z^4];\n\njulia> M = SubquoModule(F, A, B);\n\njulia> N = M;\n\njulia> W = [y*N[1], x*N[2]]\n2-element Vector{SubquoModuleElem{QQMPolyRingElem}}:\n x*y*e[1]\n x*y*e[1]\n\njulia> c = hom(M, N, W);\n\njulia> is_welldefined(c)\nfalse\n\njulia> Rg, (x, y, z) = graded_polynomial_ring(QQ, [:x, :y, :z]);\n\njulia> F = graded_free_module(Rg, 1);\n\njulia> A = Rg[x; y];\n\njulia> B = Rg[x^2; y^3; z^4];\n\njulia> M = SubquoModule(F, A, B)\nGraded subquotient of graded submodule of F with 2 generators\n  1: x*e[1]\n  2: y*e[1]\nby graded submodule of F with 3 generators\n  1: x^2*e[1]\n  2: y^3*e[1]\n  3: z^4*e[1]\n\njulia> N = M;\n\njulia> V = [y^2*N[1], x^2*N[2]];\n\njulia> a = hom(M, N, V)\nGraded module homomorphism of degree [2]\n  from M\n  to M\ndefined by\n  x*e[1] -> x*y^2*e[1]\n  y*e[1] -> x^2*y*e[1]\n\njulia> is_welldefined(a)\ntrue\n\njulia> W = Rg[y^2 0; 0 x^2]\n[y^2     0]\n[  0   x^2]\n\njulia> b = hom(M, N, W)\nGraded module homomorphism of degree [2]\n  from M\n  to M\ndefined by\n  x*e[1] -> x*y^2*e[1]\n  y*e[1] -> x^2*y*e[1]\n\njulia> a == b\ntrue\n\njulia> W = [y*N[1], x*N[2]]\n2-element Vector{SubquoModuleElem{MPolyDecRingElem{QQFieldElem, QQMPolyRingElem}}}:\n x*y*e[1]\n x*y*e[1]\n\njulia> c = hom(M, N, W)\nGraded module homomorphism of degree [1]\n  from M\n  to M\ndefined by\n  x*e[1] -> x*y*e[1]\n  y*e[1] -> x*y*e[1]\n\njulia> is_welldefined(c)\nfalse\n\n\n\n\n\n","category":"method"},{"location":"CommutativeAlgebra/ModulesOverMultivariateRings/subquotients/","page":"Subquotients","title":"Subquotients","text":"Given a homomorphism of type SubQuoHom, a matrix A representing it is recovered by the following function:","category":"page"},{"location":"CommutativeAlgebra/ModulesOverMultivariateRings/subquotients/","page":"Subquotients","title":"Subquotients","text":"matrix(a::SubQuoHom)","category":"page"},{"location":"CommutativeAlgebra/ModulesOverMultivariateRings/subquotients/#matrix-Tuple{SubQuoHom}","page":"Subquotients","title":"matrix","text":"matrix(a::SubQuoHom)\n\nGiven a homomorphism a of type  SubQuoHom with domain M and codomain N, return a matrix A with ngens(M) rows and ngens(N) columns such that a == hom(M, N, A).\n\nExamples\n\njulia> R, (x, y, z) = polynomial_ring(QQ, [:x, :y, :z])\n(Multivariate polynomial ring in 3 variables over QQ, QQMPolyRingElem[x, y, z])\n\njulia> F = free_module(R, 1)\nFree module of rank 1 over R\n\njulia> A = R[x; y]\n[x]\n[y]\n\njulia> B = R[x^2; y^3; z^4]\n[x^2]\n[y^3]\n[z^4]\n\njulia> M = SubquoModule(F, A, B)\nSubquotient of submodule with 2 generators\n  1: x*e[1]\n  2: y*e[1]\nby submodule with 3 generators\n  1: x^2*e[1]\n  2: y^3*e[1]\n  3: z^4*e[1]\n\njulia> N = M;\n\njulia> V = [y^2*N[1], x*N[2]];\n\njulia> a = hom(M, N, V);\n\njulia> A = matrix(a)\n[y^2   0]\n[  0   x]\n\njulia> a(M[1])\nx*y^2*e[1]\n\njulia> Rg, (x, y, z) = graded_polynomial_ring(QQ, [:x, :y, :z]);\n\njulia> F = graded_free_module(Rg, 1);\n\njulia> A = Rg[x; y];\n\njulia> B = Rg[x^2; y^3; z^4];\n\njulia> M = SubquoModule(F, A, B)\nGraded subquotient of graded submodule of F with 2 generators\n  1: x*e[1]\n  2: y*e[1]\nby graded submodule of F with 3 generators\n  1: x^2*e[1]\n  2: y^3*e[1]\n  3: z^4*e[1]\n\njulia> N = M;\n\njulia> V = [y^2*N[1], x^2*N[2]];\n\njulia> a = hom(M, N, V)\nGraded module homomorphism of degree [2]\n  from M\n  to M\ndefined by\n  x*e[1] -> x*y^2*e[1]\n  y*e[1] -> x^2*y*e[1]\n\njulia> matrix(a)\n[y^2     0]\n[  0   x^2]\n\n\n\n\n\n\n","category":"method"},{"location":"CommutativeAlgebra/ModulesOverMultivariateRings/subquotients/","page":"Subquotients","title":"Subquotients","text":"The domain and codomain of a homomorphism a  of type SubQuoHom can be recovered by entering domain(a) and codomain(a), respectively.","category":"page"},{"location":"CommutativeAlgebra/ModulesOverMultivariateRings/subquotients/","page":"Subquotients","title":"Subquotients","text":"The functions below test whether a homomorphism of type SubQuoHom is graded and homogeneous, respectively.","category":"page"},{"location":"CommutativeAlgebra/ModulesOverMultivariateRings/subquotients/","page":"Subquotients","title":"Subquotients","text":"is_graded(a:: SubQuoHom)","category":"page"},{"location":"CommutativeAlgebra/ModulesOverMultivariateRings/subquotients/#is_graded-Tuple{SubQuoHom}","page":"Subquotients","title":"is_graded","text":"is_graded(a::ModuleFPHom)\n\nReturn true if a is graded, false otherwise.\n\nExamples\n\njulia> R, (x, y, z) = graded_polynomial_ring(QQ, [:x, :y, :z]);\n\njulia> F = graded_free_module(R, 3)\nGraded free module R^3([0]) of rank 3 over R\n\njulia> G = graded_free_module(R, 2)\nGraded free module R^2([0]) of rank 2 over R\n\njulia> V = [y*G[1], x*G[1]+y*G[2], z*G[2]]\n3-element Vector{FreeModElem{MPolyDecRingElem{QQFieldElem, QQMPolyRingElem}}}:\n y*e[1]\n x*e[1] + y*e[2]\n z*e[2]\n\njulia> a = hom(F, G, V)\nGraded module homomorphism of degree [1]\n  from F\n  to G\ndefined by\n  e[1] -> y*e[1]\n  e[2] -> x*e[1] + y*e[2]\n  e[3] -> z*e[2]\n\njulia> is_graded(a)\ntrue\n\n\n\n\n\n","category":"method"},{"location":"CommutativeAlgebra/ModulesOverMultivariateRings/subquotients/","page":"Subquotients","title":"Subquotients","text":"is_homogeneous(a:: SubQuoHom)","category":"page"},{"location":"CommutativeAlgebra/ModulesOverMultivariateRings/subquotients/#is_homogeneous-Tuple{SubQuoHom}","page":"Subquotients","title":"is_homogeneous","text":"is_homogeneous(a::SubQuoHom)\n\nReturn true if a is homogeneous, false otherwise\n\nHere, if G is the grading group of a, a is homogeneous if a is graded of degree zero(G).\n\nExamples\n\njulia> Rg, (x, y, z) = graded_polynomial_ring(QQ, [:x, :y, :z]);\n\njulia> F = graded_free_module(Rg, 1);\n\njulia> A = Rg[x; y];\n\njulia> B = Rg[x^2; y^3; z^4];\n\njulia> M = SubquoModule(F, A, B);\n\njulia> N = M;\n\njulia> V = [y^2*N[1], x^2*N[2]];\n\njulia> a = hom(M, N, V)\nGraded module homomorphism of degree [2]\n  from M\n  to M\ndefined by\n  x*e[1] -> x*y^2*e[1]\n  y*e[1] -> x^2*y*e[1]\n\njulia> is_homogeneous(a)\nfalse\n\n\n\n\n\n","category":"method"},{"location":"CommutativeAlgebra/ModulesOverMultivariateRings/subquotients/","page":"Subquotients","title":"Subquotients","text":"In the graded case, we additionally have:","category":"page"},{"location":"CommutativeAlgebra/ModulesOverMultivariateRings/subquotients/","page":"Subquotients","title":"Subquotients","text":"degree(a:: SubQuoHom)","category":"page"},{"location":"CommutativeAlgebra/ModulesOverMultivariateRings/subquotients/#degree-Tuple{SubQuoHom}","page":"Subquotients","title":"degree","text":"degree(a::SubQuoHom; check::Bool=true)\n\nIf a is graded, return the degree of a.\n\nExamples\n\njulia> Rg, (x, y, z) = graded_polynomial_ring(QQ, [:x, :y, :z]);\n\njulia> F = graded_free_module(Rg, 1);\n\njulia> A = Rg[x; y];\n\njulia> B = Rg[x^2; y^3; z^4];\n\njulia> M = SubquoModule(F, A, B);\n\njulia> N = M;\n\njulia> V = [y^2*N[1], x^2*N[2]];\n\njulia> a = hom(M, N, V)\nGraded module homomorphism of degree [2]\n  from M\n  to M\ndefined by\n  x*e[1] -> x*y^2*e[1]\n  y*e[1] -> x^2*y*e[1]\n\njulia> degree(a)\n[2]\n\n\n\n\n\n","category":"method"},{"location":"CommutativeAlgebra/ModulesOverMultivariateRings/subquotients/","page":"Subquotients","title":"Subquotients","text":"grading_group(a:: SubQuoHom)","category":"page"},{"location":"CommutativeAlgebra/ModulesOverMultivariateRings/subquotients/#grading_group-Tuple{SubQuoHom}","page":"Subquotients","title":"grading_group","text":"grading_group(a::SubQuoHom)\n\nIf a is graded, return the grading group of a.\n\nExamples\n\njulia> Rg, (x, y, z) = graded_polynomial_ring(QQ, [:x, :y, :z]);\n\njulia> F = graded_free_module(Rg, 1);\n\njulia> A = Rg[x; y];\n\njulia> B = Rg[x^2; y^3; z^4];\n\njulia> M = SubquoModule(F, A, B);\n\njulia> N = M;\n\njulia> V = [y^2*N[1], x^2*N[2]];\n\njulia> a = hom(M, N, V)\nGraded module homomorphism of degree [2]\n  from M\n  to M\ndefined by\n  x*e[1] -> x*y^2*e[1]\n  y*e[1] -> x^2*y*e[1]\n\njulia> grading_group(a)\nZ\n\n\n\n\n\n","category":"method"},{"location":"AbstractAlgebra/mpolynomial/","page":"Sparse distributed multivariate polynomials","title":"Sparse distributed multivariate polynomials","text":"CurrentModule = AbstractAlgebra\nDocTestSetup = AbstractAlgebra.doctestsetup()","category":"page"},{"location":"AbstractAlgebra/mpolynomial/#Sparse-distributed-multivariate-polynomials","page":"Sparse distributed multivariate polynomials","title":"Sparse distributed multivariate polynomials","text":"","category":"section"},{"location":"AbstractAlgebra/mpolynomial/","page":"Sparse distributed multivariate polynomials","title":"Sparse distributed multivariate polynomials","text":"AbstractAlgebra.jl provides a module, implemented in src/MPoly.jl for sparse distributed multivariate polynomials over any commutative ring belonging to the AbstractAlgebra abstract type hierarchy.","category":"page"},{"location":"AbstractAlgebra/mpolynomial/#Generic-sparse-distributed-multivariable-polynomial-types","page":"Sparse distributed multivariate polynomials","title":"Generic sparse distributed multivariable polynomial types","text":"","category":"section"},{"location":"AbstractAlgebra/mpolynomial/","page":"Sparse distributed multivariate polynomials","title":"Sparse distributed multivariate polynomials","text":"AbstractAlgebra provides a generic multivariate polynomial type Generic.MPoly{T} where T is the type of elements of the coefficient ring.","category":"page"},{"location":"AbstractAlgebra/mpolynomial/","page":"Sparse distributed multivariate polynomials","title":"Sparse distributed multivariate polynomials","text":"The polynomials are implemented using a Julia array of coefficients and a 2-dimensional Julia array of UInts for the exponent vectors. Note that exponent n is represented by the n-th column of the exponent array, not the n-th row. This is because Julia uses a column major representation. See the file src/generic/GenericTypes.jl for details.","category":"page"},{"location":"AbstractAlgebra/mpolynomial/","page":"Sparse distributed multivariate polynomials","title":"Sparse distributed multivariate polynomials","text":"The top bit of each UInt is reserved for overflow detection.","category":"page"},{"location":"AbstractAlgebra/mpolynomial/","page":"Sparse distributed multivariate polynomials","title":"Sparse distributed multivariate polynomials","text":"Parent objects of such polynomials have type Generic.MPolyRing{T}.","category":"page"},{"location":"AbstractAlgebra/mpolynomial/","page":"Sparse distributed multivariate polynomials","title":"Sparse distributed multivariate polynomials","text":"The string representation of the variables of the polynomial ring and the base/coefficient ring R and the ordering are stored in the parent object.","category":"page"},{"location":"AbstractAlgebra/mpolynomial/#Abstract-types","page":"Sparse distributed multivariate polynomials","title":"Abstract types","text":"","category":"section"},{"location":"AbstractAlgebra/mpolynomial/","page":"Sparse distributed multivariate polynomials","title":"Sparse distributed multivariate polynomials","text":"The polynomial element types belong to the abstract type MPolyRingElem{T} and the polynomial ring types belong to the abstract type MPolyRing{T}.","category":"page"},{"location":"AbstractAlgebra/mpolynomial/","page":"Sparse distributed multivariate polynomials","title":"Sparse distributed multivariate polynomials","text":"note: Note\nNote that both the generic polynomial ring type Generic.MPolyRing{T} and the abstract type it belongs to, MPolyRing{T} are both called MPolyRing. The former is a (parameterised) concrete type for a polynomial ring over a given base ring whose elements have type T. The latter is an abstract type representing all multivariate polynomial ring types in AbstractAlgebra.jl, whether generic or very specialised (e.g. supplied by a C library).","category":"page"},{"location":"AbstractAlgebra/mpolynomial/#Polynomial-ring-constructors","page":"Sparse distributed multivariate polynomials","title":"Polynomial ring constructors","text":"","category":"section"},{"location":"AbstractAlgebra/mpolynomial/","page":"Sparse distributed multivariate polynomials","title":"Sparse distributed multivariate polynomials","text":"In order to construct multivariate polynomials in AbstractAlgebra.jl, one must first construct the polynomial ring itself. This is accomplished with the following constructors.","category":"page"},{"location":"AbstractAlgebra/mpolynomial/","page":"Sparse distributed multivariate polynomials","title":"Sparse distributed multivariate polynomials","text":"polynomial_ring(::Ring, ::Vector{Symbol})\npolynomial_ring(::Ring, ::Vararg)\npolynomial_ring(::Ring, ::Int)\n@polynomial_ring","category":"page"},{"location":"AbstractAlgebra/mpolynomial/#polynomial_ring-Tuple{Ring, Vector{Symbol}}","page":"Sparse distributed multivariate polynomials","title":"polynomial_ring","text":"polynomial_ring(R::Ring, varnames::Vector{Symbol}; cached=true, internal_ordering=:lex)\n\nGiven a coefficient ring R and variable names, say varnames = [:x1, :x2, ...], return a tuple S, [x1, x2, ...] of the polynomial ring S = Rx1 x2 dots and its generators x1 x2 dots.\n\nBy default (cached=true), the output S will be cached, i.e. if polynomial_ring is invoked again with the same arguments, the same (identical) ring is returned. Setting cached to false ensures a distinct new ring is returned, and will also prevent it from being cached.\n\nThe monomial ordering used for the internal storage of polynomials in S can be set with internal_ordering and must be one of :lex, :deglex or :degrevlex.\n\nSee also: polynomial_ring(::Ring, ::Vararg), @polynomial_ring.\n\nExample\n\njulia> S, generators = polynomial_ring(ZZ, [:x, :y, :z])\n(Multivariate polynomial ring in 3 variables over integers, AbstractAlgebra.Generic.MPoly{BigInt}[x, y, z])\n\n\n\n\n\n","category":"method"},{"location":"AbstractAlgebra/mpolynomial/#polynomial_ring-Tuple{Ring, Vararg}","page":"Sparse distributed multivariate polynomials","title":"polynomial_ring","text":"polynomial_ring(R::Ring, varnames...; cached=true, internal_ordering=:lex)\npolynomial_ring(R::Ring, varnames::Tuple; cached=true, internal_ordering=:lex)\n\nLike polynomial_ring(::Ring, ::Vector{Symbol}) with more ways to give varnames as specified in variable_names.\n\nReturn a tuple S, generators... with generators[i] corresponding to varnames[i].\n\nnote: Note\nIn the first method, varnames must not be empty, and if it consists of only one name, the univariate polynomial_ring(R::NCRing, s::VarName) method is called instead.\n\nExamples\n\njulia> S, (a, b, c) = polynomial_ring(ZZ, [:a, :b, :c])\n(Multivariate polynomial ring in 3 variables over integers, AbstractAlgebra.Generic.MPoly{BigInt}[a, b, c])\n\njulia> S, x, y = polynomial_ring(ZZ, :x => (1:2, 1:2), :y => 1:3);\n\njulia> S\nMultivariate polynomial ring in 7 variables x[1, 1], x[2, 1], x[1, 2], x[2, 2], ..., y[3]\n  over integers\n\njulia> x\n2×2 Matrix{AbstractAlgebra.Generic.MPoly{BigInt}}:\n x[1, 1]  x[1, 2]\n x[2, 1]  x[2, 2]\n\njulia> y\n3-element Vector{AbstractAlgebra.Generic.MPoly{BigInt}}:\n y[1]\n y[2]\n y[3]\n\n\n\n\n\n","category":"method"},{"location":"AbstractAlgebra/mpolynomial/#polynomial_ring-Tuple{Ring, Int64}","page":"Sparse distributed multivariate polynomials","title":"polynomial_ring","text":"polynomial_ring(R::Ring, varnames...; cached=true, internal_ordering=:lex)\npolynomial_ring(R::Ring, varnames::Tuple; cached=true, internal_ordering=:lex)\n\nLike polynomial_ring(::Ring, ::Vector{Symbol}) with more ways to give varnames as specified in variable_names.\n\nReturn a tuple S, generators... with generators[i] corresponding to varnames[i].\n\nnote: Note\nIn the first method, varnames must not be empty, and if it consists of only one name, the univariate polynomial_ring(R::NCRing, s::VarName) method is called instead.\n\nExamples\n\njulia> S, (a, b, c) = polynomial_ring(ZZ, [:a, :b, :c])\n(Multivariate polynomial ring in 3 variables over integers, AbstractAlgebra.Generic.MPoly{BigInt}[a, b, c])\n\njulia> S, x, y = polynomial_ring(ZZ, :x => (1:2, 1:2), :y => 1:3);\n\njulia> S\nMultivariate polynomial ring in 7 variables x[1, 1], x[2, 1], x[1, 2], x[2, 2], ..., y[3]\n  over integers\n\njulia> x\n2×2 Matrix{AbstractAlgebra.Generic.MPoly{BigInt}}:\n x[1, 1]  x[1, 2]\n x[2, 1]  x[2, 2]\n\njulia> y\n3-element Vector{AbstractAlgebra.Generic.MPoly{BigInt}}:\n y[1]\n y[2]\n y[3]\n\n\n\n\n\npolynomial_ring(R::Ring, n::Int, s::Symbol=:x; cached=true, internal_ordering=:lex)\n\nSame as polynomial_ring(::Ring, [\"s$i\" for i in 1:n]).\n\nExample\n\njulia> S, x = polynomial_ring(ZZ, 3)\n(Multivariate polynomial ring in 3 variables over integers, AbstractAlgebra.Generic.MPoly{BigInt}[x1, x2, x3])\n\n\n\n\n\n","category":"method"},{"location":"AbstractAlgebra/mpolynomial/#@polynomial_ring","page":"Sparse distributed multivariate polynomials","title":"@polynomial_ring","text":"@polynomial_ring(R::Ring, varnames...; cached=true, internal_ordering=:lex)\n\nReturn polynomial ring from polynomial_ring(::Ring, ::Vararg) and introduce the generators into the current scope.\n\nExamples\n\njulia> S = @polynomial_ring(ZZ, \"x#\" => (1:2, 1:2), \"y#\" => 1:3)\nMultivariate polynomial ring in 7 variables x11, x21, x12, x22, ..., y3\n  over integers\n\njulia> x11, x21, x12, x22\n(x11, x21, x12, x22)\n\njulia> y1, y2, y3\n(y1, y2, y3)\n\njulia> (S, [x11 x12; x21 x22], [y1, y2, y3]) == polynomial_ring(ZZ, \"x#\" => (1:2, 1:2), \"y#\" => 1:3)\ntrue\n\n\n\n\n\n","category":"macro"},{"location":"AbstractAlgebra/mpolynomial/","page":"Sparse distributed multivariate polynomials","title":"Sparse distributed multivariate polynomials","text":"Like for univariate polynomials, a shorthand constructor is provided when the number of generators is greater than 1: given a base ring R, we abbreviate the constructor as follows:","category":"page"},{"location":"AbstractAlgebra/mpolynomial/","page":"Sparse distributed multivariate polynomials","title":"Sparse distributed multivariate polynomials","text":"R[:x, :y, ...]","category":"page"},{"location":"AbstractAlgebra/mpolynomial/","page":"Sparse distributed multivariate polynomials","title":"Sparse distributed multivariate polynomials","text":"Here are some examples of creating multivariate polynomial rings and making use of the resulting parent objects to coerce various elements into the polynomial ring.","category":"page"},{"location":"AbstractAlgebra/mpolynomial/","page":"Sparse distributed multivariate polynomials","title":"Sparse distributed multivariate polynomials","text":"Examples","category":"page"},{"location":"AbstractAlgebra/mpolynomial/","page":"Sparse distributed multivariate polynomials","title":"Sparse distributed multivariate polynomials","text":"julia> R, (x, y) = polynomial_ring(ZZ, [:x, :y]; internal_ordering=:deglex)\n(Multivariate polynomial ring in 2 variables over integers, AbstractAlgebra.Generic.MPoly{BigInt}[x, y])\n\njulia> T, (z, t) = QQ[:z, :t]\n(Multivariate polynomial ring in 2 variables over rationals, AbstractAlgebra.Generic.MPoly{Rational{BigInt}}[z, t])\n\njulia> f = R()\n0\n\njulia> g = R(123)\n123\n\njulia> h = R(BigInt(1234))\n1234\n\njulia> k = R(x + 1)\nx + 1\n\njulia> m = R(x + y + 1)\nx + y + 1\n\njulia> derivative(k, 1)\n1\n\njulia> derivative(k, 2)\n0\n\njulia> R, x = polynomial_ring(ZZ, 10); R\nMultivariate polynomial ring in 10 variables x1, x2, x3, x4, ..., x10\n  over integers\n","category":"page"},{"location":"AbstractAlgebra/mpolynomial/#Polynomial-constructors","page":"Sparse distributed multivariate polynomials","title":"Polynomial constructors","text":"","category":"section"},{"location":"AbstractAlgebra/mpolynomial/","page":"Sparse distributed multivariate polynomials","title":"Sparse distributed multivariate polynomials","text":"Multivariate polynomials can be constructed from the generators in the usual way using arithmetic operations.","category":"page"},{"location":"AbstractAlgebra/mpolynomial/","page":"Sparse distributed multivariate polynomials","title":"Sparse distributed multivariate polynomials","text":"Also, all of the standard ring element constructors may be used to construct multivariate polynomials.","category":"page"},{"location":"AbstractAlgebra/mpolynomial/","page":"Sparse distributed multivariate polynomials","title":"Sparse distributed multivariate polynomials","text":"(R::MPolyRing{T})() where T <: RingElement\n(R::MPolyRing{T})(c::Integer) where T <: RingElement\n(R::MPolyRing{T})(a::elem_type(R)) where T <: RingElement\n(R::MPolyRing{T})(a::T) where T <: RingElement","category":"page"},{"location":"AbstractAlgebra/mpolynomial/","page":"Sparse distributed multivariate polynomials","title":"Sparse distributed multivariate polynomials","text":"For more efficient construction of multivariate polynomial, one can use the MPoly build context, where terms (coefficient followed by an exponent vector) are pushed onto a context one at a time and then the polynomial constructed from those terms in one go using the finish function.","category":"page"},{"location":"AbstractAlgebra/mpolynomial/","page":"Sparse distributed multivariate polynomials","title":"Sparse distributed multivariate polynomials","text":"MPolyBuildCtx(R::MPolyRing)\npush_term!(M::MPolyBuildCtx, c::RingElem, v::Vector{Int})\nfinish(M::MPolyBuildCtx)","category":"page"},{"location":"AbstractAlgebra/mpolynomial/#MPolyBuildCtx-Tuple{MPolyRing}","page":"Sparse distributed multivariate polynomials","title":"MPolyBuildCtx","text":"MPolyBuildCtx(R::MPolyRing)\n\nReturn a build context for creating polynomials in the given ring.\n\n\n\n\n\n","category":"method"},{"location":"AbstractAlgebra/mpolynomial/#push_term!-Tuple{MPolyBuildCtx, RingElem, Vector{Int64}}","page":"Sparse distributed multivariate polynomials","title":"push_term!","text":"push_term!(M::MPolyBuildCtx, c::RingElem, v::Vector{Int})\n\nAdd the term with coefficient c and exponent vector v to the polynomial under construction in the build context M.\n\n\n\n\n\n","category":"method"},{"location":"AbstractAlgebra/mpolynomial/#finish-Tuple{MPolyBuildCtx}","page":"Sparse distributed multivariate polynomials","title":"finish","text":"finish(M::MPolyBuildCtx)\n\nFinish construction of the polynomial, sort the terms, remove duplicate and zero terms and return the created polynomial.\n\n\n\n\n\n","category":"method"},{"location":"AbstractAlgebra/mpolynomial/","page":"Sparse distributed multivariate polynomials","title":"Sparse distributed multivariate polynomials","text":"Note that the finish function resets the build context so that it can be used to construct multiple polynomials..","category":"page"},{"location":"AbstractAlgebra/mpolynomial/","page":"Sparse distributed multivariate polynomials","title":"Sparse distributed multivariate polynomials","text":"When a multivariate polynomial type has a representation that allows constant time access (e.g. it is represented internally by arrays), the following additional constructor is available. It takes and array of coefficients and and array of exponent vectors.","category":"page"},{"location":"AbstractAlgebra/mpolynomial/","page":"Sparse distributed multivariate polynomials","title":"Sparse distributed multivariate polynomials","text":"(S::MPolyRing{T})(A::Vector{T}, m::Vector{Vector{Int}}) where T <: RingElem","category":"page"},{"location":"AbstractAlgebra/mpolynomial/","page":"Sparse distributed multivariate polynomials","title":"Sparse distributed multivariate polynomials","text":"Create the polynomial in the given ring with nonzero coefficients specified by the elements of A and corresponding exponent vectors given by the elements of m.","category":"page"},{"location":"AbstractAlgebra/mpolynomial/","page":"Sparse distributed multivariate polynomials","title":"Sparse distributed multivariate polynomials","text":"Examples","category":"page"},{"location":"AbstractAlgebra/mpolynomial/","page":"Sparse distributed multivariate polynomials","title":"Sparse distributed multivariate polynomials","text":"julia> R, (x, y) = polynomial_ring(ZZ, [:x, :y])\n(Multivariate polynomial ring in 2 variables over integers, AbstractAlgebra.Generic.MPoly{BigInt}[x, y])\n\njulia> C = MPolyBuildCtx(R)\nBuilder for an element of R\n\njulia> push_term!(C, ZZ(3), [1, 2]);\n\n\njulia> push_term!(C, ZZ(2), [1, 1]);\n\n\njulia> push_term!(C, ZZ(4), [0, 0]);\n\n\njulia> f = finish(C)\n3*x*y^2 + 2*x*y + 4\n\njulia> push_term!(C, ZZ(4), [1, 1]);\n\n\njulia> f = finish(C)\n4*x*y\n\njulia> S, (x, y) = polynomial_ring(QQ, [:x, :y])\n(Multivariate polynomial ring in 2 variables over rationals, AbstractAlgebra.Generic.MPoly{Rational{BigInt}}[x, y])\n\njulia> f = S(Rational{BigInt}[2, 3, 1], [[3, 2], [1, 0], [0, 1]])\n2*x^3*y^2 + 3*x + y","category":"page"},{"location":"AbstractAlgebra/mpolynomial/#Functions-for-types-and-parents-of-multivariate-polynomial-rings","page":"Sparse distributed multivariate polynomials","title":"Functions for types and parents of multivariate polynomial rings","text":"","category":"section"},{"location":"AbstractAlgebra/mpolynomial/","page":"Sparse distributed multivariate polynomials","title":"Sparse distributed multivariate polynomials","text":"base_ring(R::MPolyRing)\nbase_ring(a::MPolyRingElem)","category":"page"},{"location":"AbstractAlgebra/mpolynomial/","page":"Sparse distributed multivariate polynomials","title":"Sparse distributed multivariate polynomials","text":"Return the coefficient ring of the given polynomial ring or polynomial, respectively.","category":"page"},{"location":"AbstractAlgebra/mpolynomial/","page":"Sparse distributed multivariate polynomials","title":"Sparse distributed multivariate polynomials","text":"parent(a::MPolyRingElem)","category":"page"},{"location":"AbstractAlgebra/mpolynomial/","page":"Sparse distributed multivariate polynomials","title":"Sparse distributed multivariate polynomials","text":"Return the polynomial ring of the given polynomial.","category":"page"},{"location":"AbstractAlgebra/mpolynomial/","page":"Sparse distributed multivariate polynomials","title":"Sparse distributed multivariate polynomials","text":"characteristic(R::MPolyRing)","category":"page"},{"location":"AbstractAlgebra/mpolynomial/","page":"Sparse distributed multivariate polynomials","title":"Sparse distributed multivariate polynomials","text":"Return the characteristic of the given polynomial ring. If the characteristic is not known, an exception is raised.","category":"page"},{"location":"AbstractAlgebra/mpolynomial/#Polynomial-functions","page":"Sparse distributed multivariate polynomials","title":"Polynomial functions","text":"","category":"section"},{"location":"AbstractAlgebra/mpolynomial/#Basic-manipulation","page":"Sparse distributed multivariate polynomials","title":"Basic manipulation","text":"","category":"section"},{"location":"AbstractAlgebra/mpolynomial/","page":"Sparse distributed multivariate polynomials","title":"Sparse distributed multivariate polynomials","text":"All the standard ring functions are available, including the following.","category":"page"},{"location":"AbstractAlgebra/mpolynomial/","page":"Sparse distributed multivariate polynomials","title":"Sparse distributed multivariate polynomials","text":"zero(R::MPolyRing)\none(R::MPolyRing)\niszero(a::MPolyRingElem)\nisone(a::MPolyRingElem)","category":"page"},{"location":"AbstractAlgebra/mpolynomial/","page":"Sparse distributed multivariate polynomials","title":"Sparse distributed multivariate polynomials","text":"divexact(a::T, b::T) where T <: MPolyRingElem","category":"page"},{"location":"AbstractAlgebra/mpolynomial/","page":"Sparse distributed multivariate polynomials","title":"Sparse distributed multivariate polynomials","text":"All basic functions from the Multivariate Polynomial interface are provided.","category":"page"},{"location":"AbstractAlgebra/mpolynomial/","page":"Sparse distributed multivariate polynomials","title":"Sparse distributed multivariate polynomials","text":"symbols(S::MPolyRing)\nnumber_of_variables(f::MPolyRing)\ngens(S::MPolyRing)\ngen(S::MPolyRing, i::Int)","category":"page"},{"location":"AbstractAlgebra/mpolynomial/","page":"Sparse distributed multivariate polynomials","title":"Sparse distributed multivariate polynomials","text":"internal_ordering(S::MPolyRing{T})","category":"page"},{"location":"AbstractAlgebra/mpolynomial/","page":"Sparse distributed multivariate polynomials","title":"Sparse distributed multivariate polynomials","text":"Note that the currently supported orderings are :lex, :deglex and :degrevlex.","category":"page"},{"location":"AbstractAlgebra/mpolynomial/","page":"Sparse distributed multivariate polynomials","title":"Sparse distributed multivariate polynomials","text":"length(f::MPolyRingElem)\ndegrees(f::MPolyRingElem)\ntotal_degree(f::MPolyRingElem)","category":"page"},{"location":"AbstractAlgebra/mpolynomial/","page":"Sparse distributed multivariate polynomials","title":"Sparse distributed multivariate polynomials","text":"is_gen(x::MPolyRingElem)","category":"page"},{"location":"AbstractAlgebra/mpolynomial/","page":"Sparse distributed multivariate polynomials","title":"Sparse distributed multivariate polynomials","text":"divexact(f::T, g::T) where T <: MPolyRingElem","category":"page"},{"location":"AbstractAlgebra/mpolynomial/","page":"Sparse distributed multivariate polynomials","title":"Sparse distributed multivariate polynomials","text":"For multivariate polynomial types that allow constant time access to coefficients, the following are also available, allowing access to the given coefficient, monomial or term. Terms are numbered from the most significant first.","category":"page"},{"location":"AbstractAlgebra/mpolynomial/","page":"Sparse distributed multivariate polynomials","title":"Sparse distributed multivariate polynomials","text":"coeff(f::MPolyRingElem, n::Int)\ncoeff(a::MPolyRingElem, exps::Vector{Int})","category":"page"},{"location":"AbstractAlgebra/mpolynomial/","page":"Sparse distributed multivariate polynomials","title":"Sparse distributed multivariate polynomials","text":"Access a coefficient by term number or exponent vector.","category":"page"},{"location":"AbstractAlgebra/mpolynomial/","page":"Sparse distributed multivariate polynomials","title":"Sparse distributed multivariate polynomials","text":"monomial(f::MPolyRingElem, n::Int)\nmonomial!(m::T, f::T, n::Int) where T <: MPolyRingElem","category":"page"},{"location":"AbstractAlgebra/mpolynomial/","page":"Sparse distributed multivariate polynomials","title":"Sparse distributed multivariate polynomials","text":"The second version writes the result into a preexisting polynomial object to save an allocation.","category":"page"},{"location":"AbstractAlgebra/mpolynomial/","page":"Sparse distributed multivariate polynomials","title":"Sparse distributed multivariate polynomials","text":"term(f::MPolyRingElem, n::Int)","category":"page"},{"location":"AbstractAlgebra/mpolynomial/","page":"Sparse distributed multivariate polynomials","title":"Sparse distributed multivariate polynomials","text":"exponent(f::MyMPolyRingElem, i::Int, j::Int)","category":"page"},{"location":"AbstractAlgebra/mpolynomial/","page":"Sparse distributed multivariate polynomials","title":"Sparse distributed multivariate polynomials","text":"Return the exponent of the j-th variable in the i-th term of the polynomial f.","category":"page"},{"location":"AbstractAlgebra/mpolynomial/","page":"Sparse distributed multivariate polynomials","title":"Sparse distributed multivariate polynomials","text":"exponent_vector(a::MPolyRingElem, i::Int)","category":"page"},{"location":"AbstractAlgebra/mpolynomial/","page":"Sparse distributed multivariate polynomials","title":"Sparse distributed multivariate polynomials","text":"setcoeff!(a::MPolyRingElem{T}, exps::Vector{Int}, c::T) where T <: RingElement","category":"page"},{"location":"AbstractAlgebra/mpolynomial/","page":"Sparse distributed multivariate polynomials","title":"Sparse distributed multivariate polynomials","text":"Although multivariate polynomial rings are not usually Euclidean, the following functions from the Euclidean interface are often provided.","category":"page"},{"location":"AbstractAlgebra/mpolynomial/","page":"Sparse distributed multivariate polynomials","title":"Sparse distributed multivariate polynomials","text":"divides(f::T, g::T) where T <: MPolyRingElem\nremove(f::T, g::T) where T <: MPolyRingElem\nvaluation(f::T, g::T) where T <: MPolyRingElem","category":"page"},{"location":"AbstractAlgebra/mpolynomial/","page":"Sparse distributed multivariate polynomials","title":"Sparse distributed multivariate polynomials","text":"divrem(f::T, g::T) where T <: MPolyRingElem\ndiv(f::T, g::T) where T <: MPolyRingElem","category":"page"},{"location":"AbstractAlgebra/mpolynomial/","page":"Sparse distributed multivariate polynomials","title":"Sparse distributed multivariate polynomials","text":"Compute a tuple (q r) such that f = qg + r, where the coefficients of terms of r whose monomials are divisible by the leading monomial of g are reduced modulo the leading coefficient of g (according to the Euclidean function on the coefficients). The divrem version returns both quotient and remainder whilst the div version only returns the quotient.","category":"page"},{"location":"AbstractAlgebra/mpolynomial/","page":"Sparse distributed multivariate polynomials","title":"Sparse distributed multivariate polynomials","text":"Note that the result of these functions depend on the ordering of the polynomial ring.","category":"page"},{"location":"AbstractAlgebra/mpolynomial/","page":"Sparse distributed multivariate polynomials","title":"Sparse distributed multivariate polynomials","text":"gcd(f::T, g::T) where T <: MPolyRingElem","category":"page"},{"location":"AbstractAlgebra/mpolynomial/","page":"Sparse distributed multivariate polynomials","title":"Sparse distributed multivariate polynomials","text":"The following functionality is also provided for all multivariate polynomials.","category":"page"},{"location":"AbstractAlgebra/mpolynomial/","page":"Sparse distributed multivariate polynomials","title":"Sparse distributed multivariate polynomials","text":"is_univariate(::MPolyRing{T}) where T <: RingElement","category":"page"},{"location":"AbstractAlgebra/mpolynomial/#is_univariate-Union{Tuple{MPolyRing{T}}, Tuple{T}} where T<:RingElement","page":"Sparse distributed multivariate polynomials","title":"is_univariate","text":"is_univariate(R::MPolyRing)\n\nReturns true if R is a univariate polynomial ring, i.e. has exactly one variable, and false otherwise.\n\n\n\n\n\n","category":"method"},{"location":"AbstractAlgebra/mpolynomial/","page":"Sparse distributed multivariate polynomials","title":"Sparse distributed multivariate polynomials","text":"vars(p::MPolyRingElem{T}) where T <: RingElement","category":"page"},{"location":"AbstractAlgebra/mpolynomial/#vars-Union{Tuple{MPolyRingElem{T}}, Tuple{T}} where T<:RingElement","page":"Sparse distributed multivariate polynomials","title":"vars","text":"vars(p::MPolyRingElem{T}) where {T <: RingElement}\n\nReturn the variables actually occurring in p.\n\n\n\n\n\n","category":"method"},{"location":"AbstractAlgebra/mpolynomial/","page":"Sparse distributed multivariate polynomials","title":"Sparse distributed multivariate polynomials","text":"var_index(::MPolyRingElem{T}) where T <: RingElement","category":"page"},{"location":"AbstractAlgebra/mpolynomial/#var_index-Union{Tuple{MPolyRingElem{T}}, Tuple{T}} where T<:RingElement","page":"Sparse distributed multivariate polynomials","title":"var_index","text":"var_index(p::MPolyRingElem{T}) where {T <: RingElement}\n\nReturn the index of the given variable x. If x is not a variable in a multivariate polynomial ring, an exception is raised.\n\n\n\n\n\n","category":"method"},{"location":"AbstractAlgebra/mpolynomial/","page":"Sparse distributed multivariate polynomials","title":"Sparse distributed multivariate polynomials","text":"degree(::MPolyRingElem{T}, ::Int) where T <: RingElement","category":"page"},{"location":"AbstractAlgebra/mpolynomial/#degree-Union{Tuple{T}, Tuple{MPolyRingElem{T}, Int64}} where T<:RingElement","page":"Sparse distributed multivariate polynomials","title":"degree","text":"degree(f::MPolyRingElem{T}, i::Int) where T <: RingElement\n\nReturn the degree of the polynomial f in terms of the i-th variable.\n\n\n\n\n\n","category":"method"},{"location":"AbstractAlgebra/mpolynomial/","page":"Sparse distributed multivariate polynomials","title":"Sparse distributed multivariate polynomials","text":"degree(::MPolyRingElem{T}, ::MPolyRingElem{T}) where T <: RingElement","category":"page"},{"location":"AbstractAlgebra/mpolynomial/#degree-Union{Tuple{T}, Tuple{MPolyRingElem{T}, MPolyRingElem{T}}} where T<:RingElement","page":"Sparse distributed multivariate polynomials","title":"degree","text":"degree(f::MPolyRingElem{T}, x::MPolyRingElem{T}) where T <: RingElement\n\nReturn the degree of the polynomial f in terms of the variable x.\n\n\n\n\n\n","category":"method"},{"location":"AbstractAlgebra/mpolynomial/","page":"Sparse distributed multivariate polynomials","title":"Sparse distributed multivariate polynomials","text":"degrees(::MPolyRingElem{T}) where T <: RingElement","category":"page"},{"location":"AbstractAlgebra/mpolynomial/#degrees-Union{Tuple{MPolyRingElem{T}}, Tuple{T}} where T<:RingElement","page":"Sparse distributed multivariate polynomials","title":"degrees","text":"degrees(f::MPolyRingElem{T}) where T <: RingElement\n\nReturn an array of the degrees of the polynomial f in terms of each variable.\n\n\n\n\n\n","category":"method"},{"location":"AbstractAlgebra/mpolynomial/","page":"Sparse distributed multivariate polynomials","title":"Sparse distributed multivariate polynomials","text":"is_constant(::MPolyRingElem{T}) where T <: RingElement","category":"page"},{"location":"AbstractAlgebra/mpolynomial/#is_constant-Union{Tuple{MPolyRingElem{T}}, Tuple{T}} where T<:RingElement","page":"Sparse distributed multivariate polynomials","title":"is_constant","text":"is_constant(x::MPolyRingElem{T}) where T <: RingElement\n\nReturn true if x is a degree zero polynomial or the zero polynomial, i.e. a constant polynomial.\n\n\n\n\n\n","category":"method"},{"location":"AbstractAlgebra/mpolynomial/","page":"Sparse distributed multivariate polynomials","title":"Sparse distributed multivariate polynomials","text":"is_term(::MPolyRingElem{T}) where T <: RingElement","category":"page"},{"location":"AbstractAlgebra/mpolynomial/#is_term-Union{Tuple{MPolyRingElem{T}}, Tuple{T}} where T<:RingElement","page":"Sparse distributed multivariate polynomials","title":"is_term","text":"is_term(x::MPolyRingElem)\n\nReturn true if the given polynomial has precisely one term.\n\n\n\n\n\n","category":"method"},{"location":"AbstractAlgebra/mpolynomial/","page":"Sparse distributed multivariate polynomials","title":"Sparse distributed multivariate polynomials","text":"is_monomial(::MPolyRingElem{T}) where T <: RingElement","category":"page"},{"location":"AbstractAlgebra/mpolynomial/#is_monomial-Union{Tuple{MPolyRingElem{T}}, Tuple{T}} where T<:RingElement","page":"Sparse distributed multivariate polynomials","title":"is_monomial","text":"is_monomial(x::MPolyRingElem)\n\nReturn true if the given polynomial has precisely one term whose coefficient is one.\n\n\n\n\n\n","category":"method"},{"location":"AbstractAlgebra/mpolynomial/","page":"Sparse distributed multivariate polynomials","title":"Sparse distributed multivariate polynomials","text":"is_univariate(::MPolyRingElem{T}) where T <: RingElement","category":"page"},{"location":"AbstractAlgebra/mpolynomial/#is_univariate-Union{Tuple{MPolyRingElem{T}}, Tuple{T}} where T<:RingElement","page":"Sparse distributed multivariate polynomials","title":"is_univariate","text":"is_univariate(p::MPolyRingElem)\n\nReturns true if p is a univariate polynomial, i.e. involves at most one variable (thus constant polynomials are considered univariate), and false otherwise. The result depends on the terms of the polynomial, not simply on the number of variables in the polynomial ring.\n\n\n\n\n\n","category":"method"},{"location":"AbstractAlgebra/mpolynomial/","page":"Sparse distributed multivariate polynomials","title":"Sparse distributed multivariate polynomials","text":"coeff(::MPolyRingElem{T}, ::MPolyRingElem{T}) where T <: RingElement","category":"page"},{"location":"AbstractAlgebra/mpolynomial/#coeff-Union{Tuple{T}, Tuple{MPolyRingElem{T}, MPolyRingElem{T}}} where T<:RingElement","page":"Sparse distributed multivariate polynomials","title":"coeff","text":"coeff(f::MPolyRingElem{T}, m::MPolyRingElem{T}) where T <: RingElement\n\nReturn the coefficient of the monomial m of the polynomial f. If there is no such monomial, zero is returned.\n\n\n\n\n\n","category":"method"},{"location":"AbstractAlgebra/mpolynomial/","page":"Sparse distributed multivariate polynomials","title":"Sparse distributed multivariate polynomials","text":"Examples","category":"page"},{"location":"AbstractAlgebra/mpolynomial/","page":"Sparse distributed multivariate polynomials","title":"Sparse distributed multivariate polynomials","text":"julia> R, (x, y) = polynomial_ring(ZZ, [:x, :y])\n(Multivariate polynomial ring in 2 variables over integers, AbstractAlgebra.Generic.MPoly{BigInt}[x, y])\n\njulia> f = x^2 + 2x + 1\nx^2 + 2*x + 1\n\njulia> V = vars(f)\n1-element Vector{AbstractAlgebra.Generic.MPoly{BigInt}}:\n x\n\njulia> var_index(y) == 2\ntrue\n\njulia> degree(f, x) == 2\ntrue\n\njulia> degree(f, 2) == 0\ntrue\n\njulia> d = degrees(f)\n2-element Vector{Int64}:\n 2\n 0\n\njulia> is_constant(R(1))\ntrue\n\njulia> is_term(2x)\ntrue\n\njulia> is_monomial(y)\ntrue\n\njulia> is_unit(R(1))\ntrue\n\njulia> S, (x, y) = polynomial_ring(ZZ, [:x, :y])\n(Multivariate polynomial ring in 2 variables over integers, AbstractAlgebra.Generic.MPoly{BigInt}[x, y])\n\njulia> f = x^3*y + 3x*y^2 + 1\nx^3*y + 3*x*y^2 + 1\n\njulia> c1 = coeff(f, 1)\n1\n\njulia> c2 = coeff(f, x^3*y)\n1\n\njulia> m = monomial(f, 2)\nx*y^2\n\njulia> e1 = exponent(f, 1, 1)\n3\n\njulia> v1 = exponent_vector(f, 1)\n2-element Vector{Int64}:\n 3\n 1\n\njulia> t1 = term(f, 1)\nx^3*y\n\njulia> setcoeff!(f, [3, 1], 12)\n12*x^3*y + 3*x*y^2 + 1\n\njulia> S, (x, y) = polynomial_ring(QQ, [:x, :y]; internal_ordering=:deglex)\n(Multivariate polynomial ring in 2 variables over rationals, AbstractAlgebra.Generic.MPoly{Rational{BigInt}}[x, y])\n\njulia> V = symbols(S)\n2-element Vector{Symbol}:\n :x\n :y\n\njulia> X = gens(S)\n2-element Vector{AbstractAlgebra.Generic.MPoly{Rational{BigInt}}}:\n x\n y\n\njulia> ord = internal_ordering(S)\n:deglex\n\njulia> S, (x, y) = polynomial_ring(ZZ, [:x, :y])\n(Multivariate polynomial ring in 2 variables over integers, AbstractAlgebra.Generic.MPoly{BigInt}[x, y])\n\njulia> f = x^3*y + 3x*y^2 + 1\nx^3*y + 3*x*y^2 + 1\n\njulia> n = length(f)\n3\n\njulia> is_gen(y)\ntrue\n\njulia> number_of_variables(S) == 2\ntrue\n\njulia> d = total_degree(f)\n4\n\njulia> R, (x, y) = polynomial_ring(ZZ, [:x, :y])\n(Multivariate polynomial ring in 2 variables over integers, AbstractAlgebra.Generic.MPoly{BigInt}[x, y])\n\njulia> f = 2x^2*y + 2x + y + 1\n2*x^2*y + 2*x + y + 1\n\njulia> g = x^2*y^2 + 1\nx^2*y^2 + 1\n\njulia> flag, q = divides(f*g, f)\n(true, x^2*y^2 + 1)\n\njulia> d = divexact(f*g, f)\nx^2*y^2 + 1\n\njulia> v, q = remove(f*g^3, g)\n(3, 2*x^2*y + 2*x + y + 1)\n\njulia> n = valuation(f*g^3, g)\n3\n\njulia> R, (x, y) = polynomial_ring(QQ, [:x, :y])\n(Multivariate polynomial ring in 2 variables over rationals, AbstractAlgebra.Generic.MPoly{Rational{BigInt}}[x, y])\n\njulia> f = 3x^2*y^2 + 2x + 1\n3*x^2*y^2 + 2*x + 1\n\njulia> f1 = divexact(f, 5)\n3//5*x^2*y^2 + 2//5*x + 1//5\n\njulia> f2 = divexact(f, QQ(2, 3))\n9//2*x^2*y^2 + 3*x + 3//2","category":"page"},{"location":"AbstractAlgebra/mpolynomial/#Square-root","page":"Sparse distributed multivariate polynomials","title":"Square root","text":"","category":"section"},{"location":"AbstractAlgebra/mpolynomial/","page":"Sparse distributed multivariate polynomials","title":"Sparse distributed multivariate polynomials","text":"Over rings for which an exact square root is available, it is possible to take the square root of a polynomial or test whether it is a square.","category":"page"},{"location":"AbstractAlgebra/mpolynomial/","page":"Sparse distributed multivariate polynomials","title":"Sparse distributed multivariate polynomials","text":"sqrt(f::MPolyRingElem, check::Bool=true)\nis_square(::MPolyRingElem)","category":"page"},{"location":"AbstractAlgebra/mpolynomial/","page":"Sparse distributed multivariate polynomials","title":"Sparse distributed multivariate polynomials","text":"Examples","category":"page"},{"location":"AbstractAlgebra/mpolynomial/","page":"Sparse distributed multivariate polynomials","title":"Sparse distributed multivariate polynomials","text":"julia> R, (x, y) = polynomial_ring(ZZ, [:x, :y])\n(Multivariate polynomial ring in 2 variables over integers, AbstractAlgebra.Generic.MPoly{BigInt}[x, y])\n\njulia> f = -4*x^5*y^4 + 5*x^5*y^3 + 4*x^4 - x^3*y^4\n-4*x^5*y^4 + 5*x^5*y^3 + 4*x^4 - x^3*y^4\n\njulia> sqrt(f^2)\n4*x^5*y^4 - 5*x^5*y^3 - 4*x^4 + x^3*y^4\n\njulia> is_square(f)\nfalse","category":"page"},{"location":"AbstractAlgebra/mpolynomial/#Iterators","page":"Sparse distributed multivariate polynomials","title":"Iterators","text":"","category":"section"},{"location":"AbstractAlgebra/mpolynomial/","page":"Sparse distributed multivariate polynomials","title":"Sparse distributed multivariate polynomials","text":"The following iterators are provided for multivariate polynomials.","category":"page"},{"location":"AbstractAlgebra/mpolynomial/","page":"Sparse distributed multivariate polynomials","title":"Sparse distributed multivariate polynomials","text":"coefficients(p::MPoly)\nmonomials(p::MPoly)\nterms(p::MPoly)\nexponent_vectors(a::MPoly)","category":"page"},{"location":"AbstractAlgebra/mpolynomial/","page":"Sparse distributed multivariate polynomials","title":"Sparse distributed multivariate polynomials","text":"Examples","category":"page"},{"location":"AbstractAlgebra/mpolynomial/","page":"Sparse distributed multivariate polynomials","title":"Sparse distributed multivariate polynomials","text":"julia> S, (x, y) = polynomial_ring(ZZ, [:x, :y])\n(Multivariate polynomial ring in 2 variables over integers, AbstractAlgebra.Generic.MPoly{BigInt}[x, y])\n\njulia> f = x^3*y + 3x*y^2 + 1\nx^3*y + 3*x*y^2 + 1\n\njulia> C = collect(coefficients(f))\n3-element Vector{BigInt}:\n 1\n 3\n 1\n\njulia> M = collect(monomials(f))\n3-element Vector{AbstractAlgebra.Generic.MPoly{BigInt}}:\n x^3*y\n x*y^2\n 1\n\njulia> T = collect(terms(f))\n3-element Vector{AbstractAlgebra.Generic.MPoly{BigInt}}:\n x^3*y\n 3*x*y^2\n 1\n\njulia> V = collect(exponent_vectors(f))\n3-element Vector{Vector{Int64}}:\n [3, 1]\n [1, 2]\n [0, 0]","category":"page"},{"location":"AbstractAlgebra/mpolynomial/#Changing-base-(coefficient)-rings","page":"Sparse distributed multivariate polynomials","title":"Changing base (coefficient) rings","text":"","category":"section"},{"location":"AbstractAlgebra/mpolynomial/","page":"Sparse distributed multivariate polynomials","title":"Sparse distributed multivariate polynomials","text":"In order to substitute the variables of a polynomial f over a ring T by elements in a T-algebra S, you first have to change the base ring of f using the following function, where g is a function representing the structure homomorphism of the T-algebra S.","category":"page"},{"location":"AbstractAlgebra/mpolynomial/","page":"Sparse distributed multivariate polynomials","title":"Sparse distributed multivariate polynomials","text":"change_base_ring(::Ring, p::MPolyRingElem{T}) where {T <: RingElement}\nchange_coefficient_ring(::Ring, p::MPolyRingElem{T}) where {T <: RingElement}\nmap_coefficients(::Any, p::MPolyRingElem)","category":"page"},{"location":"AbstractAlgebra/mpolynomial/#change_base_ring-Union{Tuple{T}, Tuple{Ring, MPolyRingElem{T}}} where T<:RingElement","page":"Sparse distributed multivariate polynomials","title":"change_base_ring","text":"change_base_ring(R::Ring, p::MPolyRingElem{<: RingElement}; parent::MPolyRing, cached::Bool=true)\n\nReturn the polynomial obtained by coercing the non-zero coefficients of p into R.\n\nIf the optional parent keyword is provided, the polynomial will be an element of parent. The caching of the parent object can be controlled via the cached keyword argument.\n\n\n\n\n\n","category":"method"},{"location":"AbstractAlgebra/mpolynomial/#change_coefficient_ring-Union{Tuple{T}, Tuple{Ring, MPolyRingElem{T}}} where T<:RingElement","page":"Sparse distributed multivariate polynomials","title":"change_coefficient_ring","text":"change_coefficient_ring(R::Ring, p::MPolyRingElem{<: RingElement}; parent::MPolyRing, cached::Bool=true)\n\nReturn the polynomial obtained by coercing the non-zero coefficients of p into R.\n\nIf the optional parent keyword is provided, the polynomial will be an element of parent. The caching of the parent object can be controlled via the cached keyword argument.\n\n\n\n\n\n","category":"method"},{"location":"AbstractAlgebra/mpolynomial/#map_coefficients-Tuple{Any, MPolyRingElem}","page":"Sparse distributed multivariate polynomials","title":"map_coefficients","text":"map_coefficients(f, p::MPolyRingElem{<: RingElement}; parent::MPolyRing)\n\nTransform the polynomial p by applying f on each non-zero coefficient.\n\nIf the optional parent keyword is provided, the polynomial will be an element of parent. The caching of the parent object can be controlled via the cached keyword argument.\n\n\n\n\n\n","category":"method"},{"location":"AbstractAlgebra/mpolynomial/","page":"Sparse distributed multivariate polynomials","title":"Sparse distributed multivariate polynomials","text":"Examples","category":"page"},{"location":"AbstractAlgebra/mpolynomial/","page":"Sparse distributed multivariate polynomials","title":"Sparse distributed multivariate polynomials","text":"julia> R, (x, y) = polynomial_ring(ZZ, [:x, :y])\n(Multivariate polynomial ring in 2 variables over integers, AbstractAlgebra.Generic.MPoly{BigInt}[x, y])\n\njulia> fz = x^2*y^2 + x + 1\nx^2*y^2 + x + 1\n\njulia> fq = change_base_ring(QQ, fz)\nx^2*y^2 + x + 1\n\njulia> fq = change_coefficient_ring(QQ, fz)\nx^2*y^2 + x + 1\n","category":"page"},{"location":"AbstractAlgebra/mpolynomial/","page":"Sparse distributed multivariate polynomials","title":"Sparse distributed multivariate polynomials","text":"In case a specific parent ring is constructed, it can also be passed to the function.","category":"page"},{"location":"AbstractAlgebra/mpolynomial/","page":"Sparse distributed multivariate polynomials","title":"Sparse distributed multivariate polynomials","text":"Examples","category":"page"},{"location":"AbstractAlgebra/mpolynomial/","page":"Sparse distributed multivariate polynomials","title":"Sparse distributed multivariate polynomials","text":"julia> R, (x, y) = polynomial_ring(ZZ, [:x, :y])\n(Multivariate polynomial ring in 2 variables over integers, AbstractAlgebra.Generic.MPoly{BigInt}[x, y])\n\njulia> S,  = polynomial_ring(QQ, [:x, :y])\n(Multivariate polynomial ring in 2 variables over rationals, AbstractAlgebra.Generic.MPoly{Rational{BigInt}}[x, y])\n\njulia> fz = x^5 + y^3 + 1\nx^5 + y^3 + 1\n\njulia> fq = change_base_ring(QQ, fz, parent=S)\nx^5 + y^3 + 1","category":"page"},{"location":"AbstractAlgebra/mpolynomial/#Multivariate-coefficients","page":"Sparse distributed multivariate polynomials","title":"Multivariate coefficients","text":"","category":"section"},{"location":"AbstractAlgebra/mpolynomial/","page":"Sparse distributed multivariate polynomials","title":"Sparse distributed multivariate polynomials","text":"In order to return the \"coefficient\" (as a multivariate polynomial in the same ring), of a given monomial (in which some of the variables may not appear and others may be required to appear to exponent zero), we can use the following function.","category":"page"},{"location":"AbstractAlgebra/mpolynomial/","page":"Sparse distributed multivariate polynomials","title":"Sparse distributed multivariate polynomials","text":"coeff(a::MPolyRingElem{T}, vars::Vector{Int}, exps::Vector{Int}) where T <: RingElement\ncoeff(a::T, vars::Vector{T}, exps::Vector{Int}) where T <: MPolyRingElem","category":"page"},{"location":"AbstractAlgebra/mpolynomial/#coeff-Union{Tuple{T}, Tuple{MPolyRingElem{T}, Vector{Int64}, Vector{Int64}}} where T<:RingElement","page":"Sparse distributed multivariate polynomials","title":"coeff","text":"coeff(a::MPolyRingElem{T}, vars::Vector{Int}, exps::Vector{Int}) where T <: RingElement\n\nReturn the \"coefficient\" of a (as a multivariate polynomial in the same ring) of the monomial consisting of the product of the variables of the given indices raised to the given exponents (note that not all variables need to appear and the exponents can be zero). E.g. coeff(f, [1, 3], [0, 2]) returns the coefficient of x^0*z^2 in the polynomial f (assuming variables x y z in that order).\n\n\n\n\n\n","category":"method"},{"location":"AbstractAlgebra/mpolynomial/#coeff-Union{Tuple{T}, Tuple{T, Vector{T}, Vector{Int64}}} where T<:MPolyRingElem","page":"Sparse distributed multivariate polynomials","title":"coeff","text":"coeff(a::T, vars::Vector{T}, exps::Vector{Int}) where T <: MPolyRingElem\n\nReturn the \"coefficient\" of a (as a multivariate polynomial in the same ring) of the monomial consisting of the product of the given variables to the given exponents (note that not all variables need to appear and the exponents can be zero). E.g. coeff(f, [x, z], [0, 2]) returns the coefficient of x^0*z^2 in the polynomial f.\n\n\n\n\n\n","category":"method"},{"location":"AbstractAlgebra/mpolynomial/","page":"Sparse distributed multivariate polynomials","title":"Sparse distributed multivariate polynomials","text":"Examples","category":"page"},{"location":"AbstractAlgebra/mpolynomial/","page":"Sparse distributed multivariate polynomials","title":"Sparse distributed multivariate polynomials","text":"julia> R, (x, y, z) = polynomial_ring(ZZ, [:x, :y, :z])\n(Multivariate polynomial ring in 3 variables over integers, AbstractAlgebra.Generic.MPoly{BigInt}[x, y, z])\n\njulia> f = x^4*y^2*z^2 - 2x^4*y*z^2 + 4x^4*z^2 + 2x^2*y^2 + x + 1\nx^4*y^2*z^2 - 2*x^4*y*z^2 + 4*x^4*z^2 + 2*x^2*y^2 + x + 1\n\njulia> coeff(f, [1, 3], [4, 2]) == coeff(f, [x, z], [4, 2])\ntrue\n","category":"page"},{"location":"AbstractAlgebra/mpolynomial/#Inflation/deflation","page":"Sparse distributed multivariate polynomials","title":"Inflation/deflation","text":"","category":"section"},{"location":"AbstractAlgebra/mpolynomial/","page":"Sparse distributed multivariate polynomials","title":"Sparse distributed multivariate polynomials","text":"deflation(f::MPolyRingElem{T}) where T <: RingElement","category":"page"},{"location":"AbstractAlgebra/mpolynomial/#deflation-Union{Tuple{MPolyRingElem{T}}, Tuple{T}} where T<:RingElement","page":"Sparse distributed multivariate polynomials","title":"deflation","text":"deflation(f::MPolyRingElem{T}) where T <: RingElement\n\nCompute deflation parameters for the exponents of the polynomial f. This is a pair of arrays of integers, the first array of which (the shift) gives the minimum exponent for each variable of the polynomial, and the second of which (the deflation) gives the gcds of all the exponents after subtracting the shift, again per variable. This functionality is used by gcd (and can be used by factorisation algorithms).\n\n\n\n\n\n","category":"method"},{"location":"AbstractAlgebra/mpolynomial/","page":"Sparse distributed multivariate polynomials","title":"Sparse distributed multivariate polynomials","text":"deflate(f::MPolyRingElem{T}, shift::Vector{Int}, defl::Vector{Int}) where T <: RingElement\ndeflate(f::MPolyRingElem{T}, defl::Vector{Int}) where T <: RingElement\ndeflate(f::MPolyRingElem{T}) where T <: RingElement\ndeflate(f::MPolyRingElem, vars::Vector{Int}, shift::Vector{Int}, defl::Vector{Int})\ndeflate(f::T, vars::Vector{T}, shift::Vector{Int}, defl::Vector{Int}) where T <: MPolyRingElem","category":"page"},{"location":"AbstractAlgebra/mpolynomial/#deflate-Union{Tuple{T}, Tuple{MPolyRingElem{T}, Vector{Int64}, Vector{Int64}}} where T<:RingElement","page":"Sparse distributed multivariate polynomials","title":"deflate","text":"deflate(f::MPolyRingElem{T}, shift::Vector{Int}, defl::Vector{Int}) where T <: RingElement\n\nReturn a polynomial with the same coefficients as f but whose exponents have been reduced by the given shifts (supplied as an array of shifts, one for each variable), then deflated (divided) by the given exponents (again supplied as an array of deflation factors, one for each variable). The algorithm automatically replaces a deflation of 0 by 1, to avoid division by 0.\n\n\n\n\n\n","category":"method"},{"location":"AbstractAlgebra/mpolynomial/#deflate-Union{Tuple{T}, Tuple{MPolyRingElem{T}, Vector{Int64}}} where T<:RingElement","page":"Sparse distributed multivariate polynomials","title":"deflate","text":"deflate(f::MPolyRingElem{T}, defl::Vector{Int}) where T <: RingElement\n\nReturn a polynomial with the same coefficients as f but whose exponents have been deflated (divided) by the given exponents (supplied as an array of deflation factors, one for each variable).\n\nThe algorithm automatically replaces a deflation of 0 by 1, to avoid division by 0.\n\n\n\n\n\n","category":"method"},{"location":"AbstractAlgebra/mpolynomial/#deflate-Union{Tuple{MPolyRingElem{T}}, Tuple{T}} where T<:RingElement","page":"Sparse distributed multivariate polynomials","title":"deflate","text":"deflate(f::MPolyRingElem{T}, defl::Vector{Int}) where T <: RingElement\n\nReturn a polynomial with the same coefficients as f but whose exponents have been deflated maximally, i.e. with each exponent divide by the largest integer which divides the degrees of all exponents of that variable in f.\n\n\n\n\n\n","category":"method"},{"location":"AbstractAlgebra/mpolynomial/#deflate-Tuple{MPolyRingElem, Vector{Int64}, Vector{Int64}, Vector{Int64}}","page":"Sparse distributed multivariate polynomials","title":"deflate","text":"deflate(f::MPolyRingElem, vars::Vector{Int}, shift::Vector{Int}, defl::Vector{Int})\n\nReturn a polynomial with the same coefficients as f but where exponents of some variables (supplied as an array of variable indices) have been reduced by the given shifts (supplied as an array of shifts), then deflated (divided) by the given exponents (again supplied as an array of deflation factors). The algorithm automatically replaces a deflation of 0 by 1, to avoid division by 0.\n\n\n\n\n\n","category":"method"},{"location":"AbstractAlgebra/mpolynomial/#deflate-Union{Tuple{T}, Tuple{T, Vector{T}, Vector{Int64}, Vector{Int64}}} where T<:MPolyRingElem","page":"Sparse distributed multivariate polynomials","title":"deflate","text":"deflate(f::T, vars::Vector{T}, shift::Vector{Int}, defl::Vector{Int}) where T <: MPolyRingElem\n\nReturn a polynomial with the same coefficients as f but where the exponents of the given variables have been reduced by the given shifts (supplied as an array of shifts), then deflated (divided) by the given exponents (again supplied as an array of deflation factors). The algorithm automatically replaces a deflation of 0 by 1, to avoid division by 0.\n\n\n\n\n\n","category":"method"},{"location":"AbstractAlgebra/mpolynomial/","page":"Sparse distributed multivariate polynomials","title":"Sparse distributed multivariate polynomials","text":"inflate(f::MPolyRingElem{T}, shift::Vector{Int}, defl::Vector{Int}) where T <: RingElement\ninflate(f::MPolyRingElem{T}, defl::Vector{Int}) where T <: RingElement\ninflate(f::MPolyRingElem, vars::Vector{Int}, shift::Vector{Int}, defl::Vector{Int})\ninflate(f::T, vars::Vector{T}, shift::Vector{Int}, defl::Vector{Int}) where T <: MPolyRingElem","category":"page"},{"location":"AbstractAlgebra/mpolynomial/#inflate-Union{Tuple{T}, Tuple{MPolyRingElem{T}, Vector{Int64}, Vector{Int64}}} where T<:RingElement","page":"Sparse distributed multivariate polynomials","title":"inflate","text":"inflate(f::MPolyRingElem{T}, shift::Vector{Int}, defl::Vector{Int}) where T <: RingElement\n\nReturn a polynomial with the same coefficients as f but whose exponents have been inflated (multiplied) by the given deflation exponents (supplied as an array of inflation factors, one for each variable) and then increased by the given shifts (again supplied as an array of shifts, one for each variable).\n\n\n\n\n\n","category":"method"},{"location":"AbstractAlgebra/mpolynomial/#inflate-Union{Tuple{T}, Tuple{MPolyRingElem{T}, Vector{Int64}}} where T<:RingElement","page":"Sparse distributed multivariate polynomials","title":"inflate","text":"inflate(f::MPolyRingElem{T}, defl::Vector{Int}) where T <: RingElement\n\nReturn a polynomial with the same coefficients as f but whose exponents have been inflated (multiplied) by the given deflation exponents (supplied as an array of inflation factors, one for each variable).\n\n\n\n\n\n","category":"method"},{"location":"AbstractAlgebra/mpolynomial/#inflate-Tuple{MPolyRingElem, Vector{Int64}, Vector{Int64}, Vector{Int64}}","page":"Sparse distributed multivariate polynomials","title":"inflate","text":"inflate(f::MPolyRingElem, vars::Vector{Int}, shift::Vector{Int}, defl::Vector{Int})\n\nReturn a polynomial with the same coefficients as f but where exponents of some variables (supplied as an array of variable indices) have been inflated (multiplied) by the given deflation exponents (supplied as an array of inflation factors) and then increased by the given shifts (again supplied as an array of shifts).\n\n\n\n\n\n","category":"method"},{"location":"AbstractAlgebra/mpolynomial/#inflate-Union{Tuple{T}, Tuple{T, Vector{T}, Vector{Int64}, Vector{Int64}}} where T<:MPolyRingElem","page":"Sparse distributed multivariate polynomials","title":"inflate","text":"inflate(f::T, vars::Vector{T}, shift::Vector{Int}, defl::Vector{Int}) where T <: MPolyRingElem\n\nReturn a polynomial with the same coefficients as f but where the exponents of the given variables have been inflated (multiplied) by the given deflation exponents (supplied as an array of inflation factors) and then increased by the given shifts (again supplied as an array of shifts).\n\n\n\n\n\n","category":"method"},{"location":"AbstractAlgebra/mpolynomial/","page":"Sparse distributed multivariate polynomials","title":"Sparse distributed multivariate polynomials","text":"Examples","category":"page"},{"location":"AbstractAlgebra/mpolynomial/","page":"Sparse distributed multivariate polynomials","title":"Sparse distributed multivariate polynomials","text":"julia> R, (x, y) = polynomial_ring(ZZ, [:x, :y])\n(Multivariate polynomial ring in 2 variables over integers, AbstractAlgebra.Generic.MPoly{BigInt}[x, y])\n\njulia> f = x^7*y^8 + 3*x^4*y^8 - x^4*y^2 + 5x*y^5 - x*y^2\nx^7*y^8 + 3*x^4*y^8 - x^4*y^2 + 5*x*y^5 - x*y^2\n\njulia> def, shift = deflation(f)\n([1, 2], [3, 3])\n\njulia> f1 = deflate(f, def, shift)\nx^2*y^2 + 3*x*y^2 - x + 5*y - 1\n\njulia> f2 = inflate(f1, def, shift)\nx^7*y^8 + 3*x^4*y^8 - x^4*y^2 + 5*x*y^5 - x*y^2\n\njulia> f2 == f\ntrue\n\njulia> g = (x+y+1)^2\nx^2 + 2*x*y + 2*x + y^2 + 2*y + 1\n\njulia> g0 = coeff(g, [y], [0])\nx^2 + 2*x + 1\n\njulia> g1 = deflate(g - g0, [y], [1], [1])\n2*x + y + 2\n\njulia> g == g0 + y * g1\ntrue\n","category":"page"},{"location":"AbstractAlgebra/mpolynomial/#Conversions","page":"Sparse distributed multivariate polynomials","title":"Conversions","text":"","category":"section"},{"location":"AbstractAlgebra/mpolynomial/","page":"Sparse distributed multivariate polynomials","title":"Sparse distributed multivariate polynomials","text":"to_univariate(R::PolyRing{T}, p::MPolyRingElem{T}) where T <: RingElement","category":"page"},{"location":"AbstractAlgebra/mpolynomial/#to_univariate-Union{Tuple{T}, Tuple{PolyRing{T}, MPolyRingElem{T}}} where T<:RingElement","page":"Sparse distributed multivariate polynomials","title":"to_univariate","text":"to_univariate(R::PolyRing{T}, p::MPolyRingElem{T}) where T <: RingElement\n\nAssuming the polynomial p is actually a univariate polynomial, convert the polynomial to a univariate polynomial in the given univariate polynomial ring R. An exception is raised if the polynomial p involves more than one variable.\n\n\n\n\n\n","category":"method"},{"location":"AbstractAlgebra/mpolynomial/","page":"Sparse distributed multivariate polynomials","title":"Sparse distributed multivariate polynomials","text":"Examples","category":"page"},{"location":"AbstractAlgebra/mpolynomial/","page":"Sparse distributed multivariate polynomials","title":"Sparse distributed multivariate polynomials","text":"julia> R, (x, y) = polynomial_ring(ZZ, [:x, :y])\n(Multivariate polynomial ring in 2 variables over integers, AbstractAlgebra.Generic.MPoly{BigInt}[x, y])\n\njulia> S, z = polynomial_ring(ZZ, :z)\n(Univariate polynomial ring in z over integers, z)\n\njulia> f = 2x^5 + 3x^4 - 2x^2 - 1\n2*x^5 + 3*x^4 - 2*x^2 - 1\n\njulia> g = to_univariate(S, f)\n2*z^5 + 3*z^4 - 2*z^2 - 1\n","category":"page"},{"location":"AbstractAlgebra/mpolynomial/#Evaluation","page":"Sparse distributed multivariate polynomials","title":"Evaluation","text":"","category":"section"},{"location":"AbstractAlgebra/mpolynomial/","page":"Sparse distributed multivariate polynomials","title":"Sparse distributed multivariate polynomials","text":"The following function allows evaluation of a polynomial at all its variables. The result is always in the ring that a product of a coefficient and one of the values belongs to, i.e. if all the values are in the coefficient ring, the result of the evaluation will be too.","category":"page"},{"location":"AbstractAlgebra/mpolynomial/","page":"Sparse distributed multivariate polynomials","title":"Sparse distributed multivariate polynomials","text":"evaluate(::MPolyRingElem{T}, ::Vector{U}) where {T <: RingElement, U <: RingElement}","category":"page"},{"location":"AbstractAlgebra/mpolynomial/#evaluate-Union{Tuple{U}, Tuple{T}, Tuple{MPolyRingElem{T}, Vector{U}}} where {T<:RingElement, U<:RingElement}","page":"Sparse distributed multivariate polynomials","title":"evaluate","text":"evaluate(a::MPolyRingElem{T}, vals::Vector{U}) where {T <: RingElement, U <: RingElement}\n\nEvaluate the polynomial expression by substituting in the array of values for each of the variables. The evaluation will succeed if multiplication is defined between elements of the coefficient ring of a and elements of the supplied vector.\n\n\n\n\n\n","category":"method"},{"location":"AbstractAlgebra/mpolynomial/","page":"Sparse distributed multivariate polynomials","title":"Sparse distributed multivariate polynomials","text":"The following functions allow evaluation of a polynomial at some of its variables. Note that the result will be a product of values and an element of the polynomial ring, i.e. even if all the values are in the coefficient ring and all variables are given values, the result will be a constant polynomial, not a coefficient.","category":"page"},{"location":"AbstractAlgebra/mpolynomial/","page":"Sparse distributed multivariate polynomials","title":"Sparse distributed multivariate polynomials","text":"evaluate(::MPolyRingElem{T}, ::Vector{Int}, ::Vector{U}) where {T <: RingElement, U <: RingElement}","category":"page"},{"location":"AbstractAlgebra/mpolynomial/#evaluate-Union{Tuple{U}, Tuple{T}, Tuple{MPolyRingElem{T}, Vector{Int64}, Vector{U}}} where {T<:RingElement, U<:RingElement}","page":"Sparse distributed multivariate polynomials","title":"evaluate","text":"evaluate(a::MPolyRingElem{T}, vars::Vector{Int}, vals::Vector{U}) where {T <: RingElement, U <: RingElement}\n\nEvaluate the polynomial expression by substituting in the supplied values in the array vals for the corresponding variables with indices given by the array vars. The evaluation will succeed if multiplication is defined between elements of the coefficient ring of a and elements of vals.\n\n\n\n\n\n","category":"method"},{"location":"AbstractAlgebra/mpolynomial/","page":"Sparse distributed multivariate polynomials","title":"Sparse distributed multivariate polynomials","text":"evaluate(::S, ::Vector{S}, ::Vector{U}) where {S <: MPolyRingElem{T}, U <: RingElement} where T <: RingElement","category":"page"},{"location":"AbstractAlgebra/mpolynomial/#evaluate-Union{Tuple{U}, Tuple{S}, Tuple{T}, Tuple{S, Vector{S}, Vector{U}}} where {T<:RingElement, S<:MPolyRingElem{T}, U<:RingElement}","page":"Sparse distributed multivariate polynomials","title":"evaluate","text":"evaluate(a::S, vars::Vector{S}, vals::Vector{U}) where {S <: MPolyRingElem{T}, U <: RingElement} where T <: RingElement\n\nEvaluate the polynomial expression by substituting in the supplied values in the array vals for the corresponding variables (supplied as polynomials) given by the array vars. The evaluation will succeed if multiplication is defined between elements of the coefficient ring of a and elements of vals.\n\n\n\n\n\n","category":"method"},{"location":"AbstractAlgebra/mpolynomial/","page":"Sparse distributed multivariate polynomials","title":"Sparse distributed multivariate polynomials","text":"The following function allows evaluation of a polynomial at values in a not necessarily commutative ring, e.g. elements of a matrix algebra.","category":"page"},{"location":"AbstractAlgebra/mpolynomial/","page":"Sparse distributed multivariate polynomials","title":"Sparse distributed multivariate polynomials","text":"evaluate(::MPolyRingElem{T}, ::Vector{U}) where {T <: RingElement, U <: NCRingElem}","category":"page"},{"location":"AbstractAlgebra/mpolynomial/#evaluate-Union{Tuple{U}, Tuple{T}, Tuple{MPolyRingElem{T}, Vector{U}}} where {T<:RingElement, U<:NCRingElem}","page":"Sparse distributed multivariate polynomials","title":"evaluate","text":"evaluate(a::MPolyRingElem{T}, vals::Vector{U}) where {T <: RingElement, U <: NCRingElem}\n\nEvaluate the polynomial expression at the supplied values, which may be any ring elements, commutative or non-commutative, but in the same ring. Evaluation always proceeds in the order of the variables as supplied when creating the polynomial ring to which a belongs. The evaluation will succeed if a product of a coefficient of the polynomial by one of the values is defined.\n\n\n\n\n\n","category":"method"},{"location":"AbstractAlgebra/mpolynomial/","page":"Sparse distributed multivariate polynomials","title":"Sparse distributed multivariate polynomials","text":"Examples","category":"page"},{"location":"AbstractAlgebra/mpolynomial/","page":"Sparse distributed multivariate polynomials","title":"Sparse distributed multivariate polynomials","text":"julia> R, (x, y) = polynomial_ring(ZZ, [:x, :y])\n(Multivariate polynomial ring in 2 variables over integers, AbstractAlgebra.Generic.MPoly{BigInt}[x, y])\n\njulia> f = 2x^2*y^2 + 3x + y + 1\n2*x^2*y^2 + 3*x + y + 1\n\njulia> evaluate(f, BigInt[1, 2])\n14\n\njulia> evaluate(f, [QQ(1), QQ(2)])\n14//1\n\njulia> evaluate(f, [1, 2])\n14\n\njulia> f(1, 2) == 14\ntrue\n\njulia> evaluate(f, [x + y, 2y - x])\n2*x^4 - 4*x^3*y - 6*x^2*y^2 + 8*x*y^3 + 2*x + 8*y^4 + 5*y + 1\n\njulia> f(x + y, 2y - x)\n2*x^4 - 4*x^3*y - 6*x^2*y^2 + 8*x*y^3 + 2*x + 8*y^4 + 5*y + 1\n\njulia> R, (x, y, z) = polynomial_ring(ZZ, [:x, :y, :z])\n(Multivariate polynomial ring in 3 variables over integers, AbstractAlgebra.Generic.MPoly{BigInt}[x, y, z])\n\njulia> f = x^2*y^2 + 2x*z + 3y*z + z + 1\nx^2*y^2 + 2*x*z + 3*y*z + z + 1\n\njulia> evaluate(f, [1, 3], [3, 4])\n9*y^2 + 12*y + 29\n\njulia> evaluate(f, [x, z], [3, 4])\n9*y^2 + 12*y + 29\n\njulia> evaluate(f, [1, 2], [x + z, x - z])\nx^4 - 2*x^2*z^2 + 5*x*z + z^4 - z^2 + z + 1\n\njulia> S = matrix_ring(ZZ, 2)\nMatrix ring of degree 2\n  over integers\n\njulia> M1 = S([1 2; 3 4])\n[1   2]\n[3   4]\n\njulia> M2 = S([2 3; 1 -1])\n[2    3]\n[1   -1]\n\njulia> M3 = S([-1 1; 1 1])\n[-1   1]\n[ 1   1]\n\njulia> evaluate(f, [M1, M2, M3])\n[ 64    83]\n[124   149]","category":"page"},{"location":"AbstractAlgebra/mpolynomial/#Leading-and-constant-coefficients,-leading-monomials-and-leading-terms","page":"Sparse distributed multivariate polynomials","title":"Leading and constant coefficients, leading monomials and leading terms","text":"","category":"section"},{"location":"AbstractAlgebra/mpolynomial/","page":"Sparse distributed multivariate polynomials","title":"Sparse distributed multivariate polynomials","text":"The leading and trailing coefficient, constant coefficient, leading monomial and leading term of a polynomial p are returned by the following functions:","category":"page"},{"location":"AbstractAlgebra/mpolynomial/","page":"Sparse distributed multivariate polynomials","title":"Sparse distributed multivariate polynomials","text":"leading_coefficient(::MPolyRingElem{T}) where T <: RingElement\ntrailing_coefficient(p::MPolyRingElem{T}) where T <: RingElement\nleading_monomial(::MPolyRingElem{T}) where T <: RingElement\nleading_term(::MPolyRingElem{T}) where T <: RingElement\nconstant_coefficient(::MPolyRingElem{T}) where T <: RingElement\ntail(::MPolyRingElem{T}) where T <: RingElement","category":"page"},{"location":"AbstractAlgebra/mpolynomial/#leading_coefficient-Union{Tuple{MPolyRingElem{T}}, Tuple{T}} where T<:RingElement","page":"Sparse distributed multivariate polynomials","title":"leading_coefficient","text":"leading_coefficient(p::MPolyRingElem)\n\nReturn the leading coefficient of the polynomial p.\n\n\n\n\n\n","category":"method"},{"location":"AbstractAlgebra/mpolynomial/#trailing_coefficient-Union{Tuple{MPolyRingElem{T}}, Tuple{T}} where T<:RingElement","page":"Sparse distributed multivariate polynomials","title":"trailing_coefficient","text":"trailing_coefficient(p::MPolyRingElem)\n\nReturn the trailing coefficient of the polynomial p, i.e. the coefficient of the last nonzero term, or zero if the polynomial is zero.\n\n\n\n\n\n","category":"method"},{"location":"AbstractAlgebra/mpolynomial/#leading_monomial-Union{Tuple{MPolyRingElem{T}}, Tuple{T}} where T<:RingElement","page":"Sparse distributed multivariate polynomials","title":"leading_monomial","text":"leading_monomial(p::MPolyRingElem)\n\nReturn the leading monomial of p. This function throws an ArgumentError if p is zero.\n\n\n\n\n\n","category":"method"},{"location":"AbstractAlgebra/mpolynomial/#leading_term-Union{Tuple{MPolyRingElem{T}}, Tuple{T}} where T<:RingElement","page":"Sparse distributed multivariate polynomials","title":"leading_term","text":"leading_term(p::MPolyRingElem)\n\nReturn the leading term of the polynomial p. This function throws an ArgumentError if p is zero.\n\n\n\n\n\n","category":"method"},{"location":"AbstractAlgebra/mpolynomial/#constant_coefficient-Union{Tuple{MPolyRingElem{T}}, Tuple{T}} where T<:RingElement","page":"Sparse distributed multivariate polynomials","title":"constant_coefficient","text":"constant_coefficient(p::MPolyRingElem)\n\nReturn the constant coefficient of the polynomial p or zero if it doesn't have one.\n\n\n\n\n\n","category":"method"},{"location":"AbstractAlgebra/mpolynomial/#tail-Union{Tuple{MPolyRingElem{T}}, Tuple{T}} where T<:RingElement","page":"Sparse distributed multivariate polynomials","title":"tail","text":"tail(p::MPolyRingElem)\n\nReturn the tail of the polynomial p, i.e. the polynomial without its leading term (if any).\n\n\n\n\n\n","category":"method"},{"location":"AbstractAlgebra/mpolynomial/","page":"Sparse distributed multivariate polynomials","title":"Sparse distributed multivariate polynomials","text":"Examples","category":"page"},{"location":"AbstractAlgebra/mpolynomial/","page":"Sparse distributed multivariate polynomials","title":"Sparse distributed multivariate polynomials","text":"using AbstractAlgebra\nR,(x,y) = polynomial_ring(ZZ, [:x, :y], internal_ordering=:deglex)\np = 2*x*y + 3*y^3 + 1\nleading_term(p)\nleading_monomial(p)\nleading_coefficient(p)\nleading_term(p) == leading_coefficient(p) * leading_monomial(p)\nconstant_coefficient(p)\ntail(p)","category":"page"},{"location":"AbstractAlgebra/mpolynomial/#Least-common-multiple,-greatest-common-divisor","page":"Sparse distributed multivariate polynomials","title":"Least common multiple, greatest common divisor","text":"","category":"section"},{"location":"AbstractAlgebra/mpolynomial/","page":"Sparse distributed multivariate polynomials","title":"Sparse distributed multivariate polynomials","text":"The greatest common divisor of two polynomials a and b is returned by","category":"page"},{"location":"AbstractAlgebra/mpolynomial/","page":"Sparse distributed multivariate polynomials","title":"Sparse distributed multivariate polynomials","text":"gcd(a::Generic.MPoly{T}, b::Generic.MPoly{T}) where {T <: RingElement}","category":"page"},{"location":"AbstractAlgebra/mpolynomial/#gcd-Union{Tuple{T}, Tuple{AbstractAlgebra.Generic.MPoly{T}, AbstractAlgebra.Generic.MPoly{T}}} where T<:RingElement","page":"Sparse distributed multivariate polynomials","title":"gcd","text":"gcd(a::MPoly{T}, a::MPoly{T}) where {T <: RingElement}\n\nReturn the greatest common divisor of a and b in parent(a).\n\n\n\n\n\n","category":"method"},{"location":"AbstractAlgebra/mpolynomial/","page":"Sparse distributed multivariate polynomials","title":"Sparse distributed multivariate polynomials","text":"Note that this functionality is currently only provided for AbstractAlgebra generic polynomials. It is not automatically provided for all multivariate rings that implement the multivariate interface.","category":"page"},{"location":"AbstractAlgebra/mpolynomial/","page":"Sparse distributed multivariate polynomials","title":"Sparse distributed multivariate polynomials","text":"However, if such a gcd is provided, the least common multiple of two polynomials a and b is returned by","category":"page"},{"location":"AbstractAlgebra/mpolynomial/","page":"Sparse distributed multivariate polynomials","title":"Sparse distributed multivariate polynomials","text":"lcm(a::MPolyRingElem{T}, b::MPolyRingElem{T}) where {T <: RingElement}","category":"page"},{"location":"AbstractAlgebra/mpolynomial/#lcm-Union{Tuple{T}, Tuple{MPolyRingElem{T}, MPolyRingElem{T}}} where T<:RingElement","page":"Sparse distributed multivariate polynomials","title":"lcm","text":"lcm(a::AbstractAlgebra.MPolyRingElem{T}, a::AbstractAlgebra.MPolyRingElem{T}) where {T <: RingElement}\n\nReturn the least common multiple of a and b in parent(a).\n\n\n\n\n\n","category":"method"},{"location":"AbstractAlgebra/mpolynomial/","page":"Sparse distributed multivariate polynomials","title":"Sparse distributed multivariate polynomials","text":"Examples","category":"page"},{"location":"AbstractAlgebra/mpolynomial/","page":"Sparse distributed multivariate polynomials","title":"Sparse distributed multivariate polynomials","text":"julia> using AbstractAlgebra\n\njulia> R,(x,y) = polynomial_ring(ZZ, [:x, :y])\n(Multivariate polynomial ring in 2 variables over integers, AbstractAlgebra.Generic.MPoly{BigInt}[x, y])\n\njulia> a = x*y + 2*y\nx*y + 2*y\n\njulia> b = x^3*y + y\nx^3*y + y\n\njulia> gcd(a,b)\ny\n\njulia> lcm(a,b)\nx^4*y + 2*x^3*y + x*y + 2*y\n\njulia> lcm(a,b) == a * b // gcd(a,b)\ntrue\n","category":"page"},{"location":"AbstractAlgebra/mpolynomial/#Derivations","page":"Sparse distributed multivariate polynomials","title":"Derivations","text":"","category":"section"},{"location":"AbstractAlgebra/mpolynomial/","page":"Sparse distributed multivariate polynomials","title":"Sparse distributed multivariate polynomials","text":"derivative(::MPolyRingElem{T}, ::MPolyRingElem{T}) where T <: RingElement","category":"page"},{"location":"AbstractAlgebra/mpolynomial/#derivative-Union{Tuple{T}, Tuple{MPolyRingElem{T}, MPolyRingElem{T}}} where T<:RingElement","page":"Sparse distributed multivariate polynomials","title":"derivative","text":"derivative(f::MPolyRingElem{T}, x::MPolyRingElem{T}) where T <: RingElement\n\nReturn the partial derivative of f with respect to x. The value x must be a generator of the polynomial ring of f.\n\n\n\n\n\n","category":"method"},{"location":"AbstractAlgebra/mpolynomial/","page":"Sparse distributed multivariate polynomials","title":"Sparse distributed multivariate polynomials","text":"Examples","category":"page"},{"location":"AbstractAlgebra/mpolynomial/","page":"Sparse distributed multivariate polynomials","title":"Sparse distributed multivariate polynomials","text":"julia> R, (x, y) = AbstractAlgebra.polynomial_ring(ZZ, [:x, :y])\n(Multivariate polynomial ring in 2 variables over integers, AbstractAlgebra.Generic.MPoly{BigInt}[x, y])\n\njulia> f = x*y + x + y + 1\nx*y + x + y + 1\n\njulia> derivative(f, x)\ny + 1\n\njulia> derivative(f, y)\nx + 1\n\njulia> derivative(f, 1)\ny + 1\n\njulia> derivative(f, 2)\nx + 1","category":"page"},{"location":"AbstractAlgebra/mpolynomial/#Homogeneous-polynomials","page":"Sparse distributed multivariate polynomials","title":"Homogeneous polynomials","text":"","category":"section"},{"location":"AbstractAlgebra/mpolynomial/","page":"Sparse distributed multivariate polynomials","title":"Sparse distributed multivariate polynomials","text":"It is possible to test whether a polynomial is homogeneous with respect to the standard grading using the function","category":"page"},{"location":"AbstractAlgebra/mpolynomial/","page":"Sparse distributed multivariate polynomials","title":"Sparse distributed multivariate polynomials","text":"is_homogeneous(x::MPolyRingElem{T}) where T <: RingElement","category":"page"},{"location":"AbstractAlgebra/mpolynomial/#is_homogeneous-Union{Tuple{MPolyRingElem{T}}, Tuple{T}} where T<:RingElement","page":"Sparse distributed multivariate polynomials","title":"is_homogeneous","text":"is_homogeneous(x::MPoly{T}) where {T <: RingElement}\n\nReturn true if the given polynomial is homogeneous with respect to the standard grading and false otherwise.\n\n\n\n\n\n","category":"method"},{"location":"AbstractAlgebra/mpolynomial/#Random-generation","page":"Sparse distributed multivariate polynomials","title":"Random generation","text":"","category":"section"},{"location":"AbstractAlgebra/mpolynomial/","page":"Sparse distributed multivariate polynomials","title":"Sparse distributed multivariate polynomials","text":"Random multivariate polynomials in a given ring can be constructed by passing a range of degrees for the variables and a range on the number of terms. Additional parameters are used to generate the coefficients of the polynomial.","category":"page"},{"location":"AbstractAlgebra/mpolynomial/","page":"Sparse distributed multivariate polynomials","title":"Sparse distributed multivariate polynomials","text":"Note that zero coefficients may currently be generated, leading to less than the requested number of terms.","category":"page"},{"location":"AbstractAlgebra/mpolynomial/","page":"Sparse distributed multivariate polynomials","title":"Sparse distributed multivariate polynomials","text":"rand(R::MPolyRing, exp_range::AbstractUnitRange{Int}, term_range::AbstractUnitRange{Int}, v...)","category":"page"},{"location":"AbstractAlgebra/mpolynomial/","page":"Sparse distributed multivariate polynomials","title":"Sparse distributed multivariate polynomials","text":"Examples","category":"page"},{"location":"AbstractAlgebra/mpolynomial/","page":"Sparse distributed multivariate polynomials","title":"Sparse distributed multivariate polynomials","text":"julia> R, (x, y) = polynomial_ring(ZZ, [:x, :y])\n(Multivariate polynomial ring in 2 variables over integers, AbstractAlgebra.Generic.MPoly{BigInt}[x, y])\n\njulia> f = rand(R, -1:2, 3:5, -10:10)\n4*x^4*y^4\n\njulia> S, (s, t) = polynomial_ring(GF(7), [:x, :y])\n(Multivariate polynomial ring in 2 variables over finite field F_7, AbstractAlgebra.Generic.MPoly{AbstractAlgebra.GFElem{Int64}}[x, y])\n\njulia> g = rand(S, -1:2, 3:5)\n4*x^3*y^4","category":"page"},{"location":"Groups/quotients/","page":"Quotients","title":"Quotients","text":"CurrentModule = Oscar\nDocTestSetup = Oscar.doctestsetup()","category":"page"},{"location":"Groups/quotients/#quotient","page":"Quotients","title":"Quotients","text":"","category":"section"},{"location":"Groups/quotients/","page":"Quotients","title":"Quotients","text":"Quotient groups in OSCAR can be defined using the instruction quo in two ways.","category":"page"},{"location":"Groups/quotients/","page":"Quotients","title":"Quotients","text":"Quotients by normal subgroups.","category":"page"},{"location":"Groups/quotients/","page":"Quotients","title":"Quotients","text":"quo(G::GAPGroup, N::GAPGroup)","category":"page"},{"location":"Groups/quotients/#quo-Tuple{Oscar.GAPGroup, Oscar.GAPGroup}","page":"Quotients","title":"quo","text":"quo([::Type{Q}, ]G::GAPGroup, N::GAPGroup) where Q <: GAPGroup\n\nReturn the quotient group G/N, together with the projection G -> G/N.\n\nIf Q is given then G/N has type Q if possible, and an exception is thrown if not.\n\nIf Q is not given then the type of G/N is not determined by the type of G.\n\nG/N may have the same type as G (which is reasonable if N is trivial),\nG/N may have type PcGroup or SubPcGroup (which is reasonable if G/N is finite and solvable), or\nG/N may have type PermGroup (which is reasonable if G/N is finite and non-solvable).\nG/N may have type FPGroup (which is reasonable if G/N is infinite).\n\nAn exception is thrown if N is not a normal subgroup of G.\n\nExamples\n\njulia> G = symmetric_group(4)\nSym(4)\n\njulia> N = pcore(G, 2)[1];\n\njulia> typeof(quo(G, N)[1])\nPcGroup\n\njulia> typeof(quo(PermGroup, G, N)[1])\nPermGroup\n\n\n\n\n\n","category":"method"},{"location":"Groups/quotients/","page":"Quotients","title":"Quotients","text":"Quotients by elements.","category":"page"},{"location":"Groups/quotients/","page":"Quotients","title":"Quotients","text":"quo(G::T, elements::Vector{S}) where T <: GAPGroup where S <: GAPGroupElem","category":"page"},{"location":"Groups/quotients/#quo-Union{Tuple{T}, Tuple{S}, Tuple{T, Vector{S}}} where {S<:GAPGroupElem, T<:Oscar.GAPGroup}","page":"Quotients","title":"quo","text":"quo([::Type{Q}, ]G::T, elements::Vector{elem_type(G)})) where {Q <: GAPGroup, T <: GAPGroup}\n\nReturn the quotient group G/N, together with the projection G -> G/N, where N is the normal closure of elements in G.\n\nSee quo(G::GAPGroup, N::GAPGroup) for information about the type of G/N.\n\nFor groups G of type SubFPGroup, this syntax is not supported. In this case, you can switch to  group of different type, using isomorphism, or try to create the normal subgroup N in question, and call quo(G, N).\n\n\n\n\n\n","category":"method"},{"location":"Groups/quotients/","page":"Quotients","title":"Quotients","text":"This is the typical way to build finitely presented groups.","category":"page"},{"location":"Groups/quotients/","page":"Quotients","title":"Quotients","text":"Example:","category":"page"},{"location":"Groups/quotients/","page":"Quotients","title":"Quotients","text":"julia> F = @free_group(2);\n\njulia> G,_=quo(F,[f1^2,f2^3,(f1*f2)^2]);\n\njulia> is_finite(G)\ntrue\n\njulia> is_isomorphic(G,symmetric_group(3))\ntrue","category":"page"},{"location":"Groups/quotients/","page":"Quotients","title":"Quotients","text":"Similarly to the subgroups, the output consists of a pair (Q,p), where Q is the quotient group and p is the projection homomorphism of G into Q.","category":"page"},{"location":"Groups/quotients/","page":"Quotients","title":"Quotients","text":"maximal_abelian_quotient","category":"page"},{"location":"Groups/quotients/#maximal_abelian_quotient","page":"Quotients","title":"maximal_abelian_quotient","text":"maximal_abelian_quotient([::Type{Q}, ]G::GAPGroup) where Q <: Union{GAPGroup, FinGenAbGroup}\n\nReturn F, epi such that F is the largest abelian factor group of G and epi is an epimorphism from G to F.\n\nIf Q is given then F has type Q if possible, and an exception is thrown if not.\n\nIf Q is not given then the type of F is not determined by the type of G.\n\nF may have the same type as G (which is reasonable if G is abelian),\nF may have type PcGroup (which is reasonable if F is finite), or\nF may have type FPGroup (which is reasonable if F is infinite).\n\nExamples\n\njulia> G = symmetric_group(4);\n\njulia> F, epi = maximal_abelian_quotient(G);\n\njulia> order(F)\n2\n\njulia> domain(epi) === G && codomain(epi) === F\ntrue\n\njulia> typeof(F)\nPcGroup\n\njulia> typeof(maximal_abelian_quotient(free_group(1))[1])\nFPGroup\n\njulia> typeof(maximal_abelian_quotient(PermGroup, G)[1])\nPermGroup\n\n\n\n\n\n","category":"function"},{"location":"AlgebraicGeometry/Schemes/CoveredSchemes/","page":"Covered schemes","title":"Covered schemes","text":"CurrentModule = Oscar","category":"page"},{"location":"AlgebraicGeometry/Schemes/CoveredSchemes/#Covered-schemes","page":"Covered schemes","title":"Covered schemes","text":"","category":"section"},{"location":"AlgebraicGeometry/Schemes/CoveredSchemes/","page":"Covered schemes","title":"Covered schemes","text":"Oscar supports modeling abstract schemes by means of a covering by affine charts.","category":"page"},{"location":"AlgebraicGeometry/Schemes/CoveredSchemes/#Types","page":"Covered schemes","title":"Types","text":"","category":"section"},{"location":"AlgebraicGeometry/Schemes/CoveredSchemes/","page":"Covered schemes","title":"Covered schemes","text":"The abstract type for these is:","category":"page"},{"location":"AlgebraicGeometry/Schemes/CoveredSchemes/","page":"Covered schemes","title":"Covered schemes","text":"AbsCoveredScheme{BaseRingType}","category":"page"},{"location":"AlgebraicGeometry/Schemes/CoveredSchemes/#AbsCoveredScheme","page":"Covered schemes","title":"AbsCoveredScheme","text":"AbsCoveredScheme{BaseRingType}\n\nA scheme X over some base_ring 𝕜 of type  BaseRingType, given by means of affine charts and their gluings.\n\n\n\n\n\n","category":"type"},{"location":"AlgebraicGeometry/Schemes/CoveredSchemes/","page":"Covered schemes","title":"Covered schemes","text":"The basic concrete instance of an AbsCoveredScheme is:","category":"page"},{"location":"AlgebraicGeometry/Schemes/CoveredSchemes/","page":"Covered schemes","title":"Covered schemes","text":"CoveredScheme{BaseRingType}","category":"page"},{"location":"AlgebraicGeometry/Schemes/CoveredSchemes/#CoveredScheme","page":"Covered schemes","title":"CoveredScheme","text":"CoveredScheme{BaseRingType}\n\nA covered scheme X given by means of at least one Covering.\n\nA scheme may possess several coverings which are partially ordered by refinement. Use default_covering(X) to obtain one covering of X.\n\n\n\n\n\n","category":"type"},{"location":"AlgebraicGeometry/Schemes/CoveredSchemes/#Constructors","page":"Covered schemes","title":"Constructors","text":"","category":"section"},{"location":"AlgebraicGeometry/Schemes/CoveredSchemes/","page":"Covered schemes","title":"Covered schemes","text":"You can manually construct a CoveredScheme from a Covering using","category":"page"},{"location":"AlgebraicGeometry/Schemes/CoveredSchemes/","page":"Covered schemes","title":"Covered schemes","text":"CoveredScheme(C::Covering)","category":"page"},{"location":"AlgebraicGeometry/Schemes/CoveredSchemes/#CoveredScheme-Tuple{Covering}","page":"Covered schemes","title":"CoveredScheme","text":"CoveredScheme(C::Covering)\n\nReturn a CoveredScheme X with C as its default_covering.\n\nExamples\n\njulia> P1, (x,y) = QQ[:x, :y];\n\njulia> P2, (u,v) = QQ[:u, :v];\n\njulia> U1 = spec(P1);\n\njulia> U2 = spec(P2);\n\njulia> C = Covering([U1, U2]) # A Covering with two disjoint affine charts\nCovering\n  described by patches\n    1: affine 2-space\n    2: affine 2-space\n  in the coordinate(s)\n    1: [x, y]\n    2: [u, v]\n\njulia> V1 = PrincipalOpenSubset(U1, x); # Preparations for gluing\n\njulia> V2 = PrincipalOpenSubset(U2, u);\n\njulia> f = morphism(V1, V2, [1//x, y//x]); # The gluing isomorphism\n\njulia> g = morphism(V2, V1, [1//u, v//u]); # and its inverse\n\njulia> G = Gluing(U1, U2, f, g); # Construct the gluing\n\njulia> add_gluing!(C, G) # Make the gluing part of the Covering\nCovering\n  described by patches\n    1: affine 2-space\n    2: affine 2-space\n  in the coordinate(s)\n    1: [x, y]\n    2: [u, v]\n\njulia> X = CoveredScheme(C) # Create a CoveredScheme from the Gluing\nScheme\n  over rational field\nwith default covering\n  described by patches\n    1: affine 2-space\n    2: affine 2-space\n  in the coordinate(s)\n    1: [x, y]\n    2: [u, v]\n\n\n\n\n\n\n","category":"method"},{"location":"AlgebraicGeometry/Schemes/CoveredSchemes/","page":"Covered schemes","title":"Covered schemes","text":"In most cases, however, you may wish for the computer to provide you with a ready-made Covering and use a more high-level constructor, such as, for instance,","category":"page"},{"location":"AlgebraicGeometry/Schemes/CoveredSchemes/","page":"Covered schemes","title":"Covered schemes","text":"covered_scheme(P::ProjectiveScheme)","category":"page"},{"location":"AlgebraicGeometry/Schemes/CoveredSchemes/#covered_scheme-Tuple{ProjectiveScheme}","page":"Covered schemes","title":"covered_scheme","text":"covered_scheme(P::AbsProjectiveScheme)\n\nReturn a CoveredScheme X isomorphic to P with standard affine charts given by dehomogenization.\n\nUse dehomogenization_map with U one of the affine_charts of X to obtain the dehomogenization map from the homogeneous_coordinate_ring of P to the coordinate_ring of U.\n\nExamples\n\njulia> P = projective_space(QQ, 2);\n\njulia> Pcov = covered_scheme(P)\nScheme\n  over rational field\nwith default covering\n  described by patches\n    1: affine 2-space\n    2: affine 2-space\n    3: affine 2-space\n  in the coordinate(s)\n    1: [(s1//s0), (s2//s0)]\n    2: [(s0//s1), (s2//s1)]\n    3: [(s0//s2), (s1//s2)]\n\n\n\n\n\n","category":"method"},{"location":"AlgebraicGeometry/Schemes/CoveredSchemes/","page":"Covered schemes","title":"Covered schemes","text":"Other constructors:","category":"page"},{"location":"AlgebraicGeometry/Schemes/CoveredSchemes/","page":"Covered schemes","title":"Covered schemes","text":"disjoint_union(Xs::Vector{<:AbsCoveredScheme})","category":"page"},{"location":"AlgebraicGeometry/Schemes/CoveredSchemes/#disjoint_union-Tuple{Vector{<:AbsCoveredScheme}}","page":"Covered schemes","title":"disjoint_union","text":"disjoint_union(Xs::Vector{<:AbsCoveredScheme}) -> (AbsCoveredScheme, Vector{<:AbsCoveredSchemeMor})\n\nReturn the disjoint union of the non-empty vector of covered schemes as a covered scheme.\n\nInput:\n\na vector Xs of covered schemes.\n\nOutput:\n\nA pair (X mathrminjections) where X is a covered scheme and mathrminjections is a vector of inclusion morphisms ı_icolon X_i to X, where X is the disjoint union of the covered schemes X_i in Xs.\n\nExamples\n\njulia> R_1, (x, y, z) = graded_polynomial_ring(QQ, [:x, :y, :z]);\n\njulia> I_1 = ideal(R_1, z*x^2 + y^3);\n\njulia> X_1 = covered_scheme(proj(R_1, I_1))\nScheme\n  over rational field\nwith default covering\n  described by patches\n    1: scheme((y//x)^3 + (z//x))\n    2: scheme((x//y)^2*(z//y) + 1)\n    3: scheme((x//z)^2 + (y//z)^3)\n  in the coordinate(s)\n    1: [(y//x), (z//x)]\n    2: [(x//y), (z//y)]\n    3: [(x//z), (y//z)]\n\njulia> R_2, (u, v) = polynomial_ring(rational_field(), [:u, :v]);\n\njulia> I_2 = ideal(R_2, u + v^2);\n\njulia> X_2 = covered_scheme(spec(R_2, I_2))\nScheme\n  over rational field\nwith default covering\n  described by patches\n    1: scheme(u + v^2)\n  in the coordinate(s)\n    1: [u, v]\n\njulia> X, injections = disjoint_union([X_1, X_2]);\n\njulia> X\nScheme\n  over rational field\nwith default covering\n  described by patches\n    1: scheme((y//x)^3 + (z//x))\n    2: scheme((x//y)^2*(z//y) + 1)\n    3: scheme((x//z)^2 + (y//z)^3)\n    4: scheme(u + v^2)\n  in the coordinate(s)\n    1: [(y//x), (z//x)]\n    2: [(x//y), (z//y)]\n    3: [(x//z), (y//z)]\n    4: [u, v]\n\njulia> injections\n2-element Vector{CoveredSchemeMorphism{CoveredScheme{QQField}, CoveredScheme{QQField}, AbsAffineSchemeMor}}:\n Hom: scheme over QQ covered with 3 patches -> scheme over QQ covered with 4 patches\n Hom: scheme over QQ covered with 1 patch -> scheme over QQ covered with 4 patches\n\n\n\n\n\n","category":"method"},{"location":"AlgebraicGeometry/Schemes/CoveredSchemes/#Attributes","page":"Covered schemes","title":"Attributes","text":"","category":"section"},{"location":"AlgebraicGeometry/Schemes/CoveredSchemes/","page":"Covered schemes","title":"Covered schemes","text":"To access the affine charts of a CoveredScheme X use","category":"page"},{"location":"AlgebraicGeometry/Schemes/CoveredSchemes/","page":"Covered schemes","title":"Covered schemes","text":"affine_charts(X::AbsCoveredScheme)","category":"page"},{"location":"AlgebraicGeometry/Schemes/CoveredSchemes/#affine_charts-Tuple{AbsCoveredScheme}","page":"Covered schemes","title":"affine_charts","text":"affine_charts(X::AbsCoveredScheme)\n\nReturn the affine charts in the default_covering of X.\n\nExamples\n\njulia> P = projective_space(QQ, 2);\n\njulia> S = homogeneous_coordinate_ring(P);\n\njulia> I = ideal(S, [S[1]*S[2]-S[3]^2]);\n\njulia> X = subscheme(P, I)\nProjective scheme\n  over rational field\ndefined by ideal (s0*s1 - s2^2)\n\njulia> Xcov = covered_scheme(X)\nScheme\n  over rational field\nwith default covering\n  described by patches\n    1: scheme((s1//s0) - (s2//s0)^2)\n    2: scheme((s0//s1) - (s2//s1)^2)\n    3: scheme((s0//s2)*(s1//s2) - 1)\n  in the coordinate(s)\n    1: [(s1//s0), (s2//s0)]\n    2: [(s0//s1), (s2//s1)]\n    3: [(s0//s2), (s1//s2)]\n\njulia> affine_charts(Xcov)\n3-element Vector{AffineScheme{QQField, MPolyQuoRing{QQMPolyRingElem}}}:\n scheme((s1//s0) - (s2//s0)^2)\n scheme((s0//s1) - (s2//s1)^2)\n scheme((s0//s2)*(s1//s2) - 1)\n\n\n\n\n\n\n","category":"method"},{"location":"AlgebraicGeometry/Schemes/CoveredSchemes/","page":"Covered schemes","title":"Covered schemes","text":"Other attributes are the base_ring over which the scheme is defined and","category":"page"},{"location":"AlgebraicGeometry/Schemes/CoveredSchemes/","page":"Covered schemes","title":"Covered schemes","text":"default_covering(X::AbsCoveredScheme)","category":"page"},{"location":"AlgebraicGeometry/Schemes/CoveredSchemes/#default_covering-Tuple{AbsCoveredScheme}","page":"Covered schemes","title":"default_covering","text":"default_covering(X::AbsCoveredScheme)\n\nReturn the default covering for X.\n\nExamples\n\njulia> P = projective_space(QQ, 2);\n\njulia> S = homogeneous_coordinate_ring(P);\n\njulia> I = ideal(S, [S[1]*S[2]-S[3]^2]);\n\njulia> X = subscheme(P, I)\nProjective scheme\n  over rational field\ndefined by ideal (s0*s1 - s2^2)\n\njulia> Xcov = covered_scheme(X)\nScheme\n  over rational field\nwith default covering\n  described by patches\n    1: scheme((s1//s0) - (s2//s0)^2)\n    2: scheme((s0//s1) - (s2//s1)^2)\n    3: scheme((s0//s2)*(s1//s2) - 1)\n  in the coordinate(s)\n    1: [(s1//s0), (s2//s0)]\n    2: [(s0//s1), (s2//s1)]\n    3: [(s0//s2), (s1//s2)]\n\njulia> default_covering(Xcov)\nCovering\n  described by patches\n    1: scheme((s1//s0) - (s2//s0)^2)\n    2: scheme((s0//s1) - (s2//s1)^2)\n    3: scheme((s0//s2)*(s1//s2) - 1)\n  in the coordinate(s)\n    1: [(s1//s0), (s2//s0)]\n    2: [(s0//s1), (s2//s1)]\n    3: [(s0//s2), (s1//s2)]\n\n\n\n\n\n\n","category":"method"},{"location":"AlgebraicGeometry/Schemes/CoveredSchemes/#Properties","page":"Covered schemes","title":"Properties","text":"","category":"section"},{"location":"AlgebraicGeometry/Schemes/CoveredSchemes/","page":"Covered schemes","title":"Covered schemes","text":"An AbsCoveredScheme may have different properties such as","category":"page"},{"location":"AlgebraicGeometry/Schemes/CoveredSchemes/","page":"Covered schemes","title":"Covered schemes","text":"is_empty(X::AbsCoveredScheme)\nis_smooth(X::AbsCoveredScheme)","category":"page"},{"location":"AlgebraicGeometry/Schemes/CoveredSchemes/#Methods","page":"Covered schemes","title":"Methods","text":"","category":"section"},{"location":"AlgebraicGeometry/Schemes/CoveredSchemes/","page":"Covered schemes","title":"Covered schemes","text":"fiber_product(f::AbsCoveredSchemeMorphism, g::AbsCoveredSchemeMorphism)\nis_normal(X::AbsCoveredScheme; check::Bool=true)\nnormalization(X::AbsCoveredScheme; check::Bool=true)","category":"page"},{"location":"AlgebraicGeometry/Schemes/CoveredSchemes/#fiber_product-Tuple{AbsCoveredSchemeMorphism, AbsCoveredSchemeMorphism}","page":"Covered schemes","title":"fiber_product","text":"fiber_product(f::AbsCoveredSchemeMorphism, g::AbsCoveredSchemeMorphism)\n\nFor a diagram      XxY ––> Y      |        | g      V        V      X–––> Z          f this computes the fiber product XxY together with the canonical maps  to X and Y and returns the resulting triple.\n\n\n\n\n\n","category":"method"},{"location":"AlgebraicGeometry/Schemes/CoveredSchemes/#is_normal-Tuple{AbsCoveredScheme}","page":"Covered schemes","title":"is_normal","text":"is_normal(X::AbsCoveredScheme; check::Bool=true) -> Bool\n\nInput:\n\na reduced scheme X,\nif check is true, then confirm that X is reduced; this is expensive.\n\nOutput:\n\nReturns whether the scheme X is normal.\n\nExamples\n\njulia> R, (x, y, z) = QQ[:x, :y, :z];\n\njulia> X = covered_scheme(spec(R));\n\njulia> is_normal(X)\ntrue\n\n\n\n\n\n","category":"method"},{"location":"AlgebraicGeometry/Schemes/CoveredSchemes/#normalization-Tuple{AbsCoveredScheme}","page":"Covered schemes","title":"normalization","text":"normalization(X::AbsCoveredScheme; check::Bool=true) -> (AbsCoveredScheme, AbsCoveredSchemeMor, Vector{<:AbsCoveredSchemeMor})\n\nReturn the normalization of the reduced scheme X.\n\nInput:\n\na reduced scheme X,\nif check is true, then confirm that X is reduced; this is expensive.\n\nOutput:\n\nA triple (Y nucolon Y to X mathrminjs) where Y is a normal scheme, nu is the normalization, and mathrminjs is a vector of inclusion morphisms ı_icolon Y_i to Y, where Y_i are the connected components of the scheme Y. See Tag 0CDV in [Stacks] or Definition 7.5.1 in [Liu06] for normalization of non-integral schemes.\n\nExamples\n\njulia> R, (x, y, z) = graded_polynomial_ring(QQ, [:x, :y, :z]);\n\njulia> I = ideal(R, z*x^2 + y^3);\n\njulia> X = covered_scheme(proj(R, I))\nScheme\n  over rational field\nwith default covering\n  described by patches\n    1: scheme((y//x)^3 + (z//x))\n    2: scheme((x//y)^2*(z//y) + 1)\n    3: scheme((x//z)^2 + (y//z)^3)\n  in the coordinate(s)\n    1: [(y//x), (z//x)]\n    2: [(x//y), (z//y)]\n    3: [(x//z), (y//z)]\n\njulia> Y, pr_mor = normalization(X);\n\njulia> Y\nScheme\n  over rational field\nwith default covering\n  described by patches\n    1: scheme((y//x)^3 + (z//x))\n    2: scheme((x//y)^2*(z//y) + 1)\n    3: scheme(-T(1)*y + x, T(1)*x + y^2, T(1)^2 + y, x^2 + y^3)\n  in the coordinate(s)\n    1: [(y//x), (z//x)]\n    2: [(x//y), (z//y)]\n    3: [T(1), x, y]\n\njulia> pr_mor\nCovered scheme morphism\n  from scheme over QQ covered with 3 patches\n    1a: [(y//x), (z//x)]   scheme((y//x)^3 + (z//x))\n    2a: [(x//y), (z//y)]   scheme((x//y)^2*(z//y) + 1)\n    3a: [T(1), x, y]       scheme(-T(1)*y + x, T(1)*x + y^2, T(1)^2 + y, x^2 + y^3)\n  to scheme over QQ covered with 3 patches\n    1b: [(y//x), (z//x)]   scheme((y//x)^3 + (z//x))\n    2b: [(x//y), (z//y)]   scheme((x//y)^2*(z//y) + 1)\n    3b: [(x//z), (y//z)]   scheme((x//z)^2 + (y//z)^3)\ngiven by the pullback functions\n  1a -> 1b\n    (y//x) -> (y//x)\n    (z//x) -> (z//x)\n    ----------------------------------------\n  2a -> 2b\n    (x//y) -> (x//y)\n    (z//y) -> (z//y)\n    ----------------------------------------\n  3a -> 3b\n    (x//z) -> x\n    (y//z) -> y\n\njulia> inclusion_morphisms(pr_mor)\n1-element Vector{CoveredSchemeMorphism{CoveredScheme{QQField}, CoveredScheme{QQField}, AbsAffineSchemeMor}}:\n Hom: scheme over QQ covered with 3 patches -> scheme over QQ covered with 3 patches\n\n\n\n\n\n","category":"method"},{"location":"AlgebraicGeometry/Schemes/CoveredSchemes/#The-modeling-of-covered-schemes-and-their-expected-behavior","page":"Covered schemes","title":"The modeling of covered schemes and their expected behavior","text":"","category":"section"},{"location":"AlgebraicGeometry/Schemes/CoveredSchemes/","page":"Covered schemes","title":"Covered schemes","text":"Any AbsCoveredScheme may possess several Coverings. This is necessary for several reasons; for instance, a morphism f  X to Y between AbsCoveredSchemes will in general only be given on affine patches on a refinement of the default_covering of X. The list of available Coverings can be obtained using","category":"page"},{"location":"AlgebraicGeometry/Schemes/CoveredSchemes/","page":"Covered schemes","title":"Covered schemes","text":"coverings(X::AbsCoveredScheme)","category":"page"},{"location":"AlgebraicGeometry/Schemes/CoveredSchemes/#coverings-Tuple{AbsCoveredScheme}","page":"Covered schemes","title":"coverings","text":"coverings(X::AbsCoveredScheme)\n\nReturn the list of internally stored Coverings of X.\n\nExamples\n\njulia> P = projective_space(QQ, 2);\n\njulia> Pcov = covered_scheme(P)\nScheme\n  over rational field\nwith default covering\n  described by patches\n    1: affine 2-space\n    2: affine 2-space\n    3: affine 2-space\n  in the coordinate(s)\n    1: [(s1//s0), (s2//s0)]\n    2: [(s0//s1), (s2//s1)]\n    3: [(s0//s2), (s1//s2)]\n\njulia> coverings(Pcov)\n1-element Vector{Covering{QQField}}:\n Covering with 3 patches\n\n\n\n\n\n","category":"method"},{"location":"AlgebraicGeometry/Schemes/CoveredSchemes/","page":"Covered schemes","title":"Covered schemes","text":"Every AbsCoveredScheme X has to be modeled using one original default_covering C, simply to gather the data necessary to fully describe X. The affine_charts of X return the patches of this covering. For any refinement D  C, we require the following to hold: Every element U of the affine_charts of D is either","category":"page"},{"location":"AlgebraicGeometry/Schemes/CoveredSchemes/","page":"Covered schemes","title":"Covered schemes","text":"directly an element of the affine_charts of C;\na PrincipalOpenSubset with some ancestor in the affine_charts of C;\na SimplifiedAffineScheme with some original in the affine_charts of C.","category":"page"},{"location":"AlgebraicGeometry/Schemes/CoveredSchemes/","page":"Covered schemes","title":"Covered schemes","text":"In all these cases, the affine subsets in the refinements form a tree and thus remember their origins and ambient spaces. In particular, affine patches and also their gluings can be recycled and reused in different coverings and the latter should be merely seen as lists pointing to the objects involved.","category":"page"},{"location":"AbstractAlgebra/polynomial/","page":"Univariate polynomial functionality","title":"Univariate polynomial functionality","text":"CurrentModule = AbstractAlgebra\nDocTestSetup = AbstractAlgebra.doctestsetup()","category":"page"},{"location":"AbstractAlgebra/polynomial/#Univariate-polynomial-functionality","page":"Univariate polynomial functionality","title":"Univariate polynomial functionality","text":"","category":"section"},{"location":"AbstractAlgebra/polynomial/","page":"Univariate polynomial functionality","title":"Univariate polynomial functionality","text":"AbstractAlgebra.jl provides a module, implemented in src/Poly.jl for polynomials over any commutative ring belonging to the AbstractAlgebra abstract type hierarchy. This functionality will work for any univariate polynomial type which follows the Univariate Polynomial Ring interface.","category":"page"},{"location":"AbstractAlgebra/polynomial/#Generic-univariate-polynomial-types","page":"Univariate polynomial functionality","title":"Generic univariate polynomial types","text":"","category":"section"},{"location":"AbstractAlgebra/polynomial/","page":"Univariate polynomial functionality","title":"Univariate polynomial functionality","text":"AbstractAlgebra.jl provides a generic polynomial type based on Julia arrays which is implemented in src/generic/Poly.jl.","category":"page"},{"location":"AbstractAlgebra/polynomial/","page":"Univariate polynomial functionality","title":"Univariate polynomial functionality","text":"These generic polynomials have type Generic.Poly{T} where T is the type of elements of the coefficient ring. Internally they consist of a Julia array of coefficients and some additional fields for length and a parent object, etc. See the file src/generic/GenericTypes.jl for details.","category":"page"},{"location":"AbstractAlgebra/polynomial/","page":"Univariate polynomial functionality","title":"Univariate polynomial functionality","text":"Parent objects of such polynomials have type Generic.PolyRing{T}.","category":"page"},{"location":"AbstractAlgebra/polynomial/","page":"Univariate polynomial functionality","title":"Univariate polynomial functionality","text":"The string representation of the variable of the polynomial ring and the base/coefficient ring R is stored in the parent object.","category":"page"},{"location":"AbstractAlgebra/polynomial/#Abstract-types","page":"Univariate polynomial functionality","title":"Abstract types","text":"","category":"section"},{"location":"AbstractAlgebra/polynomial/","page":"Univariate polynomial functionality","title":"Univariate polynomial functionality","text":"All univariate polynomial element types belong to the abstract type PolyRingElem{T} and the polynomial ring types belong to the abstract type PolyRing{T}. This enables one to write generic functions that can accept any AbstractAlgebra polynomial type.","category":"page"},{"location":"AbstractAlgebra/polynomial/","page":"Univariate polynomial functionality","title":"Univariate polynomial functionality","text":"note: Note\nBoth the generic polynomial ring type Generic.PolyRing{T} and the abstract type it belongs to, PolyRing{T}, are called PolyRing. The former is a (parameterised) concrete type for a polynomial ring over a given base ring whose elements have type T. The latter is an abstract type representing all polynomial ring types in AbstractAlgebra.jl, whether generic or very specialised (e.g. supplied by a C library).","category":"page"},{"location":"AbstractAlgebra/polynomial/#Polynomial-ring-constructors","page":"Univariate polynomial functionality","title":"Polynomial ring constructors","text":"","category":"section"},{"location":"AbstractAlgebra/polynomial/","page":"Univariate polynomial functionality","title":"Univariate polynomial functionality","text":"In order to construct polynomials in AbstractAlgebra.jl, one must first construct the polynomial ring itself. This is accomplished with the following constructor.","category":"page"},{"location":"AbstractAlgebra/polynomial/","page":"Univariate polynomial functionality","title":"Univariate polynomial functionality","text":"polynomial_ring(R::NCRing, s::VarName; cached::Bool = true)","category":"page"},{"location":"AbstractAlgebra/polynomial/#polynomial_ring-Tuple{NCRing, Union{Char, AbstractString, Symbol}}-AbstractAlgebra-polynomial","page":"Univariate polynomial functionality","title":"polynomial_ring","text":"polynomial_ring(R::NCRing, s::VarName = :x; cached::Bool = true)\n\nGiven a base ring R and symbol/string s specifying how the generator (variable) should be printed, return a tuple S, x representing the new polynomial ring S = Rx and the generator x of the ring.\n\nBy default the parent object S depends only on R and x and will be cached. Setting the optional argument cached to false will prevent the parent object S from being cached.\n\nExamples\n\njulia> R, x = polynomial_ring(ZZ, :x)\n(Univariate polynomial ring in x over integers, x)\n\njulia> S, y = polynomial_ring(R, :y)\n(Univariate polynomial ring in y over R, y)\n\n\n\n\n\n","category":"method"},{"location":"AbstractAlgebra/polynomial/","page":"Univariate polynomial functionality","title":"Univariate polynomial functionality","text":"A shorthand version of this function is provided: given a base ring R, we abbreviate the constructor as follows.","category":"page"},{"location":"AbstractAlgebra/polynomial/","page":"Univariate polynomial functionality","title":"Univariate polynomial functionality","text":"R[:x]","category":"page"},{"location":"AbstractAlgebra/polynomial/","page":"Univariate polynomial functionality","title":"Univariate polynomial functionality","text":"Here are some examples of creating polynomial rings and their associated generators.","category":"page"},{"location":"AbstractAlgebra/polynomial/","page":"Univariate polynomial functionality","title":"Univariate polynomial functionality","text":"Examples","category":"page"},{"location":"AbstractAlgebra/polynomial/","page":"Univariate polynomial functionality","title":"Univariate polynomial functionality","text":"julia> T, z = QQ[:z]\n(Univariate polynomial ring in z over rationals, z)\n\njulia> U, x = polynomial_ring(ZZ)\n(Univariate polynomial ring in x over integers, x)","category":"page"},{"location":"AbstractAlgebra/polynomial/","page":"Univariate polynomial functionality","title":"Univariate polynomial functionality","text":"All of the examples here are generic polynomial rings, but specialised implementations of polynomial rings provided by external modules will also usually provide a polynomial_ring constructor to allow creation of their polynomial rings.","category":"page"},{"location":"AbstractAlgebra/polynomial/#Polynomial-constructors","page":"Univariate polynomial functionality","title":"Polynomial constructors","text":"","category":"section"},{"location":"AbstractAlgebra/polynomial/","page":"Univariate polynomial functionality","title":"Univariate polynomial functionality","text":"Once a polynomial ring is constructed, there are various ways to construct polynomials in that ring.","category":"page"},{"location":"AbstractAlgebra/polynomial/","page":"Univariate polynomial functionality","title":"Univariate polynomial functionality","text":"The easiest way is simply using the generator returned by the polynomial_ring constructor and build up the polynomial using basic arithmetic.","category":"page"},{"location":"AbstractAlgebra/polynomial/","page":"Univariate polynomial functionality","title":"Univariate polynomial functionality","text":"The Julia language has special syntax for the construction of polynomials in terms of a generator, e.g. we can write 2x instead of 2*x.","category":"page"},{"location":"AbstractAlgebra/polynomial/","page":"Univariate polynomial functionality","title":"Univariate polynomial functionality","text":"A second way is to use the polynomial ring to construct a polynomial. There are the usual ways of constructing an element of a ring.","category":"page"},{"location":"AbstractAlgebra/polynomial/","page":"Univariate polynomial functionality","title":"Univariate polynomial functionality","text":"(R::PolyRing)() # constructs zero\n(R::PolyRing)(c::Integer)\n(R::PolyRing)(c::elem_type(R))\n(R::PolyRing{T})(a::T) where T <: RingElement","category":"page"},{"location":"AbstractAlgebra/polynomial/","page":"Univariate polynomial functionality","title":"Univariate polynomial functionality","text":"For polynommials there is also the following more general constructor accepting an array of coefficients.","category":"page"},{"location":"AbstractAlgebra/polynomial/","page":"Univariate polynomial functionality","title":"Univariate polynomial functionality","text":"(S::PolyRing{T})(A::Vector{T}) where T <: RingElem\n(S::PolyRing{T})(A::Vector{U}) where T <: RingElem, U <: RingElem\n(S::PolyRing{T})(A::Vector{U}) where T <: RingElem, U <: Integer","category":"page"},{"location":"AbstractAlgebra/polynomial/","page":"Univariate polynomial functionality","title":"Univariate polynomial functionality","text":"Construct the polynomial in the ring S with the given array of coefficients, i.e. where A[1] is the constant coefficient.","category":"page"},{"location":"AbstractAlgebra/polynomial/","page":"Univariate polynomial functionality","title":"Univariate polynomial functionality","text":"A third way of constructing polynomials is to construct them directly without creating the polynomial ring.","category":"page"},{"location":"AbstractAlgebra/polynomial/","page":"Univariate polynomial functionality","title":"Univariate polynomial functionality","text":"polynomial(R::Ring, arr::Vector{T}, var::VarName=:x; cached::Bool=true)","category":"page"},{"location":"AbstractAlgebra/polynomial/","page":"Univariate polynomial functionality","title":"Univariate polynomial functionality","text":"Given an array of coefficients construct the polynomial with those coefficients over the given ring and with the given variable.","category":"page"},{"location":"AbstractAlgebra/polynomial/","page":"Univariate polynomial functionality","title":"Univariate polynomial functionality","text":"Examples","category":"page"},{"location":"AbstractAlgebra/polynomial/","page":"Univariate polynomial functionality","title":"Univariate polynomial functionality","text":"julia> R, x = polynomial_ring(ZZ, :x)\n(Univariate polynomial ring in x over integers, x)\n\njulia> S, y = polynomial_ring(R, :y)\n(Univariate polynomial ring in y over R, y)\n\njulia> f = x^3 + 3x + 21\nx^3 + 3*x + 21\n\njulia> g = (x + 1)*y^2 + 2x + 1\n(x + 1)*y^2 + 2*x + 1\n\njulia> R()\n0\n\njulia> S(1)\n1\n\njulia> S(y)\ny\n\njulia> S(x)\nx\n\njulia> S, x = polynomial_ring(QQ, :x)\n(Univariate polynomial ring in x over rationals, x)\n\njulia> f = S(Rational{BigInt}[2, 3, 1])\nx^2 + 3*x + 2\n\njulia> g = S(BigInt[1, 0, 4])\n4*x^2 + 1\n\njulia> h = S([4, 7, 2, 9])\n9*x^3 + 2*x^2 + 7*x + 4\n\njulia> p = polynomial(ZZ, [1, 2, 3])\n3*x^2 + 2*x + 1\n\njulia> f = polynomial(ZZ, [1, 2, 3], :y)\n3*y^2 + 2*y + 1","category":"page"},{"location":"AbstractAlgebra/polynomial/#Similar-and-zero","page":"Univariate polynomial functionality","title":"Similar and zero","text":"","category":"section"},{"location":"AbstractAlgebra/polynomial/","page":"Univariate polynomial functionality","title":"Univariate polynomial functionality","text":"Another way of constructing polynomials is to construct one similar to an existing polynomial using either similar or zero. ","category":"page"},{"location":"AbstractAlgebra/polynomial/","page":"Univariate polynomial functionality","title":"Univariate polynomial functionality","text":"similar(x::MyPoly{T}, R::Ring=base_ring(x)) where T <: RingElem\nzero(x::MyPoly{T}, R::Ring=base_ring(x)) where T <: RingElem","category":"page"},{"location":"AbstractAlgebra/polynomial/","page":"Univariate polynomial functionality","title":"Univariate polynomial functionality","text":"Construct the zero polynomial with the same variable as the given polynomial with coefficients in the given ring. Both functions behave the same way for polynomials.","category":"page"},{"location":"AbstractAlgebra/polynomial/","page":"Univariate polynomial functionality","title":"Univariate polynomial functionality","text":"similar(x::MyPoly{T}, R::Ring, var::VarName=var(parent(x))) where T <: RingElem\nsimilar(x::MyPoly{T}, var::VarName=var(parent(x))) where T <: RingElem\nzero(x::MyPoly{T}, R::Ring, var::VarName=var(parent(x))) where T <: RingElem\nzero(x::MyPoly{T}, var::VarName=var(parent(x))) where T <: RingElem","category":"page"},{"location":"AbstractAlgebra/polynomial/","page":"Univariate polynomial functionality","title":"Univariate polynomial functionality","text":"Construct the zero polynomial with the given variable and coefficients in the given ring, if specified, and in the coefficient ring of the given polynomial otherwise.","category":"page"},{"location":"AbstractAlgebra/polynomial/","page":"Univariate polynomial functionality","title":"Univariate polynomial functionality","text":"Examples","category":"page"},{"location":"AbstractAlgebra/polynomial/","page":"Univariate polynomial functionality","title":"Univariate polynomial functionality","text":"julia> R, x = polynomial_ring(ZZ, :x)\n(Univariate polynomial ring in x over integers, x)\n\njulia> f = 1 + 2x + 3x^2\n3*x^2 + 2*x + 1\n\njulia> g = similar(f)\n0\n\njulia> h = similar(f, QQ)\n0\n\njulia> k = similar(f, QQ, :y)\n0","category":"page"},{"location":"AbstractAlgebra/polynomial/#Functions-for-types-and-parents-of-polynomial-rings","page":"Univariate polynomial functionality","title":"Functions for types and parents of polynomial rings","text":"","category":"section"},{"location":"AbstractAlgebra/polynomial/","page":"Univariate polynomial functionality","title":"Univariate polynomial functionality","text":"base_ring(R::PolyRing)\nbase_ring(a::PolyRingElem)","category":"page"},{"location":"AbstractAlgebra/polynomial/","page":"Univariate polynomial functionality","title":"Univariate polynomial functionality","text":"Return the coefficient ring of the given polynomial ring or polynomial.","category":"page"},{"location":"AbstractAlgebra/polynomial/","page":"Univariate polynomial functionality","title":"Univariate polynomial functionality","text":"parent(a::NCRingElement)","category":"page"},{"location":"AbstractAlgebra/polynomial/","page":"Univariate polynomial functionality","title":"Univariate polynomial functionality","text":"Return the polynomial ring of the given polynomial..","category":"page"},{"location":"AbstractAlgebra/polynomial/","page":"Univariate polynomial functionality","title":"Univariate polynomial functionality","text":"characteristic(R::NCRing)","category":"page"},{"location":"AbstractAlgebra/polynomial/","page":"Univariate polynomial functionality","title":"Univariate polynomial functionality","text":"Return the characteristic of the given polynomial ring. If the characteristic is not known, an exception is raised.","category":"page"},{"location":"AbstractAlgebra/polynomial/","page":"Univariate polynomial functionality","title":"Univariate polynomial functionality","text":"Examples","category":"page"},{"location":"AbstractAlgebra/polynomial/","page":"Univariate polynomial functionality","title":"Univariate polynomial functionality","text":"julia> R, x = polynomial_ring(ZZ, :x)\n(Univariate polynomial ring in x over integers, x)\n\njulia> S, y = polynomial_ring(R, :y)\n(Univariate polynomial ring in y over R, y)\n\njulia> U = base_ring(S)\nUnivariate polynomial ring in x over integers\n\njulia> V = base_ring(y + 1)\nUnivariate polynomial ring in x over integers\n\njulia> T = parent(y + 1)\nUnivariate polynomial ring in y over R","category":"page"},{"location":"AbstractAlgebra/polynomial/#Euclidean-polynomial-rings","page":"Univariate polynomial functionality","title":"Euclidean polynomial rings","text":"","category":"section"},{"location":"AbstractAlgebra/polynomial/","page":"Univariate polynomial functionality","title":"Univariate polynomial functionality","text":"For polynomials over a field, the Euclidean Ring Interface is implemented.","category":"page"},{"location":"AbstractAlgebra/polynomial/","page":"Univariate polynomial functionality","title":"Univariate polynomial functionality","text":"mod(f::PolyRingElem, g::PolyRingElem)\ndivrem(f::PolyRingElem, g::PolyRingElem)\ndiv(f::PolyRingElem, g::PolyRingElem)","category":"page"},{"location":"AbstractAlgebra/polynomial/","page":"Univariate polynomial functionality","title":"Univariate polynomial functionality","text":"mulmod(f::PolyRingElem, g::PolyRingElem, m::PolyRingElem)\npowermod(f::PolyRingElem, e::Int, m::PolyRingElem)\ninvmod(f::PolyRingElem, m::PolyRingElem)","category":"page"},{"location":"AbstractAlgebra/polynomial/","page":"Univariate polynomial functionality","title":"Univariate polynomial functionality","text":"divides(f::PolyRingElem, g::PolyRingElem)\nremove(f::PolyRingElem, p::PolyRingElem)\nvaluation(f::PolyRingElem, p::PolyRingElem)","category":"page"},{"location":"AbstractAlgebra/polynomial/","page":"Univariate polynomial functionality","title":"Univariate polynomial functionality","text":"gcd(f::PolyRingElem, g::PolyRingElem)\nlcm(f::PolyRingElem, g::PolyRingElem)\ngcdx(f::PolyRingElem, g::PolyRingElem)\ngcdinv(f::PolyRingElem, g::PolyRingElem)","category":"page"},{"location":"AbstractAlgebra/polynomial/","page":"Univariate polynomial functionality","title":"Univariate polynomial functionality","text":"Examples","category":"page"},{"location":"AbstractAlgebra/polynomial/","page":"Univariate polynomial functionality","title":"Univariate polynomial functionality","text":"julia> R, x = polynomial_ring(QQ, :x)\n(Univariate polynomial ring in x over rationals, x)\n\njulia> S, = residue_ring(R, x^3 + 3x + 1);\n\njulia> T, y = polynomial_ring(S, :y)\n(Univariate polynomial ring in y over S, y)\n\njulia> f = (3*x^2 + x + 2)*y + x^2 + 1\n(3*x^2 + x + 2)*y + x^2 + 1\n\njulia> g = (5*x^2 + 2*x + 1)*y^2 + 2x*y + x + 1\n(5*x^2 + 2*x + 1)*y^2 + 2*x*y + x + 1\n\njulia> h = (3*x^3 + 2*x^2 + x + 7)*y^5 + 2x*y + 1\n(2*x^2 - 8*x + 4)*y^5 + 2*x*y + 1\n\njulia> invmod(f, g)\n(707//3530*x^2 + 2151//1765*x + 123//3530)*y - 178//1765*x^2 - 551//3530*x + 698//1765\n\njulia> mulmod(f, g, h)\n(-30*x^2 - 43*x - 9)*y^3 + (-7*x^2 - 23*x - 7)*y^2 + (4*x^2 - 10*x - 3)*y + x^2 - 2*x\n\njulia> powermod(f, 3, h)\n(69*x^2 + 243*x + 79)*y^3 + (78*x^2 + 180*x + 63)*y^2 + (27*x^2 + 42*x + 18)*y + 3*x^2 + 3*x + 2\n\njulia> h = mod(f, g)\n(3*x^2 + x + 2)*y + x^2 + 1\n\njulia> q, r = divrem(f, g)\n(0, (3*x^2 + x + 2)*y + x^2 + 1)\n\njulia> div(g, f)\n(-5//11*x^2 + 2//11*x + 6//11)*y - 13//121*x^2 - 3//11*x - 78//121\n\njulia> d = gcd(f*h, g*h)\ny + 1//11*x^2 + 6//11\n\njulia> k = gcdinv(f, h)\n(y + 1//11*x^2 + 6//11, 0)\n\njulia> m = lcm(f, h)\n(-14*x^2 - 23*x - 2)*y - 4*x^2 - 5*x + 1\n\njulia> flag, q = divides(g^2, g)\n(true, (5*x^2 + 2*x + 1)*y^2 + 2*x*y + x + 1)\n\njulia> valuation(3g^3, g) == 3\ntrue\n\njulia> val, q = remove(5g^3, g)\n(3, 5)\n\njulia> r, s, t = gcdx(g, h)\n(1, 311//3530*x^2 - 2419//3530*x + 947//1765, (707//3530*x^2 + 2151//1765*x + 123//3530)*y - 178//1765*x^2 - 551//3530*x + 698//1765)\n","category":"page"},{"location":"AbstractAlgebra/polynomial/","page":"Univariate polynomial functionality","title":"Univariate polynomial functionality","text":"Functions in the Euclidean Ring interface are supported over residue rings that are not fields, except that if an impossible inverse is encountered during the computation an error is thrown.","category":"page"},{"location":"AbstractAlgebra/polynomial/#Polynomial-functions","page":"Univariate polynomial functionality","title":"Polynomial functions","text":"","category":"section"},{"location":"AbstractAlgebra/polynomial/#Basic-functionality","page":"Univariate polynomial functionality","title":"Basic functionality","text":"","category":"section"},{"location":"AbstractAlgebra/polynomial/","page":"Univariate polynomial functionality","title":"Univariate polynomial functionality","text":"All basic ring functionality is provided for polynomials. The most important such functions are the following.","category":"page"},{"location":"AbstractAlgebra/polynomial/","page":"Univariate polynomial functionality","title":"Univariate polynomial functionality","text":"zero(R::PolyRing)\none(R::PolyRing)\niszero(a::PolyRingElem)\nisone(a::PolyRingElem)","category":"page"},{"location":"AbstractAlgebra/polynomial/","page":"Univariate polynomial functionality","title":"Univariate polynomial functionality","text":"divexact(a::T, b::T) where T <: PolyRingElem","category":"page"},{"location":"AbstractAlgebra/polynomial/","page":"Univariate polynomial functionality","title":"Univariate polynomial functionality","text":"All functions in the polynomial interface are provided. The most important are the following.","category":"page"},{"location":"AbstractAlgebra/polynomial/","page":"Univariate polynomial functionality","title":"Univariate polynomial functionality","text":"var(S::PolyRing)\nsymbols(S::PolyRing{T}) where T <: RingElem","category":"page"},{"location":"AbstractAlgebra/polynomial/","page":"Univariate polynomial functionality","title":"Univariate polynomial functionality","text":"Return a symbol or length 1 array of symbols, respectively, specifying the variable of the polynomial ring. This symbol is converted to a string when printing polynomials in that ring.","category":"page"},{"location":"AbstractAlgebra/polynomial/","page":"Univariate polynomial functionality","title":"Univariate polynomial functionality","text":"In addition, the following basic functions are provided.","category":"page"},{"location":"AbstractAlgebra/polynomial/","page":"Univariate polynomial functionality","title":"Univariate polynomial functionality","text":"modulus{T <: ResElem}(::PolyRingElem{T})","category":"page"},{"location":"AbstractAlgebra/polynomial/#modulus-Union{Tuple{PolyRingElem{T}}, Tuple{T}} where T<:ResElem","page":"Univariate polynomial functionality","title":"modulus","text":"modulus(a::PolyRingElem{T}) where {T <: ResElem}\n\nReturn the modulus of the coefficients of the given polynomial.\n\n\n\n\n\n","category":"method"},{"location":"AbstractAlgebra/polynomial/","page":"Univariate polynomial functionality","title":"Univariate polynomial functionality","text":"leading_coefficient(::PolyRingElem)\ntrailing_coefficient(::PolyRingElem)\nconstant_coefficient(::PolynomialElem)","category":"page"},{"location":"AbstractAlgebra/polynomial/#leading_coefficient-Tuple{PolyRingElem}","page":"Univariate polynomial functionality","title":"leading_coefficient","text":"leading_coefficient(a::PolynomialElem)\n\nReturn the leading coefficient of the given polynomial. This will be the nonzero coefficient of the term with highest degree unless the polynomial in the zero polynomial, in which case a zero coefficient is returned.\n\n\n\n\n\nleading_coefficient(p::MPolyRingElem)\n\nReturn the leading coefficient of the polynomial p.\n\n\n\n\n\n","category":"method"},{"location":"AbstractAlgebra/polynomial/#trailing_coefficient-Tuple{PolyRingElem}","page":"Univariate polynomial functionality","title":"trailing_coefficient","text":"trailing_coefficient(a::PolynomialElem)\n\nReturn the trailing coefficient of the given polynomial. This will be the nonzero coefficient of the term with lowest degree unless the polynomial is the zero polynomial, in which case a zero coefficient is returned.\n\n\n\n\n\ntrailing_coefficient(p::MPolyRingElem)\n\nReturn the trailing coefficient of the polynomial p, i.e. the coefficient of the last nonzero term, or zero if the polynomial is zero.\n\n\n\n\n\n","category":"method"},{"location":"AbstractAlgebra/polynomial/#constant_coefficient-Tuple{PolynomialElem}","page":"Univariate polynomial functionality","title":"constant_coefficient","text":"constant_coefficient(a::PolynomialElem)\n\nReturn the constant coefficient of the given polynomial. If the polynomial is the zero polynomial, the function will return zero.\n\n\n\n\n\n","category":"method"},{"location":"AbstractAlgebra/polynomial/","page":"Univariate polynomial functionality","title":"Univariate polynomial functionality","text":"set_coefficient!(::PolynomialElem{T}, ::Int, c::T) where T <: RingElement","category":"page"},{"location":"AbstractAlgebra/polynomial/#set_coefficient!-Union{Tuple{T}, Tuple{PolynomialElem{T}, Int64, T}} where T<:RingElement","page":"Univariate polynomial functionality","title":"set_coefficient!","text":"set_coefficient!(c::PolynomialElem{T}, n::Int, a::T) where T <: RingElement\nset_coefficient!(c::PolynomialElem{T}, n::Int, a::U) where {T <: RingElement, U <: Integer}\n\nSet the coefficient of degree n to a.\n\n\n\n\n\n","category":"method"},{"location":"AbstractAlgebra/polynomial/","page":"Univariate polynomial functionality","title":"Univariate polynomial functionality","text":"tail(::PolynomialElem)","category":"page"},{"location":"AbstractAlgebra/polynomial/#tail-Tuple{PolynomialElem}","page":"Univariate polynomial functionality","title":"tail","text":"tail(a::PolynomialElem)\n\nReturn the tail of the given polynomial, i.e. the polynomial without its leading term (if any).\n\n\n\n\n\n","category":"method"},{"location":"AbstractAlgebra/polynomial/","page":"Univariate polynomial functionality","title":"Univariate polynomial functionality","text":"gen(::PolyRingElem)","category":"page"},{"location":"AbstractAlgebra/polynomial/#gen-Tuple{PolyRingElem}","page":"Univariate polynomial functionality","title":"gen","text":"gen(M::SubquoModule{T}, i::Int) where T\n\nReturn the ith generator of M.\n\n\n\n\n\ngen(a::MPolyRing{T}, i::Int) where {T <: RingElement}\n\nReturn the i-th generator (variable) of the given polynomial ring.\n\n\n\n\n\ngen(R::AbsPowerSeriesRing{T}) where T <: RingElement\n\nReturn the generator of the power series ring, i.e. x + O(x^n) where n is the precision of the power series ring R.\n\n\n\n\n\n","category":"method"},{"location":"AbstractAlgebra/polynomial/","page":"Univariate polynomial functionality","title":"Univariate polynomial functionality","text":"is_gen(::PolyRingElem)","category":"page"},{"location":"AbstractAlgebra/polynomial/#is_gen-Tuple{PolyRingElem}","page":"Univariate polynomial functionality","title":"is_gen","text":"is_gen(a::PolynomialElem)\n\nReturn true if the given polynomial is the constant generator of its polynomial ring, otherwise return false.\n\n\n\n\n\nis_gen(x::MPoly{T}) where {T <: RingElement}\n\nReturn true if the given polynomial is a generator (variable) of the polynomial ring it belongs to.\n\n\n\n\n\n","category":"method"},{"location":"AbstractAlgebra/polynomial/","page":"Univariate polynomial functionality","title":"Univariate polynomial functionality","text":"is_monic(::PolyRingElem)","category":"page"},{"location":"AbstractAlgebra/polynomial/#is_monic-Tuple{PolyRingElem}","page":"Univariate polynomial functionality","title":"is_monic","text":"is_monic(a::PolynomialElem)\n\nReturn true if the given polynomial is monic, i.e. has leading coefficient equal to one, otherwise return false.\n\n\n\n\n\n","category":"method"},{"location":"AbstractAlgebra/polynomial/","page":"Univariate polynomial functionality","title":"Univariate polynomial functionality","text":"is_square(::PolyRingElem)","category":"page"},{"location":"AbstractAlgebra/polynomial/#is_square-Tuple{PolyRingElem}","page":"Univariate polynomial functionality","title":"is_square","text":"is_square(f::PolyRingElem{T}) where T <: RingElement\n\nReturn true if f is a perfect square.\n\n\n\n\n\nis_square(a::FracElem{T}) where T <: RingElem\n\nReturn true if a is a square.\n\n\n\n\n\n","category":"method"},{"location":"AbstractAlgebra/polynomial/","page":"Univariate polynomial functionality","title":"Univariate polynomial functionality","text":"length(::PolynomialElem)","category":"page"},{"location":"AbstractAlgebra/polynomial/#length-Tuple{PolynomialElem}","page":"Univariate polynomial functionality","title":"length","text":"length(a::PolynomialElem)\n\nReturn the length of the polynomial. The length of a univariate polynomial is defined to be the number of coefficients in its dense representation, including zero coefficients. Thus naturally the zero polynomial has length zero and additionally for nonzero polynomials the length is one more than the degree. (Note that the leading coefficient will always be nonzero.)\n\n\n\n\n\n","category":"method"},{"location":"AbstractAlgebra/polynomial/","page":"Univariate polynomial functionality","title":"Univariate polynomial functionality","text":"degree(::PolynomialElem)","category":"page"},{"location":"AbstractAlgebra/polynomial/#degree-Tuple{PolynomialElem}","page":"Univariate polynomial functionality","title":"degree","text":"degree(a::PolynomialElem)\n\nReturn the degree of the given polynomial. This is defined to be one less than the length, even for constant polynomials.\n\n\n\n\n\n","category":"method"},{"location":"AbstractAlgebra/polynomial/","page":"Univariate polynomial functionality","title":"Univariate polynomial functionality","text":"is_monomial(::PolyRingElem)","category":"page"},{"location":"AbstractAlgebra/polynomial/#is_monomial-Tuple{PolyRingElem}","page":"Univariate polynomial functionality","title":"is_monomial","text":"is_monomial(a::PolynomialElem)\n\nReturn true if the given polynomial is a monomial.\n\n\n\n\n\nis_monomial(x::MPolyRingElem)\n\nReturn true if the given polynomial has precisely one term whose coefficient is one.\n\n\n\n\n\n","category":"method"},{"location":"AbstractAlgebra/polynomial/","page":"Univariate polynomial functionality","title":"Univariate polynomial functionality","text":"is_monomial_recursive(::PolyRingElem)","category":"page"},{"location":"AbstractAlgebra/polynomial/#is_monomial_recursive-Tuple{PolyRingElem}","page":"Univariate polynomial functionality","title":"is_monomial_recursive","text":"is_monomial_recursive(a::PolynomialElem)\n\nReturn true if the given polynomial is a monomial. This function is recursive, with all scalar types returning true.\n\n\n\n\n\n","category":"method"},{"location":"AbstractAlgebra/polynomial/","page":"Univariate polynomial functionality","title":"Univariate polynomial functionality","text":"is_term(::PolyRingElem)","category":"page"},{"location":"AbstractAlgebra/polynomial/#is_term-Tuple{PolyRingElem}","page":"Univariate polynomial functionality","title":"is_term","text":"is_term(a::PolynomialElem)\n\nReturn true if the given polynomial has one term.\n\n\n\n\n\nis_term(x::MPolyRingElem)\n\nReturn true if the given polynomial has precisely one term.\n\n\n\n\n\n","category":"method"},{"location":"AbstractAlgebra/polynomial/","page":"Univariate polynomial functionality","title":"Univariate polynomial functionality","text":"is_term_recursive(::PolyRingElem)","category":"page"},{"location":"AbstractAlgebra/polynomial/#is_term_recursive-Tuple{PolyRingElem}","page":"Univariate polynomial functionality","title":"is_term_recursive","text":"is_term_recursive(a::PolynomialElem)\n\nReturn true if the given polynomial has one term. This function is recursive, with all scalar types returning true.\n\n\n\n\n\n","category":"method"},{"location":"AbstractAlgebra/polynomial/","page":"Univariate polynomial functionality","title":"Univariate polynomial functionality","text":"is_constant(::PolynomialElem)","category":"page"},{"location":"AbstractAlgebra/polynomial/#is_constant-Tuple{PolynomialElem}","page":"Univariate polynomial functionality","title":"is_constant","text":"is_constant(a::PolynomialElem)\n\nReturn true if a is a degree zero polynomial or the zero polynomial, i.e. a constant polynomial.\n\n\n\n\n\n","category":"method"},{"location":"AbstractAlgebra/polynomial/","page":"Univariate polynomial functionality","title":"Univariate polynomial functionality","text":"Examples","category":"page"},{"location":"AbstractAlgebra/polynomial/","page":"Univariate polynomial functionality","title":"Univariate polynomial functionality","text":"julia> R, x = polynomial_ring(ZZ, :x)\n(Univariate polynomial ring in x over integers, x)\n\njulia> S, y = polynomial_ring(R, :y)\n(Univariate polynomial ring in y over R, y)\n\njulia> T, z = polynomial_ring(QQ, :z)\n(Univariate polynomial ring in z over rationals, z)\n\njulia> U, = residue_ring(ZZ, 17);\n\njulia> V, w = polynomial_ring(U, :w)\n(Univariate polynomial ring in w over U, w)\n\njulia> var(R)\n:x\n\njulia> symbols(R)\n1-element Vector{Symbol}:\n :x\n\njulia> a = zero(S)\n0\n\njulia> b = one(S)\n1\n\njulia> isone(b)\ntrue\n\njulia> c = BigInt(1)//2*z^2 + BigInt(1)//3\n1//2*z^2 + 1//3\n\njulia> d = x*y^2 + (x + 1)*y + 3\nx*y^2 + (x + 1)*y + 3\n\njulia> f = leading_coefficient(d)\nx\n\njulia> y = gen(S)\ny\n\njulia> g = is_gen(w)\ntrue\n\njulia> divexact((2x + 1)*(x + 1), (x + 1))\n2*x + 1\n\njulia> m = is_unit(b)\ntrue\n\njulia> n = degree(d)\n2\n\njulia> r = modulus(w)\n17\n\njulia> is_term(2y^2)\ntrue\n\njulia> is_monomial(y^2)\ntrue\n\njulia> is_monomial_recursive(x*y^2)\ntrue\n\njulia> is_monomial(x*y^2)\nfalse\n\njulia> S, x = polynomial_ring(ZZ, :x)\n(Univariate polynomial ring in x over integers, x)\n\njulia> f = x^3 + 3x + 1\nx^3 + 3*x + 1\n\njulia> g = S(BigInt[1, 2, 0, 1, 0, 0, 0]);\n\njulia> n = length(f)\n4\n\njulia> c = coeff(f, 1)\n3\n\njulia> g = set_coefficient!(g, 2, ZZ(11))\nx^3 + 11*x^2 + 2*x + 1\n\njulia> g = set_coefficient!(g, 7, ZZ(4))\n4*x^7 + x^3 + 11*x^2 + 2*x + 1","category":"page"},{"location":"AbstractAlgebra/polynomial/#Iterators","page":"Univariate polynomial functionality","title":"Iterators","text":"","category":"section"},{"location":"AbstractAlgebra/polynomial/","page":"Univariate polynomial functionality","title":"Univariate polynomial functionality","text":"An iterator is provided to return the coefficients of a univariate polynomial. The iterator is called coefficients and allows iteration over the coefficients, starting with the term of degree zero (if there is one). Note that coefficients of each degree are given, even if they are zero. This is best illustrated by example.","category":"page"},{"location":"AbstractAlgebra/polynomial/","page":"Univariate polynomial functionality","title":"Univariate polynomial functionality","text":"Examples","category":"page"},{"location":"AbstractAlgebra/polynomial/","page":"Univariate polynomial functionality","title":"Univariate polynomial functionality","text":"julia> R, x = polynomial_ring(ZZ, :x)\n(Univariate polynomial ring in x over integers, x)\n\njulia> f = x^2 + 2\nx^2 + 2\n\njulia> C = collect(coefficients(f))\n3-element Vector{BigInt}:\n 2\n 0\n 1\n\njulia> for c in coefficients(f)\n          println(c)\n       end\n2\n0\n1","category":"page"},{"location":"AbstractAlgebra/polynomial/#Truncation","page":"Univariate polynomial functionality","title":"Truncation","text":"","category":"section"},{"location":"AbstractAlgebra/polynomial/","page":"Univariate polynomial functionality","title":"Univariate polynomial functionality","text":"truncate(::PolyRingElem, ::Int)","category":"page"},{"location":"AbstractAlgebra/polynomial/#truncate-Tuple{PolyRingElem, Int64}","page":"Univariate polynomial functionality","title":"truncate","text":"truncate(a::PolynomialElem, n::Int)\n\nReturn a truncated to n terms, i.e. the remainder upon division by x^n.\n\n\n\n\n\n","category":"method"},{"location":"AbstractAlgebra/polynomial/","page":"Univariate polynomial functionality","title":"Univariate polynomial functionality","text":"mullow{T <: RingElem}(::PolyRingElem{T}, ::PolyRingElem{T}, ::Int)","category":"page"},{"location":"AbstractAlgebra/polynomial/#mullow-Union{Tuple{T}, Tuple{PolyRingElem{T}, PolyRingElem{T}, Int64}} where T<:RingElem","page":"Univariate polynomial functionality","title":"mullow","text":"mullow(a::PolyRingElem{T}, b::PolyRingElem{T}, n::Int) where T <: RingElement\n\nReturn atimes b truncated to n terms.\n\n\n\n\n\n","category":"method"},{"location":"AbstractAlgebra/polynomial/","page":"Univariate polynomial functionality","title":"Univariate polynomial functionality","text":"Examples","category":"page"},{"location":"AbstractAlgebra/polynomial/","page":"Univariate polynomial functionality","title":"Univariate polynomial functionality","text":"julia> R, x = polynomial_ring(ZZ, :x)\n(Univariate polynomial ring in x over integers, x)\n\njulia> S, y = polynomial_ring(R, :y)\n(Univariate polynomial ring in y over R, y)\n\njulia> f = x*y^2 + (x + 1)*y + 3\nx*y^2 + (x + 1)*y + 3\n\njulia> g = (x + 1)*y + (x^3 + 2x + 2)\n(x + 1)*y + x^3 + 2*x + 2\n\njulia> h = truncate(f, 1)\n3\n\njulia> k = mullow(f, g, 4)\n(x^2 + x)*y^3 + (x^4 + 3*x^2 + 4*x + 1)*y^2 + (x^4 + x^3 + 2*x^2 + 7*x + 5)*y + 3*x^3 + 6*x + 6\n","category":"page"},{"location":"AbstractAlgebra/polynomial/#Reversal","page":"Univariate polynomial functionality","title":"Reversal","text":"","category":"section"},{"location":"AbstractAlgebra/polynomial/","page":"Univariate polynomial functionality","title":"Univariate polynomial functionality","text":"reverse(::PolyRingElem, ::Int)\nreverse(::PolyRingElem)","category":"page"},{"location":"AbstractAlgebra/polynomial/#reverse-Tuple{PolyRingElem, Int64}","page":"Univariate polynomial functionality","title":"reverse","text":"reverse(x::PolynomialElem, len::Int)\n\nReturn the reverse of the polynomial x, thought of as a polynomial of the given length (the polynomial will be notionally truncated or padded with zeroes before the leading term if necessary to match the specified length). The resulting polynomial is normalised. If len is negative we throw a DomainError().\n\n\n\n\n\n","category":"method"},{"location":"AbstractAlgebra/polynomial/#reverse-Tuple{PolyRingElem}","page":"Univariate polynomial functionality","title":"reverse","text":"reverse(x::PolynomialElem)\n\nReturn the reverse of the polynomial x, i.e. the leading coefficient of x becomes the constant coefficient of the result, etc. The resulting polynomial is normalised.\n\n\n\n\n\n","category":"method"},{"location":"AbstractAlgebra/polynomial/","page":"Univariate polynomial functionality","title":"Univariate polynomial functionality","text":"Examples","category":"page"},{"location":"AbstractAlgebra/polynomial/","page":"Univariate polynomial functionality","title":"Univariate polynomial functionality","text":"julia> R, x = polynomial_ring(ZZ, :x)\n(Univariate polynomial ring in x over integers, x)\n\njulia> S, y = polynomial_ring(R, :y)\n(Univariate polynomial ring in y over R, y)\n\njulia> f = x*y^2 + (x + 1)*y + 3\nx*y^2 + (x + 1)*y + 3\n\njulia> g = reverse(f, 7)\n3*y^6 + (x + 1)*y^5 + x*y^4\n\njulia> h = reverse(f)\n3*y^2 + (x + 1)*y + x\n","category":"page"},{"location":"AbstractAlgebra/polynomial/#Shifting","page":"Univariate polynomial functionality","title":"Shifting","text":"","category":"section"},{"location":"AbstractAlgebra/polynomial/","page":"Univariate polynomial functionality","title":"Univariate polynomial functionality","text":"shift_left(::PolyRingElem, ::Int)","category":"page"},{"location":"AbstractAlgebra/polynomial/#shift_left-Tuple{PolyRingElem, Int64}","page":"Univariate polynomial functionality","title":"shift_left","text":"shift_left(f::PolynomialElem, n::Int)\n\nReturn the polynomial f shifted left by n terms, i.e. multiplied by x^n.\n\n\n\n\n\n","category":"method"},{"location":"AbstractAlgebra/polynomial/","page":"Univariate polynomial functionality","title":"Univariate polynomial functionality","text":"shift_right(::PolyRingElem, ::Int)","category":"page"},{"location":"AbstractAlgebra/polynomial/#shift_right-Tuple{PolyRingElem, Int64}","page":"Univariate polynomial functionality","title":"shift_right","text":"shift_right(f::PolynomialElem, n::Int)\n\nReturn the polynomial f shifted right by n terms, i.e. divided by x^n.\n\n\n\n\n\n","category":"method"},{"location":"AbstractAlgebra/polynomial/","page":"Univariate polynomial functionality","title":"Univariate polynomial functionality","text":"Examples","category":"page"},{"location":"AbstractAlgebra/polynomial/","page":"Univariate polynomial functionality","title":"Univariate polynomial functionality","text":"julia> R, x = polynomial_ring(ZZ, :x)\n(Univariate polynomial ring in x over integers, x)\n\njulia> S, y = polynomial_ring(R, :y)\n(Univariate polynomial ring in y over R, y)\n\njulia> f = x*y^2 + (x + 1)*y + 3\nx*y^2 + (x + 1)*y + 3\n\njulia> g = shift_left(f, 7)\nx*y^9 + (x + 1)*y^8 + 3*y^7\n\njulia> h = shift_right(f, 2)\nx\n","category":"page"},{"location":"AbstractAlgebra/polynomial/#Inflation-and-deflation","page":"Univariate polynomial functionality","title":"Inflation and deflation","text":"","category":"section"},{"location":"AbstractAlgebra/polynomial/","page":"Univariate polynomial functionality","title":"Univariate polynomial functionality","text":"deflation(::PolyRingElem)","category":"page"},{"location":"AbstractAlgebra/polynomial/#deflation-Tuple{PolyRingElem}","page":"Univariate polynomial functionality","title":"deflation","text":"deflation(p::PolyRingElem)\n\nReturn a tuple (shift, defl) where shift is the exponent of the trailing term of p and defl is the gcd of the distance between the exponents of the nonzero terms of p. If p = 0, both shift and defl will be zero.\n\n\n\n\n\n","category":"method"},{"location":"AbstractAlgebra/polynomial/","page":"Univariate polynomial functionality","title":"Univariate polynomial functionality","text":"inflate(::PolyRingElem, ::Int, ::Int)\ninflate(::PolyRingElem, ::Int)","category":"page"},{"location":"AbstractAlgebra/polynomial/#inflate-Tuple{PolyRingElem, Int64, Int64}","page":"Univariate polynomial functionality","title":"inflate","text":"inflate(f::PolyRingElem, shift::Int64, n::Int64) -> PolyRingElem\n\nGiven a polynomial f in x, return f(x^n)*x^j, i.e. multiply all exponents by n and shift f left by j.\n\n\n\n\n\n","category":"method"},{"location":"AbstractAlgebra/polynomial/#inflate-Tuple{PolyRingElem, Int64}","page":"Univariate polynomial functionality","title":"inflate","text":"inflate(f::PolyRingElem, n::Int64) -> PolyRingElem\n\nGiven a polynomial f in x, return f(x^n), i.e. multiply all exponents by n.\n\n\n\n\n\n","category":"method"},{"location":"AbstractAlgebra/polynomial/","page":"Univariate polynomial functionality","title":"Univariate polynomial functionality","text":"deflate(::PolyRingElem, ::Int, ::Int)\ndeflate(::PolyRingElem, ::Int)\ndeflate(::PolyRingElem)","category":"page"},{"location":"AbstractAlgebra/polynomial/#deflate-Tuple{PolyRingElem, Int64, Int64}","page":"Univariate polynomial functionality","title":"deflate","text":"deflate(f::PolyRingElem, shift::Int64, n::Int64) -> PolyRingElem\n\nGiven a polynomial g in x^n such that f = g(x)*x^{shift}, write f as a polynomial in x, i.e. divide all exponents of g by n.\n\n\n\n\n\n","category":"method"},{"location":"AbstractAlgebra/polynomial/#deflate-Tuple{PolyRingElem, Int64}","page":"Univariate polynomial functionality","title":"deflate","text":"deflate(f::PolyRingElem, n::Int64) -> PolyRingElem\n\nGiven a polynomial f in x^n, write it as a polynomial in x, i.e. divide all exponents by n.\n\n\n\n\n\n","category":"method"},{"location":"AbstractAlgebra/polynomial/#deflate-Tuple{PolyRingElem}","page":"Univariate polynomial functionality","title":"deflate","text":"deflate(x::PolyRingElem) -> PolyRingElem, Int\n\nDeflate the polynomial f maximally, i.e. find the largest n s.th. f can be deflated by n, i.e. f is actually a polynomial in x^n. Return g n where g is the deflation of f.\n\n\n\n\n\n","category":"method"},{"location":"AbstractAlgebra/polynomial/#Square-root","page":"Univariate polynomial functionality","title":"Square root","text":"","category":"section"},{"location":"AbstractAlgebra/polynomial/","page":"Univariate polynomial functionality","title":"Univariate polynomial functionality","text":"Base.sqrt(::PolyRingElem{T}; check::Bool) where T <: RingElement","category":"page"},{"location":"AbstractAlgebra/polynomial/#sqrt-Union{Tuple{PolyRingElem{T}}, Tuple{T}} where T<:RingElement","page":"Univariate polynomial functionality","title":"sqrt","text":"Base.sqrt(f::PolyRingElem{T}; check::Bool=true) where T <: RingElement\n\nReturn the square root of f. By default the function checks the input is square and raises an exception if not. If check=false this check is omitted.\n\n\n\n\n\nsqrt(a::Generic.PuiseuxSeriesElem{T}; check::Bool=true) where T <: RingElement\n\nReturn the square root of the given Puiseux series a. By default the function will throw an exception if the input is not square. If check=false this test is omitted.\n\n\n\n\n\n","category":"method"},{"location":"AbstractAlgebra/polynomial/","page":"Univariate polynomial functionality","title":"Univariate polynomial functionality","text":"Examples","category":"page"},{"location":"AbstractAlgebra/polynomial/","page":"Univariate polynomial functionality","title":"Univariate polynomial functionality","text":"R, x = polynomial_ring(ZZ, :x)\ng = x^2+6*x+1\nsqrt(g^2)","category":"page"},{"location":"AbstractAlgebra/polynomial/#Change-of-base-ring","page":"Univariate polynomial functionality","title":"Change of base ring","text":"","category":"section"},{"location":"AbstractAlgebra/polynomial/","page":"Univariate polynomial functionality","title":"Univariate polynomial functionality","text":"change_base_ring(::Ring, ::PolyRingElem{T}) where T <: RingElement\nchange_coefficient_ring(::Ring, ::PolyRingElem{T}) where T <: RingElement\nmap_coefficients(::Any, ::PolyRingElem{<:RingElement})","category":"page"},{"location":"AbstractAlgebra/polynomial/#change_base_ring-Union{Tuple{T}, Tuple{Ring, PolyRingElem{T}}} where T<:RingElement","page":"Univariate polynomial functionality","title":"change_base_ring","text":"change_base_ring(R::Ring, p::PolyRingElem{<: RingElement}; parent::PolyRing)\n\nReturn the polynomial obtained by coercing the non-zero coefficients of p into R.\n\nIf the optional parent keyword is provided, the polynomial will be an element of parent. The caching of the parent object can be controlled via the cached keyword argument.\n\n\n\n\n\n","category":"method"},{"location":"AbstractAlgebra/polynomial/#change_coefficient_ring-Union{Tuple{T}, Tuple{Ring, PolyRingElem{T}}} where T<:RingElement","page":"Univariate polynomial functionality","title":"change_coefficient_ring","text":"change_coefficient_ring(R::Ring, p::PolyRingElem{<: RingElement}; parent::PolyRing)\n\nReturn the polynomial obtained by coercing the non-zero coefficients of p into R.\n\nIf the optional parent keyword is provided, the polynomial will be an element of parent. The caching of the parent object can be controlled via the cached keyword argument.\n\n\n\n\n\n","category":"method"},{"location":"AbstractAlgebra/polynomial/#map_coefficients-Tuple{Any, PolyRingElem{<:RingElement}}","page":"Univariate polynomial functionality","title":"map_coefficients","text":"map_coefficients(f, p::PolyRingElem{<: RingElement}; cached::Bool=true, parent::PolyRing)\n\nTransform the polynomial p by applying f on each non-zero coefficient.\n\nIf the optional parent keyword is provided, the polynomial will be an element of parent. The caching of the parent object can be controlled via the cached keyword argument.\n\n\n\n\n\n","category":"method"},{"location":"AbstractAlgebra/polynomial/","page":"Univariate polynomial functionality","title":"Univariate polynomial functionality","text":"Examples","category":"page"},{"location":"AbstractAlgebra/polynomial/","page":"Univariate polynomial functionality","title":"Univariate polynomial functionality","text":"R, x = polynomial_ring(ZZ, :x)\ng = x^3+6*x + 1\nchange_base_ring(GF(2), g)\nchange_coefficient_ring(GF(2), g)","category":"page"},{"location":"AbstractAlgebra/polynomial/#Pseudodivision","page":"Univariate polynomial functionality","title":"Pseudodivision","text":"","category":"section"},{"location":"AbstractAlgebra/polynomial/","page":"Univariate polynomial functionality","title":"Univariate polynomial functionality","text":"Given two polynomials a b, pseudodivision computes polynomials q and r with length(r)  length(b) such that L^d a = bq + r where d = length(a) - length(b) + 1 and L is the leading coefficient of b.","category":"page"},{"location":"AbstractAlgebra/polynomial/","page":"Univariate polynomial functionality","title":"Univariate polynomial functionality","text":"We call q the pseudoquotient and r the pseudoremainder.","category":"page"},{"location":"AbstractAlgebra/polynomial/","page":"Univariate polynomial functionality","title":"Univariate polynomial functionality","text":"pseudorem{T <: RingElem}(::PolyRingElem{T}, ::PolyRingElem{T})","category":"page"},{"location":"AbstractAlgebra/polynomial/#pseudorem-Union{Tuple{T}, Tuple{PolyRingElem{T}, PolyRingElem{T}}} where T<:RingElem","page":"Univariate polynomial functionality","title":"pseudorem","text":"pseudorem(f::PolyRingElem{T}, g::PolyRingElem{T}) where T <: RingElement\n\nReturn the pseudoremainder of f divided by g. If g = 0 we throw a DivideError().\n\n\n\n\n\n","category":"method"},{"location":"AbstractAlgebra/polynomial/","page":"Univariate polynomial functionality","title":"Univariate polynomial functionality","text":"pseudodivrem{T <: RingElem}(::PolyRingElem{T}, ::PolyRingElem{T})","category":"page"},{"location":"AbstractAlgebra/polynomial/#pseudodivrem-Union{Tuple{T}, Tuple{PolyRingElem{T}, PolyRingElem{T}}} where T<:RingElem","page":"Univariate polynomial functionality","title":"pseudodivrem","text":"pseudodivrem(f::PolyRingElem{T}, g::PolyRingElem{T}) where T <: RingElement\n\nReturn a tuple (q r) consisting of the pseudoquotient and pseudoremainder of f divided by g. If g = 0 we throw a DivideError().\n\n\n\n\n\n","category":"method"},{"location":"AbstractAlgebra/polynomial/","page":"Univariate polynomial functionality","title":"Univariate polynomial functionality","text":"Examples","category":"page"},{"location":"AbstractAlgebra/polynomial/","page":"Univariate polynomial functionality","title":"Univariate polynomial functionality","text":"julia> R, x = polynomial_ring(ZZ, :x)\n(Univariate polynomial ring in x over integers, x)\n\njulia> S, y = polynomial_ring(R, :y)\n(Univariate polynomial ring in y over R, y)\n\njulia> f = x*y^2 + (x + 1)*y + 3\nx*y^2 + (x + 1)*y + 3\n\njulia> g = (x + 1)*y + (x^3 + 2x + 2)\n(x + 1)*y + x^3 + 2*x + 2\n\njulia> h = pseudorem(f, g)\nx^7 + 3*x^5 + 2*x^4 + x^3 + 5*x^2 + 4*x + 1\n\njulia> q, r = pseudodivrem(f, g)\n((x^2 + x)*y - x^4 - x^2 + 1, x^7 + 3*x^5 + 2*x^4 + x^3 + 5*x^2 + 4*x + 1)\n","category":"page"},{"location":"AbstractAlgebra/polynomial/#Content-and-primitive-part","page":"Univariate polynomial functionality","title":"Content and primitive part","text":"","category":"section"},{"location":"AbstractAlgebra/polynomial/","page":"Univariate polynomial functionality","title":"Univariate polynomial functionality","text":"content(::PolyRingElem)","category":"page"},{"location":"AbstractAlgebra/polynomial/#content-Tuple{PolyRingElem}","page":"Univariate polynomial functionality","title":"content","text":"content(a::PolyRingElem)\n\nReturn the content of a, i.e. the greatest common divisor of its coefficients.\n\n\n\n\n\n","category":"method"},{"location":"AbstractAlgebra/polynomial/","page":"Univariate polynomial functionality","title":"Univariate polynomial functionality","text":"primpart(::PolyRingElem)","category":"page"},{"location":"AbstractAlgebra/polynomial/#primpart-Tuple{PolyRingElem}","page":"Univariate polynomial functionality","title":"primpart","text":"primpart(a::PolyRingElem)\n\nReturn the primitive part of a, i.e. the polynomial divided by its content.\n\n\n\n\n\n","category":"method"},{"location":"AbstractAlgebra/polynomial/","page":"Univariate polynomial functionality","title":"Univariate polynomial functionality","text":"Examples","category":"page"},{"location":"AbstractAlgebra/polynomial/","page":"Univariate polynomial functionality","title":"Univariate polynomial functionality","text":"R, x = polynomial_ring(ZZ, :x)\nS, y = polynomial_ring(R, :y)\n\nk = x*y^2 + (x + 1)*y + 3\n\nn = content(k)\np = primpart(k*(x^2 + 1))","category":"page"},{"location":"AbstractAlgebra/polynomial/#Evaluation,-composition-and-substitution","page":"Univariate polynomial functionality","title":"Evaluation, composition and substitution","text":"","category":"section"},{"location":"AbstractAlgebra/polynomial/","page":"Univariate polynomial functionality","title":"Univariate polynomial functionality","text":"evaluate(::PolyRingElem, b::T) where T <: RingElement","category":"page"},{"location":"AbstractAlgebra/polynomial/#evaluate-Union{Tuple{T}, Tuple{PolyRingElem, T}} where T<:RingElement","page":"Univariate polynomial functionality","title":"evaluate","text":"evaluate(a::PolyRingElem, b::T) where T <: RingElement\n\nEvaluate the polynomial expression a at the value b and return the result.\n\n\n\n\n\n","category":"method"},{"location":"AbstractAlgebra/polynomial/","page":"Univariate polynomial functionality","title":"Univariate polynomial functionality","text":"compose(::PolyRingElem, ::PolyRingElem)","category":"page"},{"location":"AbstractAlgebra/polynomial/#compose-Tuple{PolyRingElem, PolyRingElem}","page":"Univariate polynomial functionality","title":"compose","text":"compose(f::PolyRingElem, g::PolyRingElem; inner)\n\nCompose the polynomial a with the polynomial b and return the result.\n\nIf inner = :right, then f(g) is returned.\nIf inner = :left, then g(f) is returned.\n\n\n\n\n\n","category":"method"},{"location":"AbstractAlgebra/polynomial/","page":"Univariate polynomial functionality","title":"Univariate polynomial functionality","text":"subst{T <: RingElem}(::PolyRingElem{T}, ::Any)","category":"page"},{"location":"AbstractAlgebra/polynomial/#subst-Union{Tuple{T}, Tuple{PolyRingElem{T}, Any}} where T<:RingElem","page":"Univariate polynomial functionality","title":"subst","text":"subst(f::PolyRingElem{T}, a::Any) where T <: RingElement\n\nEvaluate the polynomial f at a. Note that a can be anything, whether a ring element or not.\n\n\n\n\n\n","category":"method"},{"location":"AbstractAlgebra/polynomial/","page":"Univariate polynomial functionality","title":"Univariate polynomial functionality","text":"We also overload the functional notation so that the polynomial f can be evaluated at a by writing f(a).","category":"page"},{"location":"AbstractAlgebra/polynomial/","page":"Univariate polynomial functionality","title":"Univariate polynomial functionality","text":"Examples","category":"page"},{"location":"AbstractAlgebra/polynomial/","page":"Univariate polynomial functionality","title":"Univariate polynomial functionality","text":"julia> R, x = polynomial_ring(ZZ, :x)\n(Univariate polynomial ring in x over integers, x)\n\njulia> S, y = polynomial_ring(R, :y)\n(Univariate polynomial ring in y over R, y)\n\njulia> f = x*y^2 + (x + 1)*y + 3\nx*y^2 + (x + 1)*y + 3\n\njulia> g = (x + 1)*y + (x^3 + 2x + 2)\n(x + 1)*y + x^3 + 2*x + 2\n\njulia> M = R[x + 1 2x; x - 3 2x - 1]\n[x + 1       2*x]\n[x - 3   2*x - 1]\n\njulia> k = evaluate(f, 3)\n12*x + 6\n\njulia> m = evaluate(f, x^2 + 2x + 1)\nx^5 + 4*x^4 + 7*x^3 + 7*x^2 + 4*x + 4\n\njulia> n = compose(f, g; inner = :second)\n(x^3 + 2*x^2 + x)*y^2 + (2*x^5 + 2*x^4 + 4*x^3 + 9*x^2 + 6*x + 1)*y + x^7 + 4*x^5 + 5*x^4 + 5*x^3 + 10*x^2 + 8*x + 5\n\njulia> p = subst(f, M)\n[3*x^3 - 3*x^2 + 3*x + 4       6*x^3 + 2*x^2 + 2*x]\n[3*x^3 - 8*x^2 - 2*x - 3   6*x^3 - 8*x^2 + 2*x + 2]\n\njulia> q = f(M)\n[3*x^3 - 3*x^2 + 3*x + 4       6*x^3 + 2*x^2 + 2*x]\n[3*x^3 - 8*x^2 - 2*x - 3   6*x^3 - 8*x^2 + 2*x + 2]\n\njulia> r = f(23)\n552*x + 26\n","category":"page"},{"location":"AbstractAlgebra/polynomial/#Derivative-and-integral","page":"Univariate polynomial functionality","title":"Derivative and integral","text":"","category":"section"},{"location":"AbstractAlgebra/polynomial/","page":"Univariate polynomial functionality","title":"Univariate polynomial functionality","text":"derivative(::PolyRingElem)","category":"page"},{"location":"AbstractAlgebra/polynomial/#derivative-Tuple{PolyRingElem}","page":"Univariate polynomial functionality","title":"derivative","text":"derivative(a::PolynomialElem)\n\nReturn the derivative of the polynomial a.\n\n\n\n\n\nderivative(f::AbsPowerSeriesRingElem{T})\n\nReturn the derivative of the power series f.\n\n\n\n\n\nderivative(f::RelPowerSeriesRingElem{T})\n\nReturn the derivative of the power series f.\n\njulia> R, x = power_series_ring(QQ, 10, :x)\n(Univariate power series ring in x over Rationals, x + O(x^11))\n\njulia> f = 2 + x + 3x^3\n2 + x + 3*x^3 + O(x^10)\n\njulia> derivative(f)\n1 + 9*x^2 + O(x^9)\n\n\n\n\n\nderivative(f::MPolyRingElem{T}, j::Int) where {T <: RingElement}\n\nReturn the partial derivative of f with respect to j-th variable of the polynomial ring.\n\n\n\n\n\nderivative(f::MPolyRingElem{T}, x::MPolyRingElem{T}) where T <: RingElement\n\nReturn the partial derivative of f with respect to x. The value x must be a generator of the polynomial ring of f.\n\n\n\n\n\nderivative(x::spoly{T}, n::Int) where T <: Nemo.RingElem\n\nReturn the derivative of x with respect to the variable of index n.\n\n\n\n\n\nderivative(x::spoly{T}, v::spoly{T}) where T <: Nemo.RingElem\n\nReturn the derivative of x with respect to the variable v.\n\n\n\n\n\nderivative(a::Generic.PuiseuxSeriesElem{T}) where T <: RingElement\n\nReturn the derivative of the given Puiseux series a.\n\n\n\n\n\n","category":"method"},{"location":"AbstractAlgebra/polynomial/","page":"Univariate polynomial functionality","title":"Univariate polynomial functionality","text":"integral{T <: Union{ResElem, FieldElem}}(::PolyRingElem{T})","category":"page"},{"location":"AbstractAlgebra/polynomial/#integral-Union{Tuple{PolyRingElem{T}}, Tuple{T}} where T<:Union{FieldElem, ResElem}","page":"Univariate polynomial functionality","title":"integral","text":"integral(x::PolyRingElem{T}) where {T <: Union{ResElem, FieldElement}}\n\nReturn the integral of the polynomial x.\n\n\n\n\n\nintegral(f::AbsPowerSeriesRingElem{T})\n\nReturn the integral of the power series f.\n\n\n\n\n\nintegral(f::RelPowerSeriesRingElem{T})\n\nReturn the integral of the power series f.\n\njulia> R, x = power_series_ring(QQ, 10, :x)\n(Univariate power series ring in x over Rationals, x + O(x^11))\n\njulia> f = 2 + x + 3x^3\n2 + x + 3*x^3 + O(x^10)\n\njulia> integral(f)\n2*x + 1//2*x^2 + 3//4*x^4 + O(x^11)\n\n\n\n\n\nintegral(f::RelPowerSeriesRingElem{T}) -> RelPowerSeriesRingElem\n\nReturn the integral of the power series f.\n\n\n\n\n\nintegral(a::Generic.PuiseuxSeriesElem{T}) where T <: RingElement\n\nReturn the integral of the given Puiseux series a.\n\n\n\n\n\n","category":"method"},{"location":"AbstractAlgebra/polynomial/","page":"Univariate polynomial functionality","title":"Univariate polynomial functionality","text":"Examples","category":"page"},{"location":"AbstractAlgebra/polynomial/","page":"Univariate polynomial functionality","title":"Univariate polynomial functionality","text":"julia> R, x = polynomial_ring(ZZ, :x)\n(Univariate polynomial ring in x over integers, x)\n\njulia> S, y = polynomial_ring(R, :y)\n(Univariate polynomial ring in y over R, y)\n\njulia> T, z = polynomial_ring(QQ, :z)\n(Univariate polynomial ring in z over rationals, z)\n\njulia> U, = residue_ring(T, z^3 + 3z + 1);\n\njulia> V, w = polynomial_ring(U, :w)\n(Univariate polynomial ring in w over U, w)\n\njulia> f = x*y^2 + (x + 1)*y + 3\nx*y^2 + (x + 1)*y + 3\n\njulia> g = (z^2 + 2z + 1)*w^2 + (z + 1)*w - 2z + 4\n(z^2 + 2*z + 1)*w^2 + (z + 1)*w - 2*z + 4\n\njulia> h = derivative(f)\n2*x*y + x + 1\n\njulia> k = integral(g)\n(1//3*z^2 + 2//3*z + 1//3)*w^3 + (1//2*z + 1//2)*w^2 + (-2*z + 4)*w\n","category":"page"},{"location":"AbstractAlgebra/polynomial/#Resultant-and-discriminant","page":"Univariate polynomial functionality","title":"Resultant and discriminant","text":"","category":"section"},{"location":"AbstractAlgebra/polynomial/","page":"Univariate polynomial functionality","title":"Univariate polynomial functionality","text":"sylvester_matrix{T <: RingElem}(::PolyRingElem{T}, ::PolyRingElem{T})","category":"page"},{"location":"AbstractAlgebra/polynomial/#sylvester_matrix-Union{Tuple{T}, Tuple{PolyRingElem{T}, PolyRingElem{T}}} where T<:RingElem","page":"Univariate polynomial functionality","title":"sylvester_matrix","text":"sylvester_matrix(p::PolyRingElem, q::PolyRingElem)\n\nReturn the sylvester matrix of the given polynomials.\n\n\n\n\n\n","category":"method"},{"location":"AbstractAlgebra/polynomial/","page":"Univariate polynomial functionality","title":"Univariate polynomial functionality","text":"resultant{T <: RingElem}(::PolyRingElem{T}, ::PolyRingElem{T})","category":"page"},{"location":"AbstractAlgebra/polynomial/#resultant-Union{Tuple{T}, Tuple{PolyRingElem{T}, PolyRingElem{T}}} where T<:RingElem","page":"Univariate polynomial functionality","title":"resultant","text":"resultant(p::PolyRingElem{T}, q::PolyRingElem{T}) where T <: RingElement\n\nReturn the resultant of the given polynomials.\n\n\n\n\n\n","category":"method"},{"location":"AbstractAlgebra/polynomial/","page":"Univariate polynomial functionality","title":"Univariate polynomial functionality","text":"resx{T <: RingElem}(::PolyRingElem{T}, ::PolyRingElem{T})","category":"page"},{"location":"AbstractAlgebra/polynomial/#resx-Union{Tuple{T}, Tuple{PolyRingElem{T}, PolyRingElem{T}}} where T<:RingElem","page":"Univariate polynomial functionality","title":"resx","text":"resx(a::PolyRingElem{T}, b::PolyRingElem{T}) where T <: RingElement\n\nReturn a tuple (r s t) such that r is the resultant of a and b and such that r = atimes s + btimes t.\n\n\n\n\n\n","category":"method"},{"location":"AbstractAlgebra/polynomial/","page":"Univariate polynomial functionality","title":"Univariate polynomial functionality","text":"discriminant(a::PolyRingElem)","category":"page"},{"location":"AbstractAlgebra/polynomial/#discriminant-Tuple{PolyRingElem}","page":"Univariate polynomial functionality","title":"discriminant","text":"discriminant(a::PolyRingElem)\n\nReturn the discriminant of the given polynomial.\n\n\n\n\n\n","category":"method"},{"location":"AbstractAlgebra/polynomial/","page":"Univariate polynomial functionality","title":"Univariate polynomial functionality","text":"Examples","category":"page"},{"location":"AbstractAlgebra/polynomial/","page":"Univariate polynomial functionality","title":"Univariate polynomial functionality","text":"julia> R, x = polynomial_ring(ZZ, :x)\n(Univariate polynomial ring in x over integers, x)\n\njulia> S, y = polynomial_ring(R, :y)\n(Univariate polynomial ring in y over R, y)\n\njulia> f = 3x*y^2 + (x + 1)*y + 3\n3*x*y^2 + (x + 1)*y + 3\n\njulia> g = 6(x + 1)*y + (x^3 + 2x + 2)\n(6*x + 6)*y + x^3 + 2*x + 2\n\njulia> S = sylvester_matrix(f, g)\n[    3*x           x + 1               3]\n[6*x + 6   x^3 + 2*x + 2               0]\n[      0         6*x + 6   x^3 + 2*x + 2]\n\njulia> h = resultant(f, g)\n3*x^7 + 6*x^5 - 6*x^3 + 96*x^2 + 192*x + 96\n\njulia> k = discriminant(f)\nx^2 - 34*x + 1\n","category":"page"},{"location":"AbstractAlgebra/polynomial/#Newton-representation","page":"Univariate polynomial functionality","title":"Newton representation","text":"","category":"section"},{"location":"AbstractAlgebra/polynomial/","page":"Univariate polynomial functionality","title":"Univariate polynomial functionality","text":"monomial_to_newton!{T <: RingElem}(::Vector{T}, ::Vector{T})","category":"page"},{"location":"AbstractAlgebra/polynomial/#monomial_to_newton!-Union{Tuple{T}, Tuple{Vector{T}, Vector{T}}} where T<:RingElem","page":"Univariate polynomial functionality","title":"monomial_to_newton!","text":"monomial_to_newton!(P::Vector{T}, roots::Vector{T}) where T <: RingElement\n\nConverts a polynomial p, given as an array of coefficients, in-place from its coefficients given in the standard monomial basis to the Newton basis for the roots r_0 r_1 ldots r_n-2. In other words, this determines output coefficients c_i such that c_0 + c_1(x-r_0) + c_2(x-r_0)(x-r_1) + ldots + c_n-1(x-r_0)(x-r_1)cdots(x-r_n-2) is equal to the input polynomial.\n\n\n\n\n\n","category":"method"},{"location":"AbstractAlgebra/polynomial/","page":"Univariate polynomial functionality","title":"Univariate polynomial functionality","text":"newton_to_monomial!{T <: RingElem}(::Vector{T}, ::Vector{T})","category":"page"},{"location":"AbstractAlgebra/polynomial/#newton_to_monomial!-Union{Tuple{T}, Tuple{Vector{T}, Vector{T}}} where T<:RingElem","page":"Univariate polynomial functionality","title":"newton_to_monomial!","text":"newton_to_monomial!(P::Vector{T}, roots::Vector{T}) where T <: RingElement\n\nConverts a polynomial p, given as an array of coefficients, in-place from its coefficients given in the Newton basis for the roots r_0 r_1 ldots r_n-2 to the standard monomial basis. In other words, this evaluates c_0 + c_1(x-r_0) + c_2(x-r_0)(x-r_1) + ldots + c_n-1(x-r_0)(x-r_1)cdots(x-r_n-2) where c_i are the input coefficients given by p.\n\n\n\n\n\n","category":"method"},{"location":"AbstractAlgebra/polynomial/","page":"Univariate polynomial functionality","title":"Univariate polynomial functionality","text":"Examples","category":"page"},{"location":"AbstractAlgebra/polynomial/","page":"Univariate polynomial functionality","title":"Univariate polynomial functionality","text":"julia> R, x = polynomial_ring(ZZ, :x)\n(Univariate polynomial ring in x over integers, x)\n\njulia> S, y = polynomial_ring(R, :y)\n(Univariate polynomial ring in y over R, y)\n\njulia> f = 3x*y^2 + (x + 1)*y + 3\n3*x*y^2 + (x + 1)*y + 3\n\njulia> g = deepcopy(f)\n3*x*y^2 + (x + 1)*y + 3\n\njulia> roots = [R(1), R(2), R(3)]\n3-element Vector{AbstractAlgebra.Generic.Poly{BigInt}}:\n 1\n 2\n 3\n\njulia> monomial_to_newton!(g.coeffs, roots)\n\njulia> newton_to_monomial!(g.coeffs, roots)","category":"page"},{"location":"AbstractAlgebra/polynomial/#Roots","page":"Univariate polynomial functionality","title":"Roots","text":"","category":"section"},{"location":"AbstractAlgebra/polynomial/","page":"Univariate polynomial functionality","title":"Univariate polynomial functionality","text":"roots(f::PolyRingElem)\nroots(R::Field, f::PolyRingElem)","category":"page"},{"location":"AbstractAlgebra/polynomial/#roots-Tuple{PolyRingElem}","page":"Univariate polynomial functionality","title":"roots","text":"roots(f::PolyRingElem)\n\nReturns the roots of the polynomial f in the base ring of f as an array.\n\n\n\n\n\n","category":"method"},{"location":"AbstractAlgebra/polynomial/#roots-Tuple{Field, PolyRingElem}","page":"Univariate polynomial functionality","title":"roots","text":"roots(R::Field, f::PolyRingElem)\n\nReturns the roots of the polynomial f in the field R as an array.\n\n\n\n\n\n","category":"method"},{"location":"AbstractAlgebra/polynomial/#Interpolation","page":"Univariate polynomial functionality","title":"Interpolation","text":"","category":"section"},{"location":"AbstractAlgebra/polynomial/","page":"Univariate polynomial functionality","title":"Univariate polynomial functionality","text":"interpolate{T <: RingElem}(::PolyRing, ::Vector{T}, ::Vector{T})","category":"page"},{"location":"AbstractAlgebra/polynomial/#interpolate-Union{Tuple{T}, Tuple{PolyRing, Vector{T}, Vector{T}}} where T<:RingElem","page":"Univariate polynomial functionality","title":"interpolate","text":"interpolate(S::PolyRing, x::Vector{T}, y::Vector{T}) where T <: RingElement\n\nGiven two arrays of values xs and ys of the same length n, find the polynomial f in the polynomial ring R of length at most n such that f has the value ys at the points xs. The values in the arrays xs and ys must belong to the base ring of the polynomial ring R. If no such polynomial exists, an exception is raised.\n\n\n\n\n\n","category":"method"},{"location":"AbstractAlgebra/polynomial/","page":"Univariate polynomial functionality","title":"Univariate polynomial functionality","text":"Examples","category":"page"},{"location":"AbstractAlgebra/polynomial/","page":"Univariate polynomial functionality","title":"Univariate polynomial functionality","text":"julia> R, x = polynomial_ring(ZZ, :x)\n(Univariate polynomial ring in x over integers, x)\n\njulia> S, y = polynomial_ring(R, :y)\n(Univariate polynomial ring in y over R, y)\n\njulia> xs = [R(1), R(2), R(3), R(4)]\n4-element Vector{AbstractAlgebra.Generic.Poly{BigInt}}:\n 1\n 2\n 3\n 4\n\njulia> ys = [R(1), R(4), R(9), R(16)]\n4-element Vector{AbstractAlgebra.Generic.Poly{BigInt}}:\n 1\n 4\n 9\n 16\n\njulia> f = interpolate(S, xs, ys)\ny^2\n","category":"page"},{"location":"AbstractAlgebra/polynomial/#Power-sums","page":"Univariate polynomial functionality","title":"Power sums","text":"","category":"section"},{"location":"AbstractAlgebra/polynomial/","page":"Univariate polynomial functionality","title":"Univariate polynomial functionality","text":"polynomial_to_power_sums(::PolyRingElem{T}) where T <: RingElem","category":"page"},{"location":"AbstractAlgebra/polynomial/#polynomial_to_power_sums-Union{Tuple{PolyRingElem{T}}, Tuple{T}} where T<:RingElem","page":"Univariate polynomial functionality","title":"polynomial_to_power_sums","text":"polynomial_to_power_sums(f::PolyRingElem{T}, n::Int=degree(f)) where T <: RingElement -> Vector{T}\n\nUses Newton (or Newton-Girard) formulas to compute the first n sums of powers of the roots of f from the coefficients of f, starting with the sum of (first powers of) the roots. The input polynomial must be monic, at least degree 1 and have nonzero constant coefficient.\n\n\n\n\n\n","category":"method"},{"location":"AbstractAlgebra/polynomial/","page":"Univariate polynomial functionality","title":"Univariate polynomial functionality","text":"power_sums_to_polynomial(::Vector{T}) where T <: RingElem","category":"page"},{"location":"AbstractAlgebra/polynomial/#power_sums_to_polynomial-Union{Tuple{Vector{T}}, Tuple{T}} where T<:RingElem","page":"Univariate polynomial functionality","title":"power_sums_to_polynomial","text":"power_sums_to_polynomial(P::Vector{T};\n                 parent::PolyRing{T}=PolyRing(parent(P[1])) where T <: RingElement -> PolyRingElem{T}\n\nUses the Newton (or Newton-Girard) identities to obtain the polynomial with given sums of powers of roots. The list must be nonempty and contain degree(f) entries where f is the polynomial to be recovered. The list must start with the sum of first powers of the roots.\n\n\n\n\n\n","category":"method"},{"location":"AbstractAlgebra/polynomial/","page":"Univariate polynomial functionality","title":"Univariate polynomial functionality","text":"Examples","category":"page"},{"location":"AbstractAlgebra/polynomial/","page":"Univariate polynomial functionality","title":"Univariate polynomial functionality","text":"julia> R, x = polynomial_ring(ZZ, :x)\n(Univariate polynomial ring in x over integers, x)\n\njulia> f = x^4 - 2*x^3 + 10*x^2 + 7*x - 5\nx^4 - 2*x^3 + 10*x^2 + 7*x - 5\n\njulia> V = polynomial_to_power_sums(f)\n4-element Vector{BigInt}:\n   2\n -16\n -73\n  20\n\njulia> power_sums_to_polynomial(V)\nx^4 - 2*x^3 + 10*x^2 + 7*x - 5","category":"page"},{"location":"AbstractAlgebra/polynomial/#Special-functions","page":"Univariate polynomial functionality","title":"Special functions","text":"","category":"section"},{"location":"AbstractAlgebra/polynomial/","page":"Univariate polynomial functionality","title":"Univariate polynomial functionality","text":"The following special functions can be computed for any polynomial ring. Typically one uses the generator x of a polynomial ring to get the respective special polynomials expressed in terms of that generator.","category":"page"},{"location":"AbstractAlgebra/polynomial/","page":"Univariate polynomial functionality","title":"Univariate polynomial functionality","text":"chebyshev_t(::Int, ::PolyRingElem)","category":"page"},{"location":"AbstractAlgebra/polynomial/#chebyshev_t-Tuple{Int64, PolyRingElem}","page":"Univariate polynomial functionality","title":"chebyshev_t","text":"chebyshev_t(n::Int, x::PolyRingElem)\n\nReturn the Chebyshev polynomial of the first kind T_n(x), defined by T_n(x) = cos(n cos^-1(x)).\n\n\n\n\n\n","category":"method"},{"location":"AbstractAlgebra/polynomial/","page":"Univariate polynomial functionality","title":"Univariate polynomial functionality","text":"chebyshev_u(::Int, ::PolyRingElem)","category":"page"},{"location":"AbstractAlgebra/polynomial/#chebyshev_u-Tuple{Int64, PolyRingElem}","page":"Univariate polynomial functionality","title":"chebyshev_u","text":"chebyshev_u(n::Int, x::PolyRingElem)\n\nReturn the Chebyshev polynomial of the first kind U_n(x), defined by (n+1) U_n(x) = T_n+1(x).\n\n\n\n\n\n","category":"method"},{"location":"AbstractAlgebra/polynomial/","page":"Univariate polynomial functionality","title":"Univariate polynomial functionality","text":"Examples","category":"page"},{"location":"AbstractAlgebra/polynomial/","page":"Univariate polynomial functionality","title":"Univariate polynomial functionality","text":"julia> R, x = polynomial_ring(ZZ, :x)\n(Univariate polynomial ring in x over integers, x)\n\njulia> S, y = polynomial_ring(R, :y)\n(Univariate polynomial ring in y over R, y)\n\njulia> f = chebyshev_t(20, y)\n524288*y^20 - 2621440*y^18 + 5570560*y^16 - 6553600*y^14 + 4659200*y^12 - 2050048*y^10 + 549120*y^8 - 84480*y^6 + 6600*y^4 - 200*y^2 + 1\n\njulia> g = chebyshev_u(15, y)\n32768*y^15 - 114688*y^13 + 159744*y^11 - 112640*y^9 + 42240*y^7 - 8064*y^5 + 672*y^3 - 16*y\n","category":"page"},{"location":"AbstractAlgebra/polynomial/#Random-generation","page":"Univariate polynomial functionality","title":"Random generation","text":"","category":"section"},{"location":"AbstractAlgebra/polynomial/","page":"Univariate polynomial functionality","title":"Univariate polynomial functionality","text":"One may generate random polynomials with degrees in a given range. Additional parameters are used to construct coefficients as elements of the coefficient ring.","category":"page"},{"location":"AbstractAlgebra/polynomial/","page":"Univariate polynomial functionality","title":"Univariate polynomial functionality","text":"rand(R::PolyRing, deg_range::AbstractUnitRange{Int}, v...)\nrand(R::PolyRing, deg::Int, v...)","category":"page"},{"location":"AbstractAlgebra/polynomial/","page":"Univariate polynomial functionality","title":"Univariate polynomial functionality","text":"Examples","category":"page"},{"location":"AbstractAlgebra/polynomial/","page":"Univariate polynomial functionality","title":"Univariate polynomial functionality","text":"R, x = polynomial_ring(ZZ, :x)\nf = rand(R, -1:3, -10:10)\n\nS, y = polynomial_ring(GF(7), :y)\ng = rand(S, 2:2)\n\nU, z = polynomial_ring(R, :z)\nh = rand(U, 3:3, -1:2, -10:10)","category":"page"},{"location":"AbstractAlgebra/polynomial/#Ring-homomorphisms","page":"Univariate polynomial functionality","title":"Ring homomorphisms","text":"","category":"section"},{"location":"AbstractAlgebra/polynomial/","page":"Univariate polynomial functionality","title":"Univariate polynomial functionality","text":"hom(::PolyRing, ::NCRing, ::Any, ::Any)","category":"page"},{"location":"AbstractAlgebra/polynomial/#hom-Tuple{PolyRing, NCRing, Any, Any}","page":"Univariate polynomial functionality","title":"hom","text":"hom(R::AbstractAlgebra.PolyRing, S::NCRing, [coeff_map,] image)\n\nGiven a homomorphism coeff_map from C to S, where C is the  coefficient ring of R, and given an element image of S, return the homomorphism from R to S whose restriction  to C is coeff_map, and which sends the generator of R to image.\n\nIf no coefficient map is entered, invoke a canonical homomorphism of C to S, if such a homomorphism exists, and throw an error, otherwise.\n\nExamples\n\njulia> Zx, x = ZZ[:x];\n\njulia> F = hom(Zx, Zx, x + 1);\n\njulia> F(x^2)\nx^2 + 2*x + 1\n\njulia> Fp = GF(3); Fpy, y = Fp[:y];\n\njulia> G = hom(Zx, Fpy, c -> Fp(c), y^3);\n\njulia> G(5*x + 1)\n2*y^3 + 1\n\n\n\n\n\n","category":"method"},{"location":"AlgebraicGeometry/ToricVarieties/BlowupMorphisms/","page":"Toric Blowups (Experimental)","title":"Toric Blowups (Experimental)","text":"CurrentModule = Oscar","category":"page"},{"location":"AlgebraicGeometry/ToricVarieties/BlowupMorphisms/#Toric-Blowups-(Experimental)","page":"Toric Blowups (Experimental)","title":"Toric Blowups (Experimental)","text":"","category":"section"},{"location":"AlgebraicGeometry/ToricVarieties/BlowupMorphisms/","page":"Toric Blowups (Experimental)","title":"Toric Blowups (Experimental)","text":"It is a common goal in algebraic geometry to resolve singularities. Certainly, toric varieties and their subvarieties are no exception and we provide a growing set of functionality for such tasks.","category":"page"},{"location":"AlgebraicGeometry/ToricVarieties/BlowupMorphisms/","page":"Toric Blowups (Experimental)","title":"Toric Blowups (Experimental)","text":"In general, resolutions of toric varieties need not be toric. Indeed, some of the functionality below requires fully-fledge schemes machinery, which – as of October 2023 – is still in Oscar's experimental state. For this reason, the methods below should be considered experimental.","category":"page"},{"location":"AlgebraicGeometry/ToricVarieties/BlowupMorphisms/","page":"Toric Blowups (Experimental)","title":"Toric Blowups (Experimental)","text":"We focus mainly on toric blowups given by a star subdivision of a polyhedral fan along a primitive vector, see 11.1 Star Subdivisions in [CLS11]. Below, we refer to this new primitive vector as new_ray. The main constructor is the following","category":"page"},{"location":"AlgebraicGeometry/ToricVarieties/BlowupMorphisms/","page":"Toric Blowups (Experimental)","title":"Toric Blowups (Experimental)","text":"blow_up(Y::NormalToricVariety, new_ray::AbstractVector{<:IntegerUnion}; coordinate_name::String)","category":"page"},{"location":"AlgebraicGeometry/ToricVarieties/BlowupMorphisms/","page":"Toric Blowups (Experimental)","title":"Toric Blowups (Experimental)","text":"This will also construct the underlying toric morphism. We can specify the name for the coordinate in the Cox ring that is assigned to new_ray using the optional argument coordinate_name.","category":"page"},{"location":"AlgebraicGeometry/ToricVarieties/BlowupMorphisms/","page":"Toric Blowups (Experimental)","title":"Toric Blowups (Experimental)","text":"More generally, we can construct a blowup along a closed subscheme given by an ideal in the Cox ring or by an ideal sheaf of the corresponding covered scheme. In general, this will result in a non-toric variety.","category":"page"},{"location":"AlgebraicGeometry/ToricVarieties/BlowupMorphisms/#Constructors","page":"Toric Blowups (Experimental)","title":"Constructors","text":"","category":"section"},{"location":"AlgebraicGeometry/ToricVarieties/BlowupMorphisms/","page":"Toric Blowups (Experimental)","title":"Toric Blowups (Experimental)","text":"The following methods blow up toric varieties. The closed subscheme along which the blowup is constructed can be provided in different formats. We discuss the methods in ascending generality.","category":"page"},{"location":"AlgebraicGeometry/ToricVarieties/BlowupMorphisms/","page":"Toric Blowups (Experimental)","title":"Toric Blowups (Experimental)","text":"For our most specialized blowup method, we focus on the n-th cone in the fan of the variety v in question. This cone need not be maximal. The ensuing star subdivision will subdivide this cone about its \"diagonal\" (the sum of all its rays). The result of this will always be a toric variety:","category":"page"},{"location":"AlgebraicGeometry/ToricVarieties/BlowupMorphisms/","page":"Toric Blowups (Experimental)","title":"Toric Blowups (Experimental)","text":"blow_up(v::NormalToricVariety, n::Int; coordinate_name::String = \"e\")","category":"page"},{"location":"AlgebraicGeometry/ToricVarieties/BlowupMorphisms/#blow_up-Tuple{NormalToricVariety, Int64}","page":"Toric Blowups (Experimental)","title":"blow_up","text":"blow_up(v::NormalToricVariety, n::Int; coordinate_name::String = \"e\")\n\nBlow up the toric variety by subdividing the n-th cone in the list of all cones of the fan of v. This cone need not be maximal. This function returns the corresponding morphism.\n\nBy default, we pick \"e\" as the name of the homogeneous coordinate for the exceptional prime divisor. As third optional argument one can supply a custom variable name.\n\nExamples\n\njulia> P3 = projective_space(NormalToricVariety, 3)\nNormal toric variety\n\njulia> f = blow_up(P3, 5)\nToric blowup morphism\n\njulia> bP3 = domain(f)\nNormal toric variety\n\njulia> cox_ring(bP3)\nMultivariate polynomial ring in 5 variables over QQ graded by\n  x1 -> [1 0]\n  x2 -> [0 1]\n  x3 -> [0 1]\n  x4 -> [1 0]\n  e -> [1 -1]\n\nwarning: Experimental\nThis function is part of the experimental code in Oscar. Please read here for more details.\n\n\n\n\n\n","category":"method"},{"location":"AlgebraicGeometry/ToricVarieties/BlowupMorphisms/","page":"Toric Blowups (Experimental)","title":"Toric Blowups (Experimental)","text":"More generally, we can provide a primitive element in the fan of the variety in question and construct a toric morphism as in Section 11.1 Star Subdivisions in [CLS11]. The resulting star subdivision leads to a polyhedral fan, or put differently, the blowup is always toric:","category":"page"},{"location":"AlgebraicGeometry/ToricVarieties/BlowupMorphisms/","page":"Toric Blowups (Experimental)","title":"Toric Blowups (Experimental)","text":"blow_up(v::NormalToricVariety, new_ray::AbstractVector{<:IntegerUnion}; coordinate_name::String = \"e\")","category":"page"},{"location":"AlgebraicGeometry/ToricVarieties/BlowupMorphisms/#blow_up-Tuple{NormalToricVariety, AbstractVector{<:Union{Integer, ZZRingElem}}}","page":"Toric Blowups (Experimental)","title":"blow_up","text":"blow_up(v::NormalToricVariety, new_ray::AbstractVector{<:IntegerUnion}; coordinate_name::String)\n\nBlow up the toric variety by subdividing the fan of the variety with the provided new ray. This function returns the corresponding morphism.\n\nNote that this ray must be a primitive element in the lattice Z^d, with d the dimension of the fan. In particular, it is currently impossible to blow up along a ray which corresponds to a non-Q-Cartier divisor.\n\nBy default, we pick \"e\" as the name of the homogeneous coordinate for the exceptional prime divisor. As optional argument one can supply a custom variable name.\n\nwarning: Warning\nThis function is type unstable. The type of the field center_unnormalized is always a subtype of AbsIdealSheaf (meaning that center_unnormalized(f) isa Oscar.AbsIdealSheaf is always true). Sometimes, the function computes and sets the field center_unnormalized for the output f, giving it the type ToricIdealSheafFromCoxRingIdeal (meaning that center_unnormalized(f) isa Oscar.ToricIdealSheafFromCoxRingIdeal is true and center_unnormalized(f) isa IdealSheaf is false). If it does not, then calling center_unnormalized(f) computes and sets the field center_unnormalized and it will have the type IdealSheaf (meaning that center_unnormalized(f) isa Oscar.ToricIdealSheafFromCoxRingIdeal is false and center_unnormalized(f) isa IdealSheaf is true).\n\nExamples\n\nIn the example below center_unnormalized(f) has type ToricIdealSheafFromCoxRingIdeal and we can access the corresponding ideal in the Cox ring using Oscar.ideal_in_cox_ring.\n\njulia> P3 = projective_space(NormalToricVariety, 3)\nNormal toric variety\n\njulia> f = blow_up(P3, [0, 2, 3])\nToric blowup morphism\n\njulia> bP3 = domain(f)\nNormal toric variety\n\njulia> cox_ring(bP3)\nMultivariate polynomial ring in 5 variables over QQ graded by\n  x1 -> [1 0]\n  x2 -> [1 2]\n  x3 -> [1 3]\n  x4 -> [1 0]\n  e -> [0 -1]\n\njulia> typeof(center_unnormalized(f))\nOscar.ToricIdealSheafFromCoxRingIdeal{NormalToricVariety, AbsAffineScheme, Ideal, Map}\n\njulia> Oscar.ideal_in_cox_ring(center_unnormalized(f))\nIdeal generated by\n  x2^2\n  x3^3\n\nIn the below example, center_unnormalized(f) has type IdealSheaf and we cannot access the corresponding ideal in the Cox ring.\n\nExamples\n\njulia> rs = [1 1; -1 1]\n2×2 Matrix{Int64}:\n  1  1\n -1  1\n\njulia> max_cones = incidence_matrix([[1, 2]])\n1×2 IncidenceMatrix\n[1, 2]\n\njulia> v = normal_toric_variety(max_cones, rs)\nNormal toric variety\n\njulia> f = blow_up(v, [0, 1])\nToric blowup morphism\n\njulia> center_unnormalized(f)\nSheaf of ideals\n  on normal, non-smooth toric variety\nwith restriction\n  1: Ideal (x_3_1, x_2_1, x_1_1)\n\njulia> typeof(center_unnormalized(f))\nIdealSheaf{NormalToricVariety, AbsAffineScheme, Ideal, Map}\n\nwarning: Experimental\nThis function is part of the experimental code in Oscar. Please read here for more details.\n\n\n\n\n\n","category":"method"},{"location":"AlgebraicGeometry/ToricVarieties/BlowupMorphisms/","page":"Toric Blowups (Experimental)","title":"Toric Blowups (Experimental)","text":"Most generally, we encode the closed subscheme along which we blow up by a homogeneous ideal in the Cox ring. Such blowups are often non-toric, i.e. the return value of the following method could well be non-toric.","category":"page"},{"location":"AlgebraicGeometry/ToricVarieties/BlowupMorphisms/","page":"Toric Blowups (Experimental)","title":"Toric Blowups (Experimental)","text":"blow_up(v::NormalToricVariety, I::MPolyIdeal; coordinate_name::String = \"e\")","category":"page"},{"location":"AlgebraicGeometry/ToricVarieties/BlowupMorphisms/#blow_up-Tuple{NormalToricVariety, MPolyIdeal}","page":"Toric Blowups (Experimental)","title":"blow_up","text":"blow_up(v::NormalToricVariety, I::MPolyIdeal; coordinate_name::String = \"e\")\n\nBlow up the toric variety by subdividing the cone in the list of all cones of the fan of v which corresponds to the provided ideal I. Note that this cone need not be maximal.\n\nBy default, we pick \"e\" as the name of the homogeneous coordinate for the exceptional prime divisor. As third optional argument one can supply a custom variable name.\n\nExamples\n\njulia> P3 = projective_space(NormalToricVariety, 3)\nNormal toric variety\n\njulia> (x1,x2,x3,x4) = gens(cox_ring(P3))\n4-element Vector{MPolyDecRingElem{QQFieldElem, QQMPolyRingElem}}:\n x1\n x2\n x3\n x4\n\njulia> I = ideal([x2,x3])\nIdeal generated by\n  x2\n  x3\n\njulia> bP3 = domain(blow_up(P3, I))\nNormal toric variety\n\njulia> cox_ring(bP3)\nMultivariate polynomial ring in 5 variables over QQ graded by\n  x1 -> [1 0]\n  x2 -> [0 1]\n  x3 -> [0 1]\n  x4 -> [1 0]\n  e -> [1 -1]\n\njulia> I2 = ideal([x2 * x3])\nIdeal generated by\n  x2*x3\n\njulia> b2P3 = blow_up(P3, I2);\n\njulia> codomain(b2P3) === P3\ntrue\n\nwarning: Experimental\nThis function is part of the experimental code in Oscar. Please read here for more details.\n\n\n\n\n\n","category":"method"},{"location":"AlgebraicGeometry/ToricVarieties/BlowupMorphisms/","page":"Toric Blowups (Experimental)","title":"Toric Blowups (Experimental)","text":"Instead of providing the ideal, it is possible to turn a homogeneous ideal in the Cox ring into an ideal sheaf. Consequently, we also provide the support for the following method.","category":"page"},{"location":"AlgebraicGeometry/ToricVarieties/BlowupMorphisms/","page":"Toric Blowups (Experimental)","title":"Toric Blowups (Experimental)","text":"blow_up(m::NormalToricVariety, I::ToricIdealSheafFromCoxRingIdeal; coordinate_name::String = \"e\")","category":"page"},{"location":"AlgebraicGeometry/ToricVarieties/BlowupMorphisms/#blow_up-Tuple{NormalToricVariety, Oscar.ToricIdealSheafFromCoxRingIdeal}","page":"Toric Blowups (Experimental)","title":"blow_up","text":"blow_up(m::NormalToricVariety, I::ToricIdealSheafFromCoxRingIdeal; coordinate_name::String = \"e\")\n\nBlow up the toric variety along a toric ideal sheaf.\n\nwarning: Warning\nThis function is type unstable. The type of the domain of the output f is always a subtype of AbsCoveredScheme (meaning that domain(f) isa AbsCoveredScheme is always true). Sometimes, the type of the domain will be a toric variety (meaning that domain(f) isa NormalToricVariety is true) if the algorithm can successfully detect this. In the future, the detection algorithm may be improved so that this is successful more often.\n\nExamples\n\njulia> P3 = projective_space(NormalToricVariety, 3)\nNormal toric variety\n\njulia> x1, x2, x3, x4 = gens(cox_ring(P3))\n4-element Vector{MPolyDecRingElem{QQFieldElem, QQMPolyRingElem}}:\n x1\n x2\n x3\n x4\n\njulia> II = ideal_sheaf(P3, ideal([x1*x2]))\nSheaf of ideals\n  on normal toric variety\nwith restrictions\n  1: Ideal (x_1_1*x_2_1)\n  2: Ideal (x_2_2)\n  3: Ideal (x_1_3)\n  4: Ideal (x_1_4*x_2_4)\n\njulia> f = blow_up(P3, II)\nBlowup\n  of normal toric variety\n  in sheaf of ideals with restrictions\n    1b: Ideal (x_1_1*x_2_1)\n    2b: Ideal (x_2_2)\n    3b: Ideal (x_1_3)\n    4b: Ideal (x_1_4*x_2_4)\nwith domain\n  scheme over QQ covered with 4 patches\n    1a: [x_1_1, x_2_1, x_3_1]   scheme(0)\n    2a: [x_1_2, x_2_2, x_3_2]   scheme(0)\n    3a: [x_1_3, x_2_3, x_3_3]   scheme(0)\n    4a: [x_1_4, x_2_4, x_3_4]   scheme(0)\nand exceptional divisor\n  effective cartier divisor defined by\n    sheaf of ideals with restrictions\n      1a: Ideal (x_1_1*x_2_1)\n      2a: Ideal (x_2_2)\n      3a: Ideal (x_1_3)\n      4a: Ideal (x_1_4*x_2_4)\n\nwarning: Experimental\nThis function is part of the experimental code in Oscar. Please read here for more details.\n\n\n\n\n\n","category":"method"},{"location":"AlgebraicGeometry/ToricVarieties/BlowupMorphisms/#Attributes","page":"Toric Blowups (Experimental)","title":"Attributes","text":"","category":"section"},{"location":"AlgebraicGeometry/ToricVarieties/BlowupMorphisms/","page":"Toric Blowups (Experimental)","title":"Toric Blowups (Experimental)","text":"underlying_morphism(bl::ToricBlowupMorphism)\nindex_of_new_ray(bl::ToricBlowupMorphism)\ncenter_data(bl::ToricBlowupMorphism)\ncenter_unnormalized(bl::ToricBlowupMorphism)\nexceptional_prime_divisor(bl::ToricBlowupMorphism)","category":"page"},{"location":"AlgebraicGeometry/ToricVarieties/BlowupMorphisms/#underlying_morphism-Tuple{Oscar.ToricBlowupMorphism}","page":"Toric Blowups (Experimental)","title":"underlying_morphism","text":"underlying_morphism(bl::ToricBlowupMorphism)\n\nReturn the underlying toric morphism of a toric blowup. Access to other attributes such as domain, codomain, covering_morphism are executed via underlying_morphism.\n\nExamples\n\njulia> P3 = projective_space(NormalToricVariety, 3)\nNormal toric variety\n\njulia> f = blow_up(P3, [0, 1, 1])\nToric blowup morphism\n\njulia> Oscar.underlying_morphism(f)\nToric morphism\n\n\n\n\n\n","category":"method"},{"location":"AlgebraicGeometry/ToricVarieties/BlowupMorphisms/#index_of_new_ray-Tuple{Oscar.ToricBlowupMorphism}","page":"Toric Blowups (Experimental)","title":"index_of_new_ray","text":"index_of_new_ray(bl::ToricBlowupMorphism)\n\nReturn the index of the new ray used in the construction of the toric blowup.\n\nExamples\n\njulia> P3 = projective_space(NormalToricVariety, 3)\nNormal toric variety\n\njulia> f = blow_up(P3, [0, 1, 1])\nToric blowup morphism\n\njulia> index_of_new_ray(f)\n5\n\nwarning: Experimental\nThis function is part of the experimental code in Oscar. Please read here for more details.\n\n\n\n\n\n","category":"method"},{"location":"AlgebraicGeometry/ToricVarieties/BlowupMorphisms/#center_data-Tuple{Oscar.ToricBlowupMorphism}","page":"Toric Blowups (Experimental)","title":"center_data","text":"center_data(bl::ToricBlowupMorphism)\n\nReturns the ideal, ideal sheaf or ray that was used to construct the morphism.\n\nExamples\n\njulia> P3 = projective_space(NormalToricVariety, 3)\nNormal toric variety\n\njulia> f = blow_up(P3, [0, 2, 3])\nToric blowup morphism\n\njulia> center_data(f)\n3-element Vector{Int64}:\n 0\n 2\n 3\n\nwarning: Experimental\nThis function is part of the experimental code in Oscar. Please read here for more details.\n\n\n\n\n\n","category":"method"},{"location":"AlgebraicGeometry/ToricVarieties/BlowupMorphisms/#center_unnormalized-Tuple{Oscar.ToricBlowupMorphism}","page":"Toric Blowups (Experimental)","title":"center_unnormalized","text":"center_unnormalized(bl::ToricBlowupMorphism)\n\nReturns an ideal sheaf I such that the normalization of the blowup along I gives the morphism bl.\n\nExamples\n\njulia> P3 = projective_space(NormalToricVariety, 3)\nNormal toric variety\n\njulia> f = blow_up(P3, [0, 2, 3])\nToric blowup morphism\n\njulia> center_unnormalized(f)\nSheaf of ideals\n  on normal, smooth toric variety\nwith restrictions\n  1: Ideal (x_2_1^2, x_3_1^3)\n  2: Ideal (x_2_2^2, x_3_2^3)\n  3: Ideal (1)\n  4: Ideal (1)\n\nwarning: Experimental\nThis function is part of the experimental code in Oscar. Please read here for more details.\n\n\n\n\n\n","category":"method"},{"location":"AlgebraicGeometry/ToricVarieties/BlowupMorphisms/#exceptional_prime_divisor-Tuple{Oscar.ToricBlowupMorphism}","page":"Toric Blowups (Experimental)","title":"exceptional_prime_divisor","text":"exceptional_prime_divisor(bl::ToricBlowupMorphism)\n\nReturn the exceptional prime Weil divisor (as a toric divisor) of the ray used to construct the toric blowup. Note that this divisor need not be Cartier and this divisor need not coincide with the locus where the morphism is not an isomorphism.\n\nExamples\n\njulia> P3 = projective_space(NormalToricVariety, 3)\nNormal toric variety\n\njulia> f = blow_up(P3, [0, 2, 3])\nToric blowup morphism\n\njulia> E = exceptional_prime_divisor(f)\nTorus-invariant, prime divisor on a normal toric variety\n\njulia> is_cartier(E)\nfalse\n\nwarning: Experimental\nThis function is part of the experimental code in Oscar. Please read here for more details.\n\n\n\n\n\n","category":"method"},{"location":"AlgebraicGeometry/ToricVarieties/BlowupMorphisms/","page":"Toric Blowups (Experimental)","title":"Toric Blowups (Experimental)","text":"Based on underlying_morphism, also the following attributes of toric morphisms are supported for toric blowups:","category":"page"},{"location":"AlgebraicGeometry/ToricVarieties/BlowupMorphisms/","page":"Toric Blowups (Experimental)","title":"Toric Blowups (Experimental)","text":"grid_morphism(bl::ToricBlowupMorphism),\nmorphism_on_torusinvariant_weil_divisor_group(bl::ToricBlowupMorphism),\nmorphism_on_torusinvariant_cartier_divisor_group(bl::ToricBlowupMorphism),\nmorphism_on_class_group(bl::ToricBlowupMorphism),\nmorphism_on_picard_group(bl::ToricBlowupMorphism).","category":"page"},{"location":"AlgebraicGeometry/ToricVarieties/BlowupMorphisms/","page":"Toric Blowups (Experimental)","title":"Toric Blowups (Experimental)","text":"The total and strict transform of ideal sheaves along blowups, not necessarily toric, can be computed:","category":"page"},{"location":"AlgebraicGeometry/ToricVarieties/BlowupMorphisms/","page":"Toric Blowups (Experimental)","title":"Toric Blowups (Experimental)","text":"total_transform(f::AbsSimpleBlowupMorphism, II::AbsIdealSheaf)","category":"page"},{"location":"AlgebraicGeometry/ToricVarieties/BlowupMorphisms/#total_transform-Tuple{Oscar.AbsSimpleBlowupMorphism, Oscar.AbsIdealSheaf}","page":"Toric Blowups (Experimental)","title":"total_transform","text":"total_transform(f::AbsSimpleBlowupMorphism, II::IdealSheaf)\n\nComputes the total transform of an ideal sheaf along a blowup.\n\nIn particular, this applies in the toric setting. However, note that currently (October 2023), ideal sheaves are only supported on smooth toric varieties.\n\nExamples\n\njulia> P2 = projective_space(NormalToricVariety, 2)\nNormal toric variety\n\njulia> bl = blow_up(P2, [1, 1])\nToric blowup morphism\n\njulia> S = cox_ring(P2);\n\njulia> x, y, z = gens(S);\n\njulia> I = ideal_sheaf(P2, ideal([x*y]))\nSheaf of ideals\n  on normal, smooth toric variety\nwith restrictions\n  1: Ideal (x_1_1*x_2_1)\n  2: Ideal (x_2_2)\n  3: Ideal (x_1_3)\n\njulia> total_transform(bl, I)\nSheaf of ideals\n  on normal toric variety\nwith restrictions\n  1: Ideal (x_1_1*x_2_1^2)\n  2: Ideal (x_1_2^2*x_2_2)\n  3: Ideal (x_2_3)\n  4: Ideal (x_1_4)\n\nwarning: Experimental\nThis function is part of the experimental code in Oscar. Please read here for more details.\n\n\n\n\n\n","category":"method"},{"location":"AlgebraicGeometry/ToricVarieties/BlowupMorphisms/#Arithmetics","page":"Toric Blowups (Experimental)","title":"Arithmetics","text":"","category":"section"},{"location":"AlgebraicGeometry/ToricVarieties/BlowupMorphisms/","page":"Toric Blowups (Experimental)","title":"Toric Blowups (Experimental)","text":"Toric blowups can be added, subtracted and multiplied by rational numbers. The results of such operations will not be toric morphisms, i.e. they no longer correspond to the blowup of a certain closed subscheme. Arithmetics among toric blowups and general toric morphisms is also supported, as well as equality for toric blowups.","category":"page"},{"location":"AbstractAlgebra/quotient_module/","page":"Quotient modules","title":"Quotient modules","text":"CurrentModule = AbstractAlgebra\nDocTestSetup = AbstractAlgebra.doctestsetup()","category":"page"},{"location":"AbstractAlgebra/quotient_module/#Quotient-modules","page":"Quotient modules","title":"Quotient modules","text":"","category":"section"},{"location":"AbstractAlgebra/quotient_module/","page":"Quotient modules","title":"Quotient modules","text":"AbstractAlgebra allows the construction of quotient modules/spaces of AbstractAlgebra modules over euclidean domains. These are given as the quotient of a module by a submodule of that module.","category":"page"},{"location":"AbstractAlgebra/quotient_module/","page":"Quotient modules","title":"Quotient modules","text":"We define two quotient modules to be equal if they are quotients of the same module M by two equal submodules.","category":"page"},{"location":"AbstractAlgebra/quotient_module/#Generic-quotient-module-type","page":"Quotient modules","title":"Generic quotient module type","text":"","category":"section"},{"location":"AbstractAlgebra/quotient_module/","page":"Quotient modules","title":"Quotient modules","text":"AbstractAlgebra implements the generic quotient module type Generic.QuotientModule{T} where T is the element type of the base ring, in src/generic/QuotientModule.jl.","category":"page"},{"location":"AbstractAlgebra/quotient_module/","page":"Quotient modules","title":"Quotient modules","text":"Elements of generic quotient modules have type Generic.QuotientModuleElem{T}.","category":"page"},{"location":"AbstractAlgebra/quotient_module/#Abstract-types","page":"Quotient modules","title":"Abstract types","text":"","category":"section"},{"location":"AbstractAlgebra/quotient_module/","page":"Quotient modules","title":"Quotient modules","text":"Quotient module types belong to the FPModule{T} abstract type and their elements to FPModuleElem{T}.","category":"page"},{"location":"AbstractAlgebra/quotient_module/#Constructors","page":"Quotient modules","title":"Constructors","text":"","category":"section"},{"location":"AbstractAlgebra/quotient_module/","page":"Quotient modules","title":"Quotient modules","text":"quo(M::FPModule{T}, v::Generic.Submodule{T}) where T <: RingElement","category":"page"},{"location":"AbstractAlgebra/quotient_module/#quo-Union{Tuple{T}, Tuple{AbstractAlgebra.FPModule{T}, AbstractAlgebra.Generic.Submodule{T}}} where T<:RingElement","page":"Quotient modules","title":"quo","text":"quo(m::FPModule{T}, subm::FPModule{T}) where T <: RingElement\n\nReturn the quotient M of the module m by the module subm (which must have been (transitively) constructed as a submodule of m or be m itself) along with the canonical quotient map from m to M.\n\n\n\n\n\n","category":"method"},{"location":"AbstractAlgebra/quotient_module/","page":"Quotient modules","title":"Quotient modules","text":"Note that a preimage of the canonical projection can be obtained using the preimage function described in the section on module homomorphisms. Note that a preimage element of the canonical projection is not unique and has no special properties.","category":"page"},{"location":"AbstractAlgebra/quotient_module/","page":"Quotient modules","title":"Quotient modules","text":"Examples","category":"page"},{"location":"AbstractAlgebra/quotient_module/","page":"Quotient modules","title":"Quotient modules","text":"julia> M = free_module(ZZ, 2)\nFree module of rank 2 over integers\n\njulia> m = M([ZZ(1), ZZ(2)])\n(1, 2)\n\njulia> N, f = sub(M, [m])\n(Submodule over integers with 1 generator and no relations, Hom: N -> M)\n\njulia> Q, g = quo(M, N)\n(Quotient module over integers with 1 generator and no relations, Hom: M -> Q)\n\njulia> p = M([ZZ(3), ZZ(1)])\n(3, 1)\n\njulia> v2 = g(p)\n(-5)\n\njulia> V = vector_space(QQ, 2)\nVector space of dimension 2 over rationals\n\njulia> m = V([QQ(1), QQ(2)])\n(1//1, 2//1)\n\njulia> N, f = sub(V, [m])\n(Subspace over rationals with 1 generator and no relations, Hom: N -> V)\n\njulia> Q, g = quo(V, N)\n(Quotient space over rationals with 1 generator and no relations, Hom: V -> Q)\n","category":"page"},{"location":"AbstractAlgebra/quotient_module/#Functionality-for-submodules","page":"Quotient modules","title":"Functionality for submodules","text":"","category":"section"},{"location":"AbstractAlgebra/quotient_module/","page":"Quotient modules","title":"Quotient modules","text":"In addition to the Module interface, AbstractAlgebra submodules implement the following functionality.","category":"page"},{"location":"AbstractAlgebra/quotient_module/#Basic-manipulation","page":"Quotient modules","title":"Basic manipulation","text":"","category":"section"},{"location":"AbstractAlgebra/quotient_module/","page":"Quotient modules","title":"Quotient modules","text":"supermodule(M::Generic.QuotientModule{T}) where T <: RingElement\n\ndim(N::Generic.QuotientModule{T}) where T <: FieldElement","category":"page"},{"location":"AbstractAlgebra/quotient_module/#supermodule-Union{Tuple{AbstractAlgebra.Generic.QuotientModule{T}}, Tuple{T}} where T<:RingElement","page":"Quotient modules","title":"supermodule","text":"supermodule(M::QuotientModule{T}) where T <: RingElement\n\nReturn the module that this module is a quotient of.\n\n\n\n\n\n","category":"method"},{"location":"AbstractAlgebra/quotient_module/#dim-Union{Tuple{AbstractAlgebra.Generic.QuotientModule{T}}, Tuple{T}} where T<:FieldElement","page":"Quotient modules","title":"dim","text":"dim(N::QuotientModule{T}) where T <: FieldElement\n\nReturn the dimension of the given vector quotient space.\n\n\n\n\n\n","category":"method"},{"location":"AbstractAlgebra/quotient_module/","page":"Quotient modules","title":"Quotient modules","text":"Examples","category":"page"},{"location":"AbstractAlgebra/quotient_module/","page":"Quotient modules","title":"Quotient modules","text":"julia> M = free_module(ZZ, 2)\nFree module of rank 2 over integers\n\njulia> m = M([ZZ(2), ZZ(3)])\n(2, 3)\n\njulia> N, g = sub(M, [m])\n(Submodule over integers with 1 generator and no relations, Hom: N -> M)\n\njulia> Q, h = quo(M, N)\n(Quotient module over integers with 2 generators and relations:\n[2 3], Hom: M -> Q)\n\njulia> supermodule(Q) == M\ntrue\n\njulia> V = vector_space(QQ, 2)\nVector space of dimension 2 over rationals\n\njulia> m = V([QQ(1), QQ(2)])\n(1//1, 2//1)\n\njulia> N, f = sub(V, [m])\n(Subspace over rationals with 1 generator and no relations, Hom: N -> V)\n\njulia> Q, g = quo(V, N)\n(Quotient space over rationals with 1 generator and no relations, Hom: V -> Q)\n\njulia> dim(V)\n2\n\njulia> dim(Q)\n1\n","category":"page"},{"location":"General/serialization/#serialization","page":"Saving and loading files","title":"Saving and loading files","text":"","category":"section"},{"location":"General/serialization/#Introduction","page":"Saving and loading files","title":"Introduction","text":"","category":"section"},{"location":"General/serialization/","page":"Saving and loading files","title":"Saving and loading files","text":"For some of our datatypes we provide a way to save them in and load them from JSON format.  The most common OSCAR types are supported, but it will take some time until all corners of OSCAR are covered by this effort. Our overall goal is threefold:","category":"page"},{"location":"General/serialization/","page":"Saving and loading files","title":"Saving and loading files","text":"Avoid recomputation by providing an easy way to store data.\nIncrease portability by giving a convenient possibility to transport data.\nIncrease overall software quality by testing against existing data and tracking errors through data computed by different versions of OSCAR (or other computer algebra systems).","category":"page"},{"location":"General/serialization/","page":"Saving and loading files","title":"Saving and loading files","text":"For more details read the developer documentation. Work on serialization is supported by the MaRDI project. You can find out more about its Task Area 1 (Computer Algebra) here.","category":"page"},{"location":"General/serialization/","page":"Saving and loading files","title":"Saving and loading files","text":"save\nload","category":"page"},{"location":"General/serialization/#save","page":"Saving and loading files","title":"save","text":"save(io::IO, obj::Any; metadata::MetaData=nothing, with_attrs::Bool=true)\nsave(filename::String, obj::Any, metadata::MetaData=nothing, with_attrs::Bool=true)\n\nSave an object obj to the given io stream respectively to the file filename. When used with with_attrs=true then the object will save it's attributes along with all the attributes of the types used in the object's struct. The attributes that will be saved are defined during type registration see @register_serialization_type\n\nSee load.\n\nExamples\n\njulia> meta = metadata(author_orcid=\"0000-0000-0000-0042\", name=\"42\", description=\"The meaning of life, the universe and everything\")\nOscar.MetaData(\"0000-0000-0000-0042\", \"42\", \"The meaning of life, the universe and everything\")\n\njulia> save(\"/tmp/fourtitwo.mrdi\", 42; metadata=meta);\n\njulia> read_metadata(\"/tmp/fourtitwo.mrdi\")\n{\n  \"author_orcid\": \"0000-0000-0000-0042\",\n  \"name\": \"42\",\n  \"description\": \"The meaning of life, the universe and everything\"\n}\n\njulia> load(\"/tmp/fourtitwo.mrdi\")\n42\n\n\n\n\n\n","category":"function"},{"location":"General/serialization/#load","page":"Saving and loading files","title":"load","text":"load(io::IO; params::Any = nothing, type::Any = nothing, with_attrs::Bool=true)\nload(filename::String; params::Any = nothing, type::Any = nothing, with_attrs::Bool=true)\n\nLoad the object stored in the given io stream respectively in the file filename.\n\nIf params is specified, then the root object of the loaded data either will attempt a load using these parameters. In the case of Rings this results in setting its parent, or in the case of a container of ring types such as Vector or Tuple, then the parent of the entries will be set using their  params.\n\nIf a type T is given then attempt to load the root object of the data being loaded with this type; if this fails, an error is thrown.\n\nIf with_attrs=true the object will be loaded with attributes available from the file (or serialized data).\n\nSee save.\n\nExamples\n\njulia> save(\"/tmp/fourtitwo.mrdi\", 42);\n\njulia> load(\"/tmp/fourtitwo.mrdi\")\n42\n\njulia> load(\"/tmp/fourtitwo.mrdi\"; type=Int64)\n42\n\njulia> R, x = QQ[:x]\n(Univariate polynomial ring in x over QQ, x)\n\njulia> p = x^2 - x + 1\nx^2 - x + 1\n\njulia> save(\"/tmp/p.mrdi\", p)\n\njulia> p_loaded = load(\"/tmp/p.mrdi\", params=R)\nx^2 - x + 1\n\njulia> parent(p_loaded) === R\ntrue\n\njulia> save(\"/tmp/p_v.mrdi\", [p, p])\n\njulia> loaded_p_v = load(\"/tmp/p_v.mrdi\", params=R)\n2-element Vector{QQPolyRingElem}:\n x^2 - x + 1\n x^2 - x + 1\n\njulia> parent(loaded_p_v[1]) === parent(loaded_p_v[2]) === R\ntrue\n\n\n\n\n\n","category":"function"},{"location":"General/serialization/#Objects-that-can-be-serialized","page":"Saving and loading files","title":"Objects that can be serialized","text":"","category":"section"},{"location":"General/serialization/","page":"Saving and loading files","title":"Saving and loading files","text":"In this section we will list a selection of objects that may be (de-)serialized. ","category":"page"},{"location":"General/serialization/","page":"Saving and loading files","title":"Saving and loading files","text":"Many low level objects may be stored and these in turn allow serializing higher level objects. Such low level objects are various types of matrices, vectors and sets.","category":"page"},{"location":"General/serialization/#Combinatorics","page":"Saving and loading files","title":"Combinatorics","text":"","category":"section"},{"location":"General/serialization/","page":"Saving and loading files","title":"Saving and loading files","text":"Graph\nSimplicialComplex","category":"page"},{"location":"General/serialization/#Commutative-Algebra","page":"Saving and loading files","title":"Commutative Algebra","text":"","category":"section"},{"location":"General/serialization/","page":"Saving and loading files","title":"Saving and loading files","text":"Ideal\nPolyRing\nPolyRingElem\nMPolyRing\nMPolyRingElem","category":"page"},{"location":"General/serialization/#Groups","page":"Saving and loading files","title":"Groups","text":"","category":"section"},{"location":"General/serialization/","page":"Saving and loading files","title":"Saving and loading files","text":"FPGroup\nFinGenAbGroup\nPcGroup\nPermGroup\nSubFPGroup\nSubPcGroup","category":"page"},{"location":"General/serialization/#Polyhedral-Geometry","page":"Saving and loading files","title":"Polyhedral Geometry","text":"","category":"section"},{"location":"General/serialization/","page":"Saving and loading files","title":"Saving and loading files","text":"Cone\nLinearProgram\nPolyhedralFan\nPolyhedralComplex\nPolyhedron\nSubdivisionOfPoints","category":"page"},{"location":"General/serialization/#Toric-Geometry","page":"Saving and loading files","title":"Toric Geometry","text":"","category":"section"},{"location":"General/serialization/","page":"Saving and loading files","title":"Saving and loading files","text":"NormalToricVariety\nToricDivisor","category":"page"},{"location":"General/serialization/#Tropical-Geometry","page":"Saving and loading files","title":"Tropical Geometry","text":"","category":"section"},{"location":"General/serialization/","page":"Saving and loading files","title":"Saving and loading files","text":"TropicalCurve\nTropicalHypersurface","category":"page"},{"location":"General/serialization/#Listing-all-serializable-types-of-the-current-session","page":"Saving and loading files","title":"Listing all serializable types of the current session","text":"","category":"section"},{"location":"General/serialization/","page":"Saving and loading files","title":"Saving and loading files","text":"If you are curious about whether your type can already be serialized given your version of Oscar you can run the following command in your active session.","category":"page"},{"location":"General/serialization/","page":"Saving and loading files","title":"Saving and loading files","text":"using Oscar","category":"page"},{"location":"General/serialization/","page":"Saving and loading files","title":"Saving and loading files","text":"Oscar.reverse_type_map","category":"page"},{"location":"CommutativeAlgebra/ideals/","page":"Ideals in Multivariate Rings","title":"Ideals in Multivariate Rings","text":"CurrentModule = Oscar\nDocTestSetup = Oscar.doctestsetup()","category":"page"},{"location":"CommutativeAlgebra/ideals/#Ideals-in-Multivariate-Rings","page":"Ideals in Multivariate Rings","title":"Ideals in Multivariate Rings","text":"","category":"section"},{"location":"CommutativeAlgebra/ideals/#Types","page":"Ideals in Multivariate Rings","title":"Types","text":"","category":"section"},{"location":"CommutativeAlgebra/ideals/","page":"Ideals in Multivariate Rings","title":"Ideals in Multivariate Rings","text":"The OSCAR type for ideals in multivariate polynomial rings is of parametrized form MPolyIdeal{T}, where T is the element type of the polynomial ring.","category":"page"},{"location":"CommutativeAlgebra/ideals/#Constructors","page":"Ideals in Multivariate Rings","title":"Constructors","text":"","category":"section"},{"location":"CommutativeAlgebra/ideals/","page":"Ideals in Multivariate Rings","title":"Ideals in Multivariate Rings","text":"ideal(R::MPolyRing, g::Vector)","category":"page"},{"location":"CommutativeAlgebra/ideals/#ideal-Tuple{MPolyRing, Vector}","page":"Ideals in Multivariate Rings","title":"ideal","text":"ideal(R::MPolyRing, V::Vector)\n\nGiven a vector V of polynomials in R, return the ideal of R generated by these polynomials.\n\nnote: Note\nIn the graded case, the entries of V must be homogeneous.\n\nExamples\n\njulia> R, (x, y) = polynomial_ring(QQ, [:x, :y])\n(Multivariate polynomial ring in 2 variables over QQ, QQMPolyRingElem[x, y])\n\njulia> I = ideal(R, [x*y-3*x,y^3-2*x^2*y])\nIdeal generated by\n  x*y - 3*x\n  -2*x^2*y + y^3\n\njulia> typeof(I)\nMPolyIdeal{QQMPolyRingElem}\n\njulia> S, (x, y) = graded_polynomial_ring(QQ, [:x, :y],  [1, 2])\n(Graded multivariate polynomial ring in 2 variables over QQ, MPolyDecRingElem{QQFieldElem, QQMPolyRingElem}[x, y])\n\njulia> J = ideal(S, [(x^2+y)^2])\nIdeal generated by\n  x^4 + 2*x^2*y + y^2\n\njulia> typeof(J)\nMPolyIdeal{MPolyDecRingElem{QQFieldElem, QQMPolyRingElem}}\n\n\n\n\n\n","category":"method"},{"location":"CommutativeAlgebra/ideals/#Data-Associated-to-Ideals","page":"Ideals in Multivariate Rings","title":"Data Associated to Ideals","text":"","category":"section"},{"location":"CommutativeAlgebra/ideals/#Basic-Data","page":"Ideals in Multivariate Rings","title":"Basic Data","text":"","category":"section"},{"location":"CommutativeAlgebra/ideals/","page":"Ideals in Multivariate Rings","title":"Ideals in Multivariate Rings","text":"If I is an ideal of a multivariate polynomial ring  R, then","category":"page"},{"location":"CommutativeAlgebra/ideals/","page":"Ideals in Multivariate Rings","title":"Ideals in Multivariate Rings","text":"base_ring(I) refers to R,\ngens(I) to the generators of I,\nnumber_of_generators(I) / ngens(I) to the number of these generators, and\ngen(I, k) as well as I[k] to the k-th such generator.","category":"page"},{"location":"CommutativeAlgebra/ideals/#Examples","page":"Ideals in Multivariate Rings","title":"Examples","text":"","category":"section"},{"location":"CommutativeAlgebra/ideals/","page":"Ideals in Multivariate Rings","title":"Ideals in Multivariate Rings","text":"julia> R, (x, y) = polynomial_ring(QQ, [:x, :y])\n(Multivariate polynomial ring in 2 variables over QQ, QQMPolyRingElem[x, y])\n\njulia> I = ideal(R, [x, y])^2\nIdeal generated by\n  x^2\n  x*y\n  y^2\n\njulia> base_ring(I)\nMultivariate polynomial ring in 2 variables x, y\n  over rational field\n\njulia> gens(I)\n3-element Vector{QQMPolyRingElem}:\n x^2\n x*y\n y^2\n\njulia> number_of_generators(I)\n3\n\njulia> gen(I, 2)\nx*y\n","category":"page"},{"location":"CommutativeAlgebra/ideals/#Dimension","page":"Ideals in Multivariate Rings","title":"Dimension","text":"","category":"section"},{"location":"CommutativeAlgebra/ideals/","page":"Ideals in Multivariate Rings","title":"Ideals in Multivariate Rings","text":"dim(I::MPolyIdeal)","category":"page"},{"location":"CommutativeAlgebra/ideals/#dim-Tuple{MPolyIdeal}","page":"Ideals in Multivariate Rings","title":"dim","text":"dim(I::MPolyIdeal)\n\nReturn the Krull dimension of I.\n\nExamples\n\njulia> R, (x, y, z) = polynomial_ring(QQ, [:x, :y, :z])\n(Multivariate polynomial ring in 3 variables over QQ, QQMPolyRingElem[x, y, z])\n\njulia> I = ideal(R, [y-x^2, x-z^3])\nIdeal generated by\n  -x^2 + y\n  x - z^3\n\njulia> dim(I)\n1\n\n\n\n\n\n","category":"method"},{"location":"CommutativeAlgebra/ideals/#Codimension","page":"Ideals in Multivariate Rings","title":"Codimension","text":"","category":"section"},{"location":"CommutativeAlgebra/ideals/","page":"Ideals in Multivariate Rings","title":"Ideals in Multivariate Rings","text":"codim(I::MPolyIdeal)","category":"page"},{"location":"CommutativeAlgebra/ideals/#codim-Tuple{MPolyIdeal}","page":"Ideals in Multivariate Rings","title":"codim","text":"codim(TropV::TropicalVariety)\n\nSee codim(::PolyhedralComplex).\n\n\n\n\n\n","category":"method"},{"location":"CommutativeAlgebra/ideals/","page":"Ideals in Multivariate Rings","title":"Ideals in Multivariate Rings","text":"In the graded case, we additionally have:","category":"page"},{"location":"CommutativeAlgebra/ideals/#Minimal-Sets-of-Generators","page":"Ideals in Multivariate Rings","title":"Minimal Sets of Generators","text":"","category":"section"},{"location":"CommutativeAlgebra/ideals/","page":"Ideals in Multivariate Rings","title":"Ideals in Multivariate Rings","text":"minimal_generating_set(I::MPolyIdeal{<:MPolyDecRingElem})","category":"page"},{"location":"CommutativeAlgebra/ideals/#minimal_generating_set-Tuple{MPolyIdeal{<:MPolyDecRingElem}}","page":"Ideals in Multivariate Rings","title":"minimal_generating_set","text":"minimal_generating_set(I::MPolyIdeal{<:MPolyDecRingElem})\n\nGiven a (homogeneous) ideal I in a graded multivariate polynomial ring over a field, return an array containing a minimal set of generators of I. If I is the zero ideal, an empty list is returned.\n\nExamples\n\njulia> R, (x, y, z) = graded_polynomial_ring(QQ, [:x, :y, :z]);\n\njulia> V = [x, z^2, x^3+y^3, y^4, y*z^5];\n\njulia> I = ideal(R, V)\nIdeal generated by\n  x\n  z^2\n  x^3 + y^3\n  y^4\n  y*z^5\n\njulia> minimal_generating_set(I)\n3-element Vector{MPolyDecRingElem{QQFieldElem, QQMPolyRingElem}}:\n x\n z^2\n y^3\n\njulia> I = ideal(R, zero(R))\nIdeal generated by\n  0\n\njulia> minimal_generating_set(I)\nMPolyDecRingElem{QQFieldElem, QQMPolyRingElem}[]\n\n\n\n\n\n","category":"method"},{"location":"CommutativeAlgebra/ideals/#Castelnuovo-Mumford-Regularity","page":"Ideals in Multivariate Rings","title":"Castelnuovo-Mumford Regularity","text":"","category":"section"},{"location":"CommutativeAlgebra/ideals/","page":"Ideals in Multivariate Rings","title":"Ideals in Multivariate Rings","text":"cm_regularity(I::MPolyIdeal)","category":"page"},{"location":"CommutativeAlgebra/ideals/#cm_regularity-Tuple{MPolyIdeal}","page":"Ideals in Multivariate Rings","title":"cm_regularity","text":"cm_regularity(I::MPolyIdeal)\n\nGiven a (homogeneous) ideal I in a standard mathbb Z-graded multivariate polynomial ring with coefficients in a field, return the Castelnuovo-Mumford regularity of I.\n\nExamples\n\njulia> R, (w, x, y, z) = graded_polynomial_ring(QQ, [:w, :x, :y, :z]);\n\njulia> I = ideal(R, [y^2*z − x^2*w, z^4 − x*w^3]);\n\njulia> cm_regularity(I)\n6\n\njulia> minimal_betti_table(I)\ndegree: 0  1\n------------\n     3: 1  -\n     4: 1  -\n     5: -  -\n     6: -  1\n------------\n total: 2  1\n\n\n\n\n\n","category":"method"},{"location":"CommutativeAlgebra/ideals/#Degree","page":"Ideals in Multivariate Rings","title":"Degree","text":"","category":"section"},{"location":"CommutativeAlgebra/ideals/","page":"Ideals in Multivariate Rings","title":"Ideals in Multivariate Rings","text":"degree(I::MPolyIdeal)","category":"page"},{"location":"CommutativeAlgebra/ideals/#degree-Tuple{MPolyIdeal}","page":"Ideals in Multivariate Rings","title":"degree","text":"degree(I::MPolyIdeal)\n\nGiven a (homogeneous) ideal I in a standard mathbb Z-graded multivariate polynomial ring, return the degree of I (that is, the degree of the quotient of base_ring(I) modulo I). Otherwise, return the degree of the homogenization of I with respect to the standard mathbb Z-grading.\n\nnote: Note\nGeometrically, the degree of a homogeneous ideal as above is the number of intersection points of its projective variety with a generic linear subspace of complementary dimension (counted with multiplicities). See also [MS21].\n\nExamples\n\njulia> R, (x, y, z) = polynomial_ring(QQ, [:x, :y, :z])\n(Multivariate polynomial ring in 3 variables over QQ, QQMPolyRingElem[x, y, z])\n\njulia> I = ideal(R, [y-x^2, x-z^3])\nIdeal generated by\n  -x^2 + y\n  x - z^3\n\njulia> degree(I)\n6\n\n\n\n\n\n","category":"method"},{"location":"CommutativeAlgebra/ideals/#Operations-on-Ideals","page":"Ideals in Multivariate Rings","title":"Operations on Ideals","text":"","category":"section"},{"location":"CommutativeAlgebra/ideals/#Simple-Ideal-Operations","page":"Ideals in Multivariate Rings","title":"Simple Ideal Operations","text":"","category":"section"},{"location":"CommutativeAlgebra/ideals/#Powers-of-Ideal","page":"Ideals in Multivariate Rings","title":"Powers of Ideal","text":"","category":"section"},{"location":"CommutativeAlgebra/ideals/","page":"Ideals in Multivariate Rings","title":"Ideals in Multivariate Rings","text":"^(I::MPolyIdeal, m::Int)","category":"page"},{"location":"CommutativeAlgebra/ideals/#^-Tuple{MPolyIdeal, Int64}","page":"Ideals in Multivariate Rings","title":"^","text":"^(I::MPolyIdeal, m::Int)\n\nReturn the m-th power of I.\n\nExamples\n\njulia> R, (x, y, z) = polynomial_ring(QQ, [:x, :y, :z])\n(Multivariate polynomial ring in 3 variables over QQ, QQMPolyRingElem[x, y, z])\n\njulia> I = ideal(R, [x, y])\nIdeal generated by\n  x\n  y\n\njulia> I^3\nIdeal generated by\n  x^3\n  x^2*y\n  x*y^2\n  y^3\n\n\n\n\n\n","category":"method"},{"location":"CommutativeAlgebra/ideals/#Sum-of-Ideals","page":"Ideals in Multivariate Rings","title":"Sum of Ideals","text":"","category":"section"},{"location":"CommutativeAlgebra/ideals/","page":"Ideals in Multivariate Rings","title":"Ideals in Multivariate Rings","text":"+(I::MPolyIdeal{T}, J::MPolyIdeal{T}) where T","category":"page"},{"location":"CommutativeAlgebra/ideals/#+-Union{Tuple{T}, Tuple{MPolyIdeal{T}, MPolyIdeal{T}}} where T","page":"Ideals in Multivariate Rings","title":"+","text":"+(I::MPolyIdeal{T}, J::MPolyIdeal{T}) where T\n\nReturn the sum of I and J.\n\nExamples\n\njulia> R, (x, y, z) = polynomial_ring(QQ, [:x, :y, :z])\n(Multivariate polynomial ring in 3 variables over QQ, QQMPolyRingElem[x, y, z])\n\njulia> I = ideal(R, [x, y])\nIdeal generated by\n  x\n  y\n\njulia> J = ideal(R, [z^2])\nIdeal generated by\n  z^2\n\njulia> I+J\nIdeal generated by\n  x\n  y\n  z^2\n\n\n\n\n\n","category":"method"},{"location":"CommutativeAlgebra/ideals/#Product-of-Ideals","page":"Ideals in Multivariate Rings","title":"Product of Ideals","text":"","category":"section"},{"location":"CommutativeAlgebra/ideals/","page":"Ideals in Multivariate Rings","title":"Ideals in Multivariate Rings","text":"*(I::MPolyIdeal{T}, J::MPolyIdeal{T}) where T","category":"page"},{"location":"CommutativeAlgebra/ideals/#*-Union{Tuple{T}, Tuple{MPolyIdeal{T}, MPolyIdeal{T}}} where T","page":"Ideals in Multivariate Rings","title":"*","text":"*(I::MPolyIdeal{T}, J::MPolyIdeal{T}) where T\n\nReturn the product of I and J.\n\nExamples\n\njulia> R, (x, y, z) = polynomial_ring(QQ, [:x, :y, :z])\n(Multivariate polynomial ring in 3 variables over QQ, QQMPolyRingElem[x, y, z])\n\njulia> I = ideal(R, [x, y])\nIdeal generated by\n  x\n  y\n\njulia> J = ideal(R, [z^2])\nIdeal generated by\n  z^2\n\njulia> I*J\nIdeal generated by\n  x*z^2\n  y*z^2\n\n\n\n\n\n","category":"method"},{"location":"CommutativeAlgebra/ideals/#Intersection-of-Ideals","page":"Ideals in Multivariate Rings","title":"Intersection of Ideals","text":"","category":"section"},{"location":"CommutativeAlgebra/ideals/","page":"Ideals in Multivariate Rings","title":"Ideals in Multivariate Rings","text":"intersect(I::MPolyIdeal{T}, Js::MPolyIdeal{T}...) where T","category":"page"},{"location":"CommutativeAlgebra/ideals/#intersect-Union{Tuple{T}, Tuple{MPolyIdeal{T}, Vararg{MPolyIdeal{T}}}} where T","page":"Ideals in Multivariate Rings","title":"intersect","text":"intersect(I::MPolyIdeal{T}, Js::MPolyIdeal{T}...) where T\nintersect(V::Vector{MPolyIdeal{T}}) where T\n\nReturn the intersection of two or more ideals.\n\nExamples\n\njulia> R, (x, y) = polynomial_ring(QQ, [:x, :y])\n(Multivariate polynomial ring in 2 variables over QQ, QQMPolyRingElem[x, y])\n\njulia> I = ideal(R, [x, y])^2;\n\njulia> J = ideal(R, [y^2-x^3+x]);\n\njulia> intersect(I, J)\nIdeal generated by\n  x^3*y - x*y - y^3\n  x^4 - x^2 - x*y^2\n\njulia> intersect([I, J])\nIdeal generated by\n  x^3*y - x*y - y^3\n  x^4 - x^2 - x*y^2\n\n\n\n\n\n","category":"method"},{"location":"CommutativeAlgebra/ideals/#Ideal-Quotients","page":"Ideals in Multivariate Rings","title":"Ideal Quotients","text":"","category":"section"},{"location":"CommutativeAlgebra/ideals/","page":"Ideals in Multivariate Rings","title":"Ideals in Multivariate Rings","text":"Given two ideals I J of a ring R, the ideal quotient of I by J is the ideal","category":"page"},{"location":"CommutativeAlgebra/ideals/","page":"Ideals in Multivariate Rings","title":"Ideals in Multivariate Rings","text":"IJ= biglf in Rbig f J subset Ibigrsubset R","category":"page"},{"location":"CommutativeAlgebra/ideals/","page":"Ideals in Multivariate Rings","title":"Ideals in Multivariate Rings","text":"quotient(I::MPolyIdeal{T}, J::MPolyIdeal{T}) where T","category":"page"},{"location":"CommutativeAlgebra/ideals/#quotient-Union{Tuple{T}, Tuple{MPolyIdeal{T}, MPolyIdeal{T}}} where T","page":"Ideals in Multivariate Rings","title":"quotient","text":"quotient(I::MPolyIdeal{T}, J::MPolyIdeal{T}) where T\n\nReturn the ideal quotient of I by J. Alternatively, use I:J.\n\nquotient(I::MPolyIdeal{T}, f::MPolyRingElem{T}) where T\n\nReturn the ideal quotient of I by the ideal generated by f. Alternatively, use I:f.\n\nExamples\n\njulia> R, (x, y, z) = polynomial_ring(QQ, [:x, :y, :z])\n(Multivariate polynomial ring in 3 variables over QQ, QQMPolyRingElem[x, y, z])\n\njulia> I = ideal(R, [x^4+x^2*y*z+y^3*z, y^4+x^3*z+x*y^2*z, x^3*y+x*y^3])\nIdeal generated by\n  x^4 + x^2*y*z + y^3*z\n  x^3*z + x*y^2*z + y^4\n  x^3*y + x*y^3\n\njulia> J = ideal(R, [x, y, z])^2\nIdeal generated by\n  x^2\n  x*y\n  x*z\n  y^2\n  y*z\n  z^2\n\njulia> L = quotient(I, J)\nIdeal generated by\n  x^3*z + x*y^2*z + y^4\n  x^3*y + x*y^3\n  x^4 + x^2*y*z + y^3*z\n  x^3*z^2 - x^2*y*z^2 + x*y^2*z^2 - y^3*z^2\n  x^2*y^2*z - x^2*y*z^2 - y^3*z^2\n  x^3*z^2 + x^2*y^3 - x^2*y^2*z + x*y^2*z^2\n\njulia> I:J\nIdeal generated by\n  x^3*z + x*y^2*z + y^4\n  x^3*y + x*y^3\n  x^4 + x^2*y*z + y^3*z\n  x^3*z^2 - x^2*y*z^2 + x*y^2*z^2 - y^3*z^2\n  x^2*y^2*z - x^2*y*z^2 - y^3*z^2\n  x^3*z^2 + x^2*y^3 - x^2*y^2*z + x*y^2*z^2\n\njulia> I:x\nIdeal generated by\n  x^2*y + y^3\n  x^3*z + x*y^2*z + y^4\n  x^2*z^2 + x*y^3 - x*y^2*z + y^2*z^2\n  x^4\n  x^3*z^2 - x^2*z^3 + 2*x*y^2*z^2 - y^2*z^3\n  -x^2*z^4 + x*y^2*z^3 - y^2*z^4\n\n\n\n\n\n","category":"method"},{"location":"CommutativeAlgebra/ideals/#Saturation","page":"Ideals in Multivariate Rings","title":"Saturation","text":"","category":"section"},{"location":"CommutativeAlgebra/ideals/","page":"Ideals in Multivariate Rings","title":"Ideals in Multivariate Rings","text":"Given two ideals I J of a ring R, the saturation of I with respect to J is the ideal","category":"page"},{"location":"CommutativeAlgebra/ideals/","page":"Ideals in Multivariate Rings","title":"Ideals in Multivariate Rings","text":"IJ^infty = bigl f in R big f J^k subset I text for some kgeq 1 bigr = textstylebigcuplimits_k=1^infty (IJ^k)","category":"page"},{"location":"CommutativeAlgebra/ideals/","page":"Ideals in Multivariate Rings","title":"Ideals in Multivariate Rings","text":"saturation(I::MPolyIdeal{T}, J::MPolyIdeal{T}; iteration::Bool=false) where T\nsaturation_with_index(I::MPolyIdeal{T}, J::MPolyIdeal{T}) where T","category":"page"},{"location":"CommutativeAlgebra/ideals/#saturation-Union{Tuple{T}, Tuple{MPolyIdeal{T}, MPolyIdeal{T}}} where T","page":"Ideals in Multivariate Rings","title":"saturation","text":"saturation(I::MPolyIdeal{T}, \n           J::MPolyIdeal{T} = ideal(base_ring(I), gens(base_ring(I))); \n           iteration::Bool=false) where T\n\nReturn the saturation of I with respect to J.\n\nIf the second ideal J is not given, the ideal generated by the generators (variables) of base_ring(I) is used.\n\nIf iteration is set to true, the saturation is done by carrying out successive ideal quotient computations as in the definition of saturation. Otherwise, a more sophisticated Gröbner basis approach is used which is typically faster. Applying the two approaches may lead to different generating sets of the saturation.\n\nExamples\n\njulia> R, (x, y, z) = polynomial_ring(QQ, [:x, :y, :z])\n(Multivariate polynomial ring in 3 variables over QQ, QQMPolyRingElem[x, y, z])\n\njulia> I = ideal(R, [z^3, y*z^2, x*z^2, y^2*z, x*y*z, x^2*z, x*y^2, x^2*y])\nIdeal generated by\n  z^3\n  y*z^2\n  x*z^2\n  y^2*z\n  x*y*z\n  x^2*z\n  x*y^2\n  x^2*y\n\njulia> J = ideal(R, [x, y, z])\nIdeal generated by\n  x\n  y\n  z\n\njulia> K = saturation(I, J)\nIdeal generated by\n  z\n  x*y\n\njulia> K = saturation(I)\nIdeal generated by\n  z\n  x*y\n\n\n\n\n\n\n","category":"method"},{"location":"CommutativeAlgebra/ideals/#saturation_with_index-Union{Tuple{T}, Tuple{MPolyIdeal{T}, MPolyIdeal{T}}} where T","page":"Ideals in Multivariate Rings","title":"saturation_with_index","text":"saturation_with_index(I::MPolyIdeal{T}, \n                      J::MPolyIdeal{T} = ideal(base_ring(I), gens(base_ring(I)))) where T\n\nReturn IJ^infty together with the smallest integer m such that IJ^m = IJ^infty (saturation index).\n\nIf the second ideal J is not given, the ideal generated by the generators (variables) of base_ring(I) is used.\n\nnote: Note\nIf the saturation index is not needed, we recommend to use saturation(I, J) which is typically faster.\n\nExamples\n\njulia> R, (x, y, z) = polynomial_ring(QQ, [:x, :y, :z])\n(Multivariate polynomial ring in 3 variables over QQ, QQMPolyRingElem[x, y, z])\n\njulia> I = ideal(R, [z^3, y*z^2, x*z^2, y^2*z, x*y*z, x^2*z, x*y^2, x^2*y])\nIdeal generated by\n  z^3\n  y*z^2\n  x*z^2\n  y^2*z\n  x*y*z\n  x^2*z\n  x*y^2\n  x^2*y\n\njulia> J = ideal(R, [x, y, z])\nIdeal generated by\n  x\n  y\n  z\n\njulia> K, m = saturation_with_index(I, J)\n(Ideal (z, x*y), 2)\n\njulia> K, m = saturation_with_index(I)\n(Ideal (z, x*y), 2)\n\n\n\n\n\n\n","category":"method"},{"location":"CommutativeAlgebra/ideals/#Elimination","page":"Ideals in Multivariate Rings","title":"Elimination","text":"","category":"section"},{"location":"CommutativeAlgebra/ideals/","page":"Ideals in Multivariate Rings","title":"Ideals in Multivariate Rings","text":"eliminate(I::MPolyIdeal{T}, V::Vector{T}) where T <: MPolyRingElem","category":"page"},{"location":"CommutativeAlgebra/ideals/#eliminate-Union{Tuple{T}, Tuple{MPolyIdeal{T}, Vector{T}}} where T<:MPolyRingElem","page":"Ideals in Multivariate Rings","title":"eliminate","text":"eliminate(I::MPolyIdeal{T}, V::Vector{T}) where T <: MPolyRingElem\n\nGiven a vector V of polynomials which are variables, these variables are eliminated from I. That is, return the ideal generated by all polynomials in I which only involve the remaining variables.\n\neliminate(I::MPolyIdeal, V::AbstractVector{Int})\n\nGiven a vector V of indices which specify variables, these variables are eliminated from I. That is, return the ideal generated by all polynomials in I which only involve the remaining variables.\n\nnote: Note\nThe return value is an ideal of the original ring.\n\nExamples\n\njulia> R, (t, x, y, z) = polynomial_ring(QQ, [:t, :x, :y, :z])\n(Multivariate polynomial ring in 4 variables over QQ, QQMPolyRingElem[t, x, y, z])\n\njulia> I = ideal(R, [t-x, t^2-y, t^3-z])\nIdeal generated by\n  t - x\n  t^2 - y\n  t^3 - z\n\njulia> A = [t]\n1-element Vector{QQMPolyRingElem}:\n t\n\njulia> TC = eliminate(I, A)\nIdeal generated by\n  -x*z + y^2\n  x*y - z\n  x^2 - y\n\njulia> A = [1]\n1-element Vector{Int64}:\n 1\n\njulia> TC = eliminate(I, A)\nIdeal generated by\n  -x*z + y^2\n  x*y - z\n  x^2 - y\n\njulia> base_ring(TC)\nMultivariate polynomial ring in 4 variables t, x, y, z\n  over rational field\n\n\n\n\n\n","category":"method"},{"location":"CommutativeAlgebra/ideals/#Truncation","page":"Ideals in Multivariate Rings","title":"Truncation","text":"","category":"section"},{"location":"CommutativeAlgebra/ideals/","page":"Ideals in Multivariate Rings","title":"Ideals in Multivariate Rings","text":"truncate(I::MPolyIdeal, g::FinGenAbGroupElem)","category":"page"},{"location":"CommutativeAlgebra/ideals/#truncate-Tuple{MPolyIdeal, FinGenAbGroupElem}","page":"Ideals in Multivariate Rings","title":"truncate","text":"truncate(I::MPolyIdeal, g::FinGenAbGroupElem)\n\nGiven a (homogeneous) ideal I in a mathbb Z-graded multivariate polynomial ring with positive weights, return the truncation of I at degree g.\n\ntruncate(I::MPolyIdeal, d::Int)\n\nGiven an ideal I as above, and given an integer d, convert d into an element g of the grading group of base_ring(I) and proceed as above.\n\nExamples\n\njulia> R, (x, y, z) = graded_polynomial_ring(QQ, [:x, :y, :z]);\n\njulia> I = ideal(R, [x, y^4, z^6])\nIdeal generated by\n  x\n  y^4\n  z^6\n\njulia> truncate(I, 3)\nIdeal generated by\n  x*z^2\n  x*y*z\n  x*y^2\n  x^2*z\n  x^2*y\n  x^3\n  y^4\n  z^6\n\njulia> R, (x, y, z) = graded_polynomial_ring(QQ, [:x, :y, :z], [3,2,1]);\n\njulia> I = ideal(R, [x, y^4, z^6])\nIdeal generated by\n  x\n  y^4\n  z^6\n\njulia> truncate(I, 3)\nIdeal generated by\n  x\n  y^4\n  z^6\n\njulia> truncate(I, 4)\nIdeal generated by\n  x*z\n  z^6\n  y^4\n\n\n\n\n\n","category":"method"},{"location":"CommutativeAlgebra/ideals/#Tests-on-Ideals","page":"Ideals in Multivariate Rings","title":"Tests on Ideals","text":"","category":"section"},{"location":"CommutativeAlgebra/ideals/#Basic-Tests","page":"Ideals in Multivariate Rings","title":"Basic Tests","text":"","category":"section"},{"location":"CommutativeAlgebra/ideals/","page":"Ideals in Multivariate Rings","title":"Ideals in Multivariate Rings","text":"is_zero(I::MPolyIdeal)","category":"page"},{"location":"CommutativeAlgebra/ideals/#is_zero-Tuple{MPolyIdeal}","page":"Ideals in Multivariate Rings","title":"is_zero","text":"is_zero(I::MPolyIdeal)\n\nReturn true if I is the zero ideal, false otherwise.\n\nExamples\n\njulia> R, (x, y) = polynomial_ring(QQ, [:x, :y])\n(Multivariate polynomial ring in 2 variables over QQ, QQMPolyRingElem[x, y])\n\njulia> I = ideal(R, y-x^2)\nIdeal generated by\n  -x^2 + y\n\njulia> is_zero(I)\nfalse\n\n\n\n\n\n","category":"method"},{"location":"CommutativeAlgebra/ideals/","page":"Ideals in Multivariate Rings","title":"Ideals in Multivariate Rings","text":"is_one(I::MPolyIdeal)","category":"page"},{"location":"CommutativeAlgebra/ideals/#is_one-Tuple{MPolyIdeal}","page":"Ideals in Multivariate Rings","title":"is_one","text":"is_one(I::MPolyIdeal)\n\nReturn true if I is generated by 1, false otherwise.\n\nExamples\n\njulia> R, (x, y) = polynomial_ring(QQ, [:x, :y])\n(Multivariate polynomial ring in 2 variables over QQ, QQMPolyRingElem[x, y])\n\njulia> I = ideal(R, [x, x + y, y - 1])\nIdeal generated by\n  x\n  x + y\n  y - 1\n\njulia> is_one(I)\ntrue\n\n\n\n\n\n","category":"method"},{"location":"CommutativeAlgebra/ideals/","page":"Ideals in Multivariate Rings","title":"Ideals in Multivariate Rings","text":"is_monomial(f::MPolyRingElem)","category":"page"},{"location":"CommutativeAlgebra/ideals/#is_monomial-Tuple{MPolyRingElem}","page":"Ideals in Multivariate Rings","title":"is_monomial","text":"is_monomial(f::MPolyRingElem)\n\nReturn true if f is a monomial, false otherwise.\n\nis_monomial(I::MPolyIdeal)\n\nReturn true if I can be generated by monomials, false otherwise.\n\nExamples\n\njulia> R, (x, y) = polynomial_ring(QQ, [:x, :y])\n(Multivariate polynomial ring in 2 variables over QQ, QQMPolyRingElem[x, y])\n\njulia> f = 2*x+y\n2*x + y\n\njulia> g = y\ny\n\njulia> is_monomial(f)\nfalse\n\njulia> is_monomial(g)\ntrue\n\njulia> is_monomial(ideal(R, [f, g]))\ntrue\n\n\n\n\n\n","category":"method"},{"location":"CommutativeAlgebra/ideals/#Containment-of-Ideals","page":"Ideals in Multivariate Rings","title":"Containment of Ideals","text":"","category":"section"},{"location":"CommutativeAlgebra/ideals/","page":"Ideals in Multivariate Rings","title":"Ideals in Multivariate Rings","text":"is_subset(I::MPolyIdeal, J::MPolyIdeal)","category":"page"},{"location":"CommutativeAlgebra/ideals/#is_subset-Tuple{MPolyIdeal, MPolyIdeal}","page":"Ideals in Multivariate Rings","title":"is_subset","text":"is_subset(I::MPolyIdeal, J::MPolyIdeal)\n\nReturn true if I is contained in J, false otherwise.\n\nExamples\n\njulia> R, (x, y) = polynomial_ring(QQ, [:x, :y])\n(Multivariate polynomial ring in 2 variables over QQ, QQMPolyRingElem[x, y])\n\njulia> I = ideal(R, [x^2])\nIdeal generated by\n  x^2\n\njulia> J = ideal(R, [x, y])^2\nIdeal generated by\n  x^2\n  x*y\n  y^2\n\njulia> is_subset(I, J)\ntrue\n\n\n\n\n\n","category":"method"},{"location":"CommutativeAlgebra/ideals/#Equality-of-Ideals","page":"Ideals in Multivariate Rings","title":"Equality of Ideals","text":"","category":"section"},{"location":"CommutativeAlgebra/ideals/","page":"Ideals in Multivariate Rings","title":"Ideals in Multivariate Rings","text":"==(I::MPolyIdeal, J::MPolyIdeal)","category":"page"},{"location":"CommutativeAlgebra/ideals/#==-Tuple{MPolyIdeal, MPolyIdeal}","page":"Ideals in Multivariate Rings","title":"==","text":"==(I::MPolyIdeal, J::MPolyIdeal)\n\nReturn true if I is equal to J, false otherwise.\n\nExamples\n\njulia> R, (x, y) = polynomial_ring(QQ, [:x, :y])\n(Multivariate polynomial ring in 2 variables over QQ, QQMPolyRingElem[x, y])\n\njulia> I = ideal(R, [x^2])\nIdeal generated by\n  x^2\n\njulia> J = ideal(R, [x, y])^2\nIdeal generated by\n  x^2\n  x*y\n  y^2\n\njulia> I == J\nfalse\n\n\n\n\n\n","category":"method"},{"location":"CommutativeAlgebra/ideals/#Ideal-Membership","page":"Ideals in Multivariate Rings","title":"Ideal Membership","text":"","category":"section"},{"location":"CommutativeAlgebra/ideals/","page":"Ideals in Multivariate Rings","title":"Ideals in Multivariate Rings","text":"ideal_membership(f::T, I::MPolyIdeal{T}) where T","category":"page"},{"location":"CommutativeAlgebra/ideals/#ideal_membership-Union{Tuple{T}, Tuple{T, MPolyIdeal{T}}} where T","page":"Ideals in Multivariate Rings","title":"ideal_membership","text":"ideal_membership(f::T, I::MPolyIdeal{T}) where T\n\nReturn true if f is contained in I, false otherwise. Alternatively, use f in I.\n\nExamples\n\njulia> R, (x, y) = polynomial_ring(QQ, [:x, :y])\n(Multivariate polynomial ring in 2 variables over QQ, QQMPolyRingElem[x, y])\n\njulia> f = x^2\nx^2\n\njulia> I = ideal(R, [x, y])^2\nIdeal generated by\n  x^2\n  x*y\n  y^2\n\njulia> ideal_membership(f, I)\ntrue\n\njulia> g = x\nx\n\njulia> g in I\nfalse\n\n\n\n\n\n","category":"method"},{"location":"CommutativeAlgebra/ideals/#Radical-Membership","page":"Ideals in Multivariate Rings","title":"Radical Membership","text":"","category":"section"},{"location":"CommutativeAlgebra/ideals/","page":"Ideals in Multivariate Rings","title":"Ideals in Multivariate Rings","text":"radical_membership(f::T, I::MPolyIdeal{T}) where T","category":"page"},{"location":"CommutativeAlgebra/ideals/#radical_membership-Union{Tuple{T}, Tuple{T, MPolyIdeal{T}}} where T","page":"Ideals in Multivariate Rings","title":"radical_membership","text":"radical_membership(f::T, I::MPolyIdeal{T}) where T\n\nReturn true if f is contained in the radical of I, false otherwise. Alternatively, use inradical(f, I).\n\nExamples\n\njulia> R, (x,) = polynomial_ring(QQ, [:x])\n(Multivariate polynomial ring in 1 variable over QQ, QQMPolyRingElem[x])\n\njulia> f = x\nx\n\njulia> I = ideal(R,  [x^2])\nIdeal generated by\n  x^2\n\njulia> radical_membership(f, I)\ntrue\n\njulia> g = x+1\nx + 1\n\njulia> inradical(g, I)\nfalse\n\n\n\n\n\n","category":"method"},{"location":"CommutativeAlgebra/ideals/#Primality-Test","page":"Ideals in Multivariate Rings","title":"Primality Test","text":"","category":"section"},{"location":"CommutativeAlgebra/ideals/","page":"Ideals in Multivariate Rings","title":"Ideals in Multivariate Rings","text":"is_prime(I::MPolyIdeal)","category":"page"},{"location":"CommutativeAlgebra/ideals/#is_prime-Tuple{MPolyIdeal}","page":"Ideals in Multivariate Rings","title":"is_prime","text":"is_prime(I::MPolyIdeal)\n\nReturn true if I is prime, false otherwise.\n\nwarning: Warning\nThe function computes the minimal associated primes of I. This may take some time.\n\nExamples\n\njulia> R, (x, y) = polynomial_ring(QQ, [:x, :y])\n(Multivariate polynomial ring in 2 variables over QQ, QQMPolyRingElem[x, y])\n\njulia> I = ideal(R, [x, y])^2\nIdeal generated by\n  x^2\n  x*y\n  y^2\n\njulia> is_prime(I)\nfalse\n\n\n\n\n\n","category":"method"},{"location":"CommutativeAlgebra/ideals/#Primary-Test","page":"Ideals in Multivariate Rings","title":"Primary Test","text":"","category":"section"},{"location":"CommutativeAlgebra/ideals/","page":"Ideals in Multivariate Rings","title":"Ideals in Multivariate Rings","text":"is_primary(I::MPolyIdeal)","category":"page"},{"location":"CommutativeAlgebra/ideals/#is_primary-Tuple{MPolyIdeal}","page":"Ideals in Multivariate Rings","title":"is_primary","text":"is_primary(I::MPolyIdeal)\n\nReturn true if I is primary, false otherwise.\n\nwarning: Warning\nThe function computes a primary decomposition of I. This may take some time.\n\nExamples\n\njulia> R, (x, y) = polynomial_ring(QQ, [:x, :y])\n(Multivariate polynomial ring in 2 variables over QQ, QQMPolyRingElem[x, y])\n\njulia> I = ideal(R, [x, y])^2\nIdeal generated by\n  x^2\n  x*y\n  y^2\n\njulia> is_primary(I)\ntrue\n\n\n\n\n\n","category":"method"},{"location":"CommutativeAlgebra/ideals/#Decomposition-of-Ideals","page":"Ideals in Multivariate Rings","title":"Decomposition of Ideals","text":"","category":"section"},{"location":"CommutativeAlgebra/ideals/","page":"Ideals in Multivariate Rings","title":"Ideals in Multivariate Rings","text":"We discuss various decomposition techniques. They are implemented for polynomial rings over fields and, if explicitly mentioned, also for polynomial rings over the integers. See [DGP99] for a survey.","category":"page"},{"location":"CommutativeAlgebra/ideals/#Radical","page":"Ideals in Multivariate Rings","title":"Radical","text":"","category":"section"},{"location":"CommutativeAlgebra/ideals/","page":"Ideals in Multivariate Rings","title":"Ideals in Multivariate Rings","text":"radical(I::MPolyIdeal)","category":"page"},{"location":"CommutativeAlgebra/ideals/#radical-Tuple{MPolyIdeal}","page":"Ideals in Multivariate Rings","title":"radical","text":"radical(f::SesquilinearForm{T})\n\nReturn the radical of the sesquilinear form f, i.e. the subspace of all v such that f(u,v)=0 for all u. The radical of a quadratic form Q is the set of vectors v such that Q(v)=0  and v lies in the radical of the corresponding bilinear form.\n\n\n\n\n\n","category":"method"},{"location":"CommutativeAlgebra/ideals/#Primary-Decomposition","page":"Ideals in Multivariate Rings","title":"Primary Decomposition","text":"","category":"section"},{"location":"CommutativeAlgebra/ideals/","page":"Ideals in Multivariate Rings","title":"Ideals in Multivariate Rings","text":"primary_decomposition(I::MPolyIdeal; algorithm::Symbol = :GTZ)","category":"page"},{"location":"CommutativeAlgebra/ideals/#primary_decomposition-Tuple{MPolyIdeal}","page":"Ideals in Multivariate Rings","title":"primary_decomposition","text":"primary_decomposition(I::MPolyIdeal; algorithm = :GTZ, cache=true)\n\nReturn a minimal primary decomposition of I.\n\nThe decomposition is returned as a vector of tuples (Q_1 P_1) dots (Q_t P_t), say, where each Q_i is a primary ideal with associated prime P_i, and where the intersection of the Q_i is I.\n\nImplemented Algorithms\n\nIf the base ring of I is a polynomial ring over a field, the algorithm of Gianni, Trager, and Zacharias is used by default (algorithm = :GTZ). Alternatively, the algorithm by Shimoyama and Yokoyama can be used by specifying algorithm = :SY.  For polynomial rings over the integers, the algorithm proceeds as suggested by Pfister, Sadiq, and Steidel. See [GTZ88], [SY96], and [PSS11].\n\nwarning: Warning\nThe algorithm of Gianni, Trager, and Zacharias may not terminate over a small finite field. If it terminates, the result is correct.\n\nwarning: Warning\nIf computations are done in a ring over a number field, then the output may contain redundant components.\n\nIf cache=false is set, the primary decomposition is recomputed and not cached.\n\nExamples\n\njulia> R, (x, y) = polynomial_ring(QQ, [:x, :y])\n(Multivariate polynomial ring in 2 variables over QQ, QQMPolyRingElem[x, y])\n\njulia> I = intersect(ideal(R, [x, y])^2, ideal(R, [y^2-x^3+x]))\nIdeal generated by\n  x^3*y - x*y - y^3\n  x^4 - x^2 - x*y^2\n\njulia> I = intersect(I, ideal(R, [x-y-1])^2)\nIdeal generated by\n  x^5*y - 2*x^4*y^2 - 2*x^4*y + x^3*y^3 + 2*x^3*y^2 - x^2*y^3 + 2*x^2*y^2 + 2*x^2*y + 2*x*y^4 + x*y^3 - 2*x*y^2 - x*y - y^5 - 2*y^4 - y^3\n  x^6 - 2*x^5*y - 2*x^5 + x^4*y^2 + 2*x^4*y - x^3*y^2 + 2*x^3*y + 2*x^3 + 2*x^2*y^3 + x^2*y^2 - 2*x^2*y - x^2 - x*y^4 - 2*x*y^3 - x*y^2\n\njulia> L = primary_decomposition(I)\n3-element Vector{Tuple{MPolyIdeal{QQMPolyRingElem}, MPolyIdeal{QQMPolyRingElem}}}:\n (Ideal (x^3 - x - y^2), Ideal (x^3 - x - y^2))\n (Ideal (x^2 - 2*x*y - 2*x + y^2 + 2*y + 1), Ideal (x - y - 1))\n (Ideal (y, x^2), Ideal (x, y))\n\njulia> L = primary_decomposition(I, algorithm = :SY, cache=false)\n3-element Vector{Tuple{MPolyIdeal{QQMPolyRingElem}, MPolyIdeal{QQMPolyRingElem}}}:\n (Ideal (x^3 - x - y^2), Ideal (x^3 - x - y^2))\n (Ideal (x^2 - 2*x*y - 2*x + y^2 + 2*y + 1), Ideal (x - y - 1))\n (Ideal (y, x^2), Ideal (y, x))\n\njulia> R, (a, b, c, d) = polynomial_ring(ZZ, [:a, :b, :c, :d])\n(Multivariate polynomial ring in 4 variables over ZZ, ZZMPolyRingElem[a, b, c, d])\n\njulia> I = ideal(R, [1326*a^2*d^5, 1989*a^2*c^5, 102*b^4*d^5, 153*b^4*c^5,\n       663*a^2*c^5*d^5, 51*b^4*c^5*d^5, 78*a^2*d^15, 117*a^2*c^15,\n       78*a^15*d^5, 117*a^15*c^5, 6*a^2*b^4*d^15, 9*a^2*b^4*c^15,\n       39*a^2*c^5*d^15, 39*a^2*c^15*d^5, 6*a^2*b^15*d^5, 9*a^2*b^15*c^5,\n       6*a^15*b^4*d^5, 9*a^15*b^4*c^5, 39*a^15*c^5*d^5, 3*a^2*b^4*c^5*d^15,\n       3*a^2*b^4*c^15*d^5, 3*a^2*b^15*c^5*d^5, 3*a^15*b^4*c^5*d^5])\nIdeal generated by\n  1326*a^2*d^5\n  1989*a^2*c^5\n  102*b^4*d^5\n  153*b^4*c^5\n  663*a^2*c^5*d^5\n  51*b^4*c^5*d^5\n  78*a^2*d^15\n  117*a^2*c^15\n  78*a^15*d^5\n  117*a^15*c^5\n  6*a^2*b^4*d^15\n  9*a^2*b^4*c^15\n  39*a^2*c^5*d^15\n  39*a^2*c^15*d^5\n  6*a^2*b^15*d^5\n  9*a^2*b^15*c^5\n  6*a^15*b^4*d^5\n  9*a^15*b^4*c^5\n  39*a^15*c^5*d^5\n  3*a^2*b^4*c^5*d^15\n  3*a^2*b^4*c^15*d^5\n  3*a^2*b^15*c^5*d^5\n  3*a^15*b^4*c^5*d^5\n\njulia> L = primary_decomposition(I)\n8-element Vector{Tuple{MPolyIdeal{ZZMPolyRingElem}, MPolyIdeal{ZZMPolyRingElem}}}:\n (Ideal (d^5, c^5), Ideal (d, c))\n (Ideal (a^2, b^4), Ideal (b, a))\n (Ideal (2, c^5), Ideal (2, c))\n (Ideal (3), Ideal (3))\n (Ideal (13, b^4), Ideal (13, b))\n (Ideal (17, a^2), Ideal (17, a))\n (Ideal (17, d^15, c^15, b^15, a^15), Ideal (17, d, c, b, a))\n (Ideal (9, 3*d^5, d^10), Ideal (3, d))\n\n\n\n\n\n","category":"method"},{"location":"CommutativeAlgebra/ideals/#Absolute-Primary-Decomposition","page":"Ideals in Multivariate Rings","title":"Absolute Primary Decomposition","text":"","category":"section"},{"location":"CommutativeAlgebra/ideals/","page":"Ideals in Multivariate Rings","title":"Ideals in Multivariate Rings","text":"absolute_primary_decomposition(I::MPolyIdeal{QQMPolyRingElem})","category":"page"},{"location":"CommutativeAlgebra/ideals/#absolute_primary_decomposition-Tuple{MPolyIdeal{QQMPolyRingElem}}","page":"Ideals in Multivariate Rings","title":"absolute_primary_decomposition","text":"absolute_primary_decomposition(I::MPolyIdeal{<:MPolyRingElem{QQFieldElem}})\n\nGiven an ideal I in a multivariate polynomial ring over the rationals, return an absolute minimal primary decomposition of I.\n\nReturn the decomposition as a vector of tuples (Q_i P_i P_ij d_ij), say, where (Q_i P_i) is a (primary, prime) tuple as returned by primary_decomposition(I), and P_ij represents a corresponding class of conjugated absolute associated primes defined over a number field of degree d_ij whose generator prints as _a.\n\nImplemented Algorithms\n\nThe implementation combines the algorithm of Gianni, Trager, and Zacharias for primary decomposition with absolute polynomial factorization.\n\nwarning: Warning\nOver number fields this proceduce might return redundant output.\n\nExamples\n\njulia> R, (y, z) = polynomial_ring(QQ, [:y, :z])\n(Multivariate polynomial ring in 2 variables over QQ, QQMPolyRingElem[y, z])\n\njulia> p = z^2+1\nz^2 + 1\n\njulia> q = z^3+2\nz^3 + 2\n\njulia> I = ideal(R, [p*q^2, y-z^2])\nIdeal generated by\n  z^8 + z^6 + 4*z^5 + 4*z^3 + 4*z^2 + 4\n  y - z^2\n\njulia> L = primary_decomposition(I)\n2-element Vector{Tuple{MPolyIdeal{QQMPolyRingElem}, MPolyIdeal{QQMPolyRingElem}}}:\n (Ideal (z^2 + 1, y - z^2), Ideal (z^2 + 1, y - z^2))\n (Ideal (z^6 + 4*z^3 + 4, y - z^2), Ideal (z^3 + 2, y - z^2))\n\njulia> AL = absolute_primary_decomposition(I)\n2-element Vector{Tuple{MPolyIdeal{QQMPolyRingElem}, MPolyIdeal{QQMPolyRingElem}, MPolyIdeal{AbstractAlgebra.Generic.MPoly{AbsSimpleNumFieldElem}}, Int64}}:\n (Ideal (z^2 + 1, y + 1), Ideal (z^2 + 1, y + 1), Ideal (z - _a, y + 1), 2)\n (Ideal (z^6 + 4*z^3 + 4, y - z^2), Ideal (z^3 + 2, y - z^2), Ideal (z - _a, y - _a^2), 3)\n\njulia> AP = AL[1][3]\nIdeal generated by\n  z - _a\n  y + 1\n\njulia> RAP = base_ring(AP)\nMultivariate polynomial ring in 2 variables y, z\n  over number field of degree 2 over QQ\n\njulia> NF = coefficient_ring(RAP)\nNumber field with defining polynomial x^2 + 1\n  over rational field\n\njulia> a = gen(NF)\n_a\n\njulia> minpoly(a)\nx^2 + 1\n\njulia> R, (x, y) = graded_polynomial_ring(QQ, [:x, :y])\n(Graded multivariate polynomial ring in 2 variables over QQ, MPolyDecRingElem{QQFieldElem, QQMPolyRingElem}[x, y])\n\njulia> I = ideal(R, [x^2+y^2])\nIdeal generated by\n  x^2 + y^2\n\njulia> AL = absolute_primary_decomposition(I)\n1-element Vector{Tuple{MPolyIdeal{MPolyDecRingElem{QQFieldElem, QQMPolyRingElem}}, MPolyIdeal{MPolyDecRingElem{QQFieldElem, QQMPolyRingElem}}, MPolyIdeal{MPolyDecRingElem{AbsSimpleNumFieldElem, AbstractAlgebra.Generic.MPoly{AbsSimpleNumFieldElem}}}, Int64}}:\n (Ideal (x^2 + y^2), Ideal (x^2 + y^2), Ideal (x + _a*y), 2)\n\njulia> AP = AL[1][3]\nIdeal generated by\n  x + _a*y\n\njulia> RAP = base_ring(AP)\nMultivariate polynomial ring in 2 variables over number field graded by \n  x -> [1]\n  y -> [1]\n\n\n\n\n\n","category":"method"},{"location":"CommutativeAlgebra/ideals/#Minimal-Associated-Primes","page":"Ideals in Multivariate Rings","title":"Minimal Associated Primes","text":"","category":"section"},{"location":"CommutativeAlgebra/ideals/","page":"Ideals in Multivariate Rings","title":"Ideals in Multivariate Rings","text":"minimal_primes(I::MPolyIdeal; algorithm::Symbol = :GTZ)","category":"page"},{"location":"CommutativeAlgebra/ideals/#minimal_primes-Tuple{MPolyIdeal}","page":"Ideals in Multivariate Rings","title":"minimal_primes","text":"minimal_primes(I::MPolyIdeal; algorithm::Symbol = :GTZ)\n\nReturn a vector containing the minimal associated prime ideals of I.\n\nImplemented Algorithms\n\nIf the base ring of I is a polynomial ring over a field, the algorithm of Gianni, Trager, and Zacharias is used by default (algorithm = :GTZ). Alternatively, characteristic sets can be used by specifying algorithm = :charSets. For polynomial rings over the integers, the algorithm proceeds as suggested by Pfister, Sadiq, and Steidel. See [GTZ88] and [PSS11].\n\nExamples\n\njulia> R, (x, y) = polynomial_ring(QQ, [:x, :y])\n(Multivariate polynomial ring in 2 variables over QQ, QQMPolyRingElem[x, y])\n\njulia> I = intersect(ideal(R, [x, y])^2, ideal(R, [y^2-x^3+x]))\nIdeal generated by\n  x^3*y - x*y - y^3\n  x^4 - x^2 - x*y^2\n\njulia> I = intersect(I, ideal(R, [x-y-1])^2)\nIdeal generated by\n  x^5*y - 2*x^4*y^2 - 2*x^4*y + x^3*y^3 + 2*x^3*y^2 - x^2*y^3 + 2*x^2*y^2 + 2*x^2*y + 2*x*y^4 + x*y^3 - 2*x*y^2 - x*y - y^5 - 2*y^4 - y^3\n  x^6 - 2*x^5*y - 2*x^5 + x^4*y^2 + 2*x^4*y - x^3*y^2 + 2*x^3*y + 2*x^3 + 2*x^2*y^3 + x^2*y^2 - 2*x^2*y - x^2 - x*y^4 - 2*x*y^3 - x*y^2\n\njulia> L = minimal_primes(I)\n2-element Vector{MPolyIdeal{QQMPolyRingElem}}:\n Ideal (x - y - 1)\n Ideal (x^3 - x - y^2)\n\njulia> L = minimal_primes(I, algorithm = :charSets)\n2-element Vector{MPolyIdeal{QQMPolyRingElem}}:\n Ideal (x - y - 1)\n Ideal (x^3 - x - y^2)\n\njulia> R, (a, b, c, d) = polynomial_ring(ZZ, [:a, :b, :c, :d])\n(Multivariate polynomial ring in 4 variables over ZZ, ZZMPolyRingElem[a, b, c, d])\n\njulia> I = ideal(R, [1326*a^2*d^5, 1989*a^2*c^5, 102*b^4*d^5, 153*b^4*c^5,\n       663*a^2*c^5*d^5, 51*b^4*c^5*d^5, 78*a^2*d^15, 117*a^2*c^15,\n       78*a^15*d^5, 117*a^15*c^5, 6*a^2*b^4*d^15, 9*a^2*b^4*c^15,\n       39*a^2*c^5*d^15, 39*a^2*c^15*d^5, 6*a^2*b^15*d^5, 9*a^2*b^15*c^5,\n       6*a^15*b^4*d^5, 9*a^15*b^4*c^5, 39*a^15*c^5*d^5, 3*a^2*b^4*c^5*d^15,\n       3*a^2*b^4*c^15*d^5, 3*a^2*b^15*c^5*d^5, 3*a^15*b^4*c^5*d^5])\nIdeal generated by\n  1326*a^2*d^5\n  1989*a^2*c^5\n  102*b^4*d^5\n  153*b^4*c^5\n  663*a^2*c^5*d^5\n  51*b^4*c^5*d^5\n  78*a^2*d^15\n  117*a^2*c^15\n  78*a^15*d^5\n  117*a^15*c^5\n  6*a^2*b^4*d^15\n  9*a^2*b^4*c^15\n  39*a^2*c^5*d^15\n  39*a^2*c^15*d^5\n  6*a^2*b^15*d^5\n  9*a^2*b^15*c^5\n  6*a^15*b^4*d^5\n  9*a^15*b^4*c^5\n  39*a^15*c^5*d^5\n  3*a^2*b^4*c^5*d^15\n  3*a^2*b^4*c^15*d^5\n  3*a^2*b^15*c^5*d^5\n  3*a^15*b^4*c^5*d^5\n\njulia> L = minimal_primes(I)\n6-element Vector{MPolyIdeal{ZZMPolyRingElem}}:\n Ideal (d, c)\n Ideal (b, a)\n Ideal (2, c)\n Ideal (3)\n Ideal (13, b)\n Ideal (17, a)\n\n\n\n\n\n","category":"method"},{"location":"CommutativeAlgebra/ideals/#Weak-Equidimensional-Decomposition","page":"Ideals in Multivariate Rings","title":"Weak Equidimensional Decomposition","text":"","category":"section"},{"location":"CommutativeAlgebra/ideals/","page":"Ideals in Multivariate Rings","title":"Ideals in Multivariate Rings","text":"equidimensional_decomposition_weak(I::MPolyIdeal)","category":"page"},{"location":"CommutativeAlgebra/ideals/#equidimensional_decomposition_weak-Tuple{MPolyIdeal}","page":"Ideals in Multivariate Rings","title":"equidimensional_decomposition_weak","text":"equidimensional_decomposition_weak(I::MPolyIdeal)\n\nReturn a vector of equidimensional ideals where the last entry is the equidimensional hull of I, that is, the intersection of the primary components of I of maximal dimension. Each of the previous entries is an ideal of lower dimension whose associated primes are exactly the associated primes of I of that dimension.\n\nImplemented Algorithms\n\nThe implementation relies on ideas of Eisenbud, Huneke, and Vasconcelos. See [EHV92].\n\nExamples\n\njulia> R, (x, y) = polynomial_ring(QQ, [:x, :y])\n(Multivariate polynomial ring in 2 variables over QQ, QQMPolyRingElem[x, y])\n\njulia> I = intersect(ideal(R, [x, y])^2, ideal(R, [y^2-x^3+x]))\nIdeal generated by\n  x^3*y - x*y - y^3\n  x^4 - x^2 - x*y^2\n\njulia> I = intersect(I, ideal(R, [x-y-1])^2)\nIdeal generated by\n  x^5*y - 2*x^4*y^2 - 2*x^4*y + x^3*y^3 + 2*x^3*y^2 - x^2*y^3 + 2*x^2*y^2 + 2*x^2*y + 2*x*y^4 + x*y^3 - 2*x*y^2 - x*y - y^5 - 2*y^4 - y^3\n  x^6 - 2*x^5*y - 2*x^5 + x^4*y^2 + 2*x^4*y - x^3*y^2 + 2*x^3*y + 2*x^3 + 2*x^2*y^3 + x^2*y^2 - 2*x^2*y - x^2 - x*y^4 - 2*x*y^3 - x*y^2\n\njulia> L = equidimensional_decomposition_weak(I)\n2-element Vector{MPolyIdeal{QQMPolyRingElem}}:\n Ideal (y, x)\n Ideal with 1 generator\n\n\n\n\n\n","category":"method"},{"location":"CommutativeAlgebra/ideals/#Equidimensional-Decomposition-of-radical","page":"Ideals in Multivariate Rings","title":"Equidimensional Decomposition of radical","text":"","category":"section"},{"location":"CommutativeAlgebra/ideals/","page":"Ideals in Multivariate Rings","title":"Ideals in Multivariate Rings","text":"equidimensional_decomposition_radical(I::MPolyIdeal)","category":"page"},{"location":"CommutativeAlgebra/ideals/#equidimensional_decomposition_radical-Tuple{MPolyIdeal}","page":"Ideals in Multivariate Rings","title":"equidimensional_decomposition_radical","text":"equidimensional_decomposition_radical(I::MPolyIdeal)\n\nReturn a vector of equidimensional radical ideals increasingly ordered by dimension. For each dimension, the returned radical ideal is the intersection of the associated primes of I of that dimension. \n\nImplemented Algorithms\n\nThe implementation combines the algorithms of Krick and Logar (with modifications by Laplagne) and Kemper. See [KL91] and [Kem02].\n\nExamples\n\njulia> R, (x, y) = polynomial_ring(QQ, [:x, :y])\n(Multivariate polynomial ring in 2 variables over QQ, QQMPolyRingElem[x, y])\n\njulia> I = intersect(ideal(R, [x, y])^2, ideal(R, [y^2-x^3+x]))\nIdeal generated by\n  x^3*y - x*y - y^3\n  x^4 - x^2 - x*y^2\n\njulia> I = intersect(I, ideal(R, [x-y-1])^2)\nIdeal generated by\n  x^5*y - 2*x^4*y^2 - 2*x^4*y + x^3*y^3 + 2*x^3*y^2 - x^2*y^3 + 2*x^2*y^2 + 2*x^2*y + 2*x*y^4 + x*y^3 - 2*x*y^2 - x*y - y^5 - 2*y^4 - y^3\n  x^6 - 2*x^5*y - 2*x^5 + x^4*y^2 + 2*x^4*y - x^3*y^2 + 2*x^3*y + 2*x^3 + 2*x^2*y^3 + x^2*y^2 - 2*x^2*y - x^2 - x*y^4 - 2*x*y^3 - x*y^2\n\njulia> L = equidimensional_decomposition_radical(I)\n2-element Vector{MPolyIdeal{QQMPolyRingElem}}:\n Ideal (y, x)\n Ideal (x^4 - x^3*y - x^3 - x^2 - x*y^2 + x*y + x + y^3 + y^2)\n\n\n\n\n\n","category":"method"},{"location":"CommutativeAlgebra/ideals/#Equidimensional-Hull","page":"Ideals in Multivariate Rings","title":"Equidimensional Hull","text":"","category":"section"},{"location":"CommutativeAlgebra/ideals/","page":"Ideals in Multivariate Rings","title":"Ideals in Multivariate Rings","text":"equidimensional_hull(I::MPolyIdeal)","category":"page"},{"location":"CommutativeAlgebra/ideals/#equidimensional_hull-Tuple{MPolyIdeal}","page":"Ideals in Multivariate Rings","title":"equidimensional_hull","text":"equidimensional_hull(I::MPolyIdeal)\n\nIf the base ring of I is a polynomial ring over a field, return the intersection of the primary components of I of maximal dimension. In the case of polynomials over the integers, return the intersection of the primary components of I of minimal height.  If I is the unit ideal, return [ideal(1)].\n\nImplemented Algorithms\n\nFor polynomial rings over a field, the implementation relies on ideas as used by Gianni, Trager, and Zacharias or Krick and Logar. For polynomial rings over the integers, the algorithm proceeds as suggested by Pfister, Sadiq, and Steidel. See [GTZ88], [KL91],  and [PSS11].\n\nExamples\n\njulia> R, (x, y) = polynomial_ring(QQ, [:x, :y])\n(Multivariate polynomial ring in 2 variables over QQ, QQMPolyRingElem[x, y])\n\njulia> I = intersect(ideal(R, [x, y])^2, ideal(R, [y^2-x^3+x]))\nIdeal generated by\n  x^3*y - x*y - y^3\n  x^4 - x^2 - x*y^2\n\njulia> I = intersect(I, ideal(R, [x-y-1])^2)\nIdeal generated by\n  x^5*y - 2*x^4*y^2 - 2*x^4*y + x^3*y^3 + 2*x^3*y^2 - x^2*y^3 + 2*x^2*y^2 + 2*x^2*y + 2*x*y^4 + x*y^3 - 2*x*y^2 - x*y - y^5 - 2*y^4 - y^3\n  x^6 - 2*x^5*y - 2*x^5 + x^4*y^2 + 2*x^4*y - x^3*y^2 + 2*x^3*y + 2*x^3 + 2*x^2*y^3 + x^2*y^2 - 2*x^2*y - x^2 - x*y^4 - 2*x*y^3 - x*y^2\n\njulia> L = equidimensional_hull(I)\nIdeal generated by\n  x^5 - 2*x^4*y - 2*x^4 + x^3*y^2 + 2*x^3*y - x^2*y^2 + 2*x^2*y + 2*x^2 + 2*x*y^3 + x*y^2 - 2*x*y - x - y^4 - 2*y^3 - y^2\n\njulia> R, (a, b, c, d) = polynomial_ring(ZZ, [:a, :b, :c, :d])\n(Multivariate polynomial ring in 4 variables over ZZ, ZZMPolyRingElem[a, b, c, d])\n\njulia> I = ideal(R, [1326*a^2*d^5, 1989*a^2*c^5, 102*b^4*d^5, 153*b^4*c^5,\n       663*a^2*c^5*d^5, 51*b^4*c^5*d^5, 78*a^2*d^15, 117*a^2*c^15,\n       78*a^15*d^5, 117*a^15*c^5, 6*a^2*b^4*d^15, 9*a^2*b^4*c^15,\n       39*a^2*c^5*d^15, 39*a^2*c^15*d^5, 6*a^2*b^15*d^5, 9*a^2*b^15*c^5,\n       6*a^15*b^4*d^5, 9*a^15*b^4*c^5, 39*a^15*c^5*d^5, 3*a^2*b^4*c^5*d^15,\n       3*a^2*b^4*c^15*d^5, 3*a^2*b^15*c^5*d^5, 3*a^15*b^4*c^5*d^5])\nIdeal generated by\n  1326*a^2*d^5\n  1989*a^2*c^5\n  102*b^4*d^5\n  153*b^4*c^5\n  663*a^2*c^5*d^5\n  51*b^4*c^5*d^5\n  78*a^2*d^15\n  117*a^2*c^15\n  78*a^15*d^5\n  117*a^15*c^5\n  6*a^2*b^4*d^15\n  9*a^2*b^4*c^15\n  39*a^2*c^5*d^15\n  39*a^2*c^15*d^5\n  6*a^2*b^15*d^5\n  9*a^2*b^15*c^5\n  6*a^15*b^4*d^5\n  9*a^15*b^4*c^5\n  39*a^15*c^5*d^5\n  3*a^2*b^4*c^5*d^15\n  3*a^2*b^4*c^15*d^5\n  3*a^2*b^15*c^5*d^5\n  3*a^15*b^4*c^5*d^5\n\njulia> L = equidimensional_hull(I)\nIdeal generated by\n  3\n\n\n\n\n\n","category":"method"},{"location":"CommutativeAlgebra/ideals/#Radical-of-the-Equidimensional-Hull","page":"Ideals in Multivariate Rings","title":"Radical of the Equidimensional Hull","text":"","category":"section"},{"location":"CommutativeAlgebra/ideals/","page":"Ideals in Multivariate Rings","title":"Ideals in Multivariate Rings","text":"equidimensional_hull_radical(I::MPolyIdeal)","category":"page"},{"location":"CommutativeAlgebra/ideals/#equidimensional_hull_radical-Tuple{MPolyIdeal}","page":"Ideals in Multivariate Rings","title":"equidimensional_hull_radical","text":"equidimensional_hull_radical(I::MPolyIdeal)\n\nReturn the intersection of the associated primes of I of maximal dimension. If I is the unit ideal, return [ideal(1)].\n\nImplemented Algorithms\n\nThe implementation relies on a combination of the algorithms of Krick and Logar (with modifications by Laplagne) and Kemper. See [KL91] and [Kem02].\n\nExamples\n\njulia> R, (x, y) = polynomial_ring(QQ, [:x, :y])\n(Multivariate polynomial ring in 2 variables over QQ, QQMPolyRingElem[x, y])\n\njulia> I = intersect(ideal(R, [x, y])^2, ideal(R, [y^2-x^3+x]))\nIdeal generated by\n  x^3*y - x*y - y^3\n  x^4 - x^2 - x*y^2\n\njulia> I = intersect(I, ideal(R, [x-y-1])^2)\nIdeal generated by\n  x^5*y - 2*x^4*y^2 - 2*x^4*y + x^3*y^3 + 2*x^3*y^2 - x^2*y^3 + 2*x^2*y^2 + 2*x^2*y + 2*x*y^4 + x*y^3 - 2*x*y^2 - x*y - y^5 - 2*y^4 - y^3\n  x^6 - 2*x^5*y - 2*x^5 + x^4*y^2 + 2*x^4*y - x^3*y^2 + 2*x^3*y + 2*x^3 + 2*x^2*y^3 + x^2*y^2 - 2*x^2*y - x^2 - x*y^4 - 2*x*y^3 - x*y^2\n\njulia> L = equidimensional_hull_radical(I)\nIdeal generated by\n  x^4 - x^3*y - x^3 - x^2 - x*y^2 + x*y + x + y^3 + y^2\n\n\n\n\n\n","category":"method"},{"location":"CommutativeAlgebra/ideals/#Homogenization-and-Dehomogenization","page":"Ideals in Multivariate Rings","title":"Homogenization and Dehomogenization","text":"","category":"section"},{"location":"CommutativeAlgebra/ideals/","page":"Ideals in Multivariate Rings","title":"Ideals in Multivariate Rings","text":"Referring to [KR05] for definitions and technical details, we discuss homogenization and dehomogenization in the context of mathbb Z^m-gradings. ","category":"page"},{"location":"CommutativeAlgebra/ideals/","page":"Ideals in Multivariate Rings","title":"Ideals in Multivariate Rings","text":"homogenizer(P::MPolyRing{T}, h::VarName; pos::Int=1+ngens(P))  where T\nhomogenizer(P::MPolyRing{T}, W::Union{ZZMatrix, Matrix{<:IntegerUnion}}, h::VarName; pos::Int)  where T\ndehomogenizer(H::Homogenizer)","category":"page"},{"location":"CommutativeAlgebra/ideals/#homogenizer-Union{Tuple{T}, Tuple{MPolyRing{T}, Union{Char, AbstractString, Symbol}}} where T","page":"Ideals in Multivariate Rings","title":"homogenizer","text":"homogenizer(P::MPolyRing, h::VarName;  pos::Int=1+ngens(P))\n\nCreate a \"homogenizing operator\" assuming a standard grading; h is the name of the homogenizing variable; pos indicates where to put the homogenizing variable in the list of generators of the graded polynomial ring (default is after all the other variables).\n\nExamples\n\njulia> P, (x,y) = polynomial_ring(QQ, [:x, :y]);\n\njulia> H = homogenizer(P, \"h\");\n\njulia> H(x^2+y)\nx^2 + y*h\n\njulia> V = H.([x^2+y, x+y^2]);\n\njulia> parent(V[1]) == parent(V[2])\ntrue\n\njulia> H(ideal([x^2+y]))\nIdeal generated by\n  x^2 + y*h\n\n\n\n\n\n","category":"method"},{"location":"CommutativeAlgebra/ideals/#homogenizer-Union{Tuple{T}, Tuple{MPolyRing{T}, Union{ZZMatrix, Matrix{<:Union{Integer, ZZRingElem}}}, Union{Char, AbstractString, Symbol}}} where T","page":"Ideals in Multivariate Rings","title":"homogenizer","text":"homogenizer(P::MPolyRing, W::Union{ZZMatrix, Matrix{<:IntegerUnion}}, h::VarName;  pos::Int=1+ngens(P))\n\nCreate a \"homogenizing operator\" using the grading specified by the columns of W; h is the prefix for the homogenizing variables; pos indicates where to put the homogenizing variables in the list of generators of the graded polynomial ring (default is after all the other variables).\n\nExamples\n\njulia> P, (x,y) = polynomial_ring(QQ, [:x, :y]);\n\njulia> W = ZZMatrix(2,2, [2,3,5,7]);\n\njulia> H = homogenizer(P, W, \"h\");\n\njulia> H(x^2+y)\nx^2 + y*h[1]*h[2]^3\n\njulia> V = H.([x^2+y, x+y^2]);\n\njulia> parent(V[1]) == parent(V[2])\ntrue\n\njulia> H(ideal([x^2+y]))\nIdeal generated by\n  x^2 + y*h[1]*h[2]^3\n\n\n\n\n\n","category":"method"},{"location":"CommutativeAlgebra/ideals/#dehomogenizer-Tuple{Oscar.Homogenizer}","page":"Ideals in Multivariate Rings","title":"dehomogenizer","text":"dehomogenizer(H::Homogenizer)\n\nCreate a \"dehomogenizing operator\" from a Homogenizer; it is effectively a polynomial ring homomorphism mapping all homogenizing variables to 1.  A Dehomogenizer is a post-inverse for the Homogenizer it was created from.\n\nExamples\n\njulia> P, (x,y) = polynomial_ring(QQ, [:x, :y]);\n\njulia> H = homogenizer(P, \"h\");\n\njulia> DH = dehomogenizer(H);\n\njulia> F = H(x^2+y)\nx^2 + y*h\n\njulia> DH(F)\nx^2 + y\n\njulia> V = [x^2+y, x*y+y^2]; HV = H.(V);\n\njulia> parent(DH(HV[1])) == P  &&  parent(DH(HV[2])) == P\ntrue\n\njulia> DH(H(ideal(V)))\nIdeal generated by\n  x*y + y^2\n  x^2 + y\n  y^3 + y^2\n\n\n\n\n\n","category":"method"},{"location":"CommutativeAlgebra/ideals/","page":"Ideals in Multivariate Rings","title":"Ideals in Multivariate Rings","text":"julia> P, (x, y) = polynomial_ring(QQ, [:x, :y]);\n\njulia> I = ideal([x^2+y, x*y+y^2]);\n\njulia> H = homogenizer(P, \"h\");\n\njulia> Ih = H(I)     # homogenization of ideal I\nIdeal generated by\n  x*y + y^2\n  x^2 + y*h\n  y^3 + y^2*h\n\njulia> DH = dehomogenizer(H);\n\njulia> DH(Ih) == I   # dehomogenization of Ih\ntrue","category":"page"},{"location":"CommutativeAlgebra/ideals/#Generating-Special-Ideals","page":"Ideals in Multivariate Rings","title":"Generating Special Ideals","text":"","category":"section"},{"location":"CommutativeAlgebra/ideals/#Katsura-n","page":"Ideals in Multivariate Rings","title":"Katsura-n","text":"","category":"section"},{"location":"CommutativeAlgebra/ideals/","page":"Ideals in Multivariate Rings","title":"Ideals in Multivariate Rings","text":"These systems appeared in a problem of magnetism in physics. For a given n katsura(n) has 2^n solutions and is defined in a polynomial ring with n+1 variables over the rational numbers. For a given polynomial ring R with n variables katsura(R) defines the corresponding system with 2^n-1 solutions.","category":"page"},{"location":"CommutativeAlgebra/ideals/","page":"Ideals in Multivariate Rings","title":"Ideals in Multivariate Rings","text":"katsura(n::Int)","category":"page"},{"location":"CommutativeAlgebra/ideals/#katsura-Tuple{Int64}","page":"Ideals in Multivariate Rings","title":"katsura","text":"katsura(n::Int)\n\nGiven a natural number n return the Katsura ideal over the rational numbers generated by u_m - sum_l=-n^n u_l-m u_l, 1 - sum_l = -n^n u_l where u_-i = u_i, and u_i = 0 for i  n and m in -n ldots n.\n\nNote that indices have been shifted to start from 1.\n\nExamples\n\njulia> I = katsura(2)\nIdeal generated by\n  x1 + 2*x2 + 2*x3 - 1\n  x1^2 - x1 + 2*x2^2 + 2*x3^2\n  2*x1*x2 + 2*x2*x3 - x2\njulia> base_ring(I)\nMultivariate polynomial ring in 3 variables x1, x2, x3\n  over rational field\n\n\n\n\n\n","category":"method"},{"location":"CommutativeAlgebra/ideals/","page":"Ideals in Multivariate Rings","title":"Ideals in Multivariate Rings","text":"katsura(R::MPolyRing)","category":"page"},{"location":"CommutativeAlgebra/ideals/#katsura-Tuple{MPolyRing}","page":"Ideals in Multivariate Rings","title":"katsura","text":"katsura(R::MPolyRing)\n\nReturn the Katsura ideal in the given polynomial ring R.\n\nExamples\n\njulia> R, _ = QQ[:x, :y, :z]\n(Multivariate polynomial ring in 3 variables over QQ, QQMPolyRingElem[x, y, z])\n\njulia> katsura(R)\nIdeal generated by\n  x + 2*y + 2*z - 1\n  x^2 - x + 2*y^2 + 2*z^2\n  2*x*y + 2*y*z - y\n\n\n\n\n\n","category":"method"},{"location":"AbstractAlgebra/matrix/","page":"Matrix functionality","title":"Matrix functionality","text":"CurrentModule = AbstractAlgebra\nDocTestSetup = AbstractAlgebra.doctestsetup()","category":"page"},{"location":"AbstractAlgebra/matrix/#Matrix-functionality","page":"Matrix functionality","title":"Matrix functionality","text":"","category":"section"},{"location":"AbstractAlgebra/matrix/","page":"Matrix functionality","title":"Matrix functionality","text":"AbstractAlgebra.jl provides a module, implemented in src/Matrix.jl for matrices over any ring belonging to the AbstractAlgebra abstract type hierarchy. This functionality will work for any matrix type which follows the Matrix interface.","category":"page"},{"location":"AbstractAlgebra/matrix/","page":"Matrix functionality","title":"Matrix functionality","text":"Similarly, AbstractAlgebra.jl provides a module in src/MatRing.jl for matrix algebras over a ring.","category":"page"},{"location":"AbstractAlgebra/matrix/#Generic-matrix-types","page":"Matrix functionality","title":"Generic matrix types","text":"","category":"section"},{"location":"AbstractAlgebra/matrix/","page":"Matrix functionality","title":"Matrix functionality","text":"AbstractAlgebra.jl allows the creation of dense matrices over any computable ring R. Generic matrices over a ring are implemented in src/generic/Matrix.jl.","category":"page"},{"location":"AbstractAlgebra/matrix/","page":"Matrix functionality","title":"Matrix functionality","text":"Generic matrix rings of mtimes m matrices are implemented in src/generic/MatRing.jl.","category":"page"},{"location":"AbstractAlgebra/matrix/","page":"Matrix functionality","title":"Matrix functionality","text":"Generic matrices in AbstractAlgebra.jl have type Generic.MatSpaceElem{T} for matrices in a matrix space, or Generic.MatRingElem{T} for matrices in a matrix algebra, where T is the type of elements of the matrix. Internally, generic matrices are implemented using an object wrapping a Julia two dimensional array, though they are not themselves Julia arrays. See the file src/generic/GenericTypes.jl for details.","category":"page"},{"location":"AbstractAlgebra/matrix/","page":"Matrix functionality","title":"Matrix functionality","text":"For the most part, one doesn't want to work directly with the MatSpaceElem type though, but with an abstract type called Generic.Mat which includes MatSpaceElem and views thereof.","category":"page"},{"location":"AbstractAlgebra/matrix/","page":"Matrix functionality","title":"Matrix functionality","text":"Parents of generic matrices (matrix spaces) have type MatSpace{T}. Parents of matrices in a matrix algebra have type Generic.MatRing{T}.","category":"page"},{"location":"AbstractAlgebra/matrix/","page":"Matrix functionality","title":"Matrix functionality","text":"The dimensions and base ring R of a generic matrix are stored in its parent object, however to allow creation of matrices without first creating the matrix space parent, generic matrices in Julia do not contain a reference to their parent. They contain the row and column numbers (or degree, in the case of matrix algebras) and the base ring on a per matrix basis. The parent object can then be reconstructed from this data on demand.","category":"page"},{"location":"AbstractAlgebra/matrix/#Abstract-types","page":"Matrix functionality","title":"Abstract types","text":"","category":"section"},{"location":"AbstractAlgebra/matrix/","page":"Matrix functionality","title":"Matrix functionality","text":"The generic matrix types (matrix spaces) belong to the abstract type MatElem{T} and the all matrix space parents are of the concrete type MatSpace{T}. On the other hand, the generic matrix algebra matrix types belong to the abstract type MatRingElem{T} and the parent types belong to the abstract  MatRing{T} Note that both the concrete type of a matrix space parent object and the abstract class it belongs to have the name MatElem, therefore disambiguation is required to specify which is intended. The same is true for the abstract types for matrix spaces and their elements.","category":"page"},{"location":"AbstractAlgebra/matrix/#Matrix-space-constructors","page":"Matrix functionality","title":"Matrix space constructors","text":"","category":"section"},{"location":"AbstractAlgebra/matrix/","page":"Matrix functionality","title":"Matrix functionality","text":"A matrix space in AbstractAlgebra.jl represents a collection of all matrices with given dimensions and base ring.","category":"page"},{"location":"AbstractAlgebra/matrix/","page":"Matrix functionality","title":"Matrix functionality","text":"In order to construct matrices in AbstractAlgebra.jl, one can first construct the matrix space itself. This is accomplished with the following constructor. We discuss creation of matrix algebras separately in a dedicated section elsewhere in the documentation.","category":"page"},{"location":"AbstractAlgebra/matrix/","page":"Matrix functionality","title":"Matrix functionality","text":"matrix_space(R::Ring, rows::Int, cols::Int)","category":"page"},{"location":"AbstractAlgebra/matrix/","page":"Matrix functionality","title":"Matrix functionality","text":"Construct the space of matrices with the given number of rows and columns over the given base ring.","category":"page"},{"location":"AbstractAlgebra/matrix/","page":"Matrix functionality","title":"Matrix functionality","text":"Here are some examples of creating matrix spaces and making use of the resulting parent objects to coerce various elements into the matrix space.","category":"page"},{"location":"AbstractAlgebra/matrix/","page":"Matrix functionality","title":"Matrix functionality","text":"Examples","category":"page"},{"location":"AbstractAlgebra/matrix/","page":"Matrix functionality","title":"Matrix functionality","text":"julia> R, t = polynomial_ring(QQ, :t)\n(Univariate polynomial ring in t over rationals, t)\n\njulia> S = matrix_space(R, 3, 3)\nMatrix space of 3 rows and 3 columns\n  over univariate polynomial ring in t over rationals\n\njulia> A = S()\n[0   0   0]\n[0   0   0]\n[0   0   0]\n\njulia> B = S(12)\n[12    0    0]\n[ 0   12    0]\n[ 0    0   12]\n\njulia> C = S(R(11))\n[11    0    0]\n[ 0   11    0]\n[ 0    0   11]\n","category":"page"},{"location":"AbstractAlgebra/matrix/#Matrix-element-constructors","page":"Matrix functionality","title":"Matrix element constructors","text":"","category":"section"},{"location":"AbstractAlgebra/matrix/","page":"Matrix functionality","title":"Matrix functionality","text":"There are a few ways to construct matrices other than by coercing elements as shown above. The first method is from an array of elements.","category":"page"},{"location":"AbstractAlgebra/matrix/","page":"Matrix functionality","title":"Matrix functionality","text":"This can be done with either two or one dimensional arrays.","category":"page"},{"location":"AbstractAlgebra/matrix/","page":"Matrix functionality","title":"Matrix functionality","text":"(S::MatSpace{T})(A::Matrix{S}) where {S <: RingElement, T <: RingElement}\n(S::MatRing{T})(A::Matrix{S}) where {S <: RingElement, T <: RingElement}","category":"page"},{"location":"AbstractAlgebra/matrix/","page":"Matrix functionality","title":"Matrix functionality","text":"Create the matrix in the given space/algebra whose (i j) entry is given by A[i, j], where S is the type of elements that can be coerced into the base ring of the matrix.","category":"page"},{"location":"AbstractAlgebra/matrix/","page":"Matrix functionality","title":"Matrix functionality","text":"(S::MyMatSpace{T})(A::Vector{S}) where {S <: RingElem, T <: RingElem}\n(S::MyMatAlgebra{T})(A::Vector{S}) where {S <: RingElem, T <: RingElem}","category":"page"},{"location":"AbstractAlgebra/matrix/","page":"Matrix functionality","title":"Matrix functionality","text":"Create the matrix in the given space/algebra of matrices (with dimensions mtimes n say), whose (i j) entry is given by A[i*(n - 1) + j] and where S is the type of elements that can be coerced into the base ring of the matrix.","category":"page"},{"location":"AbstractAlgebra/matrix/","page":"Matrix functionality","title":"Matrix functionality","text":"We also provide the following syntax for constructing literal matrices (similar to how Julia arrays can be be constructed).","category":"page"},{"location":"AbstractAlgebra/matrix/","page":"Matrix functionality","title":"Matrix functionality","text":"R[a b c...;...]","category":"page"},{"location":"AbstractAlgebra/matrix/","page":"Matrix functionality","title":"Matrix functionality","text":"Create the matrix over the base ring R consisting of the given rows (separated by semicolons). Each entry is coerced into R  automatically. Note that parentheses may be placed around individual entries if the lists would otherwise be ambiguous, e.g. R[1 2; 2 (- 3)].","category":"page"},{"location":"AbstractAlgebra/matrix/","page":"Matrix functionality","title":"Matrix functionality","text":"Also see the Matrix interface for a list of other ways to create matrices.","category":"page"},{"location":"AbstractAlgebra/matrix/","page":"Matrix functionality","title":"Matrix functionality","text":"Examples","category":"page"},{"location":"AbstractAlgebra/matrix/","page":"Matrix functionality","title":"Matrix functionality","text":"julia> S = matrix_space(QQ, 2, 3)\nMatrix space of 2 rows and 3 columns\n  over rationals\n\njulia> T = matrix_ring(QQ, 2)\nMatrix ring of degree 2\n  over rationals\n\njulia> M1 = S(Rational{BigInt}[2 3 1; 1 0 4])\n[2//1   3//1   1//1]\n[1//1   0//1   4//1]\n\njulia> M2 = S(BigInt[2 3 1; 1 0 4])\n[2//1   3//1   1//1]\n[1//1   0//1   4//1]\n\njulia> M3 = S(BigInt[2, 3, 1, 1, 0, 4])\n[2//1   3//1   1//1]\n[1//1   0//1   4//1]\n\njulia> N1 = T(Rational{BigInt}[2 3; 1 0])\n[2//1   3//1]\n[1//1   0//1]\n\njulia> N2 = T(BigInt[2 3; 1 0])\n[2//1   3//1]\n[1//1   0//1]\n\njulia> N3 = T(BigInt[2, 3, 1, 1])\n[2//1   3//1]\n[1//1   1//1]\n\njulia> R, t = polynomial_ring(QQ, :t)\n(Univariate polynomial ring in t over rationals, t)\n\njulia> S = matrix_space(R, 3, 3)\nMatrix space of 3 rows and 3 columns\n  over univariate polynomial ring in t over rationals\n\njulia> M = R[t + 1 1; t^2 0]\n[t + 1   1]\n[  t^2   0]\n\njulia> N = R[t + 1 2 t] # create a row vector\n[t + 1   2   t]\n\njulia> P = R[1; 2; t] # create a column vector\n[1]\n[2]\n[t]","category":"page"},{"location":"AbstractAlgebra/matrix/","page":"Matrix functionality","title":"Matrix functionality","text":"It is also possible to create matrices (in a matrix space only) directly, without first creating the corresponding matrix space (the inner constructor being called directly).","category":"page"},{"location":"AbstractAlgebra/matrix/","page":"Matrix functionality","title":"Matrix functionality","text":"matrix(R::Ring, arr::Matrix{T}) where T <: RingElement","category":"page"},{"location":"AbstractAlgebra/matrix/","page":"Matrix functionality","title":"Matrix functionality","text":"Given an mtimes n Julia matrix of entries, construct the corresponding AbstractAlgebra.jl matrix over the given ring R, assuming all the entries can be coerced into R.","category":"page"},{"location":"AbstractAlgebra/matrix/","page":"Matrix functionality","title":"Matrix functionality","text":"matrix(R::Ring, r::Int, c::Int, A::Vector{T}) where T <: RingElement","category":"page"},{"location":"AbstractAlgebra/matrix/","page":"Matrix functionality","title":"Matrix functionality","text":"Construct the given rtimes c AbstractAlgebra.jl matrix over the ring R whose (i j) entry is given by A[c*(i - 1) + j], assuming that all the entries can be coerced into R.","category":"page"},{"location":"AbstractAlgebra/matrix/","page":"Matrix functionality","title":"Matrix functionality","text":"zero_matrix(R::Ring, r::Int, c::Int)","category":"page"},{"location":"AbstractAlgebra/matrix/","page":"Matrix functionality","title":"Matrix functionality","text":"Construct the rtimes c AbstractAlgebra.jl zero matrix over the ring R.","category":"page"},{"location":"AbstractAlgebra/matrix/","page":"Matrix functionality","title":"Matrix functionality","text":"Examples","category":"page"},{"location":"AbstractAlgebra/matrix/","page":"Matrix functionality","title":"Matrix functionality","text":"julia> M = matrix(ZZ, BigInt[3 1 2; 2 0 1])\n[3   1   2]\n[2   0   1]\n\njulia> N = matrix(ZZ, 3, 2, BigInt[3, 1, 2, 2, 0, 1])\n[3   1]\n[2   2]\n[0   1]\n\njulia> P = zero_matrix(ZZ, 3, 2)\n[0   0]\n[0   0]\n[0   0]\n\njulia> R = matrix_ring(ZZ, 2)\nMatrix ring of degree 2\n  over integers\n\njulia> M = R()\n[0   0]\n[0   0]","category":"page"},{"location":"AbstractAlgebra/matrix/#Block-diagonal-matrix-constructors","page":"Matrix functionality","title":"Block diagonal matrix constructors","text":"","category":"section"},{"location":"AbstractAlgebra/matrix/","page":"Matrix functionality","title":"Matrix functionality","text":"It is also possible to create block diagonal matrices from a vector of existing matrices. It is also possible to construct them from Julia matrices if one supplies the base ring.","category":"page"},{"location":"AbstractAlgebra/matrix/","page":"Matrix functionality","title":"Matrix functionality","text":"Note that if the input matrices are not square, the output matrix may not be square.","category":"page"},{"location":"AbstractAlgebra/matrix/","page":"Matrix functionality","title":"Matrix functionality","text":"block_diagonal_matrix(::Vector{<:MatElem{T}}) where T <: RingElement\nblock_diagonal_matrix(::Ring, ::Vector{<:Matrix{T}}) where T <: RingElement","category":"page"},{"location":"AbstractAlgebra/matrix/#block_diagonal_matrix-Union{Tuple{Vector{<:MatElem{T}}}, Tuple{T}} where T<:RingElement","page":"Matrix functionality","title":"block_diagonal_matrix","text":"block_diagonal_matrix(V::Vector{<:MatElem{T}}) where T <: NCRingElement\n\nCreate the block diagonal matrix whose blocks are given by the matrices in V. There must be at least one matrix in V.\n\n\n\n\n\nblock_diagonal_matrix(xs::Vector{SMat})\n\nReturn the block diagonal matrix with the matrices in xs on the diagonal. Requires all blocks to have the same base ring.\n\n\n\n\n\n","category":"method"},{"location":"AbstractAlgebra/matrix/#block_diagonal_matrix-Union{Tuple{T}, Tuple{Ring, Vector{<:Matrix{T}}}} where T<:RingElement","page":"Matrix functionality","title":"block_diagonal_matrix","text":"block_diagonal_matrix(R::NCRing, V::Vector{<:Matrix{T}}) where T <: NCRingElement\n\nCreate the block diagonal matrix over the ring R whose blocks are given by the matrices in V. Entries are coerced into R upon creation.\n\n\n\n\n\n","category":"method"},{"location":"AbstractAlgebra/matrix/","page":"Matrix functionality","title":"Matrix functionality","text":"Examples","category":"page"},{"location":"AbstractAlgebra/matrix/","page":"Matrix functionality","title":"Matrix functionality","text":"julia> block_diagonal_matrix(ZZ, [[1 2; 3 4], [4 5 6; 7 8 9]])\n[1   2   0   0   0]\n[3   4   0   0   0]\n[0   0   4   5   6]\n[0   0   7   8   9]\n\njulia> M = matrix(ZZ, [1 2; 3 4])\n[1   2]\n[3   4]\n\njulia> N = matrix(ZZ, [4 5 6; 7 8 9])\n[4   5   6]\n[7   8   9]\n\njulia> block_diagonal_matrix([M, N])\n[1   2   0   0   0]\n[3   4   0   0   0]\n[0   0   4   5   6]\n[0   0   7   8   9]","category":"page"},{"location":"AbstractAlgebra/matrix/#Conversion-to-Julia-matrices,-iteration-and-broacasting","page":"Matrix functionality","title":"Conversion to Julia matrices, iteration and broacasting","text":"","category":"section"},{"location":"AbstractAlgebra/matrix/","page":"Matrix functionality","title":"Matrix functionality","text":"While AbstractAlgebra matrices are not instances of AbstractArray, they are closely related to Julia matrices. For convenience, a Matrix and an Array constructors taking an AbstractAlgebra matrix as input are provided:","category":"page"},{"location":"AbstractAlgebra/matrix/","page":"Matrix functionality","title":"Matrix functionality","text":"Matrix(::MatrixElem{T}) where T <: RingElement\nArray(::MatrixElem{T}) where T <: RingElement","category":"page"},{"location":"AbstractAlgebra/matrix/#Matrix-Union{Tuple{MatrixElem{T}}, Tuple{T}} where T<:RingElement","page":"Matrix functionality","title":"Matrix","text":"Matrix(A::MatrixElem{T}) where {T<:NCRingElement}\nMatrix{U}(A::MatrixElem{T}) where {U<:NCRingElement, T<:NCRingElement}\n\nConvert A to a Julia Matrix{U} of the same dimensions with the same elements. If U is omitted then eltype(M) is used in its place.\n\nExamples\n\njulia> A = ZZ[1 2 3; 4 5 6]\n[1   2   3]\n[4   5   6]\n\njulia> Matrix(A)\n2×3 Matrix{BigInt}:\n 1  2  3\n 4  5  6\n\njulia> Matrix{Int}(A)\n2×3 Matrix{Int64}:\n 1  2  3\n 4  5  6\n\n\n\n\n\n","category":"method"},{"location":"AbstractAlgebra/matrix/#Array-Union{Tuple{MatrixElem{T}}, Tuple{T}} where T<:RingElement","page":"Matrix functionality","title":"Array","text":"Array(A::MatrixElem{T}) where T <: NCRingElement\n\nConvert A to a Julia Matrix of the same dimensions with the same elements.\n\nExamples\n\njulia> R, x = ZZ[:x]; A = R[x^0 x^1; x^2 x^3]\n[  1     x]\n[x^2   x^3]\n\njulia> Array(A)\n2×2 Matrix{AbstractAlgebra.Generic.Poly{BigInt}}:\n 1    x\n x^2  x^3\n\n\n\n\n\n","category":"method"},{"location":"AbstractAlgebra/matrix/","page":"Matrix functionality","title":"Matrix functionality","text":"Matrices also support iteration, and therefore functions accepting an iterator can be called on them, e.g.:","category":"page"},{"location":"AbstractAlgebra/matrix/","page":"Matrix functionality","title":"Matrix functionality","text":"julia> M = matrix_space(ZZ, 2, 3); x = M(1:6)\n[1   2   3]\n[4   5   6]\n\njulia> collect(x)\n2×3 Matrix{BigInt}:\n 1  2  3\n 4  5  6\n\njulia> Set(x)\nSet{BigInt} with 6 elements:\n  5\n  4\n  6\n  2\n  3\n  1","category":"page"},{"location":"AbstractAlgebra/matrix/","page":"Matrix functionality","title":"Matrix functionality","text":"Matrices also support broadcasting, which amounts to elementwise application of functions to matrices:","category":"page"},{"location":"AbstractAlgebra/matrix/","page":"Matrix functionality","title":"Matrix functionality","text":"julia> k = GF(5);\n\njulia> A = ZZ[1 2; 3 4];\n\njulia> k.(A)\n[1   2]\n[3   4]\n\njulia> 3 .* A .+ 2\n[ 5    8]\n[11   14]\n\njulia> B = ZZ[3 4; 5 6];\n\njulia> ((x, y) -> x^2 + y^2).(A, B)\n[10   20]\n[34   52]","category":"page"},{"location":"AbstractAlgebra/matrix/#Views","page":"Matrix functionality","title":"Views","text":"","category":"section"},{"location":"AbstractAlgebra/matrix/","page":"Matrix functionality","title":"Matrix functionality","text":"As per Julia, AbstractAlgebra supports the construction of matrix views.  These allow one to work with a submatrix of a given matrix. Modifying the submatrix also modifies the original matrix.","category":"page"},{"location":"AbstractAlgebra/matrix/","page":"Matrix functionality","title":"Matrix functionality","text":"The syntax for views is as for Julia's own views.","category":"page"},{"location":"AbstractAlgebra/matrix/","page":"Matrix functionality","title":"Matrix functionality","text":"Examples","category":"page"},{"location":"AbstractAlgebra/matrix/","page":"Matrix functionality","title":"Matrix functionality","text":"julia> M = matrix(ZZ, 3, 3, BigInt[1, 2, 3, 2, 3, 4, 3, 4, 5])\n[1   2   3]\n[2   3   4]\n[3   4   5]\n\njulia> N1 = @view M[1:2, :]\n[1   2   3]\n[2   3   4]\n\njulia> N2 = @view M[:, 1:2]\n[1   2]\n[2   3]\n[3   4]\n\njulia> R = N1*N2\n[14   20]\n[20   29]","category":"page"},{"location":"AbstractAlgebra/matrix/#Matrix-functionality-provided-by-AbstractAlgebra.jl","page":"Matrix functionality","title":"Matrix functionality provided by AbstractAlgebra.jl","text":"","category":"section"},{"location":"AbstractAlgebra/matrix/","page":"Matrix functionality","title":"Matrix functionality","text":"Most of the following generic functionality is available for both matrix spaces and matrix algebras. Exceptions include functions that do not return or accept square matrices or which cannot specify a parent. Such functions include solve, kernel, and nullspace which can't be provided for matrix algebras.","category":"page"},{"location":"AbstractAlgebra/matrix/","page":"Matrix functionality","title":"Matrix functionality","text":"For details on functionality that is provided for matrix algebras only, see the dedicated section of the documentation.","category":"page"},{"location":"AbstractAlgebra/matrix/#Basic-matrix-functionality","page":"Matrix functionality","title":"Basic matrix functionality","text":"","category":"section"},{"location":"AbstractAlgebra/matrix/","page":"Matrix functionality","title":"Matrix functionality","text":"As well as the Ring and Matrix interfaces, the following functions are provided to manipulate matrices and to set and retrieve entries and other basic data associated with the matrices.","category":"page"},{"location":"AbstractAlgebra/matrix/","page":"Matrix functionality","title":"Matrix functionality","text":"dense_matrix_type(::Ring)","category":"page"},{"location":"AbstractAlgebra/matrix/#dense_matrix_type-Tuple{Ring}","page":"Matrix functionality","title":"dense_matrix_type","text":"dense_matrix_type(::Type{T}) where T<:NCRingElement\ndense_matrix_type(::T) where T<:NCRingElement\ndense_matrix_type(::Type{S}) where S<:NCRing\ndense_matrix_type(::S) where S<:NCRing\n\nReturn the type of matrices with coefficients of type T respectively elem_type(S).\n\n\n\n\n\n","category":"method"},{"location":"AbstractAlgebra/matrix/","page":"Matrix functionality","title":"Matrix functionality","text":"number_of_rows(::MatSpace)\nnumber_of_columns(::MatSpace)","category":"page"},{"location":"AbstractAlgebra/matrix/#number_of_rows-Tuple{MatSpace}","page":"Matrix functionality","title":"number_of_rows","text":"number_of_rows(a::MatSpace)\n\nReturn the number of rows of the given matrix space.\n\n\n\n\n\n","category":"method"},{"location":"AbstractAlgebra/matrix/#number_of_columns-Tuple{MatSpace}","page":"Matrix functionality","title":"number_of_columns","text":"number_of_columns(a::MatSpace)\n\nReturn the number of columns of the given matrix space.\n\n\n\n\n\n","category":"method"},{"location":"AbstractAlgebra/matrix/","page":"Matrix functionality","title":"Matrix functionality","text":"number_of_rows(::MatrixElem{T}) where T <: RingElement\nnumber_of_columns(::MatrixElem{T}) where T <: RingElement","category":"page"},{"location":"AbstractAlgebra/matrix/#number_of_rows-Union{Tuple{MatrixElem{T}}, Tuple{T}} where T<:RingElement","page":"Matrix functionality","title":"number_of_rows","text":"number_of_rows(a::MatrixElem{T}) where T <: NCRingElement\n\nReturn the number of rows of the given matrix.\n\n\n\n\n\n","category":"method"},{"location":"AbstractAlgebra/matrix/#number_of_columns-Union{Tuple{MatrixElem{T}}, Tuple{T}} where T<:RingElement","page":"Matrix functionality","title":"number_of_columns","text":"number_of_columns(a::MatrixElem{T}) where T <: NCRingElement\n\nReturn the number of columns of the given matrix.\n\n\n\n\n\n","category":"method"},{"location":"AbstractAlgebra/matrix/","page":"Matrix functionality","title":"Matrix functionality","text":"length(::MatrixElem{T}) where T <: RingElement","category":"page"},{"location":"AbstractAlgebra/matrix/#length-Union{Tuple{MatrixElem{T}}, Tuple{T}} where T<:RingElement","page":"Matrix functionality","title":"length","text":"length(a::MatrixElem{T}) where T <: NCRingElement\n\nReturn the number of entries in the given matrix.\n\n\n\n\n\n","category":"method"},{"location":"AbstractAlgebra/matrix/","page":"Matrix functionality","title":"Matrix functionality","text":"isempty(::MatrixElem{T}) where T <: RingElement","category":"page"},{"location":"AbstractAlgebra/matrix/#isempty-Union{Tuple{MatrixElem{T}}, Tuple{T}} where T<:RingElement","page":"Matrix functionality","title":"isempty","text":"isempty(a::MatrixElem{T}) where T <: NCRingElement\n\nReturn true if a does not contain any entry (i.e. length(a) == 0), and false otherwise.\n\n\n\n\n\n","category":"method"},{"location":"AbstractAlgebra/matrix/","page":"Matrix functionality","title":"Matrix functionality","text":"identity_matrix(::Ring, ::Int)","category":"page"},{"location":"AbstractAlgebra/matrix/#identity_matrix-Tuple{Ring, Int64}","page":"Matrix functionality","title":"identity_matrix","text":"identity_matrix(R::NCRing, n::Int)\n\nReturn the n times n identity matrix over R.\n\n\n\n\n\n","category":"method"},{"location":"AbstractAlgebra/matrix/","page":"Matrix functionality","title":"Matrix functionality","text":"identity_matrix(::MatElem{T}) where T <: RingElement","category":"page"},{"location":"AbstractAlgebra/matrix/#identity_matrix-Union{Tuple{MatElem{T}}, Tuple{T}} where T<:RingElement","page":"Matrix functionality","title":"identity_matrix","text":"identity_matrix(M::MatElem{T}) where T <: NCRingElement\n\nConstruct the identity matrix in the same matrix space as M, i.e. with ones down the diagonal and zeroes elsewhere. M must be square. This is an alias for one(M).\n\n\n\n\n\n","category":"method"},{"location":"AbstractAlgebra/matrix/","page":"Matrix functionality","title":"Matrix functionality","text":"ones_matrix(::Ring, ::Int, ::Int)","category":"page"},{"location":"AbstractAlgebra/matrix/#ones_matrix-Tuple{Ring, Int64, Int64}","page":"Matrix functionality","title":"ones_matrix","text":"ones_matrix(R::Ring, r::Int, c::Int)\n\nReturn the r times c ones matrix over R.\n\n\n\n\n\n","category":"method"},{"location":"AbstractAlgebra/matrix/","page":"Matrix functionality","title":"Matrix functionality","text":"scalar_matrix(R::Ring, n::Int, a::RingElement)","category":"page"},{"location":"AbstractAlgebra/matrix/#scalar_matrix-Tuple{Ring, Int64, RingElement}","page":"Matrix functionality","title":"scalar_matrix","text":"scalar_matrix(R::NCRing, n::Int, a::NCRingElement)\nscalar_matrix(n::Int, a::NCRingElement)\n\nReturn the n times n matrix over R with a along the main diagonal and zeroes elsewhere. If R is not specified, it defaults to parent(a).\n\n\n\n\n\n","category":"method"},{"location":"AbstractAlgebra/matrix/","page":"Matrix functionality","title":"Matrix functionality","text":"diagonal_matrix(::RingElement, ::Int, ::Int)","category":"page"},{"location":"AbstractAlgebra/matrix/#diagonal_matrix-Tuple{RingElement, Int64, Int64}","page":"Matrix functionality","title":"diagonal_matrix","text":"diagonal_matrix(x::NCRingElement, m::Int, [n::Int])\n\nReturn the m times n matrix over R with x along the main diagonal and zeroes elsewhere. If n is not specified, it defaults to m.\n\nExamples\n\njulia> diagonal_matrix(ZZ(2), 2, 3)\n[2   0   0]\n[0   2   0]\n\njulia> diagonal_matrix(QQ(-1), 3)\n[-1//1    0//1    0//1]\n[ 0//1   -1//1    0//1]\n[ 0//1    0//1   -1//1]\n\n\n\n\n\n","category":"method"},{"location":"AbstractAlgebra/matrix/","page":"Matrix functionality","title":"Matrix functionality","text":"zero(::MatSpace)\nzero(::MatElem{T}, ::Ring) where T <: RingElement","category":"page"},{"location":"AbstractAlgebra/matrix/#zero-Tuple{MatSpace}","page":"Matrix functionality","title":"zero","text":"zero(a::MatSpace)\n\nReturn the zero matrix in the given matrix space.\n\n\n\n\n\n","category":"method"},{"location":"AbstractAlgebra/matrix/#zero-Union{Tuple{T}, Tuple{MatElem{T}, Ring}} where T<:RingElement","page":"Matrix functionality","title":"zero","text":"zero(x::MatElem{T}, R::NCRing, r::Int, c::Int) where T <: NCRingElement\nzero(x::MatElem{T}, r::Int, c::Int) where T <: NCRingElement\nzero(x::MatElem{T}, R::NCRing) where T <: NCRingElement\nzero(x::MatElem{T}) where T <: NCRingElement\n\nCreate an zero matrix over the given ring and dimensions, with defaults based upon the given source matrix x.\n\n\n\n\n\n","category":"method"},{"location":"AbstractAlgebra/matrix/","page":"Matrix functionality","title":"Matrix functionality","text":"one(::MatSpace)\none(::MatElem{T}) where T <: RingElement","category":"page"},{"location":"AbstractAlgebra/matrix/#one-Tuple{MatSpace}","page":"Matrix functionality","title":"one","text":"one(a::MatSpace)\n\nReturn the identity matrix of given matrix space. The matrix space must contain square matrices or else an error is thrown.\n\n\n\n\n\n","category":"method"},{"location":"AbstractAlgebra/matrix/#one-Union{Tuple{MatElem{T}}, Tuple{T}} where T<:RingElement","page":"Matrix functionality","title":"one","text":"one(a::MatrixElem{T}) where T <: NCRingElement\n\nReturn the identity matrix in the same matrix space as a. If the space does not contain square matrices, an error is thrown.\n\n\n\n\n\n","category":"method"},{"location":"AbstractAlgebra/matrix/","page":"Matrix functionality","title":"Matrix functionality","text":"lower_triangular_matrix(L::AbstractVector{T}) where {T <: RingElement}","category":"page"},{"location":"AbstractAlgebra/matrix/#lower_triangular_matrix-Union{Tuple{AbstractVector{T}}, Tuple{T}} where T<:RingElement","page":"Matrix functionality","title":"lower_triangular_matrix","text":"lower_triangular_matrix(L::AbstractVector{T}) where {T <: NCRingElement}\n\nReturn the n by n matrix whose entries on and below the main diagonal are the elements of L, and which has zeroes elsewhere. The value of n is determined by the condition that L has length n(n+1)2.\n\nAn exception is thrown if there is no integer n with this property.\n\nExamples\n\njulia> lower_triangular_matrix([1, 2, 3])\n[1   0]\n[2   3]\n\n\n\n\n\n","category":"method"},{"location":"AbstractAlgebra/matrix/","page":"Matrix functionality","title":"Matrix functionality","text":"upper_triangular_matrix(L::AbstractVector{T}) where {T <: RingElement}","category":"page"},{"location":"AbstractAlgebra/matrix/#upper_triangular_matrix-Union{Tuple{AbstractVector{T}}, Tuple{T}} where T<:RingElement","page":"Matrix functionality","title":"upper_triangular_matrix","text":"upper_triangular_matrix(L::AbstractVector{T}) where {T <: NCRingElement}\n\nReturn the n by n matrix whose entries on and above the main diagonal are the elements of L, and which has zeroes elsewhere. The value of n is determined by the condition that L has length n(n+1)2.\n\nAn exception is thrown if there is no integer n with this property.\n\nExamples\n\njulia> upper_triangular_matrix([1, 2, 3])\n[1   2]\n[0   3]\n\n\n\n\n\n","category":"method"},{"location":"AbstractAlgebra/matrix/","page":"Matrix functionality","title":"Matrix functionality","text":"strictly_lower_triangular_matrix(L::AbstractVector{T}) where {T <: RingElement}","category":"page"},{"location":"AbstractAlgebra/matrix/#strictly_lower_triangular_matrix-Union{Tuple{AbstractVector{T}}, Tuple{T}} where T<:RingElement","page":"Matrix functionality","title":"strictly_lower_triangular_matrix","text":"strictly_lower_triangular_matrix(L::AbstractVector{T}) where {T <: NCRingElement}\n\nReturn the n by n matrix whose entries below the main diagonal are the elements of L, and which has zeroes elsewhere. The value of n is determined by the condition that L has length (n-1)n2.\n\nAn exception is thrown if there is no integer n with this property.\n\nExamples\n\njulia> strictly_lower_triangular_matrix([1, 2, 3])\n[0   0   0]\n[1   0   0]\n[2   3   0]\n\n\n\n\n\n","category":"method"},{"location":"AbstractAlgebra/matrix/","page":"Matrix functionality","title":"Matrix functionality","text":"strictly_upper_triangular_matrix(L::AbstractVector{T}) where {T <: RingElement}","category":"page"},{"location":"AbstractAlgebra/matrix/#strictly_upper_triangular_matrix-Union{Tuple{AbstractVector{T}}, Tuple{T}} where T<:RingElement","page":"Matrix functionality","title":"strictly_upper_triangular_matrix","text":"strictly_upper_triangular_matrix(L::AbstractVector{T}) where {T <: NCRingElement}\n\nReturn the n by n matrix whose entries above the main diagonal are the elements of L, and which has zeroes elsewhere. The value of n is determined by the condition that L has length (n-1)n2.\n\nAn exception is thrown if there is no integer n with this property.\n\nExamples\n\njulia> strictly_upper_triangular_matrix([1, 2, 3])\n[0   1   2]\n[0   0   3]\n[0   0   0]\n\n\n\n\n\n","category":"method"},{"location":"AbstractAlgebra/matrix/","page":"Matrix functionality","title":"Matrix functionality","text":"is_lower_triangular(::MatrixElem)","category":"page"},{"location":"AbstractAlgebra/matrix/#is_lower_triangular-Tuple{MatrixElem}","page":"Matrix functionality","title":"is_lower_triangular","text":"is_lower_triangular(A::MatrixElem)\n\nReturn true if A is an lower triangular matrix, that is, all entries above the main diagonal are zero. Note that this definition also applies to non-square matrices.\n\nAlias for LinearAlgebra.istril.\n\nExamples\n\njulia> is_lower_triangular(QQ[1 2 ; 0 4])\nfalse\n\njulia> is_lower_triangular(QQ[1 0 ; 3 4])\ntrue\n\njulia> is_lower_triangular(QQ[1 2 ;])\nfalse\n\njulia> is_lower_triangular(QQ[1 ; 2])\ntrue\n\n\n\n\n\n","category":"method"},{"location":"AbstractAlgebra/matrix/","page":"Matrix functionality","title":"Matrix functionality","text":"is_upper_triangular(::MatrixElem)","category":"page"},{"location":"AbstractAlgebra/matrix/#is_upper_triangular-Tuple{MatrixElem}","page":"Matrix functionality","title":"is_upper_triangular","text":"is_upper_triangular(A::MatrixElem)\n\nReturn true if A is an upper triangular matrix, that is, all entries below the main diagonal are zero. Note that this definition also applies to non-square matrices.\n\nAlias for LinearAlgebra.istriu.\n\nExamples\n\njulia> is_upper_triangular(QQ[1 2 ; 0 4])\ntrue\n\njulia> is_upper_triangular(QQ[1 0 ; 3 4])\nfalse\n\njulia> is_upper_triangular(QQ[1 2 ;])\ntrue\n\njulia> is_upper_triangular(QQ[1 ; 2])\nfalse\n\n\n\n\n\n","category":"method"},{"location":"AbstractAlgebra/matrix/","page":"Matrix functionality","title":"Matrix functionality","text":"is_diagonal(::MatrixElem)","category":"page"},{"location":"AbstractAlgebra/matrix/#is_diagonal-Tuple{MatrixElem}","page":"Matrix functionality","title":"is_diagonal","text":"is_diagonal(A::MatrixElem)\n\nReturn true if A is a diagonal matrix, that is, all entries off the main diagonal are zero. Note that this definition also applies to non-square matrices.\n\nAlias for LinearAlgebra.isdiag.\n\nExamples\n\njulia> is_diagonal(QQ[1 0 ; 0 4])\ntrue\n\njulia> is_diagonal(QQ[1 2 ; 3 4])\nfalse\n\njulia> is_diagonal(QQ[1 0 ;])\ntrue\n\n\n\n\n\n","category":"method"},{"location":"AbstractAlgebra/matrix/","page":"Matrix functionality","title":"Matrix functionality","text":"change_base_ring(::Ring, ::MatElem{T}) where T <: RingElement","category":"page"},{"location":"AbstractAlgebra/matrix/#change_base_ring-Union{Tuple{T}, Tuple{Ring, MatElem{T}}} where T<:RingElement","page":"Matrix functionality","title":"change_base_ring","text":"change_base_ring(R::NCRing, M::MatrixElem{T}) where T <: NCRingElement\n\nReturn the matrix obtained by coercing each entry into R.\n\n\n\n\n\n","category":"method"},{"location":"AbstractAlgebra/matrix/","page":"Matrix functionality","title":"Matrix functionality","text":"Base.map(f, ::MatrixElem{T}) where T <: RingElement","category":"page"},{"location":"AbstractAlgebra/matrix/#map-Union{Tuple{T}, Tuple{Any, MatrixElem{T}}} where T<:RingElement","page":"Matrix functionality","title":"map","text":"map(f, a::MatrixElem{T}) where T <: NCRingElement\n\nTransform matrix a by applying f on each element. This is equivalent to map_entries(f, a).\n\n\n\n\n\n","category":"method"},{"location":"AbstractAlgebra/matrix/","page":"Matrix functionality","title":"Matrix functionality","text":"Base.map!(f, ::MatrixElem{S}, ::MatrixElem{T}) where {S <: RingElement, T <: RingElement}","category":"page"},{"location":"AbstractAlgebra/matrix/#map!-Union{Tuple{T}, Tuple{S}, Tuple{Any, MatrixElem{S}, MatrixElem{T}}} where {S<:RingElement, T<:RingElement}","page":"Matrix functionality","title":"map!","text":"map!(f, dst::MatrixElem{T}, src::MatrixElem{U}) where {T <: NCRingElement, U <: NCRingElement}\n\nLike map, but stores the result in dst rather than a new matrix. This is equivalent to map_entries!(f, dst, src).\n\n\n\n\n\n","category":"method"},{"location":"AbstractAlgebra/matrix/","page":"Matrix functionality","title":"Matrix functionality","text":"Examples","category":"page"},{"location":"AbstractAlgebra/matrix/","page":"Matrix functionality","title":"Matrix functionality","text":"julia> R, t = polynomial_ring(QQ, :t)\n(Univariate polynomial ring in t over rationals, t)\n\njulia> S = matrix_space(R, 3, 3)\nMatrix space of 3 rows and 3 columns\n  over univariate polynomial ring in t over rationals\n\njulia> A = S([t + 1 t R(1); t^2 t t; R(-2) t + 2 t^2 + t + 1])\n[t + 1       t             1]\n[  t^2       t             t]\n[   -2   t + 2   t^2 + t + 1]\n\njulia> B = S([R(2) R(3) R(1); t t + 1 t + 2; R(-1) t^2 t^3])\n[ 2       3       1]\n[ t   t + 1   t + 2]\n[-1     t^2     t^3]\n\njulia> T = dense_matrix_type(R)\nAbstractAlgebra.Generic.MatSpaceElem{AbstractAlgebra.Generic.Poly{Rational{BigInt}}}\n\njulia> r = number_of_rows(B)\n3\n\njulia> c = number_of_columns(B)\n3\n\njulia> length(B)\n9\n\njulia> isempty(B)\nfalse\n\njulia> M = A + B\n[  t + 3         t + 3                   2]\n[t^2 + t       2*t + 1             2*t + 2]\n[     -3   t^2 + t + 2   t^3 + t^2 + t + 1]\n\njulia> N = 2 + A\n[t + 3       t             1]\n[  t^2   t + 2             t]\n[   -2   t + 2   t^2 + t + 3]\n\njulia> M1 = deepcopy(A)\n[t + 1       t             1]\n[  t^2       t             t]\n[   -2   t + 2   t^2 + t + 1]\n\njulia> A != B\ntrue\n\njulia> isone(one(S))\ntrue\n\njulia> V = A[1:2, :]\n[t + 1   t   1]\n[  t^2   t   t]\n\njulia> W = A^3\n[    3*t^4 + 4*t^3 + t^2 - 3*t - 5            t^4 + 5*t^3 + 10*t^2 + 7*t + 4                 2*t^4 + 7*t^3 + 9*t^2 + 8*t + 1]\n[t^5 + 4*t^4 + 3*t^3 - 7*t^2 - 4*t               4*t^4 + 8*t^3 + 7*t^2 + 2*t                 t^5 + 5*t^4 + 9*t^3 + 7*t^2 - t]\n[  t^5 + 3*t^4 - 10*t^2 - 16*t - 2   t^5 + 6*t^4 + 12*t^3 + 11*t^2 + 5*t - 2   t^6 + 3*t^5 + 8*t^4 + 15*t^3 + 10*t^2 + t - 5]\n\njulia> Z = divexact(2*A, 2)\n[t + 1       t             1]\n[  t^2       t             t]\n[   -2   t + 2   t^2 + t + 1]\n\njulia> M = matrix(ZZ, BigInt[2 3 0; 1 1 1])\n[2   3   0]\n[1   1   1]\n\njulia> M[1, 2] = BigInt(4)\n4\n\njulia> c = M[1, 1]\n2\n","category":"page"},{"location":"AbstractAlgebra/matrix/#Transpose","page":"Matrix functionality","title":"Transpose","text":"","category":"section"},{"location":"AbstractAlgebra/matrix/","page":"Matrix functionality","title":"Matrix functionality","text":"transpose(::MatrixElem{T}) where T <: RingElement","category":"page"},{"location":"AbstractAlgebra/matrix/#transpose-Union{Tuple{MatrixElem{T}}, Tuple{T}} where T<:RingElement","page":"Matrix functionality","title":"transpose","text":"transpose(x::MatrixElem{T}) where T <: NCRingElement\n\nReturn the transpose of the given matrix.\n\nExamples\n\njulia> R, t = polynomial_ring(QQ, :t)\n(Univariate polynomial ring in t over rationals, t)\n\njulia> S = matrix_space(R, 3, 3)\nMatrix space of 3 rows and 3 columns\n  over univariate polynomial ring in t over rationals\n\njulia> A = S([t + 1 t R(1); t^2 t t; R(-2) t + 2 t^2 + t + 1])\n[t + 1       t             1]\n[  t^2       t             t]\n[   -2   t + 2   t^2 + t + 1]\n\njulia> B = transpose(A)\n[t + 1   t^2            -2]\n[    t     t         t + 2]\n[    1     t   t^2 + t + 1]\n\n\n\n\n\n\ntranspose(A::SMat) -> SMat\n\nReturns the transpose of A.\n\n\n\n\n\n","category":"method"},{"location":"AbstractAlgebra/matrix/#Submatrices","page":"Matrix functionality","title":"Submatrices","text":"","category":"section"},{"location":"AbstractAlgebra/matrix/","page":"Matrix functionality","title":"Matrix functionality","text":"Submatrices are only available for matrix spaces, not for matrix algebras and generally only available for generic matrices built on Julia arrays.","category":"page"},{"location":"AbstractAlgebra/matrix/","page":"Matrix functionality","title":"Matrix functionality","text":"Submatrices return a new matrix with the same entries as the submatrix with the given range of rows and columns. They are best illustrated with examples.","category":"page"},{"location":"AbstractAlgebra/matrix/","page":"Matrix functionality","title":"Matrix functionality","text":"Examples","category":"page"},{"location":"AbstractAlgebra/matrix/","page":"Matrix functionality","title":"Matrix functionality","text":"julia> M = matrix(ZZ, BigInt[1 2 3; 2 3 4; 3 4 5])\n[1   2   3]\n[2   3   4]\n[3   4   5]\n\njulia> N1 = M[1:2, :]\n[1   2   3]\n[2   3   4]\n\njulia> N2 = M[:, :]\n[1   2   3]\n[2   3   4]\n[3   4   5]\n\njulia> N3 = M[2:3, 2:3]\n[3   4]\n[4   5]\n","category":"page"},{"location":"AbstractAlgebra/matrix/#Elementary-row-and-column-operations","page":"Matrix functionality","title":"Elementary row and column operations","text":"","category":"section"},{"location":"AbstractAlgebra/matrix/","page":"Matrix functionality","title":"Matrix functionality","text":"add_column(::MatElem{T}, ::Int, ::Int, ::Int) where T <: RingElement\nadd_column!(::MatElem{T}, ::Int, ::Int, ::Int) where T <: RingElement\nadd_row(::MatElem{T}, ::Int, ::Int, ::Int) where T <: RingElement\nadd_row!(::MatElem{T}, ::Int, ::Int, ::Int) where T <: RingElement\nmultiply_column(::MatElem{T}, ::Int, ::Int) where T <: RingElement\nmultiply_column!(::MatElem{T}, ::Int, ::Int) where T <: RingElement\nmultiply_row(::MatElem{T}, ::Int, ::Int) where T <: RingElement\nmultiply_row!(::MatElem{T}, ::Int, ::Int) where T <: RingElement\n","category":"page"},{"location":"AbstractAlgebra/matrix/#add_column-Union{Tuple{T}, Tuple{MatElem{T}, Int64, Int64, Int64}} where T<:RingElement","page":"Matrix functionality","title":"add_column","text":"add_column(a::MatrixElem{T}, s::RingElement, i::Int, j::Int, rows = 1:nrows(a)) where T <: RingElement\n\nCreate a copy of a and add s times the i-th row to the j-th row of a.\n\nBy default, the transformation is applied to all rows of a. This can be changed using the optional rows argument.\n\n\n\n\n\n","category":"method"},{"location":"AbstractAlgebra/matrix/#add_column!-Union{Tuple{T}, Tuple{MatElem{T}, Int64, Int64, Int64}} where T<:RingElement","page":"Matrix functionality","title":"add_column!","text":"add_column!(a::MatrixElem{T}, s::RingElement, i::Int, j::Int, rows = 1:nrows(a)) where T <: RingElement\n\nAdd s times the i-th row to the j-th row of a.\n\nBy default, the transformation is applied to all rows of a. This can be changed using the optional rows argument.\n\n\n\n\n\n","category":"method"},{"location":"AbstractAlgebra/matrix/#add_row-Union{Tuple{T}, Tuple{MatElem{T}, Int64, Int64, Int64}} where T<:RingElement","page":"Matrix functionality","title":"add_row","text":"add_row(a::MatrixElem{T}, s::RingElement, i::Int, j::Int, cols = 1:ncols(a)) where T <: RingElement\n\nCreate a copy of a and add s times the i-th row to the j-th row of a.\n\nBy default, the transformation is applied to all columns of a. This can be changed using the optional cols argument.\n\n\n\n\n\n","category":"method"},{"location":"AbstractAlgebra/matrix/#add_row!-Union{Tuple{T}, Tuple{MatElem{T}, Int64, Int64, Int64}} where T<:RingElement","page":"Matrix functionality","title":"add_row!","text":"add_row!(a::MatrixElem{T}, s::RingElement, i::Int, j::Int, cols = 1:ncols(a)) where T <: RingElement\n\nAdd s times the i-th row to the j-th row of a.\n\nBy default, the transformation is applied to all columns of a. This can be changed using the optional cols argument.\n\n\n\n\n\n","category":"method"},{"location":"AbstractAlgebra/matrix/#multiply_column-Union{Tuple{T}, Tuple{MatElem{T}, Int64, Int64}} where T<:RingElement","page":"Matrix functionality","title":"multiply_column","text":"multiply_column(a::MatrixElem{T}, s::RingElement, i::Int, rows = 1:nrows(a)) where T <: RingElement\n\nCreate a copy of a and multiply the ith column of a with s.\n\nBy default, the transformation is applied to all rows of a. This can be changed using the optional rows argument.\n\n\n\n\n\n","category":"method"},{"location":"AbstractAlgebra/matrix/#multiply_column!-Union{Tuple{T}, Tuple{MatElem{T}, Int64, Int64}} where T<:RingElement","page":"Matrix functionality","title":"multiply_column!","text":"multiply_column!(a::MatrixElem{T}, s::RingElement, i::Int, rows = 1:nrows(a)) where T <: RingElement\n\nMultiply the ith column of a with s.\n\nBy default, the transformation is applied to all rows of a. This can be changed using the optional rows argument.\n\n\n\n\n\n","category":"method"},{"location":"AbstractAlgebra/matrix/#multiply_row-Union{Tuple{T}, Tuple{MatElem{T}, Int64, Int64}} where T<:RingElement","page":"Matrix functionality","title":"multiply_row","text":"multiply_row(a::MatrixElem{T}, s::RingElement, i::Int, cols = 1:ncols(a)) where T <: RingElement\n\nCreate a copy of a and multiply  the ith row of a with s.\n\nBy default, the transformation is applied to all columns of a. This can be changed using the optional cols argument.\n\n\n\n\n\n","category":"method"},{"location":"AbstractAlgebra/matrix/#multiply_row!-Union{Tuple{T}, Tuple{MatElem{T}, Int64, Int64}} where T<:RingElement","page":"Matrix functionality","title":"multiply_row!","text":"multiply_row!(a::MatrixElem{T}, s::RingElement, i::Int, cols = 1:ncols(a)) where T <: RingElement\n\nMultiply the ith row of a with s.\n\nBy default, the transformation is applied to all columns of a. This can be changed using the optional cols argument.\n\n\n\n\n\n","category":"method"},{"location":"AbstractAlgebra/matrix/","page":"Matrix functionality","title":"Matrix functionality","text":"Examples","category":"page"},{"location":"AbstractAlgebra/matrix/","page":"Matrix functionality","title":"Matrix functionality","text":"julia> M = ZZ[1 2 3; 2 3 4; 4 5 5]\n[1   2   3]\n[2   3   4]\n[4   5   5]\n\njulia> add_column(M, 2, 3, 1)\n[ 7   2   3]\n[10   3   4]\n[14   5   5]\n\njulia> add_row(M, 1, 2, 3)\n[1   2   3]\n[2   3   4]\n[6   8   9]\n\njulia> multiply_column(M, 2, 3)\n[1   2    6]\n[2   3    8]\n[4   5   10]\n\njulia> multiply_row(M, 2, 3)\n[1    2    3]\n[2    3    4]\n[8   10   10]","category":"page"},{"location":"AbstractAlgebra/matrix/#Swapping-rows-and-columns","page":"Matrix functionality","title":"Swapping rows and columns","text":"","category":"section"},{"location":"AbstractAlgebra/matrix/","page":"Matrix functionality","title":"Matrix functionality","text":"swap_rows(a::MatrixElem{T}, i::Int, j::Int) where T <: RingElement\nswap_rows!(a::MatrixElem{T}, i::Int, j::Int) where T <: RingElement\nswap_cols(a::MatrixElem{T}, i::Int, j::Int) where T <: RingElement\nswap_cols!(a::MatrixElem{T}, i::Int, j::Int) where T <: RingElement","category":"page"},{"location":"AbstractAlgebra/matrix/#swap_rows-Union{Tuple{T}, Tuple{MatrixElem{T}, Int64, Int64}} where T<:RingElement","page":"Matrix functionality","title":"swap_rows","text":"swap_rows(a::MatrixElem{T}, i::Int, j::Int) where T <: NCRingElement\n\nReturn a matrix b with the entries of a, where the ith and jth row are swapped.\n\nExamples\n\njulia> M = identity_matrix(ZZ, 3)\n[1   0   0]\n[0   1   0]\n[0   0   1]\n\njulia> swap_rows(M, 1, 2)\n[0   1   0]\n[1   0   0]\n[0   0   1]\n\njulia> M  # was not modified\n[1   0   0]\n[0   1   0]\n[0   0   1]\n\n\n\n\n\n","category":"method"},{"location":"AbstractAlgebra/matrix/#swap_rows!-Union{Tuple{T}, Tuple{MatrixElem{T}, Int64, Int64}} where T<:RingElement","page":"Matrix functionality","title":"swap_rows!","text":"swap_rows!(a::MatrixElem{T}, i::Int, j::Int) where T <: NCRingElement\n\nSwap the ith and jth row of a in place. The function returns the mutated matrix (since matrices are assumed to be mutable in AbstractAlgebra.jl).\n\nExamples\n\njulia> M = identity_matrix(ZZ, 3)\n[1   0   0]\n[0   1   0]\n[0   0   1]\n\njulia> swap_rows!(M, 1, 2)\n[0   1   0]\n[1   0   0]\n[0   0   1]\n\njulia> M  # was modified\n[0   1   0]\n[1   0   0]\n[0   0   1]\n\n\n\n\n\n","category":"method"},{"location":"AbstractAlgebra/matrix/#swap_cols-Union{Tuple{T}, Tuple{MatrixElem{T}, Int64, Int64}} where T<:RingElement","page":"Matrix functionality","title":"swap_cols","text":"swap_cols(a::MatrixElem{T}, i::Int, j::Int) where T <: NCRingElement\n\nReturn a matrix b with the entries of a, where the ith and jth row are swapped.\n\n\n\n\n\n","category":"method"},{"location":"AbstractAlgebra/matrix/#swap_cols!-Union{Tuple{T}, Tuple{MatrixElem{T}, Int64, Int64}} where T<:RingElement","page":"Matrix functionality","title":"swap_cols!","text":"swap_cols!(a::MatrixElem{T}, i::Int, j::Int) where T <: NCRingElement\n\nSwap the ith and jth column of a in place. The function returns the mutated matrix (since matrices are assumed to be mutable in AbstractAlgebra.jl).\n\n\n\n\n\n","category":"method"},{"location":"AbstractAlgebra/matrix/","page":"Matrix functionality","title":"Matrix functionality","text":"Swap the rows of M in place. The function returns the mutated matrix (since matrices are assumed to be mutable in AbstractAlgebra.jl).","category":"page"},{"location":"AbstractAlgebra/matrix/#Concatenation","page":"Matrix functionality","title":"Concatenation","text":"","category":"section"},{"location":"AbstractAlgebra/matrix/","page":"Matrix functionality","title":"Matrix functionality","text":"The following are only available for matrix spaces, not for matrix algebras.","category":"page"},{"location":"AbstractAlgebra/matrix/","page":"Matrix functionality","title":"Matrix functionality","text":"hcat(M::T, N::T) where T <: MatElem","category":"page"},{"location":"AbstractAlgebra/matrix/","page":"Matrix functionality","title":"Matrix functionality","text":"Return the horizontal concatenation of M and N. It is assumed that the number of rows of M and N are the same.","category":"page"},{"location":"AbstractAlgebra/matrix/","page":"Matrix functionality","title":"Matrix functionality","text":"vcat(M::T, N::T) where T <: MatElem","category":"page"},{"location":"AbstractAlgebra/matrix/","page":"Matrix functionality","title":"Matrix functionality","text":"Return the vertical concatenation of M and N. It is assumed that the number of columns of M and N are the same.","category":"page"},{"location":"AbstractAlgebra/matrix/","page":"Matrix functionality","title":"Matrix functionality","text":"Examples","category":"page"},{"location":"AbstractAlgebra/matrix/","page":"Matrix functionality","title":"Matrix functionality","text":"julia> M = matrix(ZZ, BigInt[1 2 3; 2 3 4; 3 4 5])\n[1   2   3]\n[2   3   4]\n[3   4   5]\n\njulia> N = matrix(ZZ, BigInt[1 0 1; 0 1 0; 1 0 1])\n[1   0   1]\n[0   1   0]\n[1   0   1]\n\njulia> P = hcat(M, N)\n[1   2   3   1   0   1]\n[2   3   4   0   1   0]\n[3   4   5   1   0   1]\n\njulia> Q = vcat(M, N)\n[1   2   3]\n[2   3   4]\n[3   4   5]\n[1   0   1]\n[0   1   0]\n[1   0   1]\n","category":"page"},{"location":"AbstractAlgebra/matrix/#Similar-and-zero","page":"Matrix functionality","title":"Similar and zero","text":"","category":"section"},{"location":"AbstractAlgebra/matrix/","page":"Matrix functionality","title":"Matrix functionality","text":"Both similar and zero construct new matrices, but the entries are either undefined with similar or zero-initialized with zero.","category":"page"},{"location":"AbstractAlgebra/matrix/","page":"Matrix functionality","title":"Matrix functionality","text":"similar(x::MatElem, R::Ring=base_ring(x))\nzero(x::MatElem, R::Ring=base_ring(x))","category":"page"},{"location":"AbstractAlgebra/matrix/","page":"Matrix functionality","title":"Matrix functionality","text":"Construct the matrix with the same dimensions as the given matrix, and the same base ring unless explicitly specified.","category":"page"},{"location":"AbstractAlgebra/matrix/","page":"Matrix functionality","title":"Matrix functionality","text":"similar(x::MatElem, R::Ring, r::Int, c::Int)\nsimilar(x::MatElem, r::Int, c::Int)\nzero(x::MatElem, R::Ring, r::Int, c::Int)\nzero(x::MatElem, r::Int, c::Int)","category":"page"},{"location":"AbstractAlgebra/matrix/","page":"Matrix functionality","title":"Matrix functionality","text":"Construct the rtimes c matrix with R as base ring (which defaults to the base ring of the the given matrix). If x belongs to a matrix algebra and r neq c, an exception is raised, and it's also possible to specify only one Int as the order (e.g. similar(x, n)).","category":"page"},{"location":"AbstractAlgebra/matrix/","page":"Matrix functionality","title":"Matrix functionality","text":"Base.isassigned(M::MatElem, i, j)","category":"page"},{"location":"AbstractAlgebra/matrix/","page":"Matrix functionality","title":"Matrix functionality","text":"Test whether the given matrix has a value associated with indices i and j.","category":"page"},{"location":"AbstractAlgebra/matrix/","page":"Matrix functionality","title":"Matrix functionality","text":"Examples","category":"page"},{"location":"AbstractAlgebra/matrix/","page":"Matrix functionality","title":"Matrix functionality","text":"julia> M = matrix(ZZ, BigInt[3 1 2; 2 0 1])\n[3   1   2]\n[2   0   1]\n\njulia> isassigned(M, 1, 2)\ntrue\n\njulia> isassigned(M, 4, 4)\nfalse\n\njulia> A = similar(M)\n[#undef   #undef   #undef]\n[#undef   #undef   #undef]\n\njulia> isassigned(A, 1, 2)\nfalse\n\njulia> B = zero(M)\n[0   0   0]\n[0   0   0]\n\njulia> C = similar(M, 4, 5)\n[#undef   #undef   #undef   #undef   #undef]\n[#undef   #undef   #undef   #undef   #undef]\n[#undef   #undef   #undef   #undef   #undef]\n[#undef   #undef   #undef   #undef   #undef]\n\njulia> base_ring(B)\nIntegers\n\njulia> D = zero(M, QQ, 2, 2)\n[0//1   0//1]\n[0//1   0//1]\n\njulia> base_ring(D)\nRationals","category":"page"},{"location":"AbstractAlgebra/matrix/#Symmetry-testing","page":"Matrix functionality","title":"Symmetry testing","text":"","category":"section"},{"location":"AbstractAlgebra/matrix/","page":"Matrix functionality","title":"Matrix functionality","text":"is_symmetric(::MatrixElem)","category":"page"},{"location":"AbstractAlgebra/matrix/#is_symmetric-Tuple{MatrixElem}","page":"Matrix functionality","title":"is_symmetric","text":"is_symmetric(M::MatrixElem)\n\nReturn true if the given matrix is symmetric with respect to its main diagonal, i.e., transpose(M) == M, otherwise return false.\n\nAlias for LinearAlgebra.issymmetric.\n\nExamples\n\njulia> M = matrix(ZZ, [1 2 3; 2 4 5; 3 5 6])\n[1   2   3]\n[2   4   5]\n[3   5   6]\n\njulia> is_symmetric(M)\ntrue\n\njulia> N = matrix(ZZ, [1 2 3; 4 5 6; 7 8 9])\n[1   2   3]\n[4   5   6]\n[7   8   9]\n\njulia> is_symmetric(N)\nfalse\n\n\n\n\n\n","category":"method"},{"location":"AbstractAlgebra/matrix/","page":"Matrix functionality","title":"Matrix functionality","text":"is_skew_symmetric(::MatrixElem)","category":"page"},{"location":"AbstractAlgebra/matrix/#is_skew_symmetric-Tuple{MatrixElem}","page":"Matrix functionality","title":"is_skew_symmetric","text":"is_skew_symmetric(M::MatrixElem)\n\nReturn true if the given matrix is skew symmetric with respect to its main diagonal, i.e., transpose(M) == -M, otherwise return false.\n\nExamples\n\njulia> M = matrix(ZZ, [0 -1 -2; 1 0 -3; 2 3 0])\n[0   -1   -2]\n[1    0   -3]\n[2    3    0]\n\njulia> is_skew_symmetric(M)\ntrue\n\n\n\n\n\n\n","category":"method"},{"location":"AbstractAlgebra/matrix/#Powering","page":"Matrix functionality","title":"Powering","text":"","category":"section"},{"location":"AbstractAlgebra/matrix/","page":"Matrix functionality","title":"Matrix functionality","text":"powers(::MatElem, ::Int)","category":"page"},{"location":"AbstractAlgebra/matrix/#powers-Tuple{MatElem, Int64}","page":"Matrix functionality","title":"powers","text":"powers(a::Union{NCRingElement, MatElem}, d::Int)\n\nReturn an array M of \"powers\" of a where Mi + 1 = a^i for i = 0d.\n\nExamples\n\njulia> M = ZZ[1 2 3; 2 3 4; 4 5 5]\n[1   2   3]\n[2   3   4]\n[4   5   5]\n\njulia> A = powers(M, 4)\n5-element Vector{AbstractAlgebra.Generic.MatSpaceElem{BigInt}}:\n [1 0 0; 0 1 0; 0 0 1]\n [1 2 3; 2 3 4; 4 5 5]\n [17 23 26; 24 33 38; 34 48 57]\n [167 233 273; 242 337 394; 358 497 579]\n [1725 2398 2798; 2492 3465 4044; 3668 5102 5957]\n\n\n\n\n\n\n","category":"method"},{"location":"AbstractAlgebra/matrix/#Gram-matrix","page":"Matrix functionality","title":"Gram matrix","text":"","category":"section"},{"location":"AbstractAlgebra/matrix/","page":"Matrix functionality","title":"Matrix functionality","text":"gram(::MatElem)","category":"page"},{"location":"AbstractAlgebra/matrix/#gram-Tuple{MatElem}","page":"Matrix functionality","title":"gram","text":"gram(x::MatElem)\n\nReturn the Gram matrix of x, i.e. if x is an rtimes c matrix return the rtimes r matrix whose entries i j are the dot products of the i-th and j-th rows, respectively.\n\nExamples\n\njulia> R, t = polynomial_ring(QQ, :t)\n(Univariate polynomial ring in t over rationals, t)\n\njulia> S = matrix_space(R, 3, 3)\nMatrix space of 3 rows and 3 columns\n  over univariate polynomial ring in t over rationals\n\njulia> A = S([t + 1 t R(1); t^2 t t; R(-2) t + 2 t^2 + t + 1])\n[t + 1       t             1]\n[  t^2       t             t]\n[   -2   t + 2   t^2 + t + 1]\n\njulia> B = gram(A)\n[2*t^2 + 2*t + 2   t^3 + 2*t^2 + t                   2*t^2 + t - 1]\n[t^3 + 2*t^2 + t       t^4 + 2*t^2                       t^3 + 3*t]\n[  2*t^2 + t - 1         t^3 + 3*t   t^4 + 2*t^3 + 4*t^2 + 6*t + 9]\n\n\n\n\n\n\n","category":"method"},{"location":"AbstractAlgebra/matrix/#Trace","page":"Matrix functionality","title":"Trace","text":"","category":"section"},{"location":"AbstractAlgebra/matrix/","page":"Matrix functionality","title":"Matrix functionality","text":"tr(::MatElem{T}) where T <: RingElement","category":"page"},{"location":"AbstractAlgebra/matrix/#tr-Union{Tuple{MatElem{T}}, Tuple{T}} where T<:RingElement","page":"Matrix functionality","title":"tr","text":"tr(x::MatrixElem{T}) where T <: NCRingElement\n\nReturn the trace of the matrix a, i.e. the sum of the diagonal elements. We require the matrix to be square.\n\nExamples\n\njulia> R, t = polynomial_ring(QQ, :t)\n(Univariate polynomial ring in t over rationals, t)\n\njulia> S = matrix_space(R, 3, 3)\nMatrix space of 3 rows and 3 columns\n  over univariate polynomial ring in t over rationals\n\njulia> A = S([t + 1 t R(1); t^2 t t; R(-2) t + 2 t^2 + t + 1])\n[t + 1       t             1]\n[  t^2       t             t]\n[   -2   t + 2   t^2 + t + 1]\n\njulia> b = tr(A)\nt^2 + 3*t + 2\n\n\n\n\n\n\ntr(x::AbstractAssociativeAlgebraElem{T}) where T -> T\n\nReturns the trace of x.\n\n\n\n\n\n","category":"method"},{"location":"AbstractAlgebra/matrix/#Content","page":"Matrix functionality","title":"Content","text":"","category":"section"},{"location":"AbstractAlgebra/matrix/","page":"Matrix functionality","title":"Matrix functionality","text":"content(::MatElem{T}) where T <: RingElement","category":"page"},{"location":"AbstractAlgebra/matrix/#content-Union{Tuple{MatElem{T}}, Tuple{T}} where T<:RingElement","page":"Matrix functionality","title":"content","text":"content(x::MatrixElem{T}) where T <: RingElement\n\nReturn the content of the matrix a, i.e. the greatest common divisor of all its entries, assuming it exists.\n\nExamples\n\njulia> R, t = polynomial_ring(QQ, :t)\n(Univariate polynomial ring in t over rationals, t)\n\njulia> S = matrix_space(R, 3, 3)\nMatrix space of 3 rows and 3 columns\n  over univariate polynomial ring in t over rationals\n\njulia> A = S([t + 1 t R(1); t^2 t t; R(-2) t + 2 t^2 + t + 1])\n[t + 1       t             1]\n[  t^2       t             t]\n[   -2   t + 2   t^2 + t + 1]\n\njulia> b = content(A)\n1\n\n\n\n\n\n\n","category":"method"},{"location":"AbstractAlgebra/matrix/#Permutation","page":"Matrix functionality","title":"Permutation","text":"","category":"section"},{"location":"AbstractAlgebra/matrix/","page":"Matrix functionality","title":"Matrix functionality","text":"*(::Perm, ::MatElem{T}) where T <: RingElement","category":"page"},{"location":"AbstractAlgebra/matrix/#*-Union{Tuple{T}, Tuple{Perm, MatElem{T}}} where T<:RingElement","page":"Matrix functionality","title":"*","text":"*(P::Perm, x::MatrixElem{T}) where T <: NCRingElement\n\nApply the pemutation P to the rows of the matrix x and return the result.\n\nExamples\n\njulia> R, t = polynomial_ring(QQ, :t)\n(Univariate polynomial ring in t over rationals, t)\n\njulia> S = matrix_space(R, 3, 3)\nMatrix space of 3 rows and 3 columns\n  over univariate polynomial ring in t over rationals\n\njulia> G = SymmetricGroup(3)\nFull symmetric group over 3 elements\n\njulia> A = S([t + 1 t R(1); t^2 t t; R(-2) t + 2 t^2 + t + 1])\n[t + 1       t             1]\n[  t^2       t             t]\n[   -2   t + 2   t^2 + t + 1]\n\njulia> P = G([1, 3, 2])\n(2,3)\n\njulia> B = P*A\n[t + 1       t             1]\n[   -2   t + 2   t^2 + t + 1]\n[  t^2       t             t]\n\n\n\n\n\n\n","category":"method"},{"location":"AbstractAlgebra/matrix/#LU-factorisation","page":"Matrix functionality","title":"LU factorisation","text":"","category":"section"},{"location":"AbstractAlgebra/matrix/","page":"Matrix functionality","title":"Matrix functionality","text":"lu{T <: FieldElem}(::MatElem{T}, ::SymmetricGroup)","category":"page"},{"location":"AbstractAlgebra/matrix/#lu-Union{Tuple{T}, Tuple{MatElem{T}, AbstractAlgebra.SymmetricGroup}} where T<:FieldElem","page":"Matrix functionality","title":"lu","text":"lu(A::MatrixElem{T}, P = SymmetricGroup(nrows(A))) where {T <: FieldElement}\n\nReturn a tuple r p L U consisting of the rank of A, a permutation p of A belonging to P, a lower triangular matrix L and an upper triangular matrix U such that p(A) = LU, where p(A) stands for the matrix whose rows are the given permutation p of the rows of A.\n\n\n\n\n\n","category":"method"},{"location":"AbstractAlgebra/matrix/","page":"Matrix functionality","title":"Matrix functionality","text":"fflu{T <: RingElem}(::MatElem{T}, ::SymmetricGroup)","category":"page"},{"location":"AbstractAlgebra/matrix/#fflu-Union{Tuple{T}, Tuple{MatElem{T}, AbstractAlgebra.SymmetricGroup}} where T<:RingElem","page":"Matrix functionality","title":"fflu","text":"fflu(A::MatrixElem{T}, P = SymmetricGroup(nrows(A))) where {T <: RingElement}\n\nReturn a tuple r d p L U consisting of the rank of A, a denominator d, a permutation p of A belonging to P, a lower triangular matrix L and an upper triangular matrix U such that p(A) = LDU, where p(A) stands for the matrix whose rows are the given permutation p of the rows of A and such that D is the diagonal matrix diag(p_1 p_1p_2 ldots p_n-2p_n-1 p_n-1p_n) where the p_i are the inverses of the diagonal entries of L. The denominator d is set to pm mathrmdet(S) where S is an appropriate submatrix of A (S = A if A is square and nonsingular) and the sign is decided by the parity of the permutation.\n\n\n\n\n\n","category":"method"},{"location":"AbstractAlgebra/matrix/","page":"Matrix functionality","title":"Matrix functionality","text":"Examples","category":"page"},{"location":"AbstractAlgebra/matrix/","page":"Matrix functionality","title":"Matrix functionality","text":"julia> R, x = polynomial_ring(QQ, :x)\n(Univariate polynomial ring in x over rationals, x)\n\njulia> K, = residue_field(R, x^3 + 3x + 1); a = K(x);\n\njulia> S = matrix_space(K, 3, 3)\nMatrix space of 3 rows and 3 columns\n  over residue field of R modulo x^3 + 3*x + 1\n\njulia> A = S([K(0) 2a + 3 a^2 + 1; a^2 - 2 a - 1 2a; a^2 - 2 a - 1 2a])\n[      0   2*x + 3   x^2 + 1]\n[x^2 - 2     x - 1       2*x]\n[x^2 - 2     x - 1       2*x]\n\njulia> r, P, L, U = lu(A)\n(2, (1,2), [1 0 0; 0 1 0; 1 0 1], [x^2-2 x-1 2*x; 0 2*x+3 x^2+1; 0 0 0])\n\njulia> r, d, P, L, U = fflu(A)\n(2, 3*x^2 - 10*x - 8, (1,2), [x^2-2 0 0; 0 3*x^2-10*x-8 0; x^2-2 0 1], [x^2-2 x-1 2*x; 0 3*x^2-10*x-8 -4*x^2-x-2; 0 0 0])\n","category":"page"},{"location":"AbstractAlgebra/matrix/#Reduced-row-echelon-form","page":"Matrix functionality","title":"Reduced row-echelon form","text":"","category":"section"},{"location":"AbstractAlgebra/matrix/","page":"Matrix functionality","title":"Matrix functionality","text":"rref_rational{T <: RingElem}(::MatElem{T})\nrref{T <: FieldElem}(::MatElem{T})","category":"page"},{"location":"AbstractAlgebra/matrix/#rref_rational-Union{Tuple{MatElem{T}}, Tuple{T}} where T<:RingElem","page":"Matrix functionality","title":"rref_rational","text":"rref_rational(M::MatrixElem{T}) where {T <: RingElement}\n\nReturn a tuple (r A d) consisting of the rank r of M and a denominator d in the base ring of M and a matrix A such that Ad is the reduced row echelon form of M. Note that the denominator is not usually minimal.\n\n\n\n\n\n","category":"method"},{"location":"AbstractAlgebra/matrix/#rref-Union{Tuple{MatElem{T}}, Tuple{T}} where T<:FieldElem","page":"Matrix functionality","title":"rref","text":"rref(M::MatrixElem{T}) where {T <: FieldElement}\n\nReturn a tuple (r A) consisting of the rank r of M and a reduced row echelon form A of M.\n\n\n\n\n\n","category":"method"},{"location":"AbstractAlgebra/matrix/","page":"Matrix functionality","title":"Matrix functionality","text":"is_rref{T <: RingElem}(::MatElem{T})\nis_rref{T <: FieldElem}(::MatElem{T})","category":"page"},{"location":"AbstractAlgebra/matrix/#is_rref-Union{Tuple{MatElem{T}}, Tuple{T}} where T<:RingElem","page":"Matrix functionality","title":"is_rref","text":"is_rref(M::MatrixElem{T}) where {T <: RingElement}\n\nReturn true if M is in reduced row echelon form, otherwise return false.\n\n\n\n\n\n","category":"method"},{"location":"AbstractAlgebra/matrix/#is_rref-Union{Tuple{MatElem{T}}, Tuple{T}} where T<:FieldElem","page":"Matrix functionality","title":"is_rref","text":"is_rref(M::MatrixElem{T}) where {T <: RingElement}\n\nReturn true if M is in reduced row echelon form, otherwise return false.\n\n\n\n\n\nis_rref(M::MatrixElem{T}) where {T <: FieldElement}\n\nReturn true if M is in reduced row echelon form, otherwise return false.\n\n\n\n\n\n","category":"method"},{"location":"AbstractAlgebra/matrix/","page":"Matrix functionality","title":"Matrix functionality","text":"Examples","category":"page"},{"location":"AbstractAlgebra/matrix/","page":"Matrix functionality","title":"Matrix functionality","text":"julia> R, x = polynomial_ring(QQ, :x)\n(Univariate polynomial ring in x over rationals, x)\n\njulia> K, = residue_field(R, x^3 + 3x + 1); a = K(x);\n\njulia> S = matrix_space(K, 3, 3)\nMatrix space of 3 rows and 3 columns\n  over residue field of R modulo x^3 + 3*x + 1\n\njulia> M = S([K(0) 2a + 3 a^2 + 1; a^2 - 2 a - 1 2a; a^2 + 3a + 1 2a K(1)])\n[            0   2*x + 3   x^2 + 1]\n[      x^2 - 2     x - 1       2*x]\n[x^2 + 3*x + 1       2*x         1]\n\njulia> r, A = rref(M)\n(3, [1 0 0; 0 1 0; 0 0 1])\n\njulia> is_rref(A)\ntrue\n\njulia> R, x = polynomial_ring(ZZ, :x)\n(Univariate polynomial ring in x over integers, x)\n\njulia> S = matrix_space(R, 3, 3)\nMatrix space of 3 rows and 3 columns\n  over univariate polynomial ring in x over integers\n\njulia> M = S([R(0) 2x + 3 x^2 + 1; x^2 - 2 x - 1 2x; x^2 + 3x + 1 2x R(1)])\n[            0   2*x + 3   x^2 + 1]\n[      x^2 - 2     x - 1       2*x]\n[x^2 + 3*x + 1       2*x         1]\n\njulia> r, A, d = rref_rational(M)\n(3, [-x^5-2*x^4-15*x^3-18*x^2-8*x-7 0 0; 0 -x^5-2*x^4-15*x^3-18*x^2-8*x-7 0; 0 0 -x^5-2*x^4-15*x^3-18*x^2-8*x-7], -x^5 - 2*x^4 - 15*x^3 - 18*x^2 - 8*x - 7)\n\njulia> is_rref(A)\ntrue","category":"page"},{"location":"AbstractAlgebra/matrix/#Determinant","page":"Matrix functionality","title":"Determinant","text":"","category":"section"},{"location":"AbstractAlgebra/matrix/","page":"Matrix functionality","title":"Matrix functionality","text":"det{T <: RingElem}(::MatElem{T})","category":"page"},{"location":"AbstractAlgebra/matrix/#det-Union{Tuple{MatElem{T}}, Tuple{T}} where T<:RingElem","page":"Matrix functionality","title":"det","text":"det(M::MatrixElem{T}) where {T <: RingElement}\n\nReturn the determinant of the matrix M. We assume M is square.\n\nExamples\n\njulia> R, x = polynomial_ring(QQ, :x)\n(Univariate polynomial ring in x over rationals, x)\n\njulia> A = R[x 1; 1 x^2];\n\njulia> d = det(A)\nx^3 - 1\n\n\n\n\n\n","category":"method"},{"location":"AbstractAlgebra/matrix/#Rank","page":"Matrix functionality","title":"Rank","text":"","category":"section"},{"location":"AbstractAlgebra/matrix/","page":"Matrix functionality","title":"Matrix functionality","text":"rank{T <: RingElem}(::MatElem{T})","category":"page"},{"location":"AbstractAlgebra/matrix/#rank-Union{Tuple{MatElem{T}}, Tuple{T}} where T<:RingElem","page":"Matrix functionality","title":"rank","text":"rank(M::MatrixElem{T}) where {T <: RingElement}\n\nReturn the rank of the matrix M.\n\nExamples\n\njulia> A = QQ[1 2; 3 4];\n\njulia> d = rank(A)\n2\n\n\n\n\n\n","category":"method"},{"location":"AbstractAlgebra/matrix/#Nilpotency","page":"Matrix functionality","title":"Nilpotency","text":"","category":"section"},{"location":"AbstractAlgebra/matrix/","page":"Matrix functionality","title":"Matrix functionality","text":"is_nilpotent(::MatrixElem{T}) where {T <: RingElement}","category":"page"},{"location":"AbstractAlgebra/matrix/#is_nilpotent-Union{Tuple{MatrixElem{T}}, Tuple{T}} where T<:RingElement","page":"Matrix functionality","title":"is_nilpotent","text":"is_nilpotent(A::MatrixElem{T}) where {T <: RingElement}\n\nReturn if A is nilpotent, i.e. if there exists a natural number k such that A^k = 0. If A is not square an exception is raised.\n\n\n\n\n\n","category":"method"},{"location":"AbstractAlgebra/matrix/#Minors","page":"Matrix functionality","title":"Minors","text":"","category":"section"},{"location":"AbstractAlgebra/matrix/","page":"Matrix functionality","title":"Matrix functionality","text":"minors(::MatElem, ::Int)","category":"page"},{"location":"AbstractAlgebra/matrix/#minors-Tuple{MatElem, Int64}","page":"Matrix functionality","title":"minors","text":"minors(A::MatElem, k::Int)\n\nReturn an array consisting of the k-minors of A.\n\nExamples\n\njulia> A = ZZ[1 2 3; 4 5 6]\n[1   2   3]\n[4   5   6]\n\njulia> minors(A, 2)\n3-element Vector{BigInt}:\n -3\n -6\n -3\n\n\n\n\n\n\n","category":"method"},{"location":"AbstractAlgebra/matrix/#Exterior-power","page":"Matrix functionality","title":"Exterior power","text":"","category":"section"},{"location":"AbstractAlgebra/matrix/","page":"Matrix functionality","title":"Matrix functionality","text":"exterior_power(::MatElem, ::Int)","category":"page"},{"location":"AbstractAlgebra/matrix/#exterior_power-Tuple{MatElem, Int64}","page":"Matrix functionality","title":"exterior_power","text":"exterior_power(A::MatElem, k::Int) -> MatElem\n\nReturn the k-th exterior power of A.\n\nExamples\n\njulia> A = matrix(ZZ, 3, 3, [1, 2, 3, 4, 5, 6, 7, 8, 9]);\n\njulia> exterior_power(A, 2)\n[-3    -6   -3]\n[-6   -12   -6]\n[-3    -6   -3]\n\n\n\n\n\n","category":"method"},{"location":"AbstractAlgebra/matrix/#Pfaffian","page":"Matrix functionality","title":"Pfaffian","text":"","category":"section"},{"location":"AbstractAlgebra/matrix/","page":"Matrix functionality","title":"Matrix functionality","text":"pfaffian(::MatElem)\npfaffians(::MatElem, ::Int)","category":"page"},{"location":"AbstractAlgebra/matrix/#pfaffian-Tuple{MatElem}","page":"Matrix functionality","title":"pfaffian","text":"pfaffian(M::MatElem)\n\nReturn the Pfaffian of a skew-symmetric matrix M.\n\n\n\n\n\n","category":"method"},{"location":"AbstractAlgebra/matrix/#pfaffians-Tuple{MatElem, Int64}","page":"Matrix functionality","title":"pfaffians","text":"pfaffians(M::MatElem, k::Int)\n\nReturn a vector consisting of the k-Pfaffians of a skew-symmetric matrix M.\n\n\n\n\n\n","category":"method"},{"location":"AbstractAlgebra/matrix/","page":"Matrix functionality","title":"Matrix functionality","text":"Examples","category":"page"},{"location":"AbstractAlgebra/matrix/","page":"Matrix functionality","title":"Matrix functionality","text":"julia> R, x = polynomial_ring(QQ, [\"x$i\" for i in 1:6])\n(Multivariate polynomial ring in 6 variables over rationals, AbstractAlgebra.Generic.MPoly{Rational{BigInt}}[x1, x2, x3, x4, x5, x6])\n\njulia> M = R[0 x[1] x[2] x[3]; -x[1] 0 x[4] x[5]; -x[2] -x[4] 0 x[6]; -x[3] -x[5] -x[6] 0]\n[  0    x1    x2   x3]\n[-x1     0    x4   x5]\n[-x2   -x4     0   x6]\n[-x3   -x5   -x6    0]\n\njulia> pfaffian(M)\nx1*x6 - x2*x5 + x3*x4\n\njulia> pfaffians(M, 2)\n6-element Vector{AbstractAlgebra.Generic.MPoly{Rational{BigInt}}}:\n x1\n x2\n x4\n x3\n x5\n x6\n ","category":"page"},{"location":"AbstractAlgebra/matrix/#Linear-solving","page":"Matrix functionality","title":"Linear solving","text":"","category":"section"},{"location":"AbstractAlgebra/matrix/","page":"Matrix functionality","title":"Matrix functionality","text":"See Linear Solving & Kernel","category":"page"},{"location":"AbstractAlgebra/matrix/#Inverse","page":"Matrix functionality","title":"Inverse","text":"","category":"section"},{"location":"AbstractAlgebra/matrix/","page":"Matrix functionality","title":"Matrix functionality","text":"Base.inv{T <: RingElement}(::MatrixElem{T})","category":"page"},{"location":"AbstractAlgebra/matrix/#inv-Union{Tuple{MatrixElem{T}}, Tuple{T}} where T<:RingElement","page":"Matrix functionality","title":"inv","text":"inv(M::MatrixElem{T}) where {T <: RingElement}\n\nGiven a non-singular ntimes n matrix over a ring, return an ntimes n matrix X such that MX = I_n, where I_n is the ntimes n identity matrix. If M is not invertible over the base ring an exception is raised.\n\n\n\n\n\n","category":"method"},{"location":"AbstractAlgebra/matrix/","page":"Matrix functionality","title":"Matrix functionality","text":"is_invertible_with_inverse{T <: RingElement}(::MatrixElem{T})","category":"page"},{"location":"AbstractAlgebra/matrix/#is_invertible_with_inverse-Union{Tuple{MatrixElem{T}}, Tuple{T}} where T<:RingElement","page":"Matrix functionality","title":"is_invertible_with_inverse","text":"is_invertible_with_inverse(A::MatrixElem{T}; side::Symbol = :left) where {T <: RingElement}\n\nGiven an n times m matrix A over a ring, return a tuple (flag, B). If side is :right and flag is true, B is a right inverse of A i.e. A B is the n times n unit matrix. If side is :left and flag is true, B is a left inverse of A i.e. B A is the m times m unit matrix. If flag is false, no right or left inverse exists.\n\nTo get the space of all inverses, note that if B and C are both right inverses, then A (B - C) = 0, and similar for left inverses. Hence from one inverse one can find all by making suitable use of kernel.\n\n\n\n\n\n","category":"method"},{"location":"AbstractAlgebra/matrix/","page":"Matrix functionality","title":"Matrix functionality","text":"is_invertible{T <: RingElement}(::MatrixElem{T})","category":"page"},{"location":"AbstractAlgebra/matrix/#is_invertible-Union{Tuple{MatrixElem{T}}, Tuple{T}} where T<:RingElement","page":"Matrix functionality","title":"is_invertible","text":"is_invertible(A::MatrixElem{T}) where {T <: RingElement}\n\nReturn true if a given square matrix is invertible, false otherwise. If the inverse should also be computed, use is_invertible_with_inverse.\n\n\n\n\n\n","category":"method"},{"location":"AbstractAlgebra/matrix/","page":"Matrix functionality","title":"Matrix functionality","text":"Examples","category":"page"},{"location":"AbstractAlgebra/matrix/","page":"Matrix functionality","title":"Matrix functionality","text":"julia> R, x = polynomial_ring(QQ, :x)\n(Univariate polynomial ring in x over rationals, x)\n\njulia> K, = residue_field(R, x^3 + 3x + 1); a = K(x);\n\njulia> S = matrix_space(K, 3, 3)\nMatrix space of 3 rows and 3 columns\n  over residue field of R modulo x^3 + 3*x + 1\n\njulia> A = S([K(0) 2a + 3 a^2 + 1; a^2 - 2 a - 1 2a; a^2 + 3a + 1 2a K(1)])\n[            0   2*x + 3   x^2 + 1]\n[      x^2 - 2     x - 1       2*x]\n[x^2 + 3*x + 1       2*x         1]\n\njulia> X = inv(A)\n[-343//7817*x^2 + 717//7817*x - 2072//7817   -4964//23451*x^2 + 2195//23451*x - 11162//23451    -232//23451*x^2 - 4187//23451*x - 1561//23451]\n[ 128//7817*x^2 - 655//7817*x + 2209//7817      599//23451*x^2 - 2027//23451*x - 1327//23451   -1805//23451*x^2 + 2702//23451*x - 7394//23451]\n[ 545//7817*x^2 + 570//7817*x + 2016//7817     -1297//23451*x^2 - 5516//23451*x - 337//23451   8254//23451*x^2 - 2053//23451*x + 16519//23451]\n\njulia> is_invertible(A)\ntrue\n\njulia> is_invertible_with_inverse(A)\n(true, [-343//7817*x^2+717//7817*x-2072//7817 -4964//23451*x^2+2195//23451*x-11162//23451 -232//23451*x^2-4187//23451*x-1561//23451; 128//7817*x^2-655//7817*x+2209//7817 599//23451*x^2-2027//23451*x-1327//23451 -1805//23451*x^2+2702//23451*x-7394//23451; 545//7817*x^2+570//7817*x+2016//7817 -1297//23451*x^2-5516//23451*x-337//23451 8254//23451*x^2-2053//23451*x+16519//23451])\n\njulia> R, x = polynomial_ring(ZZ, :x)\n(Univariate polynomial ring in x over integers, x)\n\njulia> S = matrix_space(R, 3, 3)\nMatrix space of 3 rows and 3 columns\n  over univariate polynomial ring in x over integers\n\njulia> A = S([R(0) 2x + 3 x^2 + 1; x^2 - 2 x - 1 2x; x^2 + 3x + 1 2x R(1)])\n[            0   2*x + 3   x^2 + 1]\n[      x^2 - 2     x - 1       2*x]\n[x^2 + 3*x + 1       2*x         1]\n\njulia> X, d = pseudo_inv(A)\n([4*x^2-x+1 -2*x^3+3 x^3-5*x^2-5*x-1; -2*x^3-5*x^2-2*x-2 x^4+3*x^3+2*x^2+3*x+1 -x^4+x^2+2; -x^3+2*x^2+2*x-1 -2*x^3-9*x^2-11*x-3 2*x^3+3*x^2-4*x-6], -x^5 - 2*x^4 - 15*x^3 - 18*x^2 - 8*x - 7)\n","category":"page"},{"location":"AbstractAlgebra/matrix/#Nullspace","page":"Matrix functionality","title":"Nullspace","text":"","category":"section"},{"location":"AbstractAlgebra/matrix/","page":"Matrix functionality","title":"Matrix functionality","text":"nullspace{T <: FieldElem}(::MatElem{T})","category":"page"},{"location":"AbstractAlgebra/matrix/#nullspace-Union{Tuple{MatElem{T}}, Tuple{T}} where T<:FieldElem","page":"Matrix functionality","title":"nullspace","text":"nullspace(M::MatElem{T}) where {T <: RingElement}\n\nReturn a tuple (nu N) consisting of the nullity nu of M and a basis N (consisting of column vectors) for the right nullspace of M, i.e. such that MN is the zero matrix. If M is an mtimes n matrix N will be an ntimes nu matrix. Note that the nullspace is taken to be the vector space kernel over the fraction field of the base ring if the latter is not a field. In AbstractAlgebra we use the name \"kernel\" for a function to compute an integral kernel.\n\nExamples\n\njulia> R, x = polynomial_ring(ZZ, :x)\n(Univariate polynomial ring in x over integers, x)\n\njulia> S = matrix_space(R, 4, 4)\nMatrix space of 4 rows and 4 columns\n  over univariate polynomial ring in x over integers\n\njulia> M = S([-6*x^2+6*x+12 -12*x^2-21*x-15 -15*x^2+21*x+33 -21*x^2-9*x-9;\n              -8*x^2+8*x+16 -16*x^2+38*x-20 90*x^2-82*x-44 60*x^2+54*x-34;\n              -4*x^2+4*x+8 -8*x^2+13*x-10 35*x^2-31*x-14 22*x^2+21*x-15;\n              -10*x^2+10*x+20 -20*x^2+70*x-25 150*x^2-140*x-85 105*x^2+90*x-50])\n[  -6*x^2 + 6*x + 12   -12*x^2 - 21*x - 15    -15*x^2 + 21*x + 33     -21*x^2 - 9*x - 9]\n[  -8*x^2 + 8*x + 16   -16*x^2 + 38*x - 20     90*x^2 - 82*x - 44    60*x^2 + 54*x - 34]\n[   -4*x^2 + 4*x + 8    -8*x^2 + 13*x - 10     35*x^2 - 31*x - 14    22*x^2 + 21*x - 15]\n[-10*x^2 + 10*x + 20   -20*x^2 + 70*x - 25   150*x^2 - 140*x - 85   105*x^2 + 90*x - 50]\n\njulia> n, N = nullspace(M)\n(2, [1320*x^4-330*x^2-1320*x-1320 1056*x^4+1254*x^3+1848*x^2-66*x-330; -660*x^4+1320*x^3+1188*x^2-1848*x-1056 -528*x^4+132*x^3+1584*x^2+660*x-264; 396*x^3-396*x^2-792*x 0; 0 396*x^3-396*x^2-792*x])\n\n\n\n\n\nnullspace(M::MatElem{T}) where {T <: FieldElement}\n\nReturn a tuple (nu N) consisting of the nullity nu of M and a basis N (consisting of column vectors) for the right nullspace of M, i.e. such that MN is the zero matrix. If M is an mtimes n matrix N will be an ntimes nu matrix.\n\n\n\n\n\n","category":"method"},{"location":"AbstractAlgebra/matrix/#Hessenberg-form","page":"Matrix functionality","title":"Hessenberg form","text":"","category":"section"},{"location":"AbstractAlgebra/matrix/","page":"Matrix functionality","title":"Matrix functionality","text":"hessenberg{T <: RingElem}(::MatElem{T})","category":"page"},{"location":"AbstractAlgebra/matrix/#hessenberg-Union{Tuple{MatElem{T}}, Tuple{T}} where T<:RingElem","page":"Matrix functionality","title":"hessenberg","text":"hessenberg(A::MatrixElem{T}) where {T <: RingElement}\n\nReturn the Hessenberg form of M, i.e. an upper Hessenberg matrix which is similar to M. The upper Hessenberg form has nonzero entries above and on the diagonal and in the diagonal line immediately below the diagonal.\n\n\n\n\n\n","category":"method"},{"location":"AbstractAlgebra/matrix/","page":"Matrix functionality","title":"Matrix functionality","text":"is_hessenberg{T <: RingElem}(::MatElem{T})","category":"page"},{"location":"AbstractAlgebra/matrix/#is_hessenberg-Union{Tuple{MatElem{T}}, Tuple{T}} where T<:RingElem","page":"Matrix functionality","title":"is_hessenberg","text":"is_hessenberg(A::MatrixElem{T}) where {T <: RingElement}\n\nReturn true if M is in Hessenberg form, otherwise returns false.\n\n\n\n\n\n","category":"method"},{"location":"AbstractAlgebra/matrix/","page":"Matrix functionality","title":"Matrix functionality","text":"Examples","category":"page"},{"location":"AbstractAlgebra/matrix/","page":"Matrix functionality","title":"Matrix functionality","text":"julia> R, = residue_ring(ZZ, 7);\n\njulia> S = matrix_space(R, 4, 4)\nMatrix space of 4 rows and 4 columns\n  over residue ring of integers modulo 7\n\njulia> M = S([R(1) R(2) R(4) R(3); R(2) R(5) R(1) R(0);\n              R(6) R(1) R(3) R(2); R(1) R(1) R(3) R(5)])\n[1   2   4   3]\n[2   5   1   0]\n[6   1   3   2]\n[1   1   3   5]\n\njulia> A = hessenberg(M)\n[1   5   5   3]\n[2   1   1   0]\n[0   1   3   2]\n[0   0   2   2]\n\njulia> is_hessenberg(A)\ntrue\n","category":"page"},{"location":"AbstractAlgebra/matrix/#Characteristic-polynomial","page":"Matrix functionality","title":"Characteristic polynomial","text":"","category":"section"},{"location":"AbstractAlgebra/matrix/","page":"Matrix functionality","title":"Matrix functionality","text":"charpoly{T <: RingElem}(::PolyRing{T}, ::MatrixElem{T})","category":"page"},{"location":"AbstractAlgebra/matrix/#charpoly-Union{Tuple{T}, Tuple{PolyRing{T}, MatrixElem{T}}} where T<:RingElem","page":"Matrix functionality","title":"charpoly","text":"charpoly(Y::MatrixElem{T}) where {T <: RingElement}\ncharpoly(S::PolyRing{T}, Y::MatrixElem{T}) where {T <: RingElement}\n\nReturn the characteristic polynomial p of the square matrix Y. If a polynomial ring S over the same base ring as Y is supplied, the resulting polynomial is an element of it.\n\nExamples\n\njulia> R, = residue_ring(ZZ, 7);\n\njulia> S = matrix_space(R, 4, 4)\nMatrix space of 4 rows and 4 columns\n  over residue ring of integers modulo 7\n\njulia> T, y = polynomial_ring(R, :y)\n(Univariate polynomial ring in y over R, y)\n\njulia> M = S([R(1) R(2) R(4) R(3); R(2) R(5) R(1) R(0);\n              R(6) R(1) R(3) R(2); R(1) R(1) R(3) R(5)])\n[1   2   4   3]\n[2   5   1   0]\n[6   1   3   2]\n[1   1   3   5]\n\njulia> A = charpoly(T, M)\ny^4 + 2*y^2 + 6*y + 2\n\njulia> A = charpoly(M)\nx^4 + 2*x^2 + 6*x + 2\n\n\n\n\n\n","category":"method"},{"location":"AbstractAlgebra/matrix/#Minimal-polynomial","page":"Matrix functionality","title":"Minimal polynomial","text":"","category":"section"},{"location":"AbstractAlgebra/matrix/","page":"Matrix functionality","title":"Matrix functionality","text":"minpoly{T <: RingElem}(::PolyRing{T}, ::MatElem{T}, ::Bool)","category":"page"},{"location":"AbstractAlgebra/matrix/#minpoly-Union{Tuple{T}, Tuple{PolyRing{T}, MatElem{T}, Bool}} where T<:RingElem","page":"Matrix functionality","title":"minpoly","text":"minpoly(M::MatElem{T}, charpoly_only::Bool = false) where {T <: RingElement}\nminpoly(S::PolyRing{T}, M::MatElem{T}, charpoly_only::Bool = false) where {T <: RingElement}\n\nReturn the minimal polynomial p of the square matrix M. If a polynomial ring S over the same base ring as Y is supplied, the resulting polynomial is an element of it.\n\nExamples\n\njulia> R = GF(13)\nFinite field F_13\n\njulia> S, y = polynomial_ring(R, :y)\n(Univariate polynomial ring in y over R, y)\n\njulia> M = R[7 6 1;\n             7 7 5;\n             8 12 5]\n[7    6   1]\n[7    7   5]\n[8   12   5]\n\njulia> A = minpoly(S, M)\ny^2 + 10*y\n\njulia> A = minpoly(M)\nx^2 + 10*x\n\n\n\n\n\n\n","category":"method"},{"location":"AbstractAlgebra/matrix/#Transforms","page":"Matrix functionality","title":"Transforms","text":"","category":"section"},{"location":"AbstractAlgebra/matrix/","page":"Matrix functionality","title":"Matrix functionality","text":"similarity!{T <: RingElem}(::MatElem{T}, ::Int, ::T)","category":"page"},{"location":"AbstractAlgebra/matrix/#similarity!-Union{Tuple{T}, Tuple{MatElem{T}, Int64, T}} where T<:RingElem","page":"Matrix functionality","title":"similarity!","text":"similarity!(A::MatrixElem{T}, r::Int, d::T) where {T <: RingElement}\n\nApplies a similarity transform to the ntimes n matrix M in-place. Let P be the ntimes n identity matrix that has had all zero entries of row r replaced with d, then the transform applied is equivalent to M = P^-1MP. We require M to be a square matrix. A similarity transform preserves the minimal and characteristic polynomials of a matrix.\n\nExamples\n\njulia> R, = residue_ring(ZZ, 7);\n\njulia> S = matrix_space(R, 4, 4)\nMatrix space of 4 rows and 4 columns\n  over residue ring of integers modulo 7\n\njulia> M = S([R(1) R(2) R(4) R(3); R(2) R(5) R(1) R(0);\n              R(6) R(1) R(3) R(2); R(1) R(1) R(3) R(5)])\n[1   2   4   3]\n[2   5   1   0]\n[6   1   3   2]\n[1   1   3   5]\n\njulia> similarity!(M, 1, R(3))\n\n\n\n\n\n\n","category":"method"},{"location":"AbstractAlgebra/matrix/#Hermite-normal-form","page":"Matrix functionality","title":"Hermite normal form","text":"","category":"section"},{"location":"AbstractAlgebra/matrix/","page":"Matrix functionality","title":"Matrix functionality","text":"hnf{T <: RingElem}(::MatElem{T})\nhnf_with_transform{T <: RingElem}(::MatElem{T})","category":"page"},{"location":"AbstractAlgebra/matrix/#hnf-Union{Tuple{MatElem{T}}, Tuple{T}} where T<:RingElem","page":"Matrix functionality","title":"hnf","text":"hnf(A::MatrixElem{T}) where {T <: RingElement}\n\nReturn the upper right row Hermite normal form of A.\n\n\n\n\n\n","category":"method"},{"location":"AbstractAlgebra/matrix/#hnf_with_transform-Union{Tuple{MatElem{T}}, Tuple{T}} where T<:RingElem","page":"Matrix functionality","title":"hnf_with_transform","text":"hnf_with_transform(A)\n\nReturn the tuple H U consisting of the upper right row Hermite normal form H of A together with invertible matrix U such that UA = H.\n\n\n\n\n\n","category":"method"},{"location":"AbstractAlgebra/matrix/","page":"Matrix functionality","title":"Matrix functionality","text":"is_hnf{T <: RingElem}(::MatElem{T})","category":"page"},{"location":"AbstractAlgebra/matrix/#is_hnf-Union{Tuple{MatElem{T}}, Tuple{T}} where T<:RingElem","page":"Matrix functionality","title":"is_hnf","text":"is_hnf(M::MatrixElem{T}) where T <: RingElement\n\nReturn true if the matrix is in Hermite normal form.\n\n\n\n\n\n","category":"method"},{"location":"AbstractAlgebra/matrix/","page":"Matrix functionality","title":"Matrix functionality","text":"Examples","category":"page"},{"location":"AbstractAlgebra/matrix/","page":"Matrix functionality","title":"Matrix functionality","text":"julia> A = matrix(ZZ, [2 3 -1; 3 5 7; 11 1 12])\n[ 2   3   -1]\n[ 3   5    7]\n[11   1   12]\n\njulia> H = hnf(A)\n[1   0   255]\n[0   1    17]\n[0   0   281]\n\njulia> is_hnf(H)\ntrue\n\njulia> H, U = hnf_with_transform(A)\n([1 0 255; 0 1 17; 0 0 281], [-47 28 1; -3 2 0; -52 31 1])\n\njulia> U*A\n[1   0   255]\n[0   1    17]\n[0   0   281]","category":"page"},{"location":"AbstractAlgebra/matrix/#Smith-normal-form","page":"Matrix functionality","title":"Smith normal form","text":"","category":"section"},{"location":"AbstractAlgebra/matrix/","page":"Matrix functionality","title":"Matrix functionality","text":"is_snf(::MatrixElem{T}) where T <: RingElement","category":"page"},{"location":"AbstractAlgebra/matrix/#is_snf-Union{Tuple{MatrixElem{T}}, Tuple{T}} where T<:RingElement","page":"Matrix functionality","title":"is_snf","text":"is_snf(A::MatrixElem{T}) where T <: RingElement\n\nReturn true if A is in Smith Normal Form.\n\n\n\n\n\n","category":"method"},{"location":"AbstractAlgebra/matrix/","page":"Matrix functionality","title":"Matrix functionality","text":"snf{T <: RingElem}(::MatElem{T})\nsnf_with_transform{T <: RingElem}(::MatElem{T})","category":"page"},{"location":"AbstractAlgebra/matrix/#snf-Union{Tuple{MatElem{T}}, Tuple{T}} where T<:RingElem","page":"Matrix functionality","title":"snf","text":"snf(A::MatrixElem{T}) where {T <: RingElement}\n\nReturn the Smith normal form of A.\n\n\n\n\n\n","category":"method"},{"location":"AbstractAlgebra/matrix/#snf_with_transform-Union{Tuple{MatElem{T}}, Tuple{T}} where T<:RingElem","page":"Matrix functionality","title":"snf_with_transform","text":"snf_with_transform(A)\n\nReturn the tuple S T U consisting of the Smith normal form S of A together with invertible matrices T and U such that TAU = S.\n\n\n\n\n\n","category":"method"},{"location":"AbstractAlgebra/matrix/","page":"Matrix functionality","title":"Matrix functionality","text":"Examples","category":"page"},{"location":"AbstractAlgebra/matrix/","page":"Matrix functionality","title":"Matrix functionality","text":"julia> A = matrix(ZZ, [2 3 -1; 3 5 7; 11 1 12])\n[ 2   3   -1]\n[ 3   5    7]\n[11   1   12]\n\njulia> S = snf(A)\n[1   0     0]\n[0   1     0]\n[0   0   281]\n\njulia> S, T, U = snf_with_transform(A)\n([1 0 0; 0 1 0; 0 0 281], [1 0 0; 7 1 0; 229 31 1], [0 -3 26; 0 2 -17; -1 0 1])\n\njulia> T*A*U\n[1   0     0]\n[0   1     0]\n[0   0   281]","category":"page"},{"location":"AbstractAlgebra/matrix/#(Weak)-Popov-form","page":"Matrix functionality","title":"(Weak) Popov form","text":"","category":"section"},{"location":"AbstractAlgebra/matrix/","page":"Matrix functionality","title":"Matrix functionality","text":"AbstractAlgebra.jl provides algorithms for computing the (weak) Popov of a matrix with entries in a univariate polynomial ring over a field.","category":"page"},{"location":"AbstractAlgebra/matrix/","page":"Matrix functionality","title":"Matrix functionality","text":"is_weak_popov(P::MatrixElem{T}, rank::Int) where T <: Generic.Poly","category":"page"},{"location":"AbstractAlgebra/matrix/#is_weak_popov-Union{Tuple{T}, Tuple{MatrixElem{T}, Int64}} where T<:AbstractAlgebra.Generic.Poly","page":"Matrix functionality","title":"is_weak_popov","text":"is_weak_popov(P::MatrixElem{T}, rank::Int) where T <: PolyRingElem\n\nReturn true if P is a matrix in weak Popov form of the given rank.\n\n\n\n\n\n","category":"method"},{"location":"AbstractAlgebra/matrix/","page":"Matrix functionality","title":"Matrix functionality","text":"weak_popov{T <: PolyRingElem}(::MatElem{T})\nweak_popov_with_transform{T <: PolyRingElem}(::MatElem{T})\npopov{T <: PolyRingElem}(::MatElem{T})\npopov_with_transform{T <: PolyRingElem}(::MatElem{T})","category":"page"},{"location":"AbstractAlgebra/matrix/#weak_popov-Union{Tuple{MatElem{T}}, Tuple{T}} where T<:PolyRingElem","page":"Matrix functionality","title":"weak_popov","text":"weak_popov(A::MatElem{T}) where {T <: PolyRingElem}\n\nReturn the weak Popov form of A.\n\n\n\n\n\n","category":"method"},{"location":"AbstractAlgebra/matrix/#weak_popov_with_transform-Union{Tuple{MatElem{T}}, Tuple{T}} where T<:PolyRingElem","page":"Matrix functionality","title":"weak_popov_with_transform","text":"weak_popov_with_transform(A::MatElem{T}) where {T <: PolyRingElem}\n\nCompute a tuple (P U) where P is the weak Popov form of A and U is a transformation matrix so that P = UA.\n\n\n\n\n\n","category":"method"},{"location":"AbstractAlgebra/matrix/#popov-Union{Tuple{MatElem{T}}, Tuple{T}} where T<:PolyRingElem","page":"Matrix functionality","title":"popov","text":"popov(A::MatElem{T}) where {T <: PolyRingElem}\n\nReturn the Popov form of A.\n\n\n\n\n\n","category":"method"},{"location":"AbstractAlgebra/matrix/#popov_with_transform-Union{Tuple{MatElem{T}}, Tuple{T}} where T<:PolyRingElem","page":"Matrix functionality","title":"popov_with_transform","text":"popov_with_transform(A::MatElem{T}) where {T <: PolyRingElem}\n\nCompute a tuple (P U) where P is the Popov form of A and U is a transformation matrix so that P = UA.\n\n\n\n\n\n","category":"method"},{"location":"AbstractAlgebra/matrix/","page":"Matrix functionality","title":"Matrix functionality","text":"Examples","category":"page"},{"location":"AbstractAlgebra/matrix/","page":"Matrix functionality","title":"Matrix functionality","text":"julia> R, x = polynomial_ring(QQ, :x);\n\njulia> A = matrix(R, map(R, Any[1 2 3 x; x 2*x 3*x x^2; x x^2+1 x^3+x^2 x^4+x^2+1]))\n[1         2           3               x]\n[x       2*x         3*x             x^2]\n[x   x^2 + 1   x^3 + x^2   x^4 + x^2 + 1]\n\njulia> P = weak_popov(A)\n[   1                        2                    3   x]\n[   0                        0                    0   0]\n[-x^3   -2*x^3 + x^2 - 2*x + 1   -2*x^3 + x^2 - 3*x   1]\n\njulia> P, U = weak_popov_with_transform(A)\n([1 2 3 x; 0 0 0 0; -x^3 -2*x^3+x^2-2*x+1 -2*x^3+x^2-3*x 1], [1 0 0; -x 1 0; -x^3-x 0 1])\n\njulia> U*A\n[   1                        2                    3   x]\n[   0                        0                    0   0]\n[-x^3   -2*x^3 + x^2 - 2*x + 1   -2*x^3 + x^2 - 3*x   1]","category":"page"},{"location":"Hecke/manual/misc/FacElem/#Factored-Elements","page":"Factored Elements","title":"Factored Elements","text":"","category":"section"},{"location":"Hecke/manual/misc/FacElem/","page":"Factored Elements","title":"Factored Elements","text":"CurrentModule = Hecke","category":"page"},{"location":"Hecke/manual/misc/FacElem/","page":"Factored Elements","title":"Factored Elements","text":"In many applications in number theory related to the multiplicative structure of number fields, interesting elements, e.g. units, are extremely large when written wrt. to a fxied basis for the field: for the fundamental unit in Qsqrt d it is known that the coefficients wrt. the canonical basis 1 sqrt d can have O(exp sqrt d) many digits. All currently known, fast methods construct those elements as power products of smaller elements, allowing the computer to handle them.","category":"page"},{"location":"Hecke/manual/misc/FacElem/","page":"Factored Elements","title":"Factored Elements","text":"Mathematically, one can think of factored elements to formally live in the ring ZK the group ring of the non-zero field elements. Thus elements are of the form $ \\prod ai^{ei}$ where a_i are elements in K, typically small and the e_iin Z are frequently large exponents. We refer to the a_i as the base and the e_i as the exponents of the factored element.","category":"page"},{"location":"Hecke/manual/misc/FacElem/","page":"Factored Elements","title":"Factored Elements","text":"Since K is, in general, no PID, this presentation is non-unique, elements in this form can easily be multiplied, raised to large powers, but in general not compared and not added.","category":"page"},{"location":"Hecke/manual/misc/FacElem/","page":"Factored Elements","title":"Factored Elements","text":"In Hecke, this is caputured more generally by the type FacElem, parametrized by the type of the elements in the base and the type of their parent.","category":"page"},{"location":"Hecke/manual/misc/FacElem/","page":"Factored Elements","title":"Factored Elements","text":"Important special cases are","category":"page"},{"location":"Hecke/manual/misc/FacElem/","page":"Factored Elements","title":"Factored Elements","text":"FacElem{ZZRingElem, ZZRing}, factored integers\nFacElem{AbsSimpleNumFieldElem, AbsSimpleNumField}, factored algerbaic numbers\nFacElem{AbsNumFieldOrderIdeal, AbsNumFieldOrderIdealSet}, factored ideals","category":"page"},{"location":"Hecke/manual/misc/FacElem/","page":"Factored Elements","title":"Factored Elements","text":"It should be noted that an object of type `FacElemZZRingElem ZZRing will, in general, not represent an integer as the exponents can be negative.","category":"page"},{"location":"Hecke/manual/misc/FacElem/#Construction","page":"Factored Elements","title":"Construction","text":"","category":"section"},{"location":"Hecke/manual/misc/FacElem/","page":"Factored Elements","title":"Factored Elements","text":"In general one can define factored elements by giving 2 arrays, the base and the exponent, or a dictionary containing the pairs:","category":"page"},{"location":"Hecke/manual/misc/FacElem/","page":"Factored Elements","title":"Factored Elements","text":"FacElem\nFacElem(a::AbsSimpleNumFieldElem)","category":"page"},{"location":"Hecke/manual/misc/FacElem/#FacElem","page":"Factored Elements","title":"FacElem","text":"FacElem{B, S}\n\nType for factored elements, that is elements of the form     prod ai^ki for elements a_i of type B in a ring of type S.\n\n\n\n\n\n","category":"type"},{"location":"Hecke/manual/misc/FacElem/#FacElem-Tuple{AbsSimpleNumFieldElem}","page":"Factored Elements","title":"FacElem","text":"FacElem{B}(R, base::Vector{B}, exp::Vector{ZZRingElem}) -> FacElem{B}\n\nReturns the element prod b_i^e_i, un-expanded.\n\n\n\n\n\nFacElem{B}(base::Vector{B}, exp::Vector{ZZRingElem}) -> FacElem{B}\n\nReturns the element prod b_i^e_i, un-expanded.\n\n\n\n\n\nFacElem{B}(R, d::Dict{B, ZZRingElem}) -> FacElem{B}\nFacElem{B}(R, d::Dict{B, Integer}) -> FacElem{B}\n\nReturns the element prod b^dp, un-expanded.\n\n\n\n\n\nFacElem{B}(d::Dict{B, ZZRingElem}) -> FacElem{B}\nFacElem{B}(d::Dict{B, Integer}) -> FacElem{B}\n\nReturns the element prod b^dp, un-expanded.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/misc/FacElem/","page":"Factored Elements","title":"Factored Elements","text":"ideal(::AbsSimpleNumFieldOrder, ::FacElem{AbsSimpleNumFieldElem, AbsSimpleNumField})","category":"page"},{"location":"Hecke/manual/misc/FacElem/#ideal-Tuple{AbsSimpleNumFieldOrder, FacElem{AbsSimpleNumFieldElem, AbsSimpleNumField}}","page":"Factored Elements","title":"ideal","text":" ideal(O::AbsSimpleNumFieldOrder, a::FacElem{AbsSimpleNumFieldElem, AbsSimpleNumField)\n\nThe factored fractional ideal a*O.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/misc/FacElem/#Conversion","page":"Factored Elements","title":"Conversion","text":"","category":"section"},{"location":"Hecke/manual/misc/FacElem/","page":"Factored Elements","title":"Factored Elements","text":"The process of computing the value defined by a factored element is available as evaluate. Depending on the types involved this can be very efficient.","category":"page"},{"location":"Hecke/manual/misc/FacElem/","page":"Factored Elements","title":"Factored Elements","text":"evaluate(::FacElem{ZZRingElem, S}) where S\nevaluate(::FacElem{QQFieldElem, S} where S)\nevaluate(::FacElem{T,S} where S) where T\nevaluate_naive(::FacElem{T,S} where S) where T","category":"page"},{"location":"Hecke/manual/misc/FacElem/#evaluate-Union{Tuple{FacElem{ZZRingElem, S}}, Tuple{S}} where S","page":"Factored Elements","title":"evaluate","text":"evaluate{T}(x::FacElem{T}) -> T\n\nExpands or evaluates the factored element, i.e. actually computes the value. Does \"square-and-multiply\" on the exponent vectors.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/misc/FacElem/#evaluate-Tuple{FacElem{QQFieldElem}}","page":"Factored Elements","title":"evaluate","text":"evaluate(x::FacElem{QQFieldElem}) -> QQFieldElem\nevaluate(x::FacElem{ZZRingElem}) -> ZZRingElem\n\nExpands or evaluates the factored element, i.e. actually computes the the element. Works by first obtaining a simplified version of the power product into coprime base elements.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/misc/FacElem/#evaluate-Union{Tuple{FacElem{T}}, Tuple{T}} where T","page":"Factored Elements","title":"evaluate","text":"evaluate{T}(x::FacElem{T}) -> T\n\nExpands or evaluates the factored element, i.e. actually computes the value. Does \"square-and-multiply\" on the exponent vectors.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/misc/FacElem/#evaluate_naive-Union{Tuple{FacElem{T}}, Tuple{T}} where T","page":"Factored Elements","title":"evaluate_naive","text":"evaluate_naive{T}(x::FacElem{T}) -> T\n\nExpands or evaluates the factored element, i.e. actually computes the value. Uses the obvious naive algorithm. Faster for input in finite rings.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/misc/FacElem/#Special-functions","page":"Factored Elements","title":"Special functions","text":"","category":"section"},{"location":"Hecke/manual/misc/FacElem/","page":"Factored Elements","title":"Factored Elements","text":"In the case where the parent of the base allows for efficient gcd computation, power products can be made unique:","category":"page"},{"location":"Hecke/manual/misc/FacElem/","page":"Factored Elements","title":"Factored Elements","text":"simplify(x::FacElem{AbsNumFieldOrderIdeal{AbsSimpleNumField, AbsSimpleNumFieldElem}, AbsNumFieldOrderIdealSet{AbsSimpleNumField, AbsSimpleNumFieldElem}})\nsimplify(x::FacElem{QQFieldElem,S} where S)","category":"page"},{"location":"Hecke/manual/misc/FacElem/#simplify-Tuple{FacElem{AbsSimpleNumFieldOrderIdeal, Hecke.AbsNumFieldOrderIdealSet{AbsSimpleNumField, AbsSimpleNumFieldElem}}}","page":"Factored Elements","title":"simplify","text":"simplify(x::FacElem{AbsNumFieldOrderIdeal{AbsSimpleNumField, AbsSimpleNumFieldElem}, AbsNumFieldOrderIdealSet{AbsSimpleNumField, AbsSimpleNumFieldElem}}) -> FacElem\nsimplify(x::FacElem{AbsSimpleNumFieldOrderFractionalIdeal, AbsNumFieldOrderFractionalIdealSet{AbsSimpleNumField, AbsSimpleNumFieldElem}}) -> FacElem\n\nUses coprime_base to obtain a simplified version of x, ie. in the simplified version all base ideals will be pariwise coprime but not necessarily prime!.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/misc/FacElem/#simplify-Tuple{FacElem{QQFieldElem}}","page":"Factored Elements","title":"simplify","text":"simplify(x::FacElem{QQFieldElem}) -> FacElem{QQFieldElem}\nsimplify(x::FacElem{ZZRingElem}) -> FacElem{ZZRingElem}\n\nSimplfies the factored element, i.e. arranges for the base to be coprime.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/misc/FacElem/","page":"Factored Elements","title":"Factored Elements","text":"The simplified version can then be used further:","category":"page"},{"location":"Hecke/manual/misc/FacElem/","page":"Factored Elements","title":"Factored Elements","text":"isone(x::FacElem{QQFieldElem, S} where S)\nfactor_coprime(::FacElem{ZZRingElem, S} where S)\nfactor_coprime(::FacElem{AbsNumFieldOrderIdeal{AbsSimpleNumField, AbsSimpleNumFieldElem}, AbsNumFieldOrderIdealSet{AbsSimpleNumField, AbsSimpleNumFieldElem}})\nfactor_coprime(::FacElem{AbsSimpleNumFieldOrderFractionalIdeal, AbsNumFieldOrderFractionalIdealSet{AbsSimpleNumField, AbsSimpleNumFieldElem}})\nfactor_coprime(::AbsNumFieldOrderIdealSet{AbsSimpleNumField, AbsSimpleNumFieldElem}, ::FacElem{AbsSimpleNumFieldElem, AbsSimpleNumField})\nfactor(::FacElem{AbsSimpleNumFieldOrderFractionalIdeal, AbsNumFieldOrderFractionalIdealSet{AbsSimpleNumField, AbsSimpleNumFieldElem}})\nfactor(::AbsNumFieldOrderIdealSet{AbsSimpleNumField, AbsSimpleNumFieldElem}, ::FacElem{AbsSimpleNumFieldElem, AbsSimpleNumField})","category":"page"},{"location":"Hecke/manual/misc/FacElem/#isone-Tuple{FacElem{QQFieldElem}}","page":"Factored Elements","title":"isone","text":"isone(x::FacElem{QQFieldElem}) -> Bool\nisone(x::FacElem{ZZRingElem}) -> Bool\n\nTests if x represents 1 without an evaluation.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/misc/FacElem/#factor_coprime-Tuple{FacElem{ZZRingElem}}","page":"Factored Elements","title":"factor_coprime","text":"factor_coprime(x::FacElem{ZZRingElem}) -> Fac{ZZRingElem}\n\nComputed a partial factorisation of x, ie. writes x as a product of pariwise coprime integers.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/misc/FacElem/#factor_coprime-Tuple{FacElem{AbsSimpleNumFieldOrderIdeal, Hecke.AbsNumFieldOrderIdealSet{AbsSimpleNumField, AbsSimpleNumFieldElem}}}","page":"Factored Elements","title":"factor_coprime","text":"factor_coprime(x::FacElem{AbsNumFieldOrderIdeal{AbsSimpleNumField, AbsSimpleNumFieldElem}, AbsNumFieldOrderIdealSet{AbsSimpleNumField, AbsSimpleNumFieldElem}}) -> Dict{AbsNumFieldOrderIdeal{AbsSimpleNumField, AbsSimpleNumFieldElem}, Int}\n\nComputed a partial factorisation of x, ie. writes x as a product of pariwise coprime integral ideals.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/misc/FacElem/#factor_coprime-Tuple{FacElem{AbsSimpleNumFieldOrderFractionalIdeal, Hecke.AbsNumFieldOrderFractionalIdealSet{AbsSimpleNumField, AbsSimpleNumFieldElem}}}","page":"Factored Elements","title":"factor_coprime","text":"factor_coprime(Q::FacElem{AbsSimpleNumFieldOrderFractionalIdeal, AbsNumFieldOrderFractionalIdealSet{AbsSimpleNumField, AbsSimpleNumFieldElem}}) -> Dict{AbsNumFieldOrderIdeal{AbsSimpleNumField, AbsSimpleNumFieldElem}, Int}\n\nA coprime factorisation of Q: each ideal in Q is split using \\code{integral_split} and then a coprime basis is computed. This does {\\bf not} use any factorisation.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/misc/FacElem/#factor_coprime-Tuple{Hecke.AbsNumFieldOrderIdealSet{AbsSimpleNumField, AbsSimpleNumFieldElem}, FacElem{AbsSimpleNumFieldElem, AbsSimpleNumField}}","page":"Factored Elements","title":"factor_coprime","text":"factor_coprime(I::AbsNumFieldOrderIdealSet{AbsSimpleNumField, AbsSimpleNumFieldElem}, a::FacElem{AbsSimpleNumFieldElem, AbsSimpleNumField}) -> Dict{AbsNumFieldOrderIdeal{AbsSimpleNumField, AbsSimpleNumFieldElem}, ZZRingElem}\n\nFactors the rincipal ideal generated by a into coprimes by computing a coprime basis from the principal ideals in the factorisation of a.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/misc/FacElem/#factor-Tuple{FacElem{AbsSimpleNumFieldOrderFractionalIdeal, Hecke.AbsNumFieldOrderFractionalIdealSet{AbsSimpleNumField, AbsSimpleNumFieldElem}}}","page":"Factored Elements","title":"factor","text":" factor(Q::FacElem{AbsSimpleNumFieldOrderFractionalIdeal, AbsNumFieldOrderFractionalIdealSet{AbsSimpleNumField, AbsSimpleNumFieldElem}}) -> Dict{AbsNumFieldOrderIdeal{AbsSimpleNumField, AbsSimpleNumFieldElem}, Int}\n\nThe factorisation of Q, by refining a coprime factorisation.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/misc/FacElem/#factor-Tuple{Hecke.AbsNumFieldOrderIdealSet{AbsSimpleNumField, AbsSimpleNumFieldElem}, FacElem{AbsSimpleNumFieldElem, AbsSimpleNumField}}","page":"Factored Elements","title":"factor","text":"factor(I::AbsNumFieldOrderIdealSet{AbsSimpleNumField, AbsSimpleNumFieldElem}, a::FacElem{AbsSimpleNumFieldElem, AbsSimpleNumField}) -> Dict{AbsNumFieldOrderIdeal{AbsSimpleNumField, AbsSimpleNumFieldElem}, ZZRingElem}\n\nFactors the principal ideal generated by a by refining a coprime factorisation.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/misc/FacElem/","page":"Factored Elements","title":"Factored Elements","text":"For factorised algebraic numbers a unique simplification is not possible, however, this allows still do obtain partial results:","category":"page"},{"location":"Hecke/manual/misc/FacElem/","page":"Factored Elements","title":"Factored Elements","text":"compact_presentation(a::FacElem{AbsSimpleNumFieldElem, AbsSimpleNumField}, n::Int = 2)","category":"page"},{"location":"Hecke/manual/misc/FacElem/#compact_presentation","page":"Factored Elements","title":"compact_presentation","text":"compact_presentation(a::FacElem{AbsSimpleNumFieldElem, AbsSimpleNumField}, n::Int = 2; decom, arb_prec = 100, short_prec = 1000) -> FacElem\n\nComputes a presentation a = prod a_i^n_i where all the exponents n_i are powers of n and, the elements a_i are \"small\", generically, they have a norm bounded by d^n2 where d is the discriminant of the maximal order. As the algorithm needs the factorisation of the principal ideal generated by a, it can be passed in in \\code{decom}.\n\n\n\n\n\n","category":"function"},{"location":"Hecke/manual/misc/FacElem/","page":"Factored Elements","title":"Factored Elements","text":"valuation(::FacElem{AbsSimpleNumFieldElem,AbsSimpleNumField}, ::AbsNumFieldOrderIdeal{AbsSimpleNumField,AbsSimpleNumFieldElem})\nvaluation(::FacElem{AbsNumFieldOrderIdeal{AbsSimpleNumField,AbsSimpleNumFieldElem},Hecke.AbsNumFieldOrderIdealSet{AbsSimpleNumField,AbsSimpleNumFieldElem}}, ::AbsNumFieldOrderIdeal{AbsSimpleNumField,AbsSimpleNumFieldElem})\nevaluate_mod(::FacElem{AbsSimpleNumFieldElem,AbsSimpleNumField}, ::AbsSimpleNumFieldOrderFractionalIdeal)\nreduce_ideal(::FacElem{AbsNumFieldOrderIdeal{AbsSimpleNumField,AbsSimpleNumFieldElem},Hecke.AbsNumFieldOrderIdealSet{AbsSimpleNumField,AbsSimpleNumFieldElem}})\nmodular_proj(::FacElem{AbsSimpleNumFieldElem,AbsSimpleNumField}, ::Hecke.modular_env)","category":"page"},{"location":"Hecke/manual/misc/FacElem/#valuation-Tuple{FacElem{AbsSimpleNumFieldElem, AbsSimpleNumField}, AbsSimpleNumFieldOrderIdeal}","page":"Factored Elements","title":"valuation","text":"valuation(a::FacElem{AbsSimpleNumFieldElem, AbsSimpleNumField}, P::AbsNumFieldOrderIdeal{AbsSimpleNumField, AbsSimpleNumFieldElem}) -> ZZRingElem\n\nThe valuation of a at P.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/misc/FacElem/#valuation-Tuple{FacElem{AbsSimpleNumFieldOrderIdeal, Hecke.AbsNumFieldOrderIdealSet{AbsSimpleNumField, AbsSimpleNumFieldElem}}, AbsSimpleNumFieldOrderIdeal}","page":"Factored Elements","title":"valuation","text":"valuation(A::FacElem{AbsSimpleNumFieldOrderFractionalIdeal, AbsNumFieldOrderFractionalIdealSet{AbsSimpleNumField, AbsSimpleNumFieldElem}}, p::AbsNumFieldOrderIdeal{AbsSimpleNumField, AbsSimpleNumFieldElem})\nvaluation(A::FacElem{AbsNumFieldOrderIdeal{AbsSimpleNumField, AbsSimpleNumFieldElem}, AbsNumFieldOrderIdealSet{AbsSimpleNumField, AbsSimpleNumFieldElem}}, p::AbsNumFieldOrderIdeal{AbsSimpleNumField, AbsSimpleNumFieldElem})\n\nThe valuation of A at P.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/misc/FacElem/#evaluate_mod-Tuple{FacElem{AbsSimpleNumFieldElem, AbsSimpleNumField}, AbsSimpleNumFieldOrderFractionalIdeal}","page":"Factored Elements","title":"evaluate_mod","text":"evaluate_mod(a::FacElem{AbsSimpleNumFieldElem, AbsSimpleNumField}, B::AbsSimpleNumFieldOrderFractionalIdeal) -> AbsSimpleNumFieldElem\n\nEvaluates a using CRT and small primes. Assumes that the ideal generated by a is in fact B. Useful in cases where a has huge exponents, but the evaluated element is actually \"small\".\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/misc/FacElem/#reduce_ideal-Tuple{FacElem{AbsSimpleNumFieldOrderIdeal, Hecke.AbsNumFieldOrderIdealSet{AbsSimpleNumField, AbsSimpleNumFieldElem}}}","page":"Factored Elements","title":"reduce_ideal","text":"reduce_ideal(A::FacElem{AbsNumFieldOrderIdeal{AbsSimpleNumField, AbsSimpleNumFieldElem}}) -> AbsNumFieldOrderIdeal{AbsSimpleNumField, AbsSimpleNumFieldElem}, FacElem{AbsSimpleNumFieldElem}\n\nComputes B and alpha in factored form, such that alpha B = A.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/misc/FacElem/#modular_proj-Tuple{FacElem{AbsSimpleNumFieldElem, AbsSimpleNumField}, Hecke.modular_env}","page":"Factored Elements","title":"modular_proj","text":"modular_proj(a::FacElem{AbsSimpleNumFieldElem, AbsSimpleNumField}, me::modular_env) -> Vector{fqPolyRepFieldElem}\n\nGiven an algebraic number a in factored form and data \\code{me} as computed by \\code{modular_init}, project a onto the residue class fields.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/misc/FacElem/#Positivity-and-Signs","page":"Factored Elements","title":"Positivity & Signs","text":"","category":"section"},{"location":"Hecke/manual/misc/FacElem/","page":"Factored Elements","title":"Factored Elements","text":"Factored elements can be used instead of number field elements for the functions sign, signs, is_positive, is_negative and is_totally_positive, see Positivity & Signs","category":"page"},{"location":"Hecke/manual/misc/FacElem/#Miscellaneous","page":"Factored Elements","title":"Miscellaneous","text":"","category":"section"},{"location":"Hecke/manual/misc/FacElem/","page":"Factored Elements","title":"Factored Elements","text":"max_exp(a::FacElem)\nmin_exp(a::FacElem)\nmaxabs_exp(a::FacElem)","category":"page"},{"location":"Hecke/manual/misc/FacElem/#max_exp-Tuple{FacElem}","page":"Factored Elements","title":"max_exp","text":"max_exp(a::FacElem)\n\nFinds the largest exponent in the factored element a.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/misc/FacElem/#min_exp-Tuple{FacElem}","page":"Factored Elements","title":"min_exp","text":"min_exp(a::FacElem)\n\nFinds the smallest exponent in the factored element a.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/misc/FacElem/#maxabs_exp-Tuple{FacElem}","page":"Factored Elements","title":"maxabs_exp","text":"maxabs_exp(a::FacElem)\n\nFinds the largest exponent by absolute value in the factored element a.\n\n\n\n\n\n","category":"method"},{"location":"PolyhedralGeometry/mixed_integer_linear_programs/","page":"Mixed Integer Linear Programs","title":"Mixed Integer Linear Programs","text":"CurrentModule = Oscar","category":"page"},{"location":"PolyhedralGeometry/mixed_integer_linear_programs/#Mixed-Integer-Linear-Programs","page":"Mixed Integer Linear Programs","title":"Mixed Integer Linear Programs","text":"","category":"section"},{"location":"PolyhedralGeometry/mixed_integer_linear_programs/#Introduction","page":"Mixed Integer Linear Programs","title":"Introduction","text":"","category":"section"},{"location":"PolyhedralGeometry/mixed_integer_linear_programs/","page":"Mixed Integer Linear Programs","title":"Mixed Integer Linear Programs","text":"The purpose of a mixed integer linear program is to optimize a linear function over a polyhedron, where we require a given subset of the variables to be integers.","category":"page"},{"location":"PolyhedralGeometry/mixed_integer_linear_programs/#Constructions","page":"Mixed Integer Linear Programs","title":"Constructions","text":"","category":"section"},{"location":"PolyhedralGeometry/mixed_integer_linear_programs/","page":"Mixed Integer Linear Programs","title":"Mixed Integer Linear Programs","text":"Mixed integer linear programs are constructed from a polyhedron and a linear objective function which is described by a vector and (optionally) a translation. One can select whether the optimization problem is to maximize or to minimize the objective function. Furthermore one can optionally specify integer_variables, a subset of variables that are required to be integral, given as a set of integers, their respective indices.","category":"page"},{"location":"PolyhedralGeometry/mixed_integer_linear_programs/","page":"Mixed Integer Linear Programs","title":"Mixed Integer Linear Programs","text":"mixed_integer_linear_program","category":"page"},{"location":"PolyhedralGeometry/mixed_integer_linear_programs/#mixed_integer_linear_program","page":"Mixed Integer Linear Programs","title":"mixed_integer_linear_program","text":"mixed_integer_linear_program(P, c; integer_variables = [], k = 0, convention = :max)\n\nThe mixed integer linear program on the feasible set P (a Polyhedron) with respect to the function x ↦ dot(c,x)+k, where x_iinmathbbZ for all i in integer_variables. If integer_variables is empty, or not specified, all entries of x are required to be integral. If this is not intended, consider using a linear_program instead.\n\n\n\n\n\n","category":"function"},{"location":"PolyhedralGeometry/mixed_integer_linear_programs/#Functions","page":"Mixed Integer Linear Programs","title":"Functions","text":"","category":"section"},{"location":"PolyhedralGeometry/mixed_integer_linear_programs/","page":"Mixed Integer Linear Programs","title":"Mixed Integer Linear Programs","text":"feasible_region(milp::MixedIntegerLinearProgram)\nambient_dim(milp::MixedIntegerLinearProgram)\noptimal_value(milp::MixedIntegerLinearProgram{T}) where T<:scalar_types\noptimal_solution\nsolve_milp","category":"page"},{"location":"PolyhedralGeometry/mixed_integer_linear_programs/#feasible_region-Tuple{MixedIntegerLinearProgram}","page":"Mixed Integer Linear Programs","title":"feasible_region","text":"feasible_region(milp::MixedIntegerLinearProgram)\n\nReturn the feasible region of the mixed integer linear program milp, which is a Polyhedron.\n\n\n\n\n\n","category":"method"},{"location":"PolyhedralGeometry/mixed_integer_linear_programs/#ambient_dim-Tuple{MixedIntegerLinearProgram}","page":"Mixed Integer Linear Programs","title":"ambient_dim","text":"ambient_dim(MILP::MixedIntegerLinearProgram)\n\nReturn the ambient dimension of the feasible reagion of MILP.\n\n\n\n\n\n","category":"method"},{"location":"PolyhedralGeometry/mixed_integer_linear_programs/#optimal_value-Union{Tuple{MixedIntegerLinearProgram{T}}, Tuple{T}} where T<:Union{Float64, FieldElem}","page":"Mixed Integer Linear Programs","title":"optimal_value","text":"optimal_value(MILP::MixedIntegerLinearProgram)\n\nReturn, if it exists, the optimal value of the objective function of MILP over the feasible region of MILP. Otherwise, return -inf or inf depending on convention.\n\nExamples\n\nTake the square -1232^2 and optimize 11 in different settings.\n\njulia> c = cube(2, -1//2, 3//2)\nPolytope in ambient dimension 2\n\njulia> milp = mixed_integer_linear_program(c, [1,1], integer_variables=[1])\nMixed integer linear program\n\njulia> optimal_value(milp)\n5/2\n\njulia> milp = mixed_integer_linear_program(c, [1,1])\nMixed integer linear program\n\njulia> optimal_value(milp)\n2\n\n\n\n\n\n","category":"method"},{"location":"PolyhedralGeometry/mixed_integer_linear_programs/#optimal_solution","page":"Mixed Integer Linear Programs","title":"optimal_solution","text":"optimal_solution(MILP::MixedIntegerLinearProgram)\n\nReturn either a point of the feasible region of MILP which optimizes the objective function of MILP, or nothing if no such point exists.\n\nExamples\n\nTake the square -1232^2 and optimize 11 in different settings.\n\njulia> c = cube(2, -1//2, 3//2)\nPolytope in ambient dimension 2\n\njulia> milp = mixed_integer_linear_program(c, [1,1], integer_variables=[1])\nMixed integer linear program\n\njulia> optimal_solution(milp)\n2-element PointVector{QQFieldElem}:\n 1\n 3//2\n\njulia> milp = mixed_integer_linear_program(c, [1,1])\nMixed integer linear program\n\njulia> optimal_solution(milp)\n2-element PointVector{QQFieldElem}:\n 1\n 1\n\n\n\n\n\n","category":"function"},{"location":"PolyhedralGeometry/mixed_integer_linear_programs/#solve_milp","page":"Mixed Integer Linear Programs","title":"solve_milp","text":"solve_milp(MILP::MixedIntegerLinearProgram)\n\nReturn a pair (m,v) where the optimal value m of the objective function of MILP is attained at v (if m exists). If the optimum is not attained, m may be inf or -inf in which case v is nothing.\n\nExamples\n\nTake the square -1232^2 and optimize 11 in different settings.\n\njulia> c = cube(2, -1//2, 3//2)\nPolytope in ambient dimension 2\n\njulia> milp = mixed_integer_linear_program(c, [1,1], integer_variables=[1])\nMixed integer linear program\n\njulia> solve_milp(milp)\n(5/2, QQFieldElem[1, 3//2])\n\njulia> milp = mixed_integer_linear_program(c, [1,1])\nMixed integer linear program\n\njulia> solve_milp(milp)\n(2, QQFieldElem[1, 1])\n\n\n\n\n\n","category":"function"},{"location":"AlgebraicGeometry/Schemes/AffineSchemes/","page":"Affine schemes","title":"Affine schemes","text":"CurrentModule = Oscar","category":"page"},{"location":"AlgebraicGeometry/Schemes/AffineSchemes/#Affine-schemes","page":"Affine schemes","title":"Affine schemes","text":"","category":"section"},{"location":"AlgebraicGeometry/Schemes/AffineSchemes/","page":"Affine schemes","title":"Affine schemes","text":"Let mathbb k be a commutative noetherian base ring (in practice: an algebraic extension of mathbb Q or mathbb F_p). We support functionality for affine schemes X = mathrmSpec(R) over mathbb k. Currently, we support rings R of type MPolyRing, MPolyQuoRing, MPolyLocRing, and MPolyQuoLocRing defined over the integers, a finite field or algebraic field extensions of mathbb Q","category":"page"},{"location":"AlgebraicGeometry/Schemes/AffineSchemes/#Constructors","page":"Affine schemes","title":"Constructors","text":"","category":"section"},{"location":"AlgebraicGeometry/Schemes/AffineSchemes/#General-constructors","page":"Affine schemes","title":"General constructors","text":"","category":"section"},{"location":"AlgebraicGeometry/Schemes/AffineSchemes/","page":"Affine schemes","title":"Affine schemes","text":"Besides spec(R) for R of either one of the types MPolyRing, MPolyQuoRing, MPolyLocRing, or MPolyQuoLocRing, we have the following constructors:","category":"page"},{"location":"AlgebraicGeometry/Schemes/AffineSchemes/","page":"Affine schemes","title":"Affine schemes","text":"spec(R::MPolyRing, I::MPolyIdeal)\nspec(R::MPolyRing, U::AbsMPolyMultSet)\nspec(R::MPolyRing, I::MPolyIdeal, U::AbsMPolyMultSet)","category":"page"},{"location":"AlgebraicGeometry/Schemes/AffineSchemes/#spec-Tuple{MPolyRing, MPolyIdeal}","page":"Affine schemes","title":"spec","text":"spec(R::MPolyRing, I::MPolyIdeal)\n\nConstruct the affine scheme of the ideal I in the ring R. This is the spectrum of the quotient ring RI.\n\nExamples\n\njulia> R, (x, y) = polynomial_ring(QQ, [:x, :y]);\n\njulia> I = ideal(R, [x]);\n\njulia> spec(R, I)\nSpectrum\n  of quotient\n    of multivariate polynomial ring in 2 variables x, y\n      over rational field\n    by ideal (x)\n\n\n\n\n\n","category":"method"},{"location":"AlgebraicGeometry/Schemes/AffineSchemes/#spec-Tuple{MPolyRing, Oscar.AbsMPolyMultSet}","page":"Affine schemes","title":"spec","text":"spec(R::MPolyRing, U::AbsMPolyMultSet)\n\nGiven a polynomial ring R, we can localize that polynomial ring at a multiplicatively closed subset U of R. The spectrum of the localized ring U^-1 R is computed by this method.\n\nExamples\n\njulia> R, (x, y) = polynomial_ring(QQ, [:x, :y]);\n\njulia> I = ideal(R, [x]);\n\njulia> U = complement_of_prime_ideal(I);\n\njulia> spec(R, U)\nSpectrum\n  of localization\n    of multivariate polynomial ring in 2 variables x, y\n      over rational field\n    at complement of prime ideal (x)\n\n\n\n\n\n","category":"method"},{"location":"AlgebraicGeometry/Schemes/AffineSchemes/#spec-Tuple{MPolyRing, MPolyIdeal, Oscar.AbsMPolyMultSet}","page":"Affine schemes","title":"spec","text":"spec(R::MPolyRing, I::MPolyIdeal, U::AbsMPolyMultSet)\n\nWe allow to combine quotients and localizations at the same time. That is, consider a polynomial ring R, an ideal I of R and a multiplicatively closed subset U of R. The spectrum of the localized ring U^-1 (RI) is computed by this method.\n\nExamples\n\njulia> R, (x, y) = polynomial_ring(QQ, [:x, :y]);\n\njulia> I = ideal(R, [x]);\n\njulia> U = complement_of_prime_ideal(ideal(R, [y]));\n\njulia> spec(R, I, U)\nSpectrum\n  of localization\n    of quotient\n      of multivariate polynomial ring in 2 variables x, y\n        over rational field\n      by ideal (x)\n    at complement of prime ideal (y)\n\n\n\n\n\n","category":"method"},{"location":"AlgebraicGeometry/Schemes/AffineSchemes/","page":"Affine schemes","title":"Affine schemes","text":"See inclusion_morphism(::AbsAffineScheme, ::AbsAffineScheme) for a way to obtain the ideal I from X = mathrmSpec(R I).","category":"page"},{"location":"AlgebraicGeometry/Schemes/AffineSchemes/#Affine-n-space","page":"Affine schemes","title":"Affine n-space","text":"","category":"section"},{"location":"AlgebraicGeometry/Schemes/AffineSchemes/","page":"Affine schemes","title":"Affine schemes","text":"affine_space(kk::BRT, n::Int; variable_name=:x) where {BRT<:Ring}\naffine_space(kk::BRT, var_names::AbstractVector{<:VarName}) where {BRT<:Ring}","category":"page"},{"location":"AlgebraicGeometry/Schemes/AffineSchemes/#affine_space-Union{Tuple{BRT}, Tuple{BRT, Int64}} where BRT<:Ring","page":"Affine schemes","title":"affine_space","text":"affine_space(kk::BRT, n::Int; variable_name::VarName=\"x#\") where {BRT<:Ring}\n\nThe n-dimensional affine space over a ring kk is created by this method. By default, the variable names are chosen as x1, x2 and so on. This choice can be overwritten with a third optional argument.\n\nExamples\n\njulia> affine_space(QQ, 5)\nAffine space of dimension 5\n  over rational field\nwith coordinates [x1, x2, x3, x4, x5]\n\njulia> affine_space(QQ,5,variable_name=\"y#\")\nAffine space of dimension 5\n  over rational field\nwith coordinates [y1, y2, y3, y4, y5]\n\n\n\n\n\n","category":"method"},{"location":"AlgebraicGeometry/Schemes/AffineSchemes/#affine_space-Union{Tuple{BRT}, Tuple{BRT, AbstractVector{<:Union{Char, AbstractString, Symbol}}}} where BRT<:Ring","page":"Affine schemes","title":"affine_space","text":"affine_space(kk::BRT, var_names::AbstractVector{<:VarName}) where {BRT<:Ring}\n\nCreate the n-dimensional affine space over a ring kk, but allows more flexibility in the choice of variable names. The following example demonstrates this.\n\nExamples\n\njulia> affine_space(QQ, [:x, :y, :z])\nAffine space of dimension 3\n  over rational field\nwith coordinates [x, y, z]\n\njulia> affine_space(QQ, ['x', 'y', 'z'])\nAffine space of dimension 3\n  over rational field\nwith coordinates [x, y, z]\n\njulia> affine_space(QQ, [\"x\", \"y\", \"z\"])\nAffine space of dimension 3\n  over rational field\nwith coordinates [x, y, z]\n\n\n\n\n\n","category":"method"},{"location":"AlgebraicGeometry/Schemes/AffineSchemes/#Closed-subschemes","page":"Affine schemes","title":"Closed subschemes","text":"","category":"section"},{"location":"AlgebraicGeometry/Schemes/AffineSchemes/","page":"Affine schemes","title":"Affine schemes","text":"subscheme(X::AbsAffineScheme, f::Vector{<:RingElem})\nsubscheme(X::AbsAffineScheme, I::Ideal)","category":"page"},{"location":"AlgebraicGeometry/Schemes/AffineSchemes/#subscheme-Tuple{AbsAffineScheme, Vector{<:RingElem}}","page":"Affine schemes","title":"subscheme","text":"subscheme(X::AbsAffineScheme, f::Vector{<:RingElem})\n\nFor an affine spectrum X and elements f_1, f_2, etc. of the coordinate ring of X, this method computes the subscheme V(f_1 f_2 dots) of X.\n\nExamples\n\njulia> X = affine_space(QQ,3)\nAffine space of dimension 3\n  over rational field\nwith coordinates [x1, x2, x3]\n\njulia> R = OO(X)\nMultivariate polynomial ring in 3 variables x1, x2, x3\n  over rational field\n\njulia> (x1,x2,x3) = gens(R)\n3-element Vector{QQMPolyRingElem}:\n x1\n x2\n x3\n\njulia> subscheme(X,x1)\nSpectrum\n  of quotient\n    of multivariate polynomial ring in 3 variables x1, x2, x3\n      over rational field\n    by ideal (x1)\n\njulia> subscheme(X,[x1,x2])\nSpectrum\n  of quotient\n    of multivariate polynomial ring in 3 variables x1, x2, x3\n      over rational field\n    by ideal (x1, x2)\n\n\n\n\n\n","category":"method"},{"location":"AlgebraicGeometry/Schemes/AffineSchemes/#subscheme-Tuple{AbsAffineScheme, Ideal}","page":"Affine schemes","title":"subscheme","text":"subscheme(X::AbsAffineScheme, I::Ideal)\n\nFor a scheme X = Spec(R) and an ideal I  𝒪(X), return the closed subscheme defined by I.\n\nExamples\n\njulia> X = affine_space(QQ,3)\nAffine space of dimension 3\n  over rational field\nwith coordinates [x1, x2, x3]\n\njulia> R = OO(X)\nMultivariate polynomial ring in 3 variables x1, x2, x3\n  over rational field\n\njulia> (x1,x2,x3) = gens(R)\n3-element Vector{QQMPolyRingElem}:\n x1\n x2\n x3\n\njulia> subscheme(X,ideal(R,[x1*x2]))\nSpectrum\n  of quotient\n    of multivariate polynomial ring in 3 variables x1, x2, x3\n      over rational field\n    by ideal (x1*x2)\n\n\n\n\n\n","category":"method"},{"location":"AlgebraicGeometry/Schemes/AffineSchemes/#Intersections","page":"Affine schemes","title":"Intersections","text":"","category":"section"},{"location":"AlgebraicGeometry/Schemes/AffineSchemes/","page":"Affine schemes","title":"Affine schemes","text":"Base.intersect(X::AbsAffineScheme{BRT, <:Ring}, Y::AbsAffineScheme{BRT, <:Ring}) where {BRT<:Ring}","category":"page"},{"location":"AlgebraicGeometry/Schemes/AffineSchemes/#intersect-Union{Tuple{BRT}, Tuple{AbsAffineScheme{BRT}, AbsAffineScheme{BRT}}} where BRT<:Ring","page":"Affine schemes","title":"intersect","text":"Base.intersect(X::AbsAffineScheme, Y::AbsAffineScheme)\n\nThis method computes the intersection to two affine schemes that reside in the same ambient affine space.\n\nExamples\n\njulia> X = affine_space(QQ,3)\nAffine space of dimension 3\n  over rational field\nwith coordinates [x1, x2, x3]\n\njulia> R = OO(X)\nMultivariate polynomial ring in 3 variables x1, x2, x3\n  over rational field\n\njulia> (x1,x2,x3) = gens(R)\n3-element Vector{QQMPolyRingElem}:\n x1\n x2\n x3\n\njulia> Y1 = subscheme(X,[x1])\nSpectrum\n  of quotient\n    of multivariate polynomial ring in 3 variables x1, x2, x3\n      over rational field\n    by ideal (x1)\n\njulia> Y2 = subscheme(X,[x2])\nSpectrum\n  of quotient\n    of multivariate polynomial ring in 3 variables x1, x2, x3\n      over rational field\n    by ideal (x2)\n\njulia> intersect(Y1, Y2)\nSpectrum\n  of quotient\n    of multivariate polynomial ring in 3 variables x1, x2, x3\n      over rational field\n    by ideal (x1, x2)\n\n\n\n\n\n","category":"method"},{"location":"AlgebraicGeometry/Schemes/AffineSchemes/#Open-subschemes","page":"Affine schemes","title":"Open subschemes","text":"","category":"section"},{"location":"AlgebraicGeometry/Schemes/AffineSchemes/","page":"Affine schemes","title":"Affine schemes","text":"hypersurface_complement(X::AbsAffineScheme, f::RingElem)\nhypersurface_complement(X::AbsAffineScheme, f::Vector{<:RingElem})","category":"page"},{"location":"AlgebraicGeometry/Schemes/AffineSchemes/#hypersurface_complement-Tuple{AbsAffineScheme, RingElem}","page":"Affine schemes","title":"hypersurface_complement","text":"hypersurface_complement(X::AbsAffineScheme, f::RingElem)\n\nFor a scheme X = Spec(R) and an element f  R, return the open subscheme U = Spec(Rf¹) = X  V(f) defined by the complement of the vanishing locus of f.\n\nExamples\n\njulia> X = affine_space(QQ,3)\nAffine space of dimension 3\n  over rational field\nwith coordinates [x1, x2, x3]\n\njulia> R = OO(X)\nMultivariate polynomial ring in 3 variables x1, x2, x3\n  over rational field\n\njulia> (x1, x2, x3) = gens(R)\n3-element Vector{QQMPolyRingElem}:\n x1\n x2\n x3\n\njulia> hypersurface_complement(X, x1)\nSpectrum\n  of localization\n    of multivariate polynomial ring in 3 variables x1, x2, x3\n      over rational field\n    at products of (x1)\n\n\n\n\n\n","category":"method"},{"location":"AlgebraicGeometry/Schemes/AffineSchemes/#hypersurface_complement-Tuple{AbsAffineScheme, Vector{<:RingElem}}","page":"Affine schemes","title":"hypersurface_complement","text":"hypersurface_complement(X::AbsAffineScheme, f::Vector{<:RingElem})\n\nFor a scheme X = Spec(R) and elements f₁ f₂   R, return the open subscheme U = Spec(Rf₁¹f₂¹ ) = X  V(f₁f₂) defined by the complement of the vanishing locus of the product f₁f₂.\n\nExamples\n\njulia> X = affine_space(QQ,3)\nAffine space of dimension 3\n  over rational field\nwith coordinates [x1, x2, x3]\n\njulia> R = OO(X)\nMultivariate polynomial ring in 3 variables x1, x2, x3\n  over rational field\n\njulia> (x1,x2,x3) = gens(R)\n3-element Vector{QQMPolyRingElem}:\n x1\n x2\n x3\n\njulia> hypersurface_complement(X,[x1,x2])\nSpectrum\n  of localization\n    of multivariate polynomial ring in 3 variables x1, x2, x3\n      over rational field\n    at products of (x1, x2)\n\n\n\n\n\n","category":"method"},{"location":"AlgebraicGeometry/Schemes/AffineSchemes/#Closure","page":"Affine schemes","title":"Closure","text":"","category":"section"},{"location":"AlgebraicGeometry/Schemes/AffineSchemes/","page":"Affine schemes","title":"Affine schemes","text":"closure(X::AbsAffineScheme, Y::AbsAffineScheme)","category":"page"},{"location":"AlgebraicGeometry/Schemes/AffineSchemes/#closure-Tuple{AbsAffineScheme, AbsAffineScheme}","page":"Affine schemes","title":"closure","text":"closure(X::AbsAffineScheme, Y::AbsAffineScheme)\n\nReturn the closure of X in Y.\n\nExamples\n\njulia> X = affine_space(QQ,3)\nAffine space of dimension 3\n  over rational field\nwith coordinates [x1, x2, x3]\n\njulia> R = OO(X)\nMultivariate polynomial ring in 3 variables x1, x2, x3\n  over rational field\n\njulia> (x1,x2,x3) = gens(R)\n3-element Vector{QQMPolyRingElem}:\n x1\n x2\n x3\n\njulia> H = subscheme(X,ideal(R,[x1]))\nSpectrum\n  of quotient\n    of multivariate polynomial ring in 3 variables x1, x2, x3\n      over rational field\n    by ideal (x1)\n\njulia> closure(H, X)\nSpectrum\n  of quotient\n    of multivariate polynomial ring in 3 variables x1, x2, x3\n      over rational field\n    by ideal (x1)\n\n\n\n\n\n","category":"method"},{"location":"AlgebraicGeometry/Schemes/AffineSchemes/#Attributes","page":"Affine schemes","title":"Attributes","text":"","category":"section"},{"location":"AlgebraicGeometry/Schemes/AffineSchemes/#Ambient-affine-space","page":"Affine schemes","title":"Ambient affine space","text":"","category":"section"},{"location":"AlgebraicGeometry/Schemes/AffineSchemes/","page":"Affine schemes","title":"Affine schemes","text":"Most affine schemes in Oscar X = mathrmSpec(R) over a ring B, come with an embedding into an affine space mathbbA_B. More precisely, ambient_space(X) is defined for X = spec(R) if R is constructed from a polynomial ring. In particular mathrmSpec(mathbbZ) or mathrmSpec(mathbbk) for mathbb k a field do not have an ambient affine space.","category":"page"},{"location":"AlgebraicGeometry/Schemes/AffineSchemes/","page":"Affine schemes","title":"Affine schemes","text":"ambient_space(X::AbsAffineScheme)","category":"page"},{"location":"AlgebraicGeometry/Schemes/AffineSchemes/#ambient_space-Tuple{AbsAffineScheme}","page":"Affine schemes","title":"ambient_space","text":"ambient_space(X::AbsAffineScheme)\n\nReturn the ambient affine space of X.\n\nUse ambient_embedding(::AbsAffineScheme) to obtain the embedding of X in its ambient affine space.\n\nExamples\n\njulia> X = affine_space(QQ, [:x,:y])\nAffine space of dimension 2\n  over rational field\nwith coordinates [x, y]\n\njulia> ambient_space(X) == X\ntrue\n\njulia> (x, y) = coordinates(X);\n\njulia> Y = subscheme(X, [x])\nSpectrum\n  of quotient\n    of multivariate polynomial ring in 2 variables x, y\n      over rational field\n    by ideal (x)\n\njulia> X == ambient_space(Y)\ntrue\n\njulia> Z = subscheme(Y, y)\nSpectrum\n  of quotient\n    of multivariate polynomial ring in 2 variables x, y\n      over rational field\n    by ideal (x, y)\n\njulia> ambient_space(Z) == X\ntrue\n\njulia> V = hypersurface_complement(Y, y)\nSpectrum\n  of localization\n    of quotient\n      of multivariate polynomial ring in 2 variables x, y\n        over rational field\n      by ideal (x)\n    at products of (y)\n\njulia> ambient_space(V) == X\ntrue\n\nWe can create X, Y and Z also by first constructing the corresponding coordinate rings. The subset relations are inferred from the coordinate rings. More precisely, for a polynomial ring P an ideal I  P and a multiplicatively closed subset U of P let R be one of P, U^-1P, PI or U^-1(PI). In each case the ambient affine space is given by Spec(P).\n\nExamples\n\njulia> P, (x, y) = polynomial_ring(QQ, [:x, :y])\n(Multivariate polynomial ring in 2 variables over QQ, QQMPolyRingElem[x, y])\n\njulia> X = spec(P)\nSpectrum\n  of multivariate polynomial ring in 2 variables x, y\n    over rational field\n\njulia> I = ideal(P, x)\nIdeal generated by\n  x\n\njulia> RmodI, quotient_map = quo(P, I);\n\njulia> Y = spec(RmodI)\nSpectrum\n  of quotient\n    of multivariate polynomial ring in 2 variables x, y\n      over rational field\n    by ideal (x)\n\njulia> ambient_space(Y) == X\ntrue\n\njulia> J = ideal(RmodI, y);\n\njulia> RmodJ, quotient_map2 = quo(RmodI, J);\n\njulia> Z = spec(RmodJ)\nSpectrum\n  of quotient\n    of multivariate polynomial ring in 2 variables x, y\n      over rational field\n    by ideal (x, y)\n\njulia> ambient_space(Z) == X\ntrue\n\njulia> U = powers_of_element(y)\nMultiplicative subset\n  of multivariate polynomial ring in 2 variables over QQ\n  given by the products of [y]\n\njulia> URmodI, _ = localization(RmodI, U);\n\njulia> V = spec(URmodI)\nSpectrum\n  of localization\n    of quotient\n      of multivariate polynomial ring in 2 variables x, y\n        over rational field\n      by ideal (x)\n    at products of (y)\n\njulia> ambient_space(V) == X\ntrue\n\nNote: compare with ==, as the same affine space could be represented internally by different objects for technical reasons.\n\nExamples\n\njulia> AX = ambient_space(X);\n\njulia> AY = ambient_space(Y);\n\njulia> AX == AY\ntrue\n\njulia> AX === AY\nfalse\n\n\n\n\n\n","category":"method"},{"location":"AlgebraicGeometry/Schemes/AffineSchemes/#Other-attributes","page":"Affine schemes","title":"Other attributes","text":"","category":"section"},{"location":"AlgebraicGeometry/Schemes/AffineSchemes/","page":"Affine schemes","title":"Affine schemes","text":"base_ring(X::AbsAffineScheme)\ncodim(X::AbsAffineScheme)\nambient_embedding(X::AbsAffineScheme)\ndim(X::AbsAffineScheme)\nname(X::AbsAffineScheme)\nOO(X::AbsAffineScheme)","category":"page"},{"location":"AlgebraicGeometry/Schemes/AffineSchemes/#base_ring-Tuple{AbsAffineScheme}","page":"Affine schemes","title":"base_ring","text":"base_ring(M::PMat)\n\nThe PMat M defines an R-module for some maximal order R. This function returns the R that was used to defined M.\n\n\n\n\n\nbase_ring(I::MPolyIdeal)\n\nReturn the ambient ring of I.\n\nExamples\n\njulia> R, (x, y) = polynomial_ring(QQ, [:x, :y])\n(Multivariate polynomial ring in 2 variables over QQ, QQMPolyRingElem[x, y])\n\njulia> I = ideal(R, [x, y])^2\nIdeal generated by\n  x^2\n  x*y\n  y^2\n\njulia> base_ring(I)\nMultivariate polynomial ring in 2 variables x, y\n  over rational field\n\n\n\n\n\nbase_ring(X::AbsAffineScheme)\n\nOn an affine scheme X𝕜 over 𝕜 this returns the ring 𝕜.\n\nExamples\n\njulia> X = affine_space(QQ,3)\nAffine space of dimension 3\n  over rational field\nwith coordinates [x1, x2, x3]\n\njulia> base_ring(X)\nRational field\n\n\n\n\n\n","category":"method"},{"location":"AlgebraicGeometry/Schemes/AffineSchemes/#codim-Tuple{AbsAffineScheme}","page":"Affine schemes","title":"codim","text":"codim(X::AbsAffineScheme)\n\nReturn the codimension of X in its ambient affine space.\n\nThrows an error if X does not have an ambient affine space.\n\nExamples\n\njulia> X = affine_space(QQ,3)\nAffine space of dimension 3\n  over rational field\nwith coordinates [x1, x2, x3]\n\njulia> codim(X)\n0\n\njulia> R = OO(X)\nMultivariate polynomial ring in 3 variables x1, x2, x3\n  over rational field\n\njulia> (x1,x2,x3) = gens(R)\n3-element Vector{QQMPolyRingElem}:\n x1\n x2\n x3\n\njulia> Y = subscheme(X, x1)\nSpectrum\n  of quotient\n    of multivariate polynomial ring in 3 variables x1, x2, x3\n      over rational field\n    by ideal (x1)\n\njulia> codim(Y)\n1\n\n\n\n\n\n","category":"method"},{"location":"AlgebraicGeometry/Schemes/AffineSchemes/#ambient_embedding-Tuple{AbsAffineScheme}","page":"Affine schemes","title":"ambient_embedding","text":"ambient_embedding(X::AbsAffineScheme)\n\nReturn the embedding of X in its ambient affine space.\n\nExamples\n\njulia> X = affine_space(QQ, [:x,:y])\nAffine space of dimension 2\n  over rational field\nwith coordinates [x, y]\n\njulia> (x, y) = coordinates(X);\n\njulia> Y = subscheme(X, [x])\nSpectrum\n  of quotient\n    of multivariate polynomial ring in 2 variables x, y\n      over rational field\n    by ideal (x)\n\njulia> inc = ambient_embedding(Y)\nAffine scheme morphism\n  from [x, y]  scheme(x)\n  to   [x, y]  affine 2-space over QQ\ngiven by the pullback function\n  x -> x\n  y -> y\n\njulia> inc == inclusion_morphism(Y, X)\ntrue\n\n\n\n\n\n","category":"method"},{"location":"AlgebraicGeometry/Schemes/AffineSchemes/#dim-Tuple{AbsAffineScheme}","page":"Affine schemes","title":"dim","text":"dim(X::AbsAffineScheme)\n\nReturn the dimension the affine scheme X = Spec(R).\n\nBy definition, this is the Krull dimension of R.\n\nExamples\n\njulia> X = affine_space(QQ,3)\nAffine space of dimension 3\n  over rational field\nwith coordinates [x1, x2, x3]\n\njulia> dim(X)\n3\n\njulia> Y = affine_space(ZZ, 2)\nSpectrum\n  of multivariate polynomial ring in 2 variables x1, x2\n    over integer ring\n\njulia> dim(Y) # one dimension comes from ZZ and two from x1 and x2\n3\n\n\n\n\n\n","category":"method"},{"location":"AlgebraicGeometry/Schemes/AffineSchemes/#name-Tuple{AbsAffineScheme}","page":"Affine schemes","title":"name","text":"name(X::AbsAffineScheme)\n\nReturn the current name of an affine scheme.\n\nThis name can be specified via set_name!.\n\nExamples\n\njulia> X = affine_space(QQ, 3)\nAffine space of dimension 3\n  over rational field\nwith coordinates [x1, x2, x3]\n\njulia> name(X)\n\"unnamed affine variety\"\n\njulia> set_name!(X, \"affine 3-dimensional space\")\n\njulia> name(X)\n\"affine 3-dimensional space\"\n\n\n\n\n\n","category":"method"},{"location":"AlgebraicGeometry/Schemes/AffineSchemes/#OO-Tuple{AbsAffineScheme}","page":"Affine schemes","title":"OO","text":"OO(X::AbsAffineScheme)\n\nOn an affine scheme X = Spec(R), return the ring R.\n\n\n\n\n\n","category":"method"},{"location":"AlgebraicGeometry/Schemes/AffineSchemes/#Type-getters","page":"Affine schemes","title":"Type getters","text":"","category":"section"},{"location":"AlgebraicGeometry/Schemes/AffineSchemes/","page":"Affine schemes","title":"Affine schemes","text":"We support functions which return the types of schemes, associated rings, and their elements. See the source code for details.","category":"page"},{"location":"AlgebraicGeometry/Schemes/AffineSchemes/#Properties","page":"Affine schemes","title":"Properties","text":"","category":"section"},{"location":"AlgebraicGeometry/Schemes/AffineSchemes/","page":"Affine schemes","title":"Affine schemes","text":"is_open_embedding(X::AbsAffineScheme, Y::AbsAffineScheme)\nis_closed_embedding(X::AbsAffineScheme, Y::AbsAffineScheme)\nisempty(X::AbsAffineScheme)\nis_subscheme(X::AbsAffineScheme, Y::AbsAffineScheme)","category":"page"},{"location":"AlgebraicGeometry/Schemes/AffineSchemes/#is_open_embedding-Tuple{AbsAffineScheme, AbsAffineScheme}","page":"Affine schemes","title":"is_open_embedding","text":"is_open_embedding(X::AbsAffineScheme, Y::AbsAffineScheme)\n\nChecks whether X is openly embedded in Y.\n\nExamples\n\njulia> X = affine_space(QQ,3)\nAffine space of dimension 3\n  over rational field\nwith coordinates [x1, x2, x3]\n\njulia> R = OO(X)\nMultivariate polynomial ring in 3 variables x1, x2, x3\n  over rational field\n\njulia> (x1,x2,x3) = gens(R)\n3-element Vector{QQMPolyRingElem}:\n x1\n x2\n x3\n\njulia> Y = subscheme(X,ideal(R,[x1*x2]))\nSpectrum\n  of quotient\n    of multivariate polynomial ring in 3 variables x1, x2, x3\n      over rational field\n    by ideal (x1*x2)\n\njulia> is_open_embedding(Y, X)\nfalse\n\njulia> Z = hypersurface_complement(X, x1)\nSpectrum\n  of localization\n    of multivariate polynomial ring in 3 variables x1, x2, x3\n      over rational field\n    at products of (x1)\n\njulia> is_open_embedding(Z, X)\ntrue\n\n\n\n\n\n","category":"method"},{"location":"AlgebraicGeometry/Schemes/AffineSchemes/#is_closed_embedding-Tuple{AbsAffineScheme, AbsAffineScheme}","page":"Affine schemes","title":"is_closed_embedding","text":"is_closed_embedding(X::AbsAffineScheme, Y::AbsAffineScheme)\n\nChecks whether X is closed embedded in Y.\n\nExamples\n\njulia> X = affine_space(QQ,3)\nAffine space of dimension 3\n  over rational field\nwith coordinates [x1, x2, x3]\n\njulia> R = OO(X)\nMultivariate polynomial ring in 3 variables x1, x2, x3\n  over rational field\n\njulia> (x1,x2,x3) = gens(R)\n3-element Vector{QQMPolyRingElem}:\n x1\n x2\n x3\n\njulia> Y = subscheme(X,ideal(R,[x1*x2]))\nSpectrum\n  of quotient\n    of multivariate polynomial ring in 3 variables x1, x2, x3\n      over rational field\n    by ideal (x1*x2)\n\njulia> is_closed_embedding(Y, X)\ntrue\n\njulia> Z = hypersurface_complement(X, x1)\nSpectrum\n  of localization\n    of multivariate polynomial ring in 3 variables x1, x2, x3\n      over rational field\n    at products of (x1)\n\njulia> is_closed_embedding(Z, X)\nfalse\n\n\n\n\n\n","category":"method"},{"location":"AlgebraicGeometry/Schemes/AffineSchemes/#isempty-Tuple{AbsAffineScheme}","page":"Affine schemes","title":"isempty","text":"is_empty(X::AbsAffineScheme)\n\nCheck whether the affine scheme X is empty.\n\nExamples\n\njulia> X = affine_space(QQ,3)\nAffine space of dimension 3\n  over rational field\nwith coordinates [x1, x2, x3]\n\njulia> isempty(X)\nfalse\n\njulia> is_empty(subscheme(X, one(OO(X))))\ntrue\n\njulia> isempty(EmptyScheme(QQ))\ntrue\n\n\n\n\n\n","category":"method"},{"location":"AlgebraicGeometry/Schemes/AffineSchemes/#is_subscheme-Tuple{AbsAffineScheme, AbsAffineScheme}","page":"Affine schemes","title":"is_subscheme","text":"is_subscheme(X::AbsAffineScheme, Y::AbsAffineScheme)\n\nCheck whether X is a subset of Y based on the comparison of their coordinate rings. See inclusion_morphism(::AbsAffineScheme, ::AbsAffineScheme) for the corresponding morphism.\n\nExamples\n\njulia> X = affine_space(QQ,3)\nAffine space of dimension 3\n  over rational field\nwith coordinates [x1, x2, x3]\n\njulia> R = OO(X)\nMultivariate polynomial ring in 3 variables x1, x2, x3\n  over rational field\n\njulia> (x1,x2,x3) = gens(R)\n3-element Vector{QQMPolyRingElem}:\n x1\n x2\n x3\n\njulia> Y = subscheme(X,ideal(R,[x1*x2]))\nSpectrum\n  of quotient\n    of multivariate polynomial ring in 3 variables x1, x2, x3\n      over rational field\n    by ideal (x1*x2)\n\njulia> is_subscheme(X, Y)\nfalse\n\njulia> is_subscheme(Y, X)\ntrue\n\n\n\n\n\n","category":"method"},{"location":"AlgebraicGeometry/Schemes/AffineSchemes/#Methods","page":"Affine schemes","title":"Methods","text":"","category":"section"},{"location":"AlgebraicGeometry/Schemes/AffineSchemes/","page":"Affine schemes","title":"Affine schemes","text":"tangent_space(X::AbsAffineScheme{<:Field}, P::AbsAffineRationalPoint)\nis_normal(X::AbsAffineScheme; check::Bool=true)\nnormalization(X::AbsAffineScheme; check::Bool=true, algorithm=:equidimDec)","category":"page"},{"location":"AlgebraicGeometry/Schemes/AffineSchemes/#tangent_space-Tuple{AbsAffineScheme{<:Field}, AbsAffineRationalPoint}","page":"Affine schemes","title":"tangent_space","text":"tangent_space(X::AbsAffineScheme{<:Field}, P::AbsAffineRationalPoint) -> AlgebraicSet\n\nReturn the Zariski tangent space of X at its rational point P.\n\nSee also tangent_space(P::AbsAffineRationalPoint{<:Field})\n\n\n\n\n\n","category":"method"},{"location":"AlgebraicGeometry/Schemes/AffineSchemes/#is_normal-Tuple{AbsAffineScheme}","page":"Affine schemes","title":"is_normal","text":"is_normal(X::AbsAffineScheme; check::Bool=true) -> Bool\n\nInput:\n\na reduced scheme X,\nif check is true, then confirm that X is reduced; this is expensive.\n\nOutput:\n\nReturns whether the scheme X is normal.\n\nExamples\n\njulia> R, (x, y, z) = QQ[:x, :y, :z];\n\njulia> X = spec(R);\n\njulia> is_normal(X)\ntrue\n\n\n\n\n\n","category":"method"},{"location":"AlgebraicGeometry/Schemes/AffineSchemes/#normalization-Tuple{AbsAffineScheme}","page":"Affine schemes","title":"normalization","text":"normalization(X::AbsAffineScheme) -> Vector{Tuple{AbsAffineScheme, AbsAffineSchemeMor}}\n\nReturn the normalization of the reduced affine scheme X.\n\nInput:\n\nA reduced affine scheme X\nif check is true confirm that X is reduced; this is expensive\nthe keyword argument algorithm is passed on to normalization(::MPolyQuoRing)\n\nOutput:\n\nA list of pairs (Y_i f_i) where Y_i is a normal scheme and f_i is a morphism from Y_i to X. The disjoint union of the Y_i is the normalization of X and the f_i are the restrictions of the normalization morphism to Y_i.\n\n\n\n\n\n","category":"method"},{"location":"AlgebraicGeometry/Schemes/AffineSchemes/#Comparison","page":"Affine schemes","title":"Comparison","text":"","category":"section"},{"location":"AlgebraicGeometry/Schemes/AffineSchemes/","page":"Affine schemes","title":"Affine schemes","text":"Two schemes X and Y can be compared if their ambient affine spaces are equal. In particular X and Y are considered equal (==) if and only if the identity morphism of their ambient affine space induces an isomorphism of X and Y. For X and Y with different ambient affine space X==Y is always false.","category":"page"},{"location":"AlgebraicGeometry/Schemes/AffineSchemes/#Auxiliary-methods","page":"Affine schemes","title":"Auxiliary methods","text":"","category":"section"},{"location":"AlgebraicGeometry/Schemes/AffineSchemes/","page":"Affine schemes","title":"Affine schemes","text":"is_non_zero_divisor(f::RingElem, X::AbsAffineScheme)","category":"page"},{"location":"AlgebraicGeometry/Schemes/AffineSchemes/#is_non_zero_divisor-Tuple{RingElem, AbsAffineScheme}","page":"Affine schemes","title":"is_non_zero_divisor","text":"is_non_zero_divisor(f::RingElem, X::AbsAffineScheme)\n\nChecks if a ring element is a non-zero divisor in the coordinate ring of an affine scheme.\n\nExamples\n\njulia> X = affine_space(QQ,3)\nAffine space of dimension 3\n  over rational field\nwith coordinates [x1, x2, x3]\n\njulia> (x1, x2, x3) = gens(OO(X))\n3-element Vector{QQMPolyRingElem}:\n x1\n x2\n x3\n\njulia> is_non_zero_divisor(x1, X)\ntrue\n\njulia> is_non_zero_divisor(zero(OO(X)), X)\nfalse\n\n\n\n\n\n","category":"method"},{"location":"Combinatorics/simplicialcomplexes/","page":"Simplicial Complexes","title":"Simplicial Complexes","text":"CurrentModule = Oscar","category":"page"},{"location":"Combinatorics/simplicialcomplexes/#Simplicial-Complexes","page":"Simplicial Complexes","title":"Simplicial Complexes","text":"","category":"section"},{"location":"Combinatorics/simplicialcomplexes/#Introduction","page":"Simplicial Complexes","title":"Introduction","text":"","category":"section"},{"location":"Combinatorics/simplicialcomplexes/","page":"Simplicial Complexes","title":"Simplicial Complexes","text":"Abstract simplicial complexes provide a combinatorial way to define topological spaces. By no means every topological space arises in this way, but this is a (most) natural choice in a computational setup.","category":"page"},{"location":"Combinatorics/simplicialcomplexes/","page":"Simplicial Complexes","title":"Simplicial Complexes","text":"A simplicial complex K on a vertex set V is a nonempty subset of 2^V such that for each sigma in K and tau subsetsigma we have tauin K. Here V is usually n = 12dotsn for some ngeq 0.","category":"page"},{"location":"Combinatorics/simplicialcomplexes/","page":"Simplicial Complexes","title":"Simplicial Complexes","text":"General textbooks offering details on the theory include:","category":"page"},{"location":"Combinatorics/simplicialcomplexes/","page":"Simplicial Complexes","title":"Simplicial Complexes","text":"[Koz08]","category":"page"},{"location":"Combinatorics/simplicialcomplexes/#Construction","page":"Simplicial Complexes","title":"Construction","text":"","category":"section"},{"location":"Combinatorics/simplicialcomplexes/","page":"Simplicial Complexes","title":"Simplicial Complexes","text":"simplicial_complex(K::Vector{Vector{Int}})","category":"page"},{"location":"Combinatorics/simplicialcomplexes/#simplicial_complex-Tuple{Vector{Vector{Int64}}}","page":"Simplicial Complexes","title":"simplicial_complex","text":"simplical_complex(generators::Union{Vector{Vector{Int}}, Vector{Set{Int}}})\n\nConstruct an abstract simplicial complex from a set of faces. While arbitrary non-negative integers are allowed as vertices, they will be relabeled to consecutive integers starting at 1.\n\nExamples\n\njulia> K = simplicial_complex([[1,2,3],[2,3,4]])\nAbstract simplicial complex of dimension 2 on 4 vertices\n\njulia> G = complete_bipartite_graph(2,3)\nUndirected graph with 5 nodes and the following edges:\n(3, 1)(3, 2)(4, 1)(4, 2)(5, 1)(5, 2)\n\njulia> K = simplicial_complex(G)\nAbstract simplicial complex of dimension 1 on 5 vertices\n\nSimplicial complex comprising the empty set only:\n\njulia> empty = simplicial_complex(Vector{Set{Int}}([]))\nAbstract simplicial complex of dimension -1 on 0 vertices\n\nThe original vertices can be recovered:\n\njulia> L = simplicial_complex([[0,2,17],[2,17,90]]);\n\njulia> facets(L)\n2-element Vector{Set{Int64}}:\n Set([2, 3, 1])\n Set([4, 2, 3])\n\njulia> vertexindices(L)\n4-element Vector{Int64}:\n  0\n  2\n 17\n 90\n\n\n\n\n\n","category":"method"},{"location":"Combinatorics/simplicialcomplexes/#Subcomplexes","page":"Simplicial Complexes","title":"Subcomplexes","text":"","category":"section"},{"location":"Combinatorics/simplicialcomplexes/","page":"Simplicial Complexes","title":"Simplicial Complexes","text":"star_subcomplex(K::SimplicialComplex, sigma::Union{Vector{Int}, Set{Int}})\nlink_subcomplex(K::SimplicialComplex, sigma::Union{Vector{Int}, Set{Int}})","category":"page"},{"location":"Combinatorics/simplicialcomplexes/#star_subcomplex-Tuple{SimplicialComplex, Union{Set{Int64}, Vector{Int64}}}","page":"Simplicial Complexes","title":"star_subcomplex","text":"star_subcomplex(K::SimplicialComplex, sigma::Union{Vector{Int}, Set{Int}})\n\nReturn the star of the face sigma in the abstract simplicial complex K.\n\nExamples\n\njulia> K = simplicial_complex([[1,2,3],[2,3,4]]);\n\njulia> star_subcomplex(K,[1])\nAbstract simplicial complex of dimension 2 on 3 vertices\n\n\n\n\n\n","category":"method"},{"location":"Combinatorics/simplicialcomplexes/#link_subcomplex-Tuple{SimplicialComplex, Union{Set{Int64}, Vector{Int64}}}","page":"Simplicial Complexes","title":"link_subcomplex","text":"link_subcomplex(K::SimplicialComplex, sigma::Union{Vector{Int}, Set{Int}})\n\nReturn the link of the face sigma in the abstract simplicial complex K.\n\nExamples\n\njulia> K = simplicial_complex([[1,2,3],[2,3,4]]);\n\njulia> link_subcomplex(K,[2,3])\nAbstract simplicial complex of dimension 0 on 2 vertices\n\n\n\n\n\n","category":"method"},{"location":"Combinatorics/simplicialcomplexes/#Surface-examples","page":"Simplicial Complexes","title":"Surface examples","text":"","category":"section"},{"location":"Combinatorics/simplicialcomplexes/","page":"Simplicial Complexes","title":"Simplicial Complexes","text":"torus()\nklein_bottle()\nreal_projective_plane()","category":"page"},{"location":"Combinatorics/simplicialcomplexes/#torus-Tuple{}","page":"Simplicial Complexes","title":"torus","text":"torus()\n\nConstruct Möbius' (vertex-minimal) 7-vertex triangulation of the torus (surface).\n\n\n\n\n\n","category":"method"},{"location":"Combinatorics/simplicialcomplexes/#klein_bottle-Tuple{}","page":"Simplicial Complexes","title":"klein_bottle","text":"klein_bottle()\n\nConstruct a 9-vertex triangulation of the Klein bottle.\n\n\n\n\n\n","category":"method"},{"location":"Combinatorics/simplicialcomplexes/#real_projective_plane-Tuple{}","page":"Simplicial Complexes","title":"real_projective_plane","text":"real_projective_plane()\n\nConstruct the (vertex-minimal) 6-vertex triangulation of the real projective plane.\n\n\n\n\n\n","category":"method"},{"location":"Combinatorics/simplicialcomplexes/#Other-examples","page":"Simplicial Complexes","title":"Other examples","text":"","category":"section"},{"location":"Combinatorics/simplicialcomplexes/","page":"Simplicial Complexes","title":"Simplicial Complexes","text":"complex_projective_plane()","category":"page"},{"location":"Combinatorics/simplicialcomplexes/#complex_projective_plane-Tuple{}","page":"Simplicial Complexes","title":"complex_projective_plane","text":"complex_projective_plane()\n\nConstruct the (vertex-minimal) 9-vertex triangulation of the complex projective plane.\n\n\n\n\n\n","category":"method"},{"location":"Combinatorics/simplicialcomplexes/#Basic-properties","page":"Simplicial Complexes","title":"Basic properties","text":"","category":"section"},{"location":"Combinatorics/simplicialcomplexes/","page":"Simplicial Complexes","title":"Simplicial Complexes","text":"n_vertices(K::SimplicialComplex)\nn_facets(K::SimplicialComplex)\ndim(K::SimplicialComplex)\nf_vector(K::SimplicialComplex)\nh_vector(K::SimplicialComplex)\neuler_characteristic(K::SimplicialComplex)","category":"page"},{"location":"Combinatorics/simplicialcomplexes/#n_vertices-Tuple{SimplicialComplex}","page":"Simplicial Complexes","title":"n_vertices","text":"n_vertices(K::SimplicialComplex)\n\nReturn the number of vertices of the abstract simplicial complex K.\n\nExamples\n\njulia> n_vertices(torus())\n7\n\n\n\n\n\n","category":"method"},{"location":"Combinatorics/simplicialcomplexes/#n_facets-Tuple{SimplicialComplex}","page":"Simplicial Complexes","title":"n_facets","text":"n_facets(K::SimplicialComplex)\n\nReturn the number of facets of the abstract simplicial complex K.\n\n\n\n\n\n","category":"method"},{"location":"Combinatorics/simplicialcomplexes/#dim-Tuple{SimplicialComplex}","page":"Simplicial Complexes","title":"dim","text":"dim(K::SimplicialComplex)\n\nReturn the dimension of the abstract simplicial complex K.\n\n\n\n\n\n","category":"method"},{"location":"Combinatorics/simplicialcomplexes/#f_vector-Tuple{SimplicialComplex}","page":"Simplicial Complexes","title":"f_vector","text":"f_vector(K::SimplicialComplex)\n\nReturn the face vector (number of faces per dimension) of the abstract simplicial complex K.\n\nExamples\n\njulia> f_vector(torus())\n3-element Vector{Int64}:\n  7\n 21\n 14\n\n\n\n\n\n","category":"method"},{"location":"Combinatorics/simplicialcomplexes/#h_vector-Tuple{SimplicialComplex}","page":"Simplicial Complexes","title":"h_vector","text":"h_vector(K::SimplicialComplex)\n\nReturn the h-vector of the abstract simplicial complex K.\n\nExamples\n\njulia> h_vector(torus())\n4-element Vector{Int64}:\n  1\n  4\n 10\n -1\n\n\n\n\n\n","category":"method"},{"location":"Combinatorics/simplicialcomplexes/#euler_characteristic-Tuple{SimplicialComplex}","page":"Simplicial Complexes","title":"euler_characteristic","text":"euler_characteristic(K::SimplicialComplex)\n\nReturn the reduced Euler characteristic of the abstract simplicial complex K.\n\nExamples\n\njulia> euler_characteristic(complex_projective_plane())\n2\n\n\n\n\n\n","category":"method"},{"location":"Combinatorics/simplicialcomplexes/#Homology-and-cohomology","page":"Simplicial Complexes","title":"Homology and cohomology","text":"","category":"section"},{"location":"Combinatorics/simplicialcomplexes/","page":"Simplicial Complexes","title":"Simplicial Complexes","text":"homology(K::SimplicialComplex, i::Int)\nbetti_numbers(K::SimplicialComplex)\ncohomology(K::SimplicialComplex, i::Int)","category":"page"},{"location":"Combinatorics/simplicialcomplexes/#homology-Tuple{SimplicialComplex, Int64}","page":"Simplicial Complexes","title":"homology","text":"homology(K::SimplicialComplex, i::Int)\n\nReturn i-th integral homology group of K.\n\nExamples\n\njulia> [ homology(real_projective_plane(), i) for i in [0,1,2] ]\n3-element Vector{FinGenAbGroup}:\n Z\n Z/2\n Z/1\n\n\n\n\n\n","category":"method"},{"location":"Combinatorics/simplicialcomplexes/#betti_numbers-Tuple{SimplicialComplex}","page":"Simplicial Complexes","title":"betti_numbers","text":"betti_numbers(K::SimplicialComplex)\n\nReturn the reduced rational Betti numbers of the abstract simplicial complex K.\n\nExamples\n\njulia> betti_numbers(klein_bottle())\n3-element Vector{Int64}:\n 0\n 1\n 0\n\n\n\n\n\n","category":"method"},{"location":"Combinatorics/simplicialcomplexes/#cohomology-Tuple{SimplicialComplex, Int64}","page":"Simplicial Complexes","title":"cohomology","text":"cohomology(K::SimplicialComplex, i::Int)\n\nReturn i-th integral cohomology group of K.\n\nExamples\n\njulia> K = simplicial_complex([[0,1],[1,2],[0,2]]);\n\njulia> cohomology(K,1)\nZ\n\n\n\n\n\n","category":"method"},{"location":"Combinatorics/simplicialcomplexes/#Fundamental-group","page":"Simplicial Complexes","title":"Fundamental group","text":"","category":"section"},{"location":"Combinatorics/simplicialcomplexes/","page":"Simplicial Complexes","title":"Simplicial Complexes","text":"fundamental_group(K::SimplicialComplex)","category":"page"},{"location":"Combinatorics/simplicialcomplexes/#fundamental_group-Tuple{SimplicialComplex}","page":"Simplicial Complexes","title":"fundamental_group","text":"fundamental_group(K::SimplicialComplex)\n\nReturn the fundamental group of the abstract simplicial complex K.\n\nExamples\n\njulia> pi_1 = fundamental_group(torus());\n\njulia> describe(pi_1)\n\"Z x Z\"\n\n\n\n\n\n","category":"method"},{"location":"Combinatorics/simplicialcomplexes/#Recognizing-topological-spaces","page":"Simplicial Complexes","title":"Recognizing topological spaces","text":"","category":"section"},{"location":"Combinatorics/simplicialcomplexes/","page":"Simplicial Complexes","title":"Simplicial Complexes","text":"is_sphere(K::SimplicialComplex)\nis_ball(K::SimplicialComplex)\nis_manifold(K::SimplicialComplex)","category":"page"},{"location":"Combinatorics/simplicialcomplexes/#is_sphere-Tuple{SimplicialComplex}","page":"Simplicial Complexes","title":"is_sphere","text":"is_sphere(K::SimplicialComplex)\n\nHeuristically check if the abstract simplicial complex K is a combinatorial sphere; see [JLLT22]. Note that this is undecidable in general. Returns true if recognized as a sphere. Returns false if not a sphere. Returns nothing if heuristics unsuccessful.\n\nExamples\n\njulia> K = simplicial_complex([[1,2,3],[2,3,4]]);\n\njulia> is_sphere(K)\nfalse\n\n\n\n\n\n","category":"method"},{"location":"Combinatorics/simplicialcomplexes/#is_ball-Tuple{SimplicialComplex}","page":"Simplicial Complexes","title":"is_ball","text":"is_ball(K::SimplicialComplex)\n\nHeuristically check if the abstract simplicial complex K is a combinatorial ball; see [JLLT22]. Note that this is undecidable in general. Returns true if recognized as a ball. Returns false if not a ball. Returns nothing if heuristics unsuccessful.\n\nExamples\n\njulia> K = simplicial_complex([[1,2,3],[2,3,4]]);\n\njulia> is_ball(K)\ntrue\n\n\n\n\n\n","category":"method"},{"location":"Combinatorics/simplicialcomplexes/#is_manifold-Tuple{SimplicialComplex}","page":"Simplicial Complexes","title":"is_manifold","text":"is_manifold(K::SimplicialComplex)\n\nCheck if the abstract simplicial complex K is a combinatorial manifold, possibly with boundary. Note that this is undecidable in general. Returns true if recognized as a manifold. Returns false if not a manifold. Returns nothing if heuristics unsuccessful.\n\nExamples\n\njulia> is_manifold(torus())\ntrue\n\njulia> is_manifold(simplicial_complex([[1,2],[2,3]]))\ntrue\n\njulia> is_manifold(simplicial_complex([[1,2],[2,3],[2,4]]))\nfalse\n\n\n\n\n\n","category":"method"},{"location":"Combinatorics/simplicialcomplexes/#Connection-to-commutative-algebra","page":"Simplicial Complexes","title":"Connection to commutative algebra","text":"","category":"section"},{"location":"Combinatorics/simplicialcomplexes/","page":"Simplicial Complexes","title":"Simplicial Complexes","text":"The complements of the minimal non-faces form the facets of the Alexander dual.","category":"page"},{"location":"Combinatorics/simplicialcomplexes/","page":"Simplicial Complexes","title":"Simplicial Complexes","text":"minimal_nonfaces(K::SimplicialComplex)\nalexander_dual(K::SimplicialComplex)","category":"page"},{"location":"Combinatorics/simplicialcomplexes/#minimal_nonfaces-Tuple{SimplicialComplex}","page":"Simplicial Complexes","title":"minimal_nonfaces","text":"minimal_nonfaces(K::SimplicialComplex)\n\nReturn the minimal non-faces of the abstract simplicial complex K.\n\nExamples\n\njulia> K = simplicial_complex([[1,2,3],[2,3,4]]);\n\njulia> minimal_nonfaces(K)\n1-element Vector{Set{Int64}}:\n Set([4, 1])\n\n\n\n\n\n","category":"method"},{"location":"Combinatorics/simplicialcomplexes/#alexander_dual-Tuple{SimplicialComplex}","page":"Simplicial Complexes","title":"alexander_dual","text":"alexander_dual(K::SimplicialComplex)\n\nReturn the Alexander dual of the abstract simplicial complex K.\n\nExamples\n\njulia> K = simplicial_complex([[1,2,3],[2,3,4]]);\n\njulia> alexander_dual(K)\nAbstract simplicial complex of dimension 1 on 2 vertices\n\n\n\n\n\n","category":"method"},{"location":"Combinatorics/simplicialcomplexes/","page":"Simplicial Complexes","title":"Simplicial Complexes","text":"Let K be a simplicial complex on n vertices. The minimal non-faces of K generate a square-free monomial ideal, known as the Stanley-Reisner ideal of K. The quotient of the polynomial ring (in n variables, with integer coefficients) modulo that ideal is the Stanley-Reisner ring. For details see Chapter 5 of [BH09].","category":"page"},{"location":"Combinatorics/simplicialcomplexes/","page":"Simplicial Complexes","title":"Simplicial Complexes","text":"stanley_reisner_ideal(K::SimplicialComplex)\nstanley_reisner_ideal(R::MPolyRing, K::SimplicialComplex)\nstanley_reisner_ring(K::SimplicialComplex)\nstanley_reisner_ring(R::MPolyRing, K::SimplicialComplex)","category":"page"},{"location":"Combinatorics/simplicialcomplexes/#stanley_reisner_ideal-Tuple{SimplicialComplex}","page":"Simplicial Complexes","title":"stanley_reisner_ideal","text":"stanley_reisner_ideal(K::SimplicialComplex)\n\nReturn the Stanley-Reisner ideal of the abstract simplicial complex K.\n\nExamples\n\njulia> stanley_reisner_ideal(real_projective_plane())\nIdeal generated by\n  x1*x2*x3\n  x1*x2*x4\n  x1*x5*x6\n  x2*x5*x6\n  x1*x3*x6\n  x1*x4*x5\n  x3*x4*x5\n  x3*x4*x6\n  x2*x3*x5\n  x2*x4*x6\n\n\n\n\n\n","category":"method"},{"location":"Combinatorics/simplicialcomplexes/#stanley_reisner_ideal-Tuple{MPolyRing, SimplicialComplex}","page":"Simplicial Complexes","title":"stanley_reisner_ideal","text":"stanley_reisner_ideal(R::MPolyRing, K::SimplicialComplex)\n\nReturn the Stanley-Reisner ideal of the abstract simplicial complex K, in the given ring R.\n\nExamples\n\njulia> R, _ = QQ[:a, :b, :c, :d, :e, :f];\n\njulia> stanley_reisner_ideal(R, real_projective_plane())\nIdeal generated by\n  a*b*c\n  a*b*d\n  a*e*f\n  b*e*f\n  a*c*f\n  a*d*e\n  c*d*e\n  c*d*f\n  b*c*e\n  b*d*f\n\n\n\n\n\n","category":"method"},{"location":"Combinatorics/simplicialcomplexes/#stanley_reisner_ring-Tuple{SimplicialComplex}","page":"Simplicial Complexes","title":"stanley_reisner_ring","text":"stanley_reisner_ring(K::SimplicialComplex)\n\nReturn the Stanley-Reisner ring of the abstract simplicial complex K.\n\nExamples\n\njulia> K = simplicial_complex([[1,2,3],[2,3,4]]);\n\njulia> stanley_reisner_ring(K)\n(Quotient of multivariate polynomial ring by ideal (x1*x4), Map: multivariate polynomial ring -> quotient of multivariate polynomial ring)\n\n\n\n\n\n","category":"method"},{"location":"Combinatorics/simplicialcomplexes/#stanley_reisner_ring-Tuple{MPolyRing, SimplicialComplex}","page":"Simplicial Complexes","title":"stanley_reisner_ring","text":"stanley_reisner_ring(R::MPolyRing, K::SimplicialComplex)\n\nReturn the Stanley-Reisner ring of the abstract simplicial complex K, as a quotient of a given ring R.\n\nExamples\n\njulia>  R, _ = ZZ[:a, :b, :c, :d, :e, :f];\n\njulia> stanley_reisner_ring(R, real_projective_plane())\n(Quotient of multivariate polynomial ring by ideal (a*b*c, a*b*d, a*e*f, b*e*f, a*c*f, a*d*e, c*d*e, c*d*f, b*c*e, b*d*f), Map: R -> quotient of multivariate polynomial ring)\n\n\n\n\n\n","category":"method"},{"location":"Combinatorics/simplicialcomplexes/#Helpful-functions","page":"Simplicial Complexes","title":"Helpful functions","text":"","category":"section"},{"location":"Combinatorics/simplicialcomplexes/","page":"Simplicial Complexes","title":"Simplicial Complexes","text":"is_isomorphic(K1::SimplicialComplex, K2::SimplicialComplex)\nconnected_sum(K1::SimplicialComplex, K2::SimplicialComplex, f1::Int=0, f2::Int=0)\ndeletion(K::SimplicialComplex, face::Union{<:AbstractSet{Int},<:AbstractVector{Int}})\nautomorphism_group(K::SimplicialComplex; action=:on_vertices)\non_simplicial_complex(K::SimplicialComplex, g::PermGroupElem)","category":"page"},{"location":"Combinatorics/simplicialcomplexes/#is_isomorphic-Tuple{SimplicialComplex, SimplicialComplex}","page":"Simplicial Complexes","title":"is_isomorphic","text":"is_isomorphic(K1::SimplicialComplex, K2::SimplicialComplex)\n\nChecks if the given simplicial complexes are isomorphic.\n\nExamples\n\njulia> K1 = simplicial_complex([[1,2,3],[2,3,4]]);\n\njulia> K2 = simplicial_complex([[1,2,3],[2,3,4]]);\n\njulia> is_isomorphic(K1, K2)\ntrue\n\n\n\n\n\n","category":"method"},{"location":"Combinatorics/simplicialcomplexes/#connected_sum","page":"Simplicial Complexes","title":"connected_sum","text":"connected_sum(K1::SimplicialComplex, K2::SimplicialComplex, f1::Int=0, f2::Int=0)\n\nCompute the connected sum of two abstract simplicial complexes. Parameters f1 and f2 specify which facet  of the first and second complex correspondingly are glued together. Default is the 0-th facet of both. The vertices in the selected facets are identified with each other according to their order in the facet (that is, in increasing index order).\n\nExamples\n\njulia> K = torus();\n\njulia> surface_genus_2 = connected_sum(K, K)\nAbstract simplicial complex of dimension 2 on 11 vertices\n\njulia> homology(surface_genus_2, 1)\nZ^4\n\njulia> is_manifold(surface_genus_2)\ntrue\n\n\n\n\n\n","category":"function"},{"location":"Combinatorics/simplicialcomplexes/#deletion-Tuple{SimplicialComplex, Union{AbstractSet{Int64}, AbstractVector{Int64}}}","page":"Simplicial Complexes","title":"deletion","text":"deletion(K::SimplicialComplex, face::Union{<:AbstractSet{Int},<:AbstractVector{Int}})\n\nRemove the given face and all the faces containing it from an abstract simplicial complex K.\n\nExamples\n\njulia> K = simplicial_complex([[1, 2, 3], [2, 3, 4]]);\n\njulia> K_with_deletion = deletion(K, Set([1, 2]));\n\njulia> facets(K_with_deletion)\n2-element Vector{Set{Int64}}:\n Set([3, 1])\n Set([4, 2, 3])\n\n\n\n\n\n","category":"method"},{"location":"Combinatorics/simplicialcomplexes/#automorphism_group-Tuple{SimplicialComplex}","page":"Simplicial Complexes","title":"automorphism_group","text":"automorphism_group(K::SimplicialComplex; action=:on_vertices)\n\nGiven a simplicial complex K return its automorphism group as a PermGroup. The group can be returned as a subgroup of the permutation group of the vertices by passing :on_vertices to the action keyword argument or on the facets  by passing :on_facets.\n\nExamples\n\njulia> K = simplicial_complex([[1, 2, 3], [2, 3, 4]])\nAbstract simplicial complex of dimension 2 on 4 vertices\n\njulia> automorphism_group(K)\nPermutation group of degree 4\n\n\n\n\n\n","category":"method"},{"location":"Combinatorics/simplicialcomplexes/#on_simplicial_complex-Tuple{SimplicialComplex, PermGroupElem}","page":"Simplicial Complexes","title":"on_simplicial_complex","text":"on_simplicial_complex(K::SimplicialComplex, g::PermGroupElem)\n\nGiven a simplicial complex K return the simplicial complex corresponding to a permutation on it's vertices given by g.\n\nExamples\n\njulia> K = simplicial_complex([[1, 2, 3], [2, 3, 4]])\nAbstract simplicial complex of dimension 2 on 4 vertices\n\njulia> G = automorphism_group(K)\nPermutation group of degree 4\n\njulia> g = collect(G)[2]\n(1,4)\n\njulia> facets(on_simplicial_complex(K, g))\n2-element Vector{Set{Int64}}:\n Set([2, 3, 1])\n Set([4, 2, 3])\n\n\n\n\n\n","category":"method"},{"location":"Combinatorics/simplicialcomplexes/#Saving-and-loading","page":"Simplicial Complexes","title":"Saving and loading","text":"","category":"section"},{"location":"Combinatorics/simplicialcomplexes/","page":"Simplicial Complexes","title":"Simplicial Complexes","text":"Objects of type SimplicialComplex can be saved to a file and loaded with the two methods save and load.  The file is in JSON format and contains the underlying polymake object.  In particular, such a file can be read by both polymake and OSCAR.","category":"page"},{"location":"NoncommutativeAlgebra/intro/","page":"Introduction","title":"Introduction","text":"CurrentModule = Oscar","category":"page"},{"location":"NoncommutativeAlgebra/intro/#Introduction","page":"Introduction","title":"Introduction","text":"","category":"section"},{"location":"NoncommutativeAlgebra/intro/","page":"Introduction","title":"Introduction","text":"Working over a field K, our focus in this chapter is on noncommutative Gröbner bases and their application to the computational study of finitely presented associative K-algebras. At present state, OSCAR offers","category":"page"},{"location":"NoncommutativeAlgebra/intro/","page":"Introduction","title":"Introduction","text":"an evolving toolkit for dealing with PBW-algebras and their quotients modulo two-sided ideals,\nsome functionality for computing and applying (partial) two-sided Gröbner bases in free associative algebras on finitely many letters.","category":"page"},{"location":"NoncommutativeAlgebra/intro/","page":"Introduction","title":"Introduction","text":"note: Note\nIn contrast to the general case of finitely presented associative algebras, (left, right, two-sided) ideals in PBW-algebras admit finite  (left, right, two-sided) Gröbner bases. In particular, PBW-algebras are Noetherian.","category":"page"},{"location":"NoncommutativeAlgebra/intro/","page":"Introduction","title":"Introduction","text":"note: Note\nThe class of PBW-algebras includes the Weyl algebras. Algebras which arise as quotients of PBW-algebras include the Clifford algebras (in particular, the exterior algebras).","category":"page"},{"location":"NoncommutativeAlgebra/intro/","page":"Introduction","title":"Introduction","text":"The textbooks","category":"page"},{"location":"NoncommutativeAlgebra/intro/","page":"Introduction","title":"Introduction","text":"[GP08]\n[DL06]\n[BGV03]","category":"page"},{"location":"NoncommutativeAlgebra/intro/","page":"Introduction","title":"Introduction","text":"and the thesis","category":"page"},{"location":"NoncommutativeAlgebra/intro/","page":"Introduction","title":"Introduction","text":"[Lev05]","category":"page"},{"location":"NoncommutativeAlgebra/intro/","page":"Introduction","title":"Introduction","text":"offer details on theory and algorithms.","category":"page"},{"location":"NoncommutativeAlgebra/intro/#Contact","page":"Introduction","title":"Contact","text":"","category":"section"},{"location":"NoncommutativeAlgebra/intro/","page":"Introduction","title":"Introduction","text":"Please direct questions about this part of OSCAR to the following people:","category":"page"},{"location":"NoncommutativeAlgebra/intro/","page":"Introduction","title":"Introduction","text":"Wolfram Decker.","category":"page"},{"location":"NoncommutativeAlgebra/intro/","page":"Introduction","title":"Introduction","text":"You can ask questions in the OSCAR Slack.","category":"page"},{"location":"NoncommutativeAlgebra/intro/","page":"Introduction","title":"Introduction","text":"Alternatively, you can raise an issue on github.","category":"page"},{"location":"AlgebraicGeometry/Schemes/Cycles/","page":"Cycles and divisors","title":"Cycles and divisors","text":"CurrentModule = Oscar","category":"page"},{"location":"AlgebraicGeometry/Schemes/Cycles/#Cycles-and-divisors","page":"Cycles and divisors","title":"Cycles and divisors","text":"","category":"section"},{"location":"AlgebraicGeometry/Schemes/Cycles/#Algebraic-Cycles","page":"Cycles and divisors","title":"Algebraic Cycles","text":"","category":"section"},{"location":"AlgebraicGeometry/Schemes/Cycles/","page":"Cycles and divisors","title":"Cycles and divisors","text":"AbsAlgebraicCycle{CoveredSchemeType<:AbsCoveredScheme, CoefficientRingType<:AbstractAlgebra.Ring}","category":"page"},{"location":"AlgebraicGeometry/Schemes/Cycles/#AbsAlgebraicCycle","page":"Cycles and divisors","title":"AbsAlgebraicCycle","text":"AbsAlgebraicCycle{CoveredSchemeType<:AbsCoveredScheme, CoefficientRingType<:Ring}\n\nAn algebraic cycle D on a (locally) Noetherian integral scheme X with coefficients in a ring R  is a formal linear combination sum_i a_i D_i with  D_i subseteq X integral, closed subschemes and the a_i in R.\n\nSuch a cycle is represented non-uniquely as a formal sum E = sum_l b_l mathcalI_l  of equidimensional ideal sheaves mathcalI_l subseteq mathcalO_X.  For an equidimensional ideal sheaf mathcalI its interpretation as a cycle is as follows: Let V(mathcalI)=E_1 cup dots cup E_n be the decomposition of the vanishing locus of mathcalI into irreducible components E_i=V(mathcalP_i) with mathcalP_i prime.  Then E corresponds to the cycle D = sum_i=1^n mathrmcolength_mathcalP_i(mathcalI)E_i.\n\nExamples\n\njulia> P2 = projective_space(QQ,2); (s0,s1,s2) = homogeneous_coordinates(P2);\n\njulia> I = ideal_sheaf(P2,ideal([s0,s1^2]))\nSheaf of ideals\n  on scheme over QQ covered with 3 patches\n    1: [(s1//s0), (s2//s0)]   affine 2-space\n    2: [(s0//s1), (s2//s1)]   affine 2-space\n    3: [(s0//s2), (s1//s2)]   affine 2-space\nwith restrictions\n  1: Ideal (1, (s1//s0)^2)\n  2: Ideal ((s0//s1), 1)\n  3: Ideal ((s0//s2), (s1//s2)^2)\n\njulia> D = algebraic_cycle(I)\nEffective algebraic cycle\n  on scheme over QQ covered with 3 patches\nwith coefficients in integer ring\ngiven as the formal sum of\n  1 * sheaf of ideals\n\njulia> irreducible_decomposition(D)\nEffective algebraic cycle\n  on scheme over QQ covered with 3 patches\nwith coefficients in integer ring\ngiven as the formal sum of\n  2 * sheaf of prime ideals\n\n\n\n\n\n\n","category":"type"},{"location":"AlgebraicGeometry/Schemes/Cycles/#Constructors","page":"Cycles and divisors","title":"Constructors","text":"","category":"section"},{"location":"AlgebraicGeometry/Schemes/Cycles/","page":"Cycles and divisors","title":"Cycles and divisors","text":"algebraic_cycle(X::AbsCoveredScheme, R::Ring)\nalgebraic_cycle(I::AbsIdealSheaf, R::Ring)\nalgebraic_cycle(I::AbsIdealSheaf)","category":"page"},{"location":"AlgebraicGeometry/Schemes/Cycles/#algebraic_cycle-Tuple{AbsCoveredScheme, Ring}","page":"Cycles and divisors","title":"algebraic_cycle","text":"algebraic_cycle(X::AbsCoveredScheme, R::Ring) -> AlgebraicCycle\n\nReturn the zero AlgebraicCycle over X with coefficients in R.\n\nExamples\n\njulia> P, (x, y, z) = graded_polynomial_ring(QQ, [:x, :y, :z]);\n\njulia> I = ideal([x^3-y^2*z]);\n\njulia> Y = proj(P, I);\n\njulia> Ycov = covered_scheme(Y);\n\njulia> R = ZZ;\n\njulia> algebraic_cycle(Ycov, R)\nZero algebraic cycle\n  on scheme over QQ covered with 3 patches\nwith coefficients in integer ring\n\n\n\n\n\n","category":"method"},{"location":"AlgebraicGeometry/Schemes/Cycles/#algebraic_cycle-Tuple{Oscar.AbsIdealSheaf, Ring}","page":"Cycles and divisors","title":"algebraic_cycle","text":"algebraic_cycle(I::AbsIdealSheaf, R::Ring) -> AlgebraicCycle\n\nReturn the AlgebraicCycle D = 1  I with coefficients in R for a sheaf of equidimensional ideals I.\n\nNote that I must be equidimensional.\n\nExamples\n\njulia> P, (x, y, z) = graded_polynomial_ring(QQ, [:x, :y, :z]);\n\njulia> I = ideal([x^3-y^2*z]);\n\njulia> Y = proj(P);\n\njulia> II = IdealSheaf(Y, I);\n\njulia> R = ZZ;\n\njulia> algebraic_cycle(II, R)\nEffective algebraic cycle\n  on scheme over QQ covered with 3 patches\nwith coefficients in integer ring\ngiven as the formal sum of\n  1 * sheaf of ideals\n\n\n\n\n\n\n","category":"method"},{"location":"AlgebraicGeometry/Schemes/Cycles/#algebraic_cycle-Tuple{Oscar.AbsIdealSheaf}","page":"Cycles and divisors","title":"algebraic_cycle","text":"algebraic_cycle(I::AbsIdealSheaf) -> AlgebraicCycle\n\nReturn the AlgebraicCycle D = 1  I with coefficients in ℤ for a sheaf of equidimensional ideals I.\n\nExamples\n\njulia> P, (x, y, z) = graded_polynomial_ring(QQ, [:x, :y, :z]);\n\njulia> I = ideal([x^3-y^2*z]);\n\njulia> Y = proj(P);\n\njulia> II = IdealSheaf(Y, I);\n\njulia> R = ZZ;\n\njulia> algebraic_cycle(II, R)\nEffective algebraic cycle\n  on scheme over QQ covered with 3 patches\nwith coefficients in integer ring\ngiven as the formal sum of\n  1 * sheaf of ideals\n\n\n\n\n\n","category":"method"},{"location":"AlgebraicGeometry/Schemes/Cycles/#Properties","page":"Cycles and divisors","title":"Properties","text":"","category":"section"},{"location":"AlgebraicGeometry/Schemes/Cycles/","page":"Cycles and divisors","title":"Cycles and divisors","text":"ambient_scheme(D::AbsAlgebraicCycle)\ncomponents(D::AbsAlgebraicCycle)\ndim(D::AbsAlgebraicCycle)\nirreducible_decomposition(D::AbsAlgebraicCycle)\nintegral(W::AbsAlgebraicCycle; check::Bool=true)","category":"page"},{"location":"AlgebraicGeometry/Schemes/Cycles/#ambient_scheme-Tuple{AbsAlgebraicCycle}","page":"Cycles and divisors","title":"ambient_scheme","text":"ambient_scheme(D::AbsAlgebraicCycle)\n\nReturn the CoveredScheme X on which D is defined.\n\n\n\n\n\n","category":"method"},{"location":"AlgebraicGeometry/Schemes/Cycles/#components-Tuple{AbsAlgebraicCycle}","page":"Cycles and divisors","title":"components","text":"components(D::AbsAlgebraicCycle)\n\nReturn a list of ideal sheaves such that D is a linear combination of the corresponding cycles.\n\nnote: Note\nThe order of the components may change in different julia sessions. It is however consistent with the printing.\n\nnote: Note\nThe ideal sheaves are only guaranteed equidimensional and may carry multiplicities. See irreducible_decomposition(::AbsAlgebraicCycle) for the more conventional decomposition. \n\n\n\n\n\n","category":"method"},{"location":"AlgebraicGeometry/Schemes/Cycles/#dim-Tuple{AbsAlgebraicCycle}","page":"Cycles and divisors","title":"dim","text":"dim(D::AbsAlgebraicCycle)\n\nReturn the dimension of the support of the cycle D.\n\n\n\n\n\n","category":"method"},{"location":"AlgebraicGeometry/Schemes/Cycles/#irreducible_decomposition-Tuple{AbsAlgebraicCycle}","page":"Cycles and divisors","title":"irreducible_decomposition","text":"irreducible_decomposition(D::AbsAlgebraicCycle)\n\nReturn a cycle E equal to D but as a formal sum E = ₖ aₖ  Iₖ where the components Iₖ of E are pairwise distinct sheaves of prime ideals.\n\n\n\n\n\n","category":"method"},{"location":"AlgebraicGeometry/Schemes/Cycles/#integral-Tuple{AbsAlgebraicCycle}","page":"Cycles and divisors","title":"integral","text":"integral(W::AbsAlgebraicCycle)\n\nAssume W is an algebraic cycle on X. This returns the sum of  the lengths of all the components of dimension 0 of W.\n\n\n\n\n\n","category":"method"},{"location":"AlgebraicGeometry/Schemes/Cycles/#Attributes","page":"Cycles and divisors","title":"Attributes","text":"","category":"section"},{"location":"AlgebraicGeometry/Schemes/Cycles/","page":"Cycles and divisors","title":"Cycles and divisors","text":"is_effective(A::AbsAlgebraicCycle)\nis_prime(D::AbsAlgebraicCycle)","category":"page"},{"location":"AlgebraicGeometry/Schemes/Cycles/#is_effective-Tuple{AbsAlgebraicCycle}","page":"Cycles and divisors","title":"is_effective","text":"is_effective(A::AbsAlgebraicCycle)\n\nReturn whether all the coefficients are non-negative.\n\n\n\n\n\n","category":"method"},{"location":"AlgebraicGeometry/Schemes/Cycles/#is_prime-Tuple{AbsAlgebraicCycle}","page":"Cycles and divisors","title":"is_prime","text":"is_prime(D::AbsAlgebraicCycle)\n\nAn algebraic cycle is called prime if it consists of a single irreducible subvariety.\n\nNote that this property is not stable under base extension. \n\n\n\n\n\n","category":"method"},{"location":"AlgebraicGeometry/Schemes/Cycles/#Methods","page":"Cycles and divisors","title":"Methods","text":"","category":"section"},{"location":"AlgebraicGeometry/Schemes/Cycles/","page":"Cycles and divisors","title":"Cycles and divisors","text":"Base.:<=(A::AbsAlgebraicCycle,B::AbsAlgebraicCycle)","category":"page"},{"location":"AlgebraicGeometry/Schemes/Cycles/#<=-Tuple{AbsAlgebraicCycle, AbsAlgebraicCycle}","page":"Cycles and divisors","title":"<=","text":"Base.:<=(A::AbsAlgebraicCycle, B::AbsAlgebraicCycle)\n\nA leq B\n\nif and only if B - A is effective.\n\n\n\n\n\n","category":"method"},{"location":"AlgebraicGeometry/Schemes/Cycles/#Weil-Divisors","page":"Cycles and divisors","title":"Weil Divisors","text":"","category":"section"},{"location":"AlgebraicGeometry/Schemes/Cycles/","page":"Cycles and divisors","title":"Cycles and divisors","text":"AbsWeilDivisor{CoveredSchemeType, CoefficientRingType}","category":"page"},{"location":"AlgebraicGeometry/Schemes/Cycles/#AbsWeilDivisor","page":"Cycles and divisors","title":"AbsWeilDivisor","text":"AbsWeilDivisor{CoveredSchemeType, CoefficientRingType} <: AbsAlgebraicCycle{CoveredSchemeType, CoefficientRingType}\n\nA Weil divisor with coefficients of type CoefficientRingType on a (locally) Noetherian integral scheme X  of type CoveredSchemeType.\n\nExamples\n\njulia> P2 = projective_space(QQ,2); (s0,s1,s2) = homogeneous_coordinates(P2);\n\njulia> I = ideal((s0*s1)^2);\n\njulia> II = ideal_sheaf(P2, I);\n\njulia> D = weil_divisor(II)\nEffective weil divisor\n  on scheme over QQ covered with 3 patches\nwith coefficients in integer ring\ngiven as the formal sum of\n  1 * sheaf of ideals\n\njulia> E = irreducible_decomposition(D)\nEffective weil divisor\n  on scheme over QQ covered with 3 patches\nwith coefficients in integer ring\ngiven as the formal sum of\n  2 * prime ideal sheaf on scheme over QQ covered with 3 patches extended from ideal ((s1//s0)) on affine 2-space\n  2 * prime ideal sheaf on scheme over QQ covered with 3 patches extended from ideal ((s0//s1)) on affine 2-space\n\njulia> P = components(E)[1]\nPrime ideal sheaf on Scheme over QQ covered with 3 patches extended from Ideal ((s1//s0)) on Affine 2-space\n\njulia> components(D)[1] == II\ntrue\n\njulia> D[II] # to get the coefficient\n1\n\njulia> E[P]\n2\n\n\n\n\n\n","category":"type"},{"location":"AlgebraicGeometry/Schemes/Cycles/#Constructors-2","page":"Cycles and divisors","title":"Constructors","text":"","category":"section"},{"location":"AlgebraicGeometry/Schemes/Cycles/","page":"Cycles and divisors","title":"Cycles and divisors","text":"weil_divisor(X::AbsCoveredScheme, R::Ring)\nweil_divisor(I::AbsIdealSheaf; check::Bool=true)\nweil_divisor(I::AbsIdealSheaf, R::Ring; check::Bool=true)","category":"page"},{"location":"AlgebraicGeometry/Schemes/Cycles/#weil_divisor-Tuple{AbsCoveredScheme, Ring}","page":"Cycles and divisors","title":"weil_divisor","text":"weil_divisor(X::AbsCoveredScheme, R::Ring) -> WeilDivisor\n\nReturn the zero weil divisor on X with coefficients in the ring R.\n\nExamples\n\njulia> P, (x, y, z) = graded_polynomial_ring(QQ, [:x, :y, :z]);\n\njulia> I = ideal([x^3-y^2*z]);\n\njulia> Y = proj(P, I);\n\njulia> Ycov = covered_scheme(Y);\n\njulia> weil_divisor(Ycov, QQ)\nZero weil divisor\n  on scheme over QQ covered with 3 patches\nwith coefficients in rational field\n\n\n\n\n\n","category":"method"},{"location":"AlgebraicGeometry/Schemes/Cycles/#weil_divisor-Tuple{Oscar.AbsIdealSheaf}","page":"Cycles and divisors","title":"weil_divisor","text":"weil_divisor(I::AbsIdealSheaf) -> WeilDivisor\n\nGiven an ideal sheaf I of pure codimension 1, return the weil divisor D = 1  I with coefficients in the integer ring.\n\nExamples\n\njulia> P, (x, y, z) = graded_polynomial_ring(QQ, [:x, :y, :z]);\n\njulia> Y = proj(P);\n\njulia> I = ideal([(x^3-y^2*z)]);\n\njulia> II = IdealSheaf(Y, I);\n\njulia> weil_divisor(II)\nEffective weil divisor\n  on scheme over QQ covered with 3 patches\nwith coefficients in integer ring\ngiven as the formal sum of\n  1 * sheaf of ideals\n  \njulia> JJ = II^2;\n\njulia> D = weil_divisor(JJ)\nEffective weil divisor\n  on scheme over QQ covered with 3 patches\nwith coefficients in integer ring\ngiven as the formal sum of\n  1 * product of 2 ideal sheaves\n\njulia> irreducible_decomposition(D)\nEffective weil divisor\n  on scheme over QQ covered with 3 patches\nwith coefficients in integer ring\ngiven as the formal sum of\n  2 * sheaf of prime ideals\n\n\n\n\n\n\n","category":"method"},{"location":"AlgebraicGeometry/Schemes/Cycles/#weil_divisor-Tuple{Oscar.AbsIdealSheaf, Ring}","page":"Cycles and divisors","title":"weil_divisor","text":"weil_divisor(I::AbsIdealSheaf, R::Ring; check::Bool=true)\n\nGiven an ideal sheaf I of pure codimension 1 and a ring R, return the weil divisor D = 1  I with coefficients in R.\n\n\n\n\n\n","category":"method"},{"location":"AlgebraicGeometry/Schemes/Cycles/#Methods-2","page":"Cycles and divisors","title":"Methods","text":"","category":"section"},{"location":"AlgebraicGeometry/Schemes/Cycles/","page":"Cycles and divisors","title":"Cycles and divisors","text":"Besides the methods for AbsAlgebraicCycle the following are available.","category":"page"},{"location":"AlgebraicGeometry/Schemes/Cycles/","page":"Cycles and divisors","title":"Cycles and divisors","text":"is_in_linear_system(f::VarietyFunctionFieldElem, D::AbsWeilDivisor; regular_on_complement::Bool=false, check::Bool=true)\norder_of_vanishing(f::VarietyFunctionFieldElem, D::AbsWeilDivisor; check::Bool=true)\nintersect(D::AbsWeilDivisor, E::AbsWeilDivisor; covering::Covering=default_covering(scheme(D)))","category":"page"},{"location":"AlgebraicGeometry/Schemes/Cycles/#is_in_linear_system-Tuple{VarietyFunctionFieldElem, Oscar.AbsWeilDivisor}","page":"Cycles and divisors","title":"is_in_linear_system","text":"is_in_linear_system(f::VarietyFunctionFieldElem, D::AbsWeilDivisor; regular_on_complement::Bool=true, check::Bool=true) -> Bool\n\nReturn whether the rational function f is in the linear system D, i.e. if (f) + D geq 0.\n\nInput\n\nregular_on_complement – set to true if f is regular on the complement of the support of D. \n\n\n\n\n\n","category":"method"},{"location":"AlgebraicGeometry/Schemes/Cycles/#order_of_vanishing-Tuple{VarietyFunctionFieldElem, Oscar.AbsWeilDivisor}","page":"Cycles and divisors","title":"order_of_vanishing","text":"order_of_vanishing(f::VarietyFunctionFieldElem, D::AbsWeilDivisor; check::Bool=true)\n\nReturn the order of vanishing of the rational function f on the prime divisor D.\n\n\n\n\n\n","category":"method"},{"location":"AlgebraicGeometry/Schemes/Cycles/#intersect-Tuple{Oscar.AbsWeilDivisor, Oscar.AbsWeilDivisor}","page":"Cycles and divisors","title":"intersect","text":"intersect(D::AbsWeilDivisor, E::AbsWeilDivisor; covering::Covering=default_covering(ambient_scheme(D)))\n\nReturn the intersection number of the the Weil divisors D and E on a complete smooth surface as defined in [Har77].\n\nInput\n\nThe optional keyword argument covering specifies the covering to be used for the computation.\n\n\n\n\n\n","category":"method"},{"location":"AlgebraicGeometry/Schemes/Cycles/#Linear-Systems","page":"Cycles and divisors","title":"Linear Systems","text":"","category":"section"},{"location":"AlgebraicGeometry/Schemes/Cycles/","page":"Cycles and divisors","title":"Cycles and divisors","text":"LinearSystem{DivisorType<:AbsWeilDivisor}\nweil_divisor(L::LinearSystem)\nvariety(L::LinearSystem)\nsubsystem(L::LinearSystem, D::AbsWeilDivisor)","category":"page"},{"location":"AlgebraicGeometry/Schemes/Cycles/#LinearSystem","page":"Cycles and divisors","title":"LinearSystem","text":"LinearSystem\n\nA linear system of a Weil divisor D on a variety X,  generated by rational functions f₁fᵣ  K(X).\n\n\n\n\n\n","category":"type"},{"location":"AlgebraicGeometry/Schemes/Cycles/#weil_divisor-Tuple{LinearSystem}","page":"Cycles and divisors","title":"weil_divisor","text":"weil_divisor(L::LinearSystem)\n\nReturn the divisor D of the linear system L = D.\n\n\n\n\n\n","category":"method"},{"location":"AlgebraicGeometry/Schemes/Cycles/#variety-Tuple{LinearSystem}","page":"Cycles and divisors","title":"variety","text":"variety(L::LinearSystem)\n\nReturn the variety on which L is defined.\n\n\n\n\n\n","category":"method"},{"location":"AlgebraicGeometry/Schemes/Cycles/#subsystem-Tuple{LinearSystem, Oscar.AbsWeilDivisor}","page":"Cycles and divisors","title":"subsystem","text":"subsystem(L::LinearSystem, D::AbsWeilDivisor) -> LinearSystem, MatElem\n\nGiven a linear system L = E and a divisor D leq E compute D and the matrix representing the inclusion D hookrightarrow E with respect to the given bases of both systems.\n\n\n\n\n\n","category":"method"},{"location":"AlgebraicGeometry/Schemes/Cycles/#Cartier-Divisors","page":"Cycles and divisors","title":"Cartier Divisors","text":"","category":"section"},{"location":"AlgebraicGeometry/Schemes/Cycles/","page":"Cycles and divisors","title":"Cycles and divisors","text":"CartierDivisor{CoveredSchemeType<:AbsCoveredScheme, CoeffType<:RingElem}\nEffectiveCartierDivisor{CoveredSchemeType<:AbsCoveredScheme}","category":"page"},{"location":"AlgebraicGeometry/Schemes/Cycles/#CartierDivisor","page":"Cycles and divisors","title":"CartierDivisor","text":"CartierDivisor{CoveredSchemeType<:AbsCoveredScheme, CoeffType<:RingElem}\n\nA Cartier divisor C on a scheme X with coefficients a_i in a ring R is a formal linear combination  sum_i a_i D_i of effective Cartier divisors D_i.\n\nThe scheme X is of type CoveredSchemeType. The coefficients a_i are of type CoeffType.\n\n\n\n\n\n","category":"type"},{"location":"AlgebraicGeometry/Schemes/Cycles/#EffectiveCartierDivisor","page":"Cycles and divisors","title":"EffectiveCartierDivisor","text":"EffectiveCartierDivisor{CoveredSchemeType<:AbsCoveredScheme}\n\nAn effective Cartier divisor on a scheme X is a closed subscheme D subseteq X whose ideal sheaf mathcalI_D subseteq mathcalO_X is an invertible mathcalO_X-module. In particular, mathcalI_D is locally principal.\n\nInternally, C stores a trivializing_covering(C::EffectiveCartierDivisor). The scheme X is of type CoveredSchemeType.\n\n\n\n\n\n","category":"type"},{"location":"AlgebraicGeometry/Schemes/Cycles/","page":"Cycles and divisors","title":"Cycles and divisors","text":"Cartier divisors support elementary arithmetic.","category":"page"},{"location":"AlgebraicGeometry/Schemes/Cycles/#Constructors-3","page":"Cycles and divisors","title":"Constructors","text":"","category":"section"},{"location":"AlgebraicGeometry/Schemes/Cycles/","page":"Cycles and divisors","title":"Cycles and divisors","text":"effective_cartier_divisor(I::AbsIdealSheaf; trivializing_covering::Covering = default_covering(scheme(I)), check::Bool = true)\neffective_cartier_divisor(IP::AbsProjectiveScheme, f::Union{MPolyDecRingElem, MPolyQuoRingElem})\ncartier_divisor(E::EffectiveCartierDivisor)\ncartier_divisor(IP::AbsProjectiveScheme, f::Union{MPolyDecRingElem, MPolyQuoRingElem})","category":"page"},{"location":"AlgebraicGeometry/Schemes/Cycles/#effective_cartier_divisor-Tuple{Oscar.AbsIdealSheaf}","page":"Cycles and divisors","title":"effective_cartier_divisor","text":"effective_cartier_divisor(I::IdealSheaf;\n                          trivializing_covering::Covering = default_covering(scheme(I)))\n                                                            -> EffectiveCartierDivisor\n\nReturn the effective Cartier divisor defined by the ideal sheaf I, given that I is principal in the given covering of the scheme on which it is defined.\n\nExamples\n\njulia> P, (x, y, z) = graded_polynomial_ring(QQ, [:x, :y, :z]);\n\njulia> I = ideal([x^3-y^2*z]);\n\njulia> Y = proj(P);\n\njulia> II = IdealSheaf(Y, I);\n\njulia> effective_cartier_divisor(II)\nEffective cartier divisor\n  on scheme over QQ covered with 3 patches\n    1: [(y//x), (z//x)]   affine 2-space\n    2: [(x//y), (z//y)]   affine 2-space\n    3: [(x//z), (y//z)]   affine 2-space\ndefined by\n  sheaf of ideals with restrictions\n    1: Ideal (-(y//x)^2*(z//x) + 1)\n    2: Ideal ((x//y)^3 - (z//y))\n    3: Ideal ((x//z)^3 - (y//z)^2)\n\n\n\n\n\n","category":"method"},{"location":"AlgebraicGeometry/Schemes/Cycles/#effective_cartier_divisor-Tuple{AbsProjectiveScheme, Union{MPolyDecRingElem, MPolyQuoRingElem}}","page":"Cycles and divisors","title":"effective_cartier_divisor","text":"effective_cartier_divisor(IP::AbsProjectiveScheme, f::Union{MPolyDecRingElem, MPolyQuoRingElem})\n\nReturn the effective Cartier divisor on the projective scheme X defined by the homogeneous  polynomial f. \n\n\n\n\n\n","category":"method"},{"location":"AlgebraicGeometry/Schemes/Cycles/#cartier_divisor-Tuple{EffectiveCartierDivisor}","page":"Cycles and divisors","title":"cartier_divisor","text":"cartier_divisor(E::EffectiveCartierDivisor) -> CartierDivisor\n\nConvert an EffectiveCartierDivisor into a CartierDivisor with coefficient 1 in the ring of integers.\n\nExamples\n\njulia> P, (x, y, z) = graded_polynomial_ring(QQ, [:x, :y, :z]);\n\njulia> I = ideal([x^3-y^2*z]);\n\njulia> Y = proj(P);\n\njulia> II = IdealSheaf(Y, I);\n\njulia> E = effective_cartier_divisor(II)\nEffective cartier divisor\n  on scheme over QQ covered with 3 patches\n    1: [(y//x), (z//x)]   affine 2-space\n    2: [(x//y), (z//y)]   affine 2-space\n    3: [(x//z), (y//z)]   affine 2-space\ndefined by\n  sheaf of ideals with restrictions\n    1: Ideal (-(y//x)^2*(z//x) + 1)\n    2: Ideal ((x//y)^3 - (z//y))\n    3: Ideal ((x//z)^3 - (y//z)^2)\n\njulia> cartier_divisor(E)\nCartier divisor\n  on scheme over QQ covered with 3 patches\nwith coefficients in integer ring\ndefined by the formal sum of\n  1 * effective cartier divisor on scheme over QQ covered with 3 patches\n\n\n\n\n\n","category":"method"},{"location":"AlgebraicGeometry/Schemes/Cycles/#cartier_divisor-Tuple{AbsProjectiveScheme, Union{MPolyDecRingElem, MPolyQuoRingElem}}","page":"Cycles and divisors","title":"cartier_divisor","text":"cartier_divisor(IP::AbsProjectiveScheme, f::Union{MPolyDecRingElem, MPolyQuoRingElem})\n\nReturn the (effective) Cartier divisor on the projective scheme X defined by the homogeneous  polynomial f. \n\n\n\n\n\n","category":"method"},{"location":"AlgebraicGeometry/Schemes/Cycles/#Attributes-2","page":"Cycles and divisors","title":"Attributes","text":"","category":"section"},{"location":"AlgebraicGeometry/Schemes/Cycles/","page":"Cycles and divisors","title":"Cycles and divisors","text":"ideal_sheaf(C::EffectiveCartierDivisor)\nambient_scheme(C::EffectiveCartierDivisor)\nambient_scheme(C::CartierDivisor)\ncoefficient_ring(C::CartierDivisor)\ncomponents(C::CartierDivisor)\ntrivializing_covering(C::EffectiveCartierDivisor)","category":"page"},{"location":"AlgebraicGeometry/Schemes/Cycles/#ideal_sheaf-Tuple{EffectiveCartierDivisor}","page":"Cycles and divisors","title":"ideal_sheaf","text":"ideal_sheaf(C::EffectiveCartierDivisor)\n\nReturn the sheaf of ideals mathcalI_C subseteq mathcalO_X representing C.\n\n\n\n\n\n","category":"method"},{"location":"AlgebraicGeometry/Schemes/Cycles/#ambient_scheme-Tuple{EffectiveCartierDivisor}","page":"Cycles and divisors","title":"ambient_scheme","text":"ambient_scheme(C::EffectiveCartierDivisor)\n\nReturn the ambient scheme containing C. \n\n\n\n\n\n","category":"method"},{"location":"AlgebraicGeometry/Schemes/Cycles/#ambient_scheme-Tuple{CartierDivisor}","page":"Cycles and divisors","title":"ambient_scheme","text":"ambient_scheme(C::CartierDivisor)\n\nReturn the ambient scheme containing C. \n\n\n\n\n\n","category":"method"},{"location":"AlgebraicGeometry/Schemes/Cycles/#coefficient_ring-Tuple{CartierDivisor}","page":"Cycles and divisors","title":"coefficient_ring","text":"coefficient_ring(C::CartierDivisor)\n\nReturn the ring of coefficients of C.\n\n\n\n\n\n","category":"method"},{"location":"AlgebraicGeometry/Schemes/Cycles/#components-Tuple{CartierDivisor}","page":"Cycles and divisors","title":"components","text":"components(C::CartierDivisor)\n\nReturn a list of effective Cartier divisors C_i such that C is a linear combination of the C_i.\n\n\n\n\n\n","category":"method"},{"location":"AlgebraicGeometry/Schemes/Cycles/#trivializing_covering-Tuple{EffectiveCartierDivisor}","page":"Cycles and divisors","title":"trivializing_covering","text":"trivializing_covering(C::EffectiveCartierDivisor)\n\nReturn the trivializing covering of the effective Cartier divisor C.\n\nA covering (U_i)_i in I is called trivializing for C if  C(U_i) is principal for all i in I.\n\n\n\n\n\n","category":"method"},{"location":"AlgebraicGeometry/Schemes/CoveringsAndGluings/","page":"Coverings","title":"Coverings","text":"CurrentModule = Oscar","category":"page"},{"location":"AlgebraicGeometry/Schemes/CoveringsAndGluings/#Coverings","page":"Coverings","title":"Coverings","text":"","category":"section"},{"location":"AlgebraicGeometry/Schemes/CoveringsAndGluings/","page":"Coverings","title":"Coverings","text":"Coverings are the backbone data structure for CoveredSchemes in Oscar. ","category":"page"},{"location":"AlgebraicGeometry/Schemes/CoveringsAndGluings/","page":"Coverings","title":"Coverings","text":"Covering","category":"page"},{"location":"AlgebraicGeometry/Schemes/CoveringsAndGluings/#Covering","page":"Coverings","title":"Covering","text":"Covering\n\nA covering of a scheme X by affine charts Uᵢ which are glued along isomorphisms gᵢⱼ  Uᵢ Vᵢⱼ   Vⱼᵢ  Uⱼ.\n\nNote: The distinction between the different affine charts of the scheme is made from their hashes. Thus, an affine scheme must not appear more than once in any covering!\n\n\n\n\n\n","category":"type"},{"location":"AlgebraicGeometry/Schemes/CoveringsAndGluings/#Constructors","page":"Coverings","title":"Constructors","text":"","category":"section"},{"location":"AlgebraicGeometry/Schemes/CoveringsAndGluings/","page":"Coverings","title":"Coverings","text":"Covering(patches::Vector{<:AbsAffineScheme})\ndisjoint_union(C1::Covering, C2::Covering)","category":"page"},{"location":"AlgebraicGeometry/Schemes/CoveringsAndGluings/#Covering-Tuple{Vector{<:AbsAffineScheme}}","page":"Coverings","title":"Covering","text":"Covering(patches::Vector{<:AbsAffineScheme})\n\nReturn a Covering with pairwise disjoint affine charts Uᵢ given by the entries of patches. This Covering will have no gluings except those gluings along the identity of every affine chart to itself.\n\nExamples\n\njulia> P1, (x,y) = QQ[:x, :y];\n\njulia> P2, (u,v) = QQ[:u, :v];\n\njulia> U1 = spec(P1);\n\njulia> U2 = spec(P2);\n\njulia> C = Covering([U1, U2]) # A Covering with two disjoint affine charts\nCovering\n  described by patches\n    1: affine 2-space\n    2: affine 2-space\n  in the coordinate(s)\n    1: [x, y]\n    2: [u, v]\n\n\n\n\n\n","category":"method"},{"location":"AlgebraicGeometry/Schemes/CoveringsAndGluings/#disjoint_union-Tuple{Covering, Covering}","page":"Coverings","title":"disjoint_union","text":"disjoint_union(C1::Covering, C2::Covering)\n\nReturn the Covering corresponding to the disjoint union of C1 and C2.\n\nThe charts and gluings of the disjoint union are given by the disjoint union of the charts and gluings of the covers C1 and C2.\n\nExamples\n\njulia> P1, (x,y) = QQ[:x, :y];\n\njulia> P2, (u,v) = QQ[:u, :v];\n\njulia> U1 = spec(P1);\n\njulia> U2 = spec(P2);\n\njulia> C1 = Covering(U1) # Set up the trivial covering with only one patch\nCovering\n  described by patches\n    1: affine 2-space\n  in the coordinate(s)\n    1: [x, y]\n\njulia> C2 = Covering(U2)\nCovering\n  described by patches\n    1: affine 2-space\n  in the coordinate(s)\n    1: [u, v]\n\njulia> C = disjoint_union(C1, C2)\nCovering\n  described by patches\n    1: affine 2-space\n    2: affine 2-space\n  in the coordinate(s)\n    1: [x, y]\n    2: [u, v]\n\n\n\n\n\n","category":"method"},{"location":"AlgebraicGeometry/Schemes/CoveringsAndGluings/#Attributes","page":"Coverings","title":"Attributes","text":"","category":"section"},{"location":"AlgebraicGeometry/Schemes/CoveringsAndGluings/","page":"Coverings","title":"Coverings","text":"affine_charts(C::Covering)\ngluings(C::Covering)","category":"page"},{"location":"AlgebraicGeometry/Schemes/CoveringsAndGluings/#affine_charts-Tuple{Covering}","page":"Coverings","title":"affine_charts","text":"affine_charts(C::Covering)\n\nReturn the list of affine charts that make up the Covering C.\n\n\n\n\n\n","category":"method"},{"location":"AlgebraicGeometry/Schemes/CoveringsAndGluings/#gluings-Tuple{Covering}","page":"Coverings","title":"gluings","text":"gluings(C::Covering)\n\nReturn a dictionary of gluings of the affine_charts of C.\n\nThe keys are pairs (U, V) of affine_charts. One can also use C[U, V] to obtain the respective gluing.\n\nNote: Gluings are lazy in the sense that they are in general only computed when asked for. This method only returns the internal cache, but does not try to compute new gluings.\n\n\n\n\n\n","category":"method"},{"location":"AlgebraicGeometry/Schemes/CoveringsAndGluings/#Methods","page":"Coverings","title":"Methods","text":"","category":"section"},{"location":"AlgebraicGeometry/Schemes/CoveringsAndGluings/","page":"Coverings","title":"Coverings","text":"add_gluing!(C::Covering, G::AbsGluing)","category":"page"},{"location":"AlgebraicGeometry/Schemes/CoveringsAndGluings/#add_gluing!-Tuple{Covering, AbsGluing}","page":"Coverings","title":"add_gluing!","text":"add_gluing!(C::Covering, G::AbsGluing)\n\nAdd a gluing G to the covering C.\n\nThe patches of G must be among the affine_charts of C.\n\nExamples\n\njulia> P1, (x,y) = QQ[:x, :y];\n\njulia> P2, (u,v) = QQ[:u, :v];\n\njulia> U1 = spec(P1);\n\njulia> U2 = spec(P2);\n\njulia> C = Covering([U1, U2]) # A Covering with two disjoint affine charts\nCovering\n  described by patches\n    1: affine 2-space\n    2: affine 2-space\n  in the coordinate(s)\n    1: [x, y]\n    2: [u, v]\n\njulia> V1 = PrincipalOpenSubset(U1, x); # Preparations for gluing\n\njulia> V2 = PrincipalOpenSubset(U2, u);\n\njulia> f = morphism(V1, V2, [1//x, y//x]); # The gluing isomorphism\n\njulia> g = morphism(V2, V1, [1//u, v//u]); # and its inverse\n\njulia> G = Gluing(U1, U2, f, g); # Construct the gluing\n\njulia> add_gluing!(C, G) # Make the gluing part of the Covering\nCovering\n  described by patches\n    1: affine 2-space\n    2: affine 2-space\n  in the coordinate(s)\n    1: [x, y]\n    2: [u, v]\n\njulia> C[U1, U2] == G # Check whether the gluing of U1 and U2 in C is G.\ntrue\n\n\n\n\n\n","category":"method"},{"location":"AlgebraicGeometry/Schemes/CoveringsAndGluings/#Gluings","page":"Coverings","title":"Gluings","text":"","category":"section"},{"location":"AlgebraicGeometry/Schemes/CoveringsAndGluings/","page":"Coverings","title":"Coverings","text":"Gluings are used to identify open subsets U subset X and V subset Y  of affine schemes along an isomorphism f colon U leftrightarrow V colon g. ","category":"page"},{"location":"AlgebraicGeometry/Schemes/CoveringsAndGluings/#Types","page":"Coverings","title":"Types","text":"","category":"section"},{"location":"AlgebraicGeometry/Schemes/CoveringsAndGluings/","page":"Coverings","title":"Coverings","text":"The abstract type of any such gluing is ","category":"page"},{"location":"AlgebraicGeometry/Schemes/CoveringsAndGluings/","page":"Coverings","title":"Coverings","text":"AbsGluing","category":"page"},{"location":"AlgebraicGeometry/Schemes/CoveringsAndGluings/#AbsGluing","page":"Coverings","title":"AbsGluing","text":"AbsGluing\n\nA gluing of two affine schemes X and Y (the patches) along  open subsets U in X and V in Y (the gluing_domains) along mutual isomorphisms f  U  V  g (the gluing_morphisms).\n\n\n\n\n\n","category":"type"},{"location":"AlgebraicGeometry/Schemes/CoveringsAndGluings/","page":"Coverings","title":"Coverings","text":"The available concrete types are ","category":"page"},{"location":"AlgebraicGeometry/Schemes/CoveringsAndGluings/","page":"Coverings","title":"Coverings","text":"Gluing\nSimpleGluing","category":"page"},{"location":"AlgebraicGeometry/Schemes/CoveringsAndGluings/#Gluing","page":"Coverings","title":"Gluing","text":"Gluing\n\nConcrete instance of an AbsGluing for gluings of affine schemes  X  U  V  Y along open subsets U and V of type AffineSchemeOpenSubscheme.\n\n\n\n\n\n","category":"type"},{"location":"AlgebraicGeometry/Schemes/CoveringsAndGluings/#SimpleGluing","page":"Coverings","title":"SimpleGluing","text":"SimpleGluing\n\nConcrete instance of an AbsGluing for gluings of affine schemes  X  U  V  Y along open subsets U and V of type  PrincipalOpenSubset.\n\n\n\n\n\n","category":"type"},{"location":"AlgebraicGeometry/Schemes/CoveringsAndGluings/#Constructors-2","page":"Coverings","title":"Constructors","text":"","category":"section"},{"location":"AlgebraicGeometry/Schemes/CoveringsAndGluings/","page":"Coverings","title":"Coverings","text":"Gluing(X::AbsAffineScheme, Y::AbsAffineScheme, f::SchemeMor, g::SchemeMor)","category":"page"},{"location":"AlgebraicGeometry/Schemes/CoveringsAndGluings/#Gluing-Tuple{AbsAffineScheme, AbsAffineScheme, SchemeMor, SchemeMor}","page":"Coverings","title":"Gluing","text":"Gluing(X::AbsAffineScheme, Y::AbsAffineScheme, f::SchemeMor, g::SchemeMor)\n\nGlue two affine schemes X and Y along mutual isomorphisms f and g of open subsets U of X and V of Y.\n\nExamples\n\njulia> P1, (x,y) = QQ[:x, :y]; P2, (u,v) = QQ[:u, :v];\n\njulia> U1 = spec(P1); U2 = spec(P2);\n\njulia> V1 = PrincipalOpenSubset(U1, x); # Preparations for gluing\n\njulia> V2 = PrincipalOpenSubset(U2, u);\n\njulia> f = morphism(V1, V2, [1//x, y//x]); # The gluing isomorphism\n\njulia> g = morphism(V2, V1, [1//u, v//u]); # and its inverse\n\njulia> G = Gluing(U1, U2, f, g) # Construct the gluing\nGluing\n  of affine 2-space\n  and affine 2-space\nalong the open subsets\n  [x, y]   AA^2 \\ scheme(x)\n  [u, v]   AA^2 \\ scheme(u)\ngiven by the pullback function\n  u -> 1/x\n  v -> y/x\n\njulia> G isa SimpleGluing # Since the gluing domains were `PrincipalOpenSubsets`, this defaults to a `SimpleGluing`\ntrue\n\njulia> # Alternative using AffineSchemeOpenSubschemes as gluing domains:\n\njulia> W1 = AffineSchemeOpenSubscheme(U1, [x]); W2 = AffineSchemeOpenSubscheme(U2, [u]);\n\njulia> h1 = AffineSchemeOpenSubschemeMor(W1, W2, [1//x, y//x]);\n\njulia> h2 = AffineSchemeOpenSubschemeMor(W2, W1, [1//u, v//u]);\n\njulia> H = Gluing(U1, U2, h1, h2)\nGluing\n  of affine 2-space\n  and affine 2-space\nalong the open subsets\n  [x, y]   complement to V(x) in affine scheme with coordinates [x, y]\n  [u, v]   complement to V(u) in affine scheme with coordinates [u, v]\ndefined by the map\n  affine scheme morphism\n    from [x, y]  AA^2 \\ scheme(x)\n    to   [u, v]  affine 2-space\n  given by the pullback function\n    u -> 1/x\n    v -> y/x\n\njulia> H isa Gluing\ntrue\n\n\n\n\n\n","category":"method"},{"location":"AlgebraicGeometry/Schemes/CoveringsAndGluings/#Attributes-2","page":"Coverings","title":"Attributes","text":"","category":"section"},{"location":"AlgebraicGeometry/Schemes/CoveringsAndGluings/","page":"Coverings","title":"Coverings","text":"patches(G::AbsGluing)\ngluing_domains(G::AbsGluing)\ngluing_morphisms(G::AbsGluing)\ninverse(G::AbsGluing)","category":"page"},{"location":"AlgebraicGeometry/Schemes/CoveringsAndGluings/#patches-Tuple{AbsGluing}","page":"Coverings","title":"patches","text":"patches(G::AbsGluing)\n\nReturn a pair of affine schemes (X, Y) which are glued by G.\n\n\n\n\n\n","category":"method"},{"location":"AlgebraicGeometry/Schemes/CoveringsAndGluings/#gluing_domains-Tuple{AbsGluing}","page":"Coverings","title":"gluing_domains","text":"gluing_domains(G::AbsGluing)\n\nReturn a pair of open subsets U and V of the  respective patches of G which are glued by G  along the gluing_morphisms of G.\n\n\n\n\n\n","category":"method"},{"location":"AlgebraicGeometry/Schemes/CoveringsAndGluings/#gluing_morphisms-Tuple{AbsGluing}","page":"Coverings","title":"gluing_morphisms","text":"gluing_morphisms(G::AbsGluing)\n\nReturn a pair of mutually inverse isomorphisms (f, g)  of open subsets U and V of the respective  patches of G which are used for the gluing  identification.\n\n\n\n\n\n","category":"method"},{"location":"AlgebraicGeometry/Schemes/CoveringsAndGluings/#inverse-Tuple{AbsGluing}","page":"Coverings","title":"inverse","text":"inverse(G::AbsGluing)\n\nReturn the gluing H with patches, gluing_domains,  and gluing_morphisms in opposite order compared to G.\n\n\n\n\n\n","category":"method"},{"location":"AlgebraicGeometry/Schemes/CoveringsAndGluings/#Methods-2","page":"Coverings","title":"Methods","text":"","category":"section"},{"location":"AlgebraicGeometry/Schemes/CoveringsAndGluings/","page":"Coverings","title":"Coverings","text":"compose(G::AbsGluing, H::AbsGluing)\nmaximal_extension(G::Gluing)\nrestrict(G::AbsGluing, f::AbsAffineSchemeMor, g::AbsAffineSchemeMor; check::Bool=true)","category":"page"},{"location":"AlgebraicGeometry/Schemes/CoveringsAndGluings/#compose-Tuple{AbsGluing, AbsGluing}","page":"Coverings","title":"compose","text":"compose(G::AbsGluing, H::AbsGluing)\n\nGiven gluings X ↩ U ≅ V ↪  Y and Y ↩ V' ≅ W ↪ Z, return the gluing X ↩  V ∩ V' ↪ Z. \n\nWARNING: In general such a gluing will not provide a separated scheme.  Use maximal_extension to extend the gluing.\n\n\n\n\n\n","category":"method"},{"location":"AlgebraicGeometry/Schemes/CoveringsAndGluings/#maximal_extension-Tuple{Gluing}","page":"Coverings","title":"maximal_extension","text":"maximal_extension(G::Gluing)\n\nGiven a gluing X ↩ U ≅ V ↪ Y, try to find the maximal extension to an open  subset U' ⊃ U in X and V' ⊃ V in Y so that the resulting scheme is separated.\n\n\n\n\n\n","category":"method"},{"location":"AlgebraicGeometry/Schemes/CoveringsAndGluings/#restrict-Tuple{AbsGluing, AbsAffineSchemeMor, AbsAffineSchemeMor}","page":"Coverings","title":"restrict","text":"restrict(G::AbsGluing, f::AbsAffineSchemeMor, g::AbsAffineSchemeMor; check::Bool=true)\n\nGiven a gluing X  U  V  Y and isomorphisms f  X  X and g Y  Y, return the induced gluing of X and Y.\n\n\n\n\n\n","category":"method"},{"location":"InvariantTheory/finite_groups/","page":"Invariants of Finite Groups","title":"Invariants of Finite Groups","text":"CurrentModule = Oscar\nDocTestSetup = Oscar.doctestsetup()","category":"page"},{"location":"InvariantTheory/finite_groups/#Invariants-of-Finite-Groups","page":"Invariants of Finite Groups","title":"Invariants of Finite Groups","text":"","category":"section"},{"location":"InvariantTheory/finite_groups/","page":"Invariants of Finite Groups","title":"Invariants of Finite Groups","text":"In this section, with notation as in the introduction to this chapter, G will be a finite group.","category":"page"},{"location":"InvariantTheory/finite_groups/","page":"Invariants of Finite Groups","title":"Invariants of Finite Groups","text":"note: Note\nThe ssumption that G is finite implies:By a result of Emmy Noether, KV is integral over KV^G. In particular,\n     dim KV^G = dim KV = n\nMoreover, KV^G is finitely generated as a K-algebra.\nIf the group order G is invertible in K, then we have the explicit Reynolds operator\n     mathcal R KV to KV fmapsto frac1Gsum_piin G(f      pi)","category":"page"},{"location":"InvariantTheory/finite_groups/","page":"Invariants of Finite Groups","title":"Invariants of Finite Groups","text":"note: Note\nWe speak of non-modular invariant theory if G is invertible in K, and of modular invariant theory otherwise.","category":"page"},{"location":"InvariantTheory/finite_groups/","page":"Invariants of Finite Groups","title":"Invariants of Finite Groups","text":"note: Note\nIn the non-modular case, using  Emmy Noether's result and the Reynolds operator, it is not too difficult to show that KV^G is a free module over any of its graded Noether normalizations. That is, KV^G is Cohen-Macaulay. In the modular case, KV^G may not be Cohen-Macaulay.","category":"page"},{"location":"InvariantTheory/finite_groups/","page":"Invariants of Finite Groups","title":"Invariants of Finite Groups","text":"note: Note\nIn the non-modular case, the Hilbert series of KV^G can be precomputed as its Molien series. See [DK15] and [DJ98] for explicit formulas.","category":"page"},{"location":"InvariantTheory/finite_groups/","page":"Invariants of Finite Groups","title":"Invariants of Finite Groups","text":"Knowing the Hilbert series means to know the dimension of each graded piece KV^G_d. This information can often be used to speed up algorithms for finding invariants. The most basic task here is to compute the invariants of  some given degree d, that is, to find  an explicit K-basis of KV^G_d. There are two different approaches:","category":"page"},{"location":"InvariantTheory/finite_groups/","page":"Invariants of Finite Groups","title":"Invariants of Finite Groups","text":"The Reynolds Operator Method, available in  the non-modular case, applies the Reynolds operator to sufficiently many monomials in Kx_1 dots x_n_dcong KV_d,  and extracts a K-basis from the resulting generating set.\nThe Linear Algebra Method, available in the non-modular and the modular case, finds the elements of a K-basis all at once by setting up and solving an appropriate K-linear system of equations.","category":"page"},{"location":"InvariantTheory/finite_groups/","page":"Invariants of Finite Groups","title":"Invariants of Finite Groups","text":"These methods are, in particular, crucial to the computation of primary and secondary invariants. Primary invariants and irreducible secondary invariants together generate KV^G as a K-algebra. Omitting redundant generators yields a system of fundamental invariants. In the non-modular case, an alternative and typically more effective way to compute generators of KV^G is King's algorithm which finds a system of fundamental invariants directly, without computing primary and secondary invariants. See [Kin13].","category":"page"},{"location":"InvariantTheory/finite_groups/","page":"Invariants of Finite Groups","title":"Invariants of Finite Groups","text":"We discuss the relevant OSCAR functionality below.","category":"page"},{"location":"InvariantTheory/finite_groups/#Creating-Invariant-Rings","page":"Invariants of Finite Groups","title":"Creating Invariant Rings","text":"","category":"section"},{"location":"InvariantTheory/finite_groups/#How-Finite-Groups-are-Given","page":"Invariants of Finite Groups","title":"How Finite Groups are Given","text":"","category":"section"},{"location":"InvariantTheory/finite_groups/","page":"Invariants of Finite Groups","title":"Invariants of Finite Groups","text":"The invariant theory part of OSCAR  distinguishes two ways of how  finite groups and their actions on Kx_1 dots x_ncong KV are specified:","category":"page"},{"location":"InvariantTheory/finite_groups/#Matrix-Groups","page":"Invariants of Finite Groups","title":"Matrix Groups","text":"","category":"section"},{"location":"InvariantTheory/finite_groups/","page":"Invariants of Finite Groups","title":"Invariants of Finite Groups","text":"Here, G will be explicitly given as a matrix group Gsubset textGL_n(K)cong textGL(V)  by (finitely many) generating matrices acting on Kx_1 dots x_ncong KV by linear substitution:","category":"page"},{"location":"InvariantTheory/finite_groups/","page":"Invariants of Finite Groups","title":"Invariants of Finite Groups","text":"(f      pi)  (x_1 dots x_n)  = f((x_1 dots x_n) cdot rho(pi)) text for all  piin G","category":"page"},{"location":"InvariantTheory/finite_groups/#Permutation-Groups","page":"Invariants of Finite Groups","title":"Permutation Groups","text":"","category":"section"},{"location":"InvariantTheory/finite_groups/","page":"Invariants of Finite Groups","title":"Invariants of Finite Groups","text":"Here, G will be given as a permutation group, acting on Kx_1 dots x_ncong KV by permuting the variables.","category":"page"},{"location":"InvariantTheory/finite_groups/#Constructors-for-Invariant-Rings","page":"Invariants of Finite Groups","title":"Constructors for Invariant Rings","text":"","category":"section"},{"location":"InvariantTheory/finite_groups/","page":"Invariants of Finite Groups","title":"Invariants of Finite Groups","text":"invariant_ring(G::MatrixGroup)","category":"page"},{"location":"InvariantTheory/finite_groups/#invariant_ring-Tuple{MatrixGroup}","page":"Invariants of Finite Groups","title":"invariant_ring","text":"invariant_ring(G::MatrixGroup)\ninvariant_ring(K::Field = QQ, G::PermGroup)\ninvariant_ring(R::MPolyDecRing, G::MatrixGroup)\ninvariant_ring(R::MPolyDecRing, G::PermGroup)\n\nReturn the invariant ring of the finite matrix group or permutation group G.\n\nIn the latter case, use the specified field K as the coefficient field.  The default value for K is QQ.\n\nThe polynomial ring R on which G acts can be supplied as a first argument, in case an existing ring should be used.\n\nnote: Note\nThe creation of invariant rings is lazy in the sense that no explicit computations are done until specifically invoked (for example, by the primary_invariants function).\n\nExamples\n\njulia> K, a = cyclotomic_field(3, \"a\");\n\njulia> M1 = matrix(K, [0 0 1; 1 0 0; 0 1 0]);\n\njulia> M2 = matrix(K, [1 0 0; 0 a 0; 0 0 -a-1]);\n\njulia> G = matrix_group(M1, M2);\n\njulia> IRm = invariant_ring(G)\nInvariant ring\n  of matrix group of degree 3 over K\n\njulia> IRp = invariant_ring(symmetric_group(3))\nInvariant ring\n  of Sym(3)\n\njulia> coefficient_ring(IRp)\nRational field\n\n\n\n\n\n","category":"method"},{"location":"InvariantTheory/finite_groups/#Basic-Data-Associated-to-Invariant-Rings","page":"Invariants of Finite Groups","title":"Basic Data Associated to Invariant Rings","text":"","category":"section"},{"location":"InvariantTheory/finite_groups/","page":"Invariants of Finite Groups","title":"Invariants of Finite Groups","text":"If IR is the invariant ring Kx_1 x_n^G of a finite matrix group G, then","category":"page"},{"location":"InvariantTheory/finite_groups/","page":"Invariants of Finite Groups","title":"Invariants of Finite Groups","text":"group(IR) refers to G,\ncoefficient_ring(IR) to K, and\npolynomial_ring(IR) to Kx_1 x_n.","category":"page"},{"location":"InvariantTheory/finite_groups/","page":"Invariants of Finite Groups","title":"Invariants of Finite Groups","text":"Moreover, is_modular(IR) returns true in the modular case, and false otherwise.","category":"page"},{"location":"InvariantTheory/finite_groups/#Examples","page":"Invariants of Finite Groups","title":"Examples","text":"","category":"section"},{"location":"InvariantTheory/finite_groups/","page":"Invariants of Finite Groups","title":"Invariants of Finite Groups","text":"julia> K, a = cyclotomic_field(3, \"a\")\n(Cyclotomic field of order 3, a)\n\njulia> M1 = matrix(K, [0 0 1; 1 0 0; 0 1 0])\n[0   0   1]\n[1   0   0]\n[0   1   0]\n\njulia> M2 = matrix(K, [1 0 0; 0 a 0; 0 0 -a-1])\n[1   0        0]\n[0   a        0]\n[0   0   -a - 1]\n\njulia> G = matrix_group(M1, M2)\nMatrix group of degree 3\n  over cyclotomic field of order 3\n\njulia> IR = invariant_ring(G)\nInvariant ring\n  of matrix group of degree 3 over K\n\njulia> group(IR)\nMatrix group of degree 3\n  over cyclotomic field of order 3\n\njulia> coefficient_ring(IR)\nNumber field with defining polynomial _$^2 + _$ + 1\n  over rational field\n\njulia> R = polynomial_ring(IR)\nMultivariate polynomial ring in 3 variables over K graded by\n  x[1] -> [1]\n  x[2] -> [1]\n  x[3] -> [1]\n\njulia> x = gens(R)\n3-element Vector{MPolyDecRingElem{AbsSimpleNumFieldElem, AbstractAlgebra.Generic.MPoly{AbsSimpleNumFieldElem}}}:\n x[1]\n x[2]\n x[3]\n\njulia> is_modular(IR)\nfalse\n","category":"page"},{"location":"InvariantTheory/finite_groups/#The-Reynolds-Operator","page":"Invariants of Finite Groups","title":"The Reynolds Operator","text":"","category":"section"},{"location":"InvariantTheory/finite_groups/","page":"Invariants of Finite Groups","title":"Invariants of Finite Groups","text":"reynolds_operator(IR::FinGroupInvarRing{FldT, GrpT, T}, f::T) where {FldT, GrpT, T <: MPolyRingElem}\n\nreynolds_operator(IR::FinGroupInvarRing{FldT, GrpT, T}, f::T, chi::GAPGroupClassFunction) where {FldT, GrpT, T <: MPolyRingElem}","category":"page"},{"location":"InvariantTheory/finite_groups/#reynolds_operator-Union{Tuple{T}, Tuple{GrpT}, Tuple{FldT}, Tuple{Oscar.FinGroupInvarRing{FldT, GrpT, T}, T}} where {FldT, GrpT, T<:MPolyRingElem}","page":"Invariants of Finite Groups","title":"reynolds_operator","text":"reynolds_operator(IR::FinGroupInvarRing{FldT, GrpT, T}, f::T) where {FldT, GrpT, T <: MPolyRingElem}\n\nIn the non-modular case, return the image of f under the Reynolds operator projecting onto IR.\n\nExamples\n\njulia> K, a = cyclotomic_field(3, \"a\")\n(Cyclotomic field of order 3, a)\n\njulia> M1 = matrix(K, [0 0 1; 1 0 0; 0 1 0])\n[0   0   1]\n[1   0   0]\n[0   1   0]\n\njulia> M2 = matrix(K, [1 0 0; 0 a 0; 0 0 -a-1])\n[1   0        0]\n[0   a        0]\n[0   0   -a - 1]\n\njulia> G = matrix_group(M1, M2)\nMatrix group of degree 3\n  over cyclotomic field of order 3\n\njulia> IR = invariant_ring(G)\nInvariant ring\n  of matrix group of degree 3 over K\n\njulia> R = polynomial_ring(IR)\nMultivariate polynomial ring in 3 variables over K graded by\n  x[1] -> [1]\n  x[2] -> [1]\n  x[3] -> [1]\n\njulia> x = gens(R)\n3-element Vector{MPolyDecRingElem{AbsSimpleNumFieldElem, AbstractAlgebra.Generic.MPoly{AbsSimpleNumFieldElem}}}:\n x[1]\n x[2]\n x[3]\n\njulia> f = x[1]^3\nx[1]^3\n\njulia> reynolds_operator(IR, f)\n1//3*x[1]^3 + 1//3*x[2]^3 + 1//3*x[3]^3\n\njulia> M = matrix(GF(3), [0 1 0; -1 0 0; 0 0 -1])\n[0   1   0]\n[2   0   0]\n[0   0   2]\n\njulia> G = matrix_group(M)\nMatrix group of degree 3\n  over prime field of characteristic 3\n\njulia> IR = invariant_ring(G)\nInvariant ring\n  of matrix group of degree 3 over GF(3)\n\njulia> R = polynomial_ring(IR)\nMultivariate polynomial ring in 3 variables over GF(3) graded by\n  x[1] -> [1]\n  x[2] -> [1]\n  x[3] -> [1]\n\njulia> x = gens(R)\n3-element Vector{MPolyDecRingElem{FqFieldElem, FqMPolyRingElem}}:\n x[1]\n x[2]\n x[3]\n\njulia> f = x[1]^2\nx[1]^2\n\njulia> reynolds_operator(IR, f)\n2*x[1]^2 + 2*x[2]^2\n\njulia> f = x[1]^3\nx[1]^3\n\njulia> reynolds_operator(IR, f)\n0\n\n\n\n\n\n","category":"method"},{"location":"InvariantTheory/finite_groups/#reynolds_operator-Union{Tuple{T}, Tuple{GrpT}, Tuple{FldT}, Tuple{Oscar.FinGroupInvarRing{FldT, GrpT, T}, T, Oscar.GAPGroupClassFunction}} where {FldT, GrpT, T<:MPolyRingElem}","page":"Invariants of Finite Groups","title":"reynolds_operator","text":"reynolds_operator(IR::FinGroupInvarRing{FldT, GrpT, T}, f::T, chi::GAPGroupClassFunction)\n  where {FldT, GrpT, T <: MPolyRingElem}\n\nIn the case of characteristic zero, return the image of f under the twisted Reynolds operator projecting onto the isotypic component of the polynomial ring with respect to chi, that is, the semi-invariants (or relative invariants) with respect to chi, see [Sta79]. It is assumed that chi is an irreducible character.\n\nIn case chi is a linear character, the returned polynomial, say h, fulfils h^g = chi(g)h for all g in group(IR) (possibly h is zero).\n\nnote: Note\nIf coefficient_ring(IR) does not contain all character values of chi, an error is raised.\n\nExamples\n\njulia> K, a = cyclotomic_field(3, \"a\");\n\njulia> M1 = matrix(K, [0 0 1; 1 0 0; 0 1 0]);\n\njulia> M2 = matrix(K, [1 0 0; 0 a 0; 0 0 -a-1]);\n\njulia> G = matrix_group(M1, M2);\n\njulia> IR = invariant_ring(G);\n\njulia> R = polynomial_ring(IR);\n\njulia> x = gens(R);\n\njulia> f = x[1]^3\nx[1]^3\n\njulia> reynolds_operator(IR, f, trivial_character(G))\n1//3*x[1]^3 + 1//3*x[2]^3 + 1//3*x[3]^3\n\njulia> S2 = symmetric_group(2);\n\njulia> IR = invariant_ring(QQ, S2);\n\njulia> R = polynomial_ring(IR);\n\njulia> x = gens(R);\n\njulia> F = abelian_closure(QQ)[1];\n\njulia> chi = Oscar.class_function(S2, [ F(sign(representative(c))) for c in conjugacy_classes(S2) ])\nclass_function(character table of S2, [1, -1])\n\njulia> reynolds_operator(IR, x[1], chi)\n1//2*x[1] - 1//2*x[2]\n\n\n\n\n\n","category":"method"},{"location":"InvariantTheory/finite_groups/#Invariants-of-a-Given-Degree","page":"Invariants of Finite Groups","title":"Invariants of a Given Degree","text":"","category":"section"},{"location":"InvariantTheory/finite_groups/","page":"Invariants of Finite Groups","title":"Invariants of Finite Groups","text":"basis(IR::FinGroupInvarRing, d::Int, algorithm::Symbol = :default)\n\nbasis(IR::FinGroupInvarRing, d::Int, chi::GAPGroupClassFunction)","category":"page"},{"location":"InvariantTheory/finite_groups/#basis","page":"Invariants of Finite Groups","title":"basis","text":"basis(IR::FinGroupInvarRing, d::Int, algorithm::Symbol = :default)\n\nGiven an invariant ring IR and an integer d, return a basis for the invariants in degree d.\n\nThe optional argument algorithm specifies the algorithm to be used. If algorithm = :reynolds, the Reynolds operator is utilized (this method is only available in the non-modular case). Setting algorithm = :linear_algebra means that plain linear algebra is used. The default option algorithm = :default asks to select the heuristically best algorithm.\n\nSee also iterate_basis.\n\nExamples\n\njulia> K, a = cyclotomic_field(3, \"a\")\n(Cyclotomic field of order 3, a)\n\njulia> M1 = matrix(K, [0 0 1; 1 0 0; 0 1 0])\n[0   0   1]\n[1   0   0]\n[0   1   0]\n\njulia> M2 = matrix(K, [1 0 0; 0 a 0; 0 0 -a-1])\n[1   0        0]\n[0   a        0]\n[0   0   -a - 1]\n\njulia> G = matrix_group(M1, M2)\nMatrix group of degree 3\n  over cyclotomic field of order 3\n\njulia> IR = invariant_ring(G)\nInvariant ring\n  of matrix group of degree 3 over K\n\njulia> basis(IR, 6)\n4-element Vector{MPolyDecRingElem{AbsSimpleNumFieldElem, AbstractAlgebra.Generic.MPoly{AbsSimpleNumFieldElem}}}:\n x[1]^2*x[2]^2*x[3]^2\n x[1]^4*x[2]*x[3] + x[1]*x[2]^4*x[3] + x[1]*x[2]*x[3]^4\n x[1]^3*x[2]^3 + x[1]^3*x[3]^3 + x[2]^3*x[3]^3\n x[1]^6 + x[2]^6 + x[3]^6\n\njulia> M = matrix(GF(3), [0 1 0; -1 0 0; 0 0 -1])\n[0   1   0]\n[2   0   0]\n[0   0   2]\n\njulia> G = matrix_group(M)\nMatrix group of degree 3\n  over prime field of characteristic 3\n\njulia> IR = invariant_ring(G)\nInvariant ring\n  of matrix group of degree 3 over GF(3)\n\njulia> basis(IR, 2)\n2-element Vector{MPolyDecRingElem{FqFieldElem, FqMPolyRingElem}}:\n x[1]^2 + x[2]^2\n x[3]^2\n\njulia> basis(IR, 3)\n2-element Vector{MPolyDecRingElem{FqFieldElem, FqMPolyRingElem}}:\n x[1]*x[2]*x[3]\n x[1]^2*x[3] + 2*x[2]^2*x[3]\n\n\n\n\n\n","category":"function"},{"location":"InvariantTheory/finite_groups/#basis-Tuple{Oscar.FinGroupInvarRing, Int64, Oscar.GAPGroupClassFunction}","page":"Invariants of Finite Groups","title":"basis","text":"basis(IR::FinGroupInvarRing, d::Int, chi::GAPGroupClassFunction)\n\nGiven an invariant ring IR, an integer d and an irreducible character chi, return a basis for the semi-invariants (or relative invariants) in degree d with respect to chi.\n\nThis function is only implemented in the case of characteristic zero.\n\nnote: Note\nIf coefficient_ring(IR) does not contain all character values of chi, an error is raised.\n\nSee also iterate_basis.\n\nExamples\n\njulia> K, a = cyclotomic_field(3, \"a\");\n\njulia> M1 = matrix(K, [0 0 1; 1 0 0; 0 1 0]);\n\njulia> M2 = matrix(K, [1 0 0; 0 a 0; 0 0 -a-1]);\n\njulia> G = matrix_group(M1, M2);\n\njulia> IR = invariant_ring(G);\n\njulia> basis(IR, 6, trivial_character(G))\n4-element Vector{MPolyDecRingElem{AbsSimpleNumFieldElem, AbstractAlgebra.Generic.MPoly{AbsSimpleNumFieldElem}}}:\n x[1]^6 + x[2]^6 + x[3]^6\n x[1]^4*x[2]*x[3] + x[1]*x[2]^4*x[3] + x[1]*x[2]*x[3]^4\n x[1]^3*x[2]^3 + x[1]^3*x[3]^3 + x[2]^3*x[3]^3\n x[1]^2*x[2]^2*x[3]^2\n\njulia> S2 = symmetric_group(2);\n\njulia> R = invariant_ring(QQ, S2);\n\njulia> F = abelian_closure(QQ)[1];\n\njulia> chi = Oscar.class_function(S2, [ F(sign(representative(c))) for c in conjugacy_classes(S2) ])\nclass_function(character table of group Sym( [ 1 .. 2 ] ), [1, -1])\n\njulia> basis(R, 3, chi)\n2-element Vector{MPolyDecRingElem{QQFieldElem, QQMPolyRingElem}}:\n x[1]^3 - x[2]^3\n x[1]^2*x[2] - x[1]*x[2]^2\n\n\n\n\n\n\n","category":"method"},{"location":"InvariantTheory/finite_groups/","page":"Invariants of Finite Groups","title":"Invariants of Finite Groups","text":"iterate_basis(IR::FinGroupInvarRing, d::Int, algorithm::Symbol = :default)\n\niterate_basis(IR::FinGroupInvarRing, d::Int, chi::GAPGroupClassFunction)","category":"page"},{"location":"InvariantTheory/finite_groups/#iterate_basis","page":"Invariants of Finite Groups","title":"iterate_basis","text":"iterate_basis(IR::FinGroupInvarRing, d::Int, algorithm::Symbol = :default)\n\nGiven an invariant ring IR and an integer d, return an iterator over a basis for the invariants in degree d.\n\nThe optional argument algorithm specifies the algorithm to be used. If algorithm = :reynolds, the Reynolds operator is utilized (this method is only available in the non-modular case). Setting algorithm = :linear_algebra means that plain linear algebra is used. The default option algorithm = :default asks to select the heuristically best algorithm.\n\nWhen using the Reynolds operator, the basis is constructed element-by-element. With linear algebra, this is not possible and the basis will be constructed all at once when calling the function.\n\nSee also basis.\n\nExamples\n\njulia> K, a = cyclotomic_field(3, \"a\")\n(Cyclotomic field of order 3, a)\n\njulia> M1 = matrix(K, [0 0 1; 1 0 0; 0 1 0])\n[0   0   1]\n[1   0   0]\n[0   1   0]\n\njulia> M2 = matrix(K, [1 0 0; 0 a 0; 0 0 -a-1])\n[1   0        0]\n[0   a        0]\n[0   0   -a - 1]\n\njulia> G = matrix_group(M1, M2)\nMatrix group of degree 3\n  over cyclotomic field of order 3\n\njulia> IR = invariant_ring(G)\nInvariant ring\n  of matrix group of degree 3 over K\n\njulia> B = iterate_basis(IR, 6)\nIterator over a basis of the component of degree 6\n  of invariant ring of G\n\njulia> collect(B)\n4-element Vector{MPolyDecRingElem{AbsSimpleNumFieldElem, AbstractAlgebra.Generic.MPoly{AbsSimpleNumFieldElem}}}:\n x[1]^2*x[2]^2*x[3]^2\n x[1]^4*x[2]*x[3] + x[1]*x[2]^4*x[3] + x[1]*x[2]*x[3]^4\n x[1]^3*x[2]^3 + x[1]^3*x[3]^3 + x[2]^3*x[3]^3\n x[1]^6 + x[2]^6 + x[3]^6\n\njulia> M = matrix(GF(3), [0 1 0; -1 0 0; 0 0 -1])\n[0   1   0]\n[2   0   0]\n[0   0   2]\n\njulia> G = matrix_group(M)\nMatrix group of degree 3\n  over prime field of characteristic 3\n\njulia> IR = invariant_ring(G)\nInvariant ring\n  of matrix group of degree 3 over GF(3)\n\njulia> B = iterate_basis(IR, 2)\nIterator over a basis of the component of degree 2\n  of invariant ring of G\n\njulia> collect(B)\n2-element Vector{MPolyDecRingElem{FqFieldElem, FqMPolyRingElem}}:\n x[1]^2 + x[2]^2\n x[3]^2\n\n\n\n\n\n","category":"function"},{"location":"InvariantTheory/finite_groups/#iterate_basis-Tuple{Oscar.FinGroupInvarRing, Int64, Oscar.GAPGroupClassFunction}","page":"Invariants of Finite Groups","title":"iterate_basis","text":"iterate_basis(IR::FinGroupInvarRing, d::Int, chi::GAPGroupClassFunction)\n\nGiven an invariant ring IR, an integer d and an irreducible character chi, return an iterator over a basis for the semi-invariants (or relative invariants) in degree d with respect to chi.\n\nThis function is only implemented in the case of characteristic zero.\n\nnote: Note\nIf coefficient_ring(IR) does not contain all character values of chi, an error is raised.\n\nSee also basis.\n\nExamples\n\njulia> K, a = cyclotomic_field(3, \"a\");\n\njulia> M1 = matrix(K, [0 0 1; 1 0 0; 0 1 0]);\n\njulia> M2 = matrix(K, [1 0 0; 0 a 0; 0 0 -a-1]);\n\njulia> G = matrix_group(M1, M2);\n\njulia> IR = invariant_ring(G);\n\njulia> B = iterate_basis(IR, 6, trivial_character(G))\nIterator over a basis of the component of degree 6\n  of invariant ring of G\nrelative to a character\n\njulia> collect(B)\n4-element Vector{MPolyDecRingElem{AbsSimpleNumFieldElem, AbstractAlgebra.Generic.MPoly{AbsSimpleNumFieldElem}}}:\n x[1]^6 + x[2]^6 + x[3]^6\n x[1]^4*x[2]*x[3] + x[1]*x[2]^4*x[3] + x[1]*x[2]*x[3]^4\n x[1]^3*x[2]^3 + x[1]^3*x[3]^3 + x[2]^3*x[3]^3\n x[1]^2*x[2]^2*x[3]^2\n\njulia> S2 = symmetric_group(2);\n\njulia> R = invariant_ring(QQ, S2);\n\njulia> F = abelian_closure(QQ)[1];\n\njulia> chi = Oscar.class_function(S2, [ F(sign(representative(c))) for c in conjugacy_classes(S2) ])\nclass_function(character table of S2, [1, -1])\n\njulia> B = iterate_basis(R, 3, chi)\nIterator over a basis of the component of degree 3\n  of invariant ring of S2\nrelative to a character\n\njulia> collect(B)\n2-element Vector{MPolyDecRingElem{QQFieldElem, QQMPolyRingElem}}:\n x[1]^3 - x[2]^3\n x[1]^2*x[2] - x[1]*x[2]^2\n\n\n\n\n\n\n","category":"method"},{"location":"InvariantTheory/finite_groups/#The-Molien-Series","page":"Invariants of Finite Groups","title":"The Molien Series","text":"","category":"section"},{"location":"InvariantTheory/finite_groups/","page":"Invariants of Finite Groups","title":"Invariants of Finite Groups","text":" molien_series([S::PolyRing], I::FinGroupInvarRing, [chi::GAPGroupClassFunction])","category":"page"},{"location":"InvariantTheory/finite_groups/#molien_series-Tuple{PolyRing, Oscar.FinGroupInvarRing, Oscar.GAPGroupClassFunction}","page":"Invariants of Finite Groups","title":"molien_series","text":"molien_series([S::PolyRing], I::FinGroupInvarRing, [chi::GAPGroupClassFunction])\n\nIn the non-modular case, return the Molien series of I as a rational function.\n\nIf a univariate polynomial ring with rational coefficients is specified by the optional argument S::PolyRing, then return the Molien series as an element of the fraction field of that ring.\n\nIf a character chi is specified, the series relative to chi is returned. This is the Molien series of the module of semi-invariants (or relative invariants) with respect to chi, see [Sta79].\n\nExamples\n\njulia> K, a = cyclotomic_field(3, \"a\");\n\njulia> M1 = matrix(K, [0 0 1; 1 0 0; 0 1 0]);\n\njulia> M2 = matrix(K, [1 0 0; 0 a 0; 0 0 -a-1]);\n\njulia> G = matrix_group(M1, M2);\n\njulia> IR = invariant_ring(G);\n\njulia> MS = molien_series(IR)\n(-t^6 + t^3 - 1)//(t^9 - 3*t^6 + 3*t^3 - 1)\n\njulia> parent(MS)\nFraction field\n  of univariate polynomial ring in t over QQ\n\njulia> expand(MS, 10)\n1 + 2*t^3 + 4*t^6 + 7*t^9 + O(t^11)\n\njulia> S2 = symmetric_group(2);\n\njulia> IR = invariant_ring(QQ, S2);\n\njulia> F = abelian_closure(QQ)[1];\n\njulia> chi = Oscar.class_function(S2, [ F(sign(representative(c))) for c in conjugacy_classes(S2) ])\nclass_function(character table of S2, [1, -1])\n\njulia> molien_series(IR)\n1//(t^3 - t^2 - t + 1)\n\njulia> molien_series(IR, chi)\nt//(t^3 - t^2 - t + 1)\n\n\n\n\n\n","category":"method"},{"location":"InvariantTheory/finite_groups/#Primary-Invariants","page":"Invariants of Finite Groups","title":"Primary Invariants","text":"","category":"section"},{"location":"InvariantTheory/finite_groups/","page":"Invariants of Finite Groups","title":"Invariants of Finite Groups","text":"primary_invariants(IR::FinGroupInvarRing)","category":"page"},{"location":"InvariantTheory/finite_groups/#primary_invariants-Tuple{Oscar.FinGroupInvarRing}","page":"Invariants of Finite Groups","title":"primary_invariants","text":"primary_invariants(IR::FinGroupInvarRing;\n  ensure_minimality::Int = 0, degree_bound::Int = 1,\n  primary_degrees::Vector{Int} = Int[])\n\nReturn a system of primary invariants for IR as a Vector sorted by increasing degree. The result is cached, so calling this function again with argument IR will be fast and give the same result.\n\nThe primary invariants are computed using the algorithm in [Kem99].\n\nThe product of the degrees d_1dots d_n of the returned primary invariants is guaranteed to be minimal among all possible sets of primary invariants.\n\nExpert users (or users happy to experiment) may enter the following keyword arguments to speed up the computation. Note that all of these options are ignored if there are already primary invariants cached. If admissible degrees d_1dots d_n for a system of primary invariants are known a priori, these degrees can be specified by primary_degrees = [d_1, ..., d_n]. Note that an error is raised if in fact no primary invariants of the given degrees exist. An a priori known number k geq 1 with d_1cdots d_n geq k cdot G, where G is the underlying group, can be specified by degree_bound = k. The default value is degree_bound = 1. In some situations, the runtime of the algorithm might be improved by assigning a positive integer to ensure_minimality. This leads to an early cancelation of loops in the algorithm and the described minimality of the degrees is not guaranteed anymore. A smaller (positive) value of ensure_minimality corresponds to an earlier cancelation. However, the default value ensure_minimality = 0 corresponds to no cancelation.\n\nExamples\n\njulia> K, a = cyclotomic_field(3, \"a\");\n\njulia> M1 = matrix(K, [0 0 1; 1 0 0; 0 1 0]);\n\njulia> M2 = matrix(K, [1 0 0; 0 a 0; 0 0 -a-1]);\n\njulia> G = matrix_group(M1, M2);\n\njulia> IR = invariant_ring(G);\n\njulia> primary_invariants(IR)\n3-element Vector{MPolyDecRingElem{AbsSimpleNumFieldElem, AbstractAlgebra.Generic.MPoly{AbsSimpleNumFieldElem}}}:\n x[1]*x[2]*x[3]\n x[1]^3 + x[2]^3 + x[3]^3\n x[1]^3*x[2]^3 + x[1]^3*x[3]^3 + x[2]^3*x[3]^3\n\njulia> IR = invariant_ring(G); # \"New\" ring to avoid caching\n\njulia> primary_invariants(IR, primary_degrees = [ 3, 6, 6 ])\n3-element Vector{MPolyDecRingElem{AbsSimpleNumFieldElem, AbstractAlgebra.Generic.MPoly{AbsSimpleNumFieldElem}}}:\n x[1]*x[2]*x[3]\n x[1]^3*x[2]^3 + x[1]^3*x[3]^3 + x[2]^3*x[3]^3\n x[1]^6 + x[2]^6 + x[3]^6\n\n\n\n\n\n\n","category":"method"},{"location":"InvariantTheory/finite_groups/#Secondary-Invariants","page":"Invariants of Finite Groups","title":"Secondary Invariants","text":"","category":"section"},{"location":"InvariantTheory/finite_groups/","page":"Invariants of Finite Groups","title":"Invariants of Finite Groups","text":"secondary_invariants(IR::FinGroupInvarRing)","category":"page"},{"location":"InvariantTheory/finite_groups/#secondary_invariants-Tuple{Oscar.FinGroupInvarRing}","page":"Invariants of Finite Groups","title":"secondary_invariants","text":"secondary_invariants(IR::FinGroupInvarRing)\n\nReturn a system of secondary invariants for IR as a Vector sorted by increasing degree. The result is cached, so calling this function again  with argument IR will be fast and give the same result. Note that the secondary invariants are defined with respect to the currently cached system of primary invariants for IR (if no system of primary invariants for IR is cached, such a system is computed and cached first).\n\nImplemented Algorithms\n\nFor the non-modular case, the function relies on Algorithm 3.7.2 in [DK15],  enhanced by ideas from [Kin07]. In the modular case, Algorithm 3.7.5 in  [DK15] is used.\n\nExamples\n\njulia> K, a = cyclotomic_field(3, \"a\");\n\njulia> M1 = matrix(K, [0 0 1; 1 0 0; 0 1 0]);\n\njulia> M2 = matrix(K, [1 0 0; 0 a 0; 0 0 -a-1]);\n\njulia> G = matrix_group(M1, M2);\n\njulia> IR = invariant_ring(G);\n\njulia> secondary_invariants(IR)\n2-element Vector{MPolyDecRingElem{AbsSimpleNumFieldElem, AbstractAlgebra.Generic.MPoly{AbsSimpleNumFieldElem}}}:\n 1\n x[1]^3*x[2]^6 + x[1]^6*x[3]^3 + x[2]^3*x[3]^6\n\n\n\n\n\n","category":"method"},{"location":"InvariantTheory/finite_groups/","page":"Invariants of Finite Groups","title":"Invariants of Finite Groups","text":"irreducible_secondary_invariants(IR::FinGroupInvarRing)","category":"page"},{"location":"InvariantTheory/finite_groups/#irreducible_secondary_invariants-Tuple{Oscar.FinGroupInvarRing}","page":"Invariants of Finite Groups","title":"irreducible_secondary_invariants","text":"irreducible_secondary_invariants(IR::FinGroupInvarRing)\n\nReturn a system of irreducible secondary invariants for IR as a Vector sorted by increasing degree. The result is cached, so calling this function again will be fast and give the same result. Here, a secondary invariant is called irreducible, if it cannot be written as a polynomial expression in the primary invariants and the other secondary invariants.\n\nNote that the secondary invariants and hence the irreducible secondary invariants are defined with respect to the currently cached system of primary invariants for IR (if no system of primary invariants for IR is cached, such a system is  computed and cached first).\n\nExamples\n\njulia> M = matrix(QQ, [0 -1 0 0 0; 1 -1 0 0 0; 0 0 0 0 1; 0 0 1 0 0; 0 0 0 1 0]);\n\njulia> G = matrix_group(M);\n\njulia> IR = invariant_ring(G);\n\njulia> secondary_invariants(IR)\n12-element Vector{MPolyDecRingElem{QQFieldElem, QQMPolyRingElem}}:\n 1\n x[1]*x[3] - x[2]*x[3] + x[2]*x[4] - x[1]*x[5]\n x[3]^2 + x[4]^2 + x[5]^2\n x[1]^3 - 3*x[1]*x[2]^2 + x[2]^3\n x[1]^2*x[3] - x[1]*x[2]*x[3] - x[1]*x[2]*x[4] + x[2]^2*x[4] + x[1]*x[2]*x[5]\n x[1]*x[3]^2 - x[2]*x[3]^2 + x[2]*x[4]^2 - x[1]*x[5]^2\n x[1]^2*x[3] + x[1]^2*x[4] - 2*x[1]*x[2]*x[4] + x[2]^2*x[4] + x[2]^2*x[5]\n x[1]*x[3]*x[4] - x[2]*x[3]*x[4] - x[1]*x[3]*x[5] + x[2]*x[4]*x[5]\n x[3]*x[4]^2 + x[3]^2*x[5] + x[4]*x[5]^2\n x[1]*x[3]^3 - x[2]*x[3]^3 + x[2]*x[3]^2*x[4] + x[1]*x[3]*x[4]^2 - x[2]*x[3]*x[4]^2 + x[2]*x[4]^3 - x[1]*x[3]^2*x[5] - x[1]*x[4]^2*x[5] + x[1]*x[3]*x[5]^2 - x[2]*x[3]*x[5]^2 + x[2]*x[4]*x[5]^2 - x[1]*x[5]^3\n x[3]^4 + 2*x[3]^2*x[4]^2 + x[4]^4 + 2*x[3]^2*x[5]^2 + 2*x[4]^2*x[5]^2 + x[5]^4\n x[1]*x[3]^5 - x[2]*x[3]^5 + x[2]*x[3]^4*x[4] + 2*x[1]*x[3]^3*x[4]^2 - 2*x[2]*x[3]^3*x[4]^2 + 2*x[2]*x[3]^2*x[4]^3 + x[1]*x[3]*x[4]^4 - x[2]*x[3]*x[4]^4 + x[2]*x[4]^5 - x[1]*x[3]^4*x[5] - 2*x[1]*x[3]^2*x[4]^2*x[5] - x[1]*x[4]^4*x[5] + 2*x[1]*x[3]^3*x[5]^2 - 2*x[2]*x[3]^3*x[5]^2 + 2*x[2]*x[3]^2*x[4]*x[5]^2 + 2*x[1]*x[3]*x[4]^2*x[5]^2 - 2*x[2]*x[3]*x[4]^2*x[5]^2 + 2*x[2]*x[4]^3*x[5]^2 - 2*x[1]*x[3]^2*x[5]^3 - 2*x[1]*x[4]^2*x[5]^3 + x[1]*x[3]*x[5]^4 - x[2]*x[3]*x[5]^4 + x[2]*x[4]*x[5]^4 - x[1]*x[5]^5\n\njulia> irreducible_secondary_invariants(IR)\n8-element Vector{MPolyDecRingElem{QQFieldElem, QQMPolyRingElem}}:\n x[1]*x[3] - x[2]*x[3] + x[2]*x[4] - x[1]*x[5]\n x[3]^2 + x[4]^2 + x[5]^2\n x[1]^3 - 3*x[1]*x[2]^2 + x[2]^3\n x[1]^2*x[3] - x[1]*x[2]*x[3] - x[1]*x[2]*x[4] + x[2]^2*x[4] + x[1]*x[2]*x[5]\n x[1]*x[3]^2 - x[2]*x[3]^2 + x[2]*x[4]^2 - x[1]*x[5]^2\n x[1]^2*x[3] + x[1]^2*x[4] - 2*x[1]*x[2]*x[4] + x[2]^2*x[4] + x[2]^2*x[5]\n x[1]*x[3]*x[4] - x[2]*x[3]*x[4] - x[1]*x[3]*x[5] + x[2]*x[4]*x[5]\n x[3]*x[4]^2 + x[3]^2*x[5] + x[4]*x[5]^2\n\n\n\n\n\n","category":"method"},{"location":"InvariantTheory/finite_groups/","page":"Invariants of Finite Groups","title":"Invariants of Finite Groups","text":"module_syzygies(RG::FinGroupInvarRing)","category":"page"},{"location":"InvariantTheory/finite_groups/#module_syzygies-Tuple{Oscar.FinGroupInvarRing}","page":"Invariants of Finite Groups","title":"module_syzygies","text":"module_syzygies(RG::FinGroupInvarRing)\n\nGiven an invariant ring RG over a ring R, compute a presentation of RG as a module over the subalgebra generated by a system of primary invariants. Return a module M over a ring S, a map M \\to R which is onto RG by mapping the generators of M to a system of secondary invariants, and a map S \\to R which is onto the subalgebra generated by the primary invariants.\n\n\n\n\n\n","category":"method"},{"location":"InvariantTheory/finite_groups/#Fundamental-Systems-of-Invariants","page":"Invariants of Finite Groups","title":"Fundamental Systems of Invariants","text":"","category":"section"},{"location":"InvariantTheory/finite_groups/","page":"Invariants of Finite Groups","title":"Invariants of Finite Groups","text":"fundamental_invariants(IR::FinGroupInvarRing, algorithm::Symbol = :default; beta::Int = 0)","category":"page"},{"location":"InvariantTheory/finite_groups/#fundamental_invariants","page":"Invariants of Finite Groups","title":"fundamental_invariants","text":"fundamental_invariants(IR::FinGroupInvarRing, algorithm::Symbol = :default; beta::Int = 0)\n\nReturn a system of fundamental invariants for IR.\n\nThe result is cached, so calling this function again with argument IR  will be fast and give the same result.\n\nImplemented Algorithms\n\nIn the non-modular case the function relies on King's algorithm [Kin13] which finds a system of fundamental invariants directly, without computing primary and secondary invariants. If an upper bound for the degrees of fundamental invariants is known, this can be supplied by the keyword argument beta and might result in an earlier termination of the algorithm. By default, the algorithm uses the bounds from [DH00] and [Sez02].\n\nAlternatively, if specified by algorithm = :primary_and_secondary, the function computes fundamental invariants from a collection of primary and irreducible secondary invariants. The optional keyword argument beta is ignored for this algorithm.\n\nIn the modular case, only the second method is available for theoretical reasons.\n\nExamples\n\njulia> K, a = cyclotomic_field(3, \"a\")\n(Cyclotomic field of order 3, a)\n\njulia> M1 = matrix(K, [0 0 1; 1 0 0; 0 1 0])\n[0   0   1]\n[1   0   0]\n[0   1   0]\n\njulia> M2 = matrix(K, [1 0 0; 0 a 0; 0 0 -a-1])\n[1   0        0]\n[0   a        0]\n[0   0   -a - 1]\n\njulia> G = matrix_group(M1, M2)\nMatrix group of degree 3\n  over cyclotomic field of order 3\n\njulia> IR = invariant_ring(G)\nInvariant ring\n  of matrix group of degree 3 over K\n\njulia> fundamental_invariants(IR)\n4-element Vector{MPolyDecRingElem{AbsSimpleNumFieldElem, AbstractAlgebra.Generic.MPoly{AbsSimpleNumFieldElem}}}:\n x[1]*x[2]*x[3]\n x[1]^3 + x[2]^3 + x[3]^3\n x[1]^3*x[2]^3 + x[1]^3*x[3]^3 + x[2]^3*x[3]^3\n x[1]^3*x[2]^6 + x[1]^6*x[3]^3 + x[2]^3*x[3]^6\n\n\n\n\n\n","category":"function"},{"location":"InvariantTheory/finite_groups/#Invariant-Rings-as-Affine-Algebras","page":"Invariants of Finite Groups","title":"Invariant Rings as Affine Algebras","text":"","category":"section"},{"location":"InvariantTheory/finite_groups/","page":"Invariants of Finite Groups","title":"Invariants of Finite Groups","text":"affine_algebra(IR::FinGroupInvarRing)","category":"page"},{"location":"InvariantTheory/finite_groups/#affine_algebra-Tuple{Oscar.FinGroupInvarRing}","page":"Invariants of Finite Groups","title":"affine_algebra","text":"affine_algebra(IR::FinGroupInvarRing;\n  algo_gens::Symbol = :default, algo_rels::Symbol = :groebner_basis)\n\nGiven an invariant ring IR with underlying graded polynomial ring, say R, return a graded affine algebra, say A, together with a graded algebra homomorphism A to R which maps A isomorphically onto IR.\n\nnote: Note\nIf a system of fundamental invariants for IR is already cached, the function makes use of that system. Otherwise, such a system is computed and cached first. The algebra A is graded according to the degrees of the fundamental invariants, the modulus of A is generated by the algebra relations on these invariants, and the algebra homomorphism A to R is defined by sending the i-th generator of A to the i-th fundamental invariant.\n\nOptional arguments\n\nUsing the arguments :king or :primary_and_secondary for algo_gens selects the algorithm for the computation of the fundamental invariants (see fundamental_invariants for details). The argument :groebner_basis or :linear_algebra for algo_rels controls which algorithm for the computation of the relations between the fundamental invariants is used. With :groebner_basis, the relations are computed via the standard computation of a kernel of a morphism between multivariate polynomial rings. The option :linear_algebra uses an algorithm by Kemper and Steel [KS99], Section 17.5.5, to compute the relations without the use of Groebner bases. Note that this option is only available, if the fundamental invariants are computed via primary and secondary invariants (i.e. algo_gens = :primary_and_secondary).\n\nnote: Note\nIf a presentation of IR is already computed (and hence cached), this cached presentation will be returned and the values of algo_gens and algo_rels will be ignored. Further, if fundamental invariants are already computed and cached, the value of algo_gens might be ignored, as the cached system is used.\n\nExamples\n\njulia> K, a = cyclotomic_field(3, \"a\")\n(Cyclotomic field of order 3, a)\n\njulia> M1 = matrix(K, [0 0 1; 1 0 0; 0 1 0])\n[0   0   1]\n[1   0   0]\n[0   1   0]\n\njulia> M2 = matrix(K, [1 0 0; 0 a 0; 0 0 -a-1])\n[1   0        0]\n[0   a        0]\n[0   0   -a - 1]\n\njulia> G = matrix_group(M1, M2)\nMatrix group of degree 3\n  over cyclotomic field of order 3\n\njulia> IR = invariant_ring(G)\nInvariant ring\n  of matrix group of degree 3 over K\n\njulia> affine_algebra(IR)\n(Quotient of multivariate polynomial ring by ideal (9*y1^6 + y1^3*y2^3 - 6*y1^3*y2*y3 + 3*y1^3*y4 - y2*y3*y4 + y3^3 + y4^2), Hom: quotient of multivariate polynomial ring -> graded multivariate polynomial ring)\n\n\n\n\n\n","category":"method"},{"location":"InvariantTheory/finite_groups/#Semi-invariants-/-relative-invariants","page":"Invariants of Finite Groups","title":"Semi-invariants / relative invariants","text":"","category":"section"},{"location":"InvariantTheory/finite_groups/","page":"Invariants of Finite Groups","title":"Invariants of Finite Groups","text":"semi_invariants(IR::FinGroupInvarRing, chi::GAPGroupClassFunction)","category":"page"},{"location":"InvariantTheory/finite_groups/#semi_invariants-Tuple{Oscar.FinGroupInvarRing, Oscar.GAPGroupClassFunction}","page":"Invariants of Finite Groups","title":"semi_invariants","text":"semi_invariants(IR::FinGroupInvarRing, chi::GAPGroupClassFunction)\nrelative_invariants(IR::FinGroupInvarRing, chi::GAPGroupClassFunction)\n\nGiven an irreducible character chi of the underlying group, return a system of semi-invariants (or relative invariants) with respect to chi. By this, we mean a set of free generators of the isotypic component of the of the polynomial ring with respect to chi as a module over the algebra generated by primary invariants for IR. See also [Gat96] and [Sta79].\n\nnote: Note\nIf coefficient_ring(IR) does not contain all character values of chi, an error is raised.\n\nThis function is so far only implemented in the case of characteristic zero.\n\nExamples\n\njulia> S2 = symmetric_group(2);\n\njulia> RS2 = invariant_ring(S2);\n\njulia> F = abelian_closure(QQ)[1];\n\njulia> chi = Oscar.class_function(S2, [ F(sign(representative(c))) for c in conjugacy_classes(S2) ])\nclass_function(character table of S2, [1, -1])\n\njulia> semi_invariants(RS2, chi)\n1-element Vector{MPolyDecRingElem{QQFieldElem, QQMPolyRingElem}}:\n x[1] - x[2]\n\n\n\n\n\n\n","category":"method"},{"location":"Nemo/finitefield/","page":"Finite fields","title":"Finite fields","text":"CurrentModule = Nemo\nDocTestSetup = quote\n    using Nemo\nend","category":"page"},{"location":"Nemo/finitefield/#Finite-fields","page":"Finite fields","title":"Finite fields","text":"","category":"section"},{"location":"Nemo/finitefield/","page":"Finite fields","title":"Finite fields","text":"A finite field K is represented as simple extension K = k(alpha) = kx(f), where k can be","category":"page"},{"location":"Nemo/finitefield/","page":"Finite fields","title":"Finite fields","text":"a prime field mathbfF_p (K is then an absolute finite field), or\nan arbitrary finite field k (K is then a relative finite field).","category":"page"},{"location":"Nemo/finitefield/","page":"Finite fields","title":"Finite fields","text":"In both cases, we call k the base field of K, alpha a generator and f the defining polynomial of K.","category":"page"},{"location":"Nemo/finitefield/","page":"Finite fields","title":"Finite fields","text":"Note that all field theoretic properties (like basis, degree or trace) are defined with respect to the base field. Methods with prefix absolute_ return ","category":"page"},{"location":"Nemo/finitefield/#Finite-field-functionality","page":"Finite fields","title":"Finite field functionality","text":"","category":"section"},{"location":"Nemo/finitefield/","page":"Finite fields","title":"Finite fields","text":"Finite fields in Nemo provide all the field functionality described in AbstractAlgebra:","category":"page"},{"location":"Nemo/finitefield/","page":"Finite fields","title":"Finite fields","text":"https://nemocas.github.io/AbstractAlgebra.jl/stable/field","category":"page"},{"location":"Nemo/finitefield/","page":"Finite fields","title":"Finite fields","text":"Below we describe the functionality that is provided in addition to this.","category":"page"},{"location":"Nemo/finitefield/#Constructors","page":"Finite fields","title":"Constructors","text":"","category":"section"},{"location":"Nemo/finitefield/","page":"Finite fields","title":"Finite fields","text":"finite_field\nGF","category":"page"},{"location":"Nemo/finitefield/#finite_field","page":"Finite fields","title":"finite_field","text":"finite_field(p::IntegerUnion, d::Int, s::VarName = :o; cached::Bool = true, check::Bool = true)\nfinite_field(q::IntegerUnion, s::VarName = :o; cached::Bool = true, check::Bool = true)\nfinite_field(f::FqPolyRingElem, s::VarName = :o; cached::Bool = true, check::Bool = true)\n\nReturn a tuple (K x) of a finite field K of order q = p^d, where p is a prime, and a generator x of K (see gen for a definition). The identifier s is used to designate how the finite field generator will be printed.\n\nIf a polynomial f in kX over a finite field k is specified, the finite field K = kX(f) will be constructed as a finite field with base field k.\n\nSee also GF which only returns K.\n\nExamples\n\njulia> K, a = finite_field(3, 2, \"a\")\n(Finite field of degree 2 and characteristic 3, a)\n\njulia> K, a = finite_field(9, \"a\")\n(Finite field of degree 2 and characteristic 3, a)\n\njulia> Kx, x = K[\"x\"];\n\njulia> L, b = finite_field(x^3 + x^2 + x + 2, \"b\")\n(Finite field of degree 3 over GF(3, 2), b)\n\n\n\n\n\n","category":"function"},{"location":"Nemo/finitefield/#GF","page":"Finite fields","title":"GF","text":"GF(p::IntegerUnion, d::Int, s::VarName = :o; cached::Bool = true, check::Bool = true)\nGF(q::IntegerUnion, s::VarName = :o; cached::Bool = true, check::Bool = true)\nGF(f::FqPolyRingElem, s::VarName = :o; cached::Bool = true, check::Bool = true)\n\nReturn a finite field K of order q = p^d, where p is a prime. The identifier s is used to designate how the finite field generator will be printed.\n\nIf a polynomial f in kX over a finite field k is specified, the finite field K = kX(f) will be constructed as a finite field with base field k.\n\nSee also finite_field which additionally returns a finite field generator of K.\n\nExamples\n\njulia> K = GF(3, 2, \"a\")\nFinite field of degree 2 and characteristic 3\n\njulia> K = GF(9, \"a\")\nFinite field of degree 2 and characteristic 3\n\njulia> Kx, x = K[\"x\"];\n\njulia> L = GF(x^3 + x^2 + x + 2, \"b\")\nFinite field of degree 3 over GF(3, 2)\n\n\n\n\n\n","category":"function"},{"location":"Nemo/finitefield/#Field-functionality","page":"Finite fields","title":"Field functionality","text":"","category":"section"},{"location":"Nemo/finitefield/","page":"Finite fields","title":"Finite fields","text":"base_field(::FqField)\nprime_field(::FqField)\ndegree(::FqField)\nabsolute_degree(::FqField)\nis_absolute(::FqField)\ndefining_polynomial(::FqPolyRing, ::FqField)","category":"page"},{"location":"Nemo/finitefield/#base_field-Tuple{FqField}","page":"Finite fields","title":"base_field","text":"base_field(F::FqField)\n\nReturn the base field of F.\n\n\n\n\n\n","category":"method"},{"location":"Nemo/finitefield/#prime_field-Tuple{FqField}","page":"Finite fields","title":"prime_field","text":"prime_field(F::FqField)\n\nReturn the prime field of F.\n\n\n\n\n\n","category":"method"},{"location":"Nemo/finitefield/#degree-Tuple{FqField}","page":"Finite fields","title":"degree","text":"degree(K::FqField) -> Int\n\nReturn the degree of the given finite field over the base field.\n\nExamples\n\njulia> K, a = finite_field(3, 2, \"a\");\n\njulia> degree(K)\n2\n\njulia> Kx, x = K[\"x\"];\n\njulia> L, b = finite_field(x^3 + x^2 + x + 2, \"b\");\n\njulia> degree(L)\n3\n\n\n\n\n\n","category":"method"},{"location":"Nemo/finitefield/#absolute_degree-Tuple{FqField}","page":"Finite fields","title":"absolute_degree","text":"absolute_degree(a::FqField)\n\nReturn the degree of the given finite field over the prime field.\n\n\n\n\n\n","category":"method"},{"location":"Nemo/finitefield/#is_absolute-Tuple{FqField}","page":"Finite fields","title":"is_absolute","text":"is_absolute(F::FqField)\n\nReturn whether the base field of F is a prime field.\n\n\n\n\n\n","category":"method"},{"location":"Nemo/finitefield/#defining_polynomial-Tuple{FqPolyRing, FqField}","page":"Finite fields","title":"defining_polynomial","text":"defining_polynomial([R::FqPolyRing], K::FqField)\n\nReturn the defining polynomial of K as a polynomial over the base field of K.\n\nIf the polynomial ring R is specified, the polynomial will be an element of R.\n\nExamples\n\njulia> K, a = finite_field(9, \"a\");\n\njulia> defining_polynomial(K)\nx^2 + 2*x + 2\n\njulia> Ky, y = K[\"y\"];\n\njulia> L, b = finite_field(y^3 + y^2 + y + 2, \"b\");\n\njulia> defining_polynomial(L)\ny^3 + y^2 + y + 2\n\n\n\n\n\n","category":"method"},{"location":"Nemo/finitefield/#Element-functionality","page":"Finite fields","title":"Element functionality","text":"","category":"section"},{"location":"Nemo/finitefield/","page":"Finite fields","title":"Finite fields","text":"gen(::FqField)\nis_gen(::FqFieldElem)\ntr(::FqFieldElem)\nabsolute_tr(::FqFieldElem)\nnorm(::FqFieldElem)\nabsolute_norm(::FqFieldElem)\nlift(::FqPolyRing, ::FqFieldElem)\nlift(::ZZRing, ::FqFieldElem)","category":"page"},{"location":"Nemo/finitefield/#gen-Tuple{FqField}","page":"Finite fields","title":"gen","text":"gen(L::FqField)\n\nReturn a K-algebra generator a of the finite field L, where K is the base field of L. The element a satisfies defining_polyomial(a) == 0.\n\nNote that this is in general not a multiplicative generator and can be zero, if LK is an extension of degree one.\n\n\n\n\n\n","category":"method"},{"location":"Nemo/finitefield/#is_gen-Tuple{FqFieldElem}","page":"Finite fields","title":"is_gen","text":"is_gen(a::FqFieldElem)\n\nReturn true if the given finite field element is the generator of the finite field over its base field, otherwise return false.\n\n\n\n\n\n","category":"method"},{"location":"Nemo/finitefield/#tr-Tuple{FqFieldElem}","page":"Finite fields","title":"tr","text":"tr(x::FqFieldElem)\n\nReturn the trace of x. This is an element of the base field.\n\n\n\n\n\n","category":"method"},{"location":"Nemo/finitefield/#absolute_tr-Tuple{FqFieldElem}","page":"Finite fields","title":"absolute_tr","text":"absolute_tr(x::FqFieldElem)\n\nReturn the absolute trace of x. This is an element of the prime field.\n\n\n\n\n\n","category":"method"},{"location":"Nemo/finitefield/#norm-Tuple{FqFieldElem}","page":"Finite fields","title":"norm","text":"norm(x::FqFieldElem)\n\nReturn the norm of x. This is an element of the base field.\n\n\n\n\n\n","category":"method"},{"location":"Nemo/finitefield/#absolute_norm-Tuple{FqFieldElem}","page":"Finite fields","title":"absolute_norm","text":"absolute_norm(x::FqFieldElem)\n\nReturn the absolute norm of x. This is an element of the prime field.\n\n\n\n\n\n","category":"method"},{"location":"Nemo/finitefield/#lift-Tuple{FqPolyRing, FqFieldElem}","page":"Finite fields","title":"lift","text":"lift(R::FqPolyRing, a::FqFieldElem) -> FqPolyRingElem\n\nGiven a polynomial ring over the base field of the parent of a, return a lift such that parent(a)(lift(R, a)) == a is true.\n\n\n\n\n\n","category":"method"},{"location":"Nemo/finitefield/#lift-Tuple{ZZRing, FqFieldElem}","page":"Finite fields","title":"lift","text":"lift(::ZZRing, x::FqFieldElem) -> ZZRingElem\n\nGiven an element x of a prime field mathbfF_p, return a preimage under the canonical map mathbfZ to mathbfF_p.\n\nExamples\n\njulia> K = GF(19);\n\njulia> lift(ZZ, K(3))\n3\n\n\n\n\n\n","category":"method"},{"location":"DeveloperDocumentation/printing_details/#Printing-in-OSCAR","page":"Printing in OSCAR","title":"Printing in OSCAR","text":"","category":"section"},{"location":"DeveloperDocumentation/printing_details/","page":"Printing in OSCAR","title":"Printing in OSCAR","text":"The following section contains more details and examples on how to implement OSCAR's 2+1 printing modes. The specifications and a minimal example may be found in the Developer Style Guide.","category":"page"},{"location":"DeveloperDocumentation/printing_details/#Implementing-show-functions","page":"Printing in OSCAR","title":"Implementing show functions","text":"","category":"section"},{"location":"DeveloperDocumentation/printing_details/","page":"Printing in OSCAR","title":"Printing in OSCAR","text":"Here is the translation between :detail, one line and terse, where io is an IO object (such as stdout or an IOBuffer):","category":"page"},{"location":"DeveloperDocumentation/printing_details/","page":"Printing in OSCAR","title":"Printing in OSCAR","text":"show(io, MIME\"text/plain\"(), x)                # detailed printing\nprint(io, x)                                   # one line printing\nprint(terse(io), x)                            # terse printing","category":"page"},{"location":"DeveloperDocumentation/printing_details/","page":"Printing in OSCAR","title":"Printing in OSCAR","text":"For reference, string interpolation \"$(x)\" uses one line printing via print(io, x), while on the REPL detailed printing is used to show top level objects.","category":"page"},{"location":"DeveloperDocumentation/printing_details/","page":"Printing in OSCAR","title":"Printing in OSCAR","text":"warning: display\nPlease do not use display! From the Julia documentation of display: \"In general, you cannot assume that display output goes to stdout [...]\". In particular, the output of display will not work in the jldoctests.","category":"page"},{"location":"DeveloperDocumentation/printing_details/#Mockup","page":"Printing in OSCAR","title":"Mockup","text":"","category":"section"},{"location":"DeveloperDocumentation/printing_details/#Detailed-printing-with-a-new-line","page":"Printing in OSCAR","title":"Detailed printing with a new line","text":"","category":"section"},{"location":"DeveloperDocumentation/printing_details/","page":"Printing in OSCAR","title":"Printing in OSCAR","text":"struct NewRing\n  base_ring\nend\n\nbase_ring(R::NewRing) = R.base_ring","category":"page"},{"location":"DeveloperDocumentation/printing_details/","page":"Printing in OSCAR","title":"Printing in OSCAR","text":"The following is a template for detailed printing. Note that at least one new line is needed for technical reasons. see below why.","category":"page"},{"location":"DeveloperDocumentation/printing_details/","page":"Printing in OSCAR","title":"Printing in OSCAR","text":"function Base.show(io::IO, ::MIME\"text/plain\", R::NewRing)\n  println(io, \"I am a new ring\")  # at least one new line is needed\n  println(io, \"I print with newlines\")\n  print(io, base_ring(R)) # the last print statement must not add a new line\nend","category":"page"},{"location":"DeveloperDocumentation/printing_details/","page":"Printing in OSCAR","title":"Printing in OSCAR","text":"The following is a template for one line and terse printing.","category":"page"},{"location":"DeveloperDocumentation/printing_details/","page":"Printing in OSCAR","title":"Printing in OSCAR","text":"function Base.show(io::IO, R::NewRing)\n  if is_terse(io)\n    # no nested printing\n    print(io, \"terse printing of newring \")\n  else\n    # nested printing allowed, preferably terse\n    print(io, \"one line printing of newring with \")\n    print(terse(io), \"terse \", base_ring(R))\n  end\nend","category":"page"},{"location":"DeveloperDocumentation/printing_details/","page":"Printing in OSCAR","title":"Printing in OSCAR","text":"And this is how it looks like:","category":"page"},{"location":"DeveloperDocumentation/printing_details/","page":"Printing in OSCAR","title":"Printing in OSCAR","text":"julia> R = NewRing(QQ)\nI am a new ring\nI print with newlines\nQQ\n\njulia> [R,R]\n2-element Vector{NewRing}:\n one line printing of newring with terse QQ\n one line printing of newring with terse QQ\n","category":"page"},{"location":"DeveloperDocumentation/printing_details/#Detailed-printing-in-a-single-line","page":"Printing in OSCAR","title":"Detailed printing in a single line","text":"","category":"section"},{"location":"DeveloperDocumentation/printing_details/","page":"Printing in OSCAR","title":"Printing in OSCAR","text":"This version needs to be used in case the detailed printing does not contain newlines. Then detailed and one line printing agree. The if clause takes care of terse printing as well.","category":"page"},{"location":"DeveloperDocumentation/printing_details/","page":"Printing in OSCAR","title":"Printing in OSCAR","text":"struct NewRing2\n  base_ring\nend\n\nbase_ring(R::NewRing2) = R.base_ring\n\nfunction Base.show(io::IO, R::NewRing2)\n  if is_terse(io)\n    # no nested printing\n    print(io, \"terse printing of newring\")\n  else\n    # nested printing allowed, preferably terse\n    print(io, \"I am a new ring and always print in one line \" )\n    print(terse(io), base_ring(R))\n  end\nend","category":"page"},{"location":"DeveloperDocumentation/printing_details/","page":"Printing in OSCAR","title":"Printing in OSCAR","text":"And this is how it looks like:","category":"page"},{"location":"DeveloperDocumentation/printing_details/","page":"Printing in OSCAR","title":"Printing in OSCAR","text":"julia> R = NewRing2(QQ)\nI am a new ring and always print in one line QQ\n\njulia> [R,R]\n2-element Vector{NewRing2}:\n I am a new ring and always print in one line Rational Field\n I am a new ring and always print in one line Rational Field\n\njulia> print(terse(Base.stdout) ,R)\nterse printing of newring","category":"page"},{"location":"DeveloperDocumentation/printing_details/","page":"Printing in OSCAR","title":"Printing in OSCAR","text":"The terse printing uses an IOContext (see IOContext from the Julia documentation) to pass information to other show methods invoked recursively (for example in nested printings). The same mechanism can be used to pass other context data. For instance, this is used by the Scheme code in some nested printings which invoke several objects whose printing depends on a given covering: we use IOContext to pass a fix covering to the printing of each sub-object for consistency and readability.","category":"page"},{"location":"DeveloperDocumentation/printing_details/#The-following-is-not-working-as-expected-and-should-not-be-used","page":"Printing in OSCAR","title":"The following is not working as expected and should not be used","text":"","category":"section"},{"location":"DeveloperDocumentation/printing_details/","page":"Printing in OSCAR","title":"Printing in OSCAR","text":"This example does not work correctly because the detailed printing does not include a newline, which is expected by the Julia printing system. To correctly support single line detailed printing, read the preceding section.","category":"page"},{"location":"DeveloperDocumentation/printing_details/","page":"Printing in OSCAR","title":"Printing in OSCAR","text":"function Base.show(io::IO, ::MIME\"text/plain\", R::NewRing)  # do not implement me like this\n  print(io, \"I am a new ring with a detailed printing of one line\")\nend","category":"page"},{"location":"DeveloperDocumentation/printing_details/","page":"Printing in OSCAR","title":"Printing in OSCAR","text":"Then the following will not be used for array/tuple printing. It will be used for print(io, R::NewRing) though.","category":"page"},{"location":"DeveloperDocumentation/printing_details/","page":"Printing in OSCAR","title":"Printing in OSCAR","text":"function Base.show(io::IO, R::NewRing)\n  if is_terse(io)\n    print(io, \"terse printing of newring\")\n  else # this is what we call one line\n    print(io, \"one line printing of newring with \")\n    print(terse(io), \"terse \", R.base_ring)\n  end\nend","category":"page"},{"location":"DeveloperDocumentation/printing_details/","page":"Printing in OSCAR","title":"Printing in OSCAR","text":"This example illustrates the unexpected behavior.","category":"page"},{"location":"DeveloperDocumentation/printing_details/","page":"Printing in OSCAR","title":"Printing in OSCAR","text":"julia> R = NewRing(1)\n\njulia> R\nI am a new ring with a detailed printing of one line\n\njulia> [R,R]  # one line printing is ignored\n2-element Vector{NewRing}:\n I am a new ring with a detailed printing of one line\n I am a new ring with a detailed printing of one line\n\njulia> print(Base.stdout, R)\none line printing of newring with terse QQ","category":"page"},{"location":"DeveloperDocumentation/printing_details/#Advanced-printing-functionality","page":"Printing in OSCAR","title":"Advanced printing functionality","text":"","category":"section"},{"location":"DeveloperDocumentation/printing_details/","page":"Printing in OSCAR","title":"Printing in OSCAR","text":"To facilitate printing of nested mathematical structures, we provide a modified IOCustom object. To create one, we use the following command:","category":"page"},{"location":"DeveloperDocumentation/printing_details/","page":"Printing in OSCAR","title":"Printing in OSCAR","text":"AbstractAlgebra.pretty(::IO)","category":"page"},{"location":"DeveloperDocumentation/printing_details/#pretty-Tuple{IO}","page":"Printing in OSCAR","title":"pretty","text":"pretty(io::IO) -> IOCustom\n\nWrap io into an IOCustom object.\n\nExamples\n\njulia> io = AbstractAlgebra.pretty(stdout);\n\n\n\n\n\n","category":"method"},{"location":"DeveloperDocumentation/printing_details/","page":"Printing in OSCAR","title":"Printing in OSCAR","text":"The IOCustom object allows one to locally control:","category":"page"},{"location":"DeveloperDocumentation/printing_details/","page":"Printing in OSCAR","title":"Printing in OSCAR","text":"indentation using Indent() and Dedent(),\ncapitalization using Lowercase() and LowercaseOff().","category":"page"},{"location":"DeveloperDocumentation/printing_details/#Example","page":"Printing in OSCAR","title":"Example","text":"","category":"section"},{"location":"DeveloperDocumentation/printing_details/","page":"Printing in OSCAR","title":"Printing in OSCAR","text":"We illustrate this with an example","category":"page"},{"location":"DeveloperDocumentation/printing_details/","page":"Printing in OSCAR","title":"Printing in OSCAR","text":"struct A{T}\n  x::T\nend\n\nfunction Base.show(io::IO, a::A)\n  io = pretty(io)\n  println(io, \"Something of type A\")\n  print(io, Indent(), \"over \", Lowercase(), a.x)\n  print(io, Dedent()) # don't forget to undo the indentation!\nend\n\nstruct B\nend\n\nfunction Base.show(io::IO, b::B)\n  io = pretty(io)\n  print(io, LowercaseOff(), \"Hilbert thing\")\nend","category":"page"},{"location":"DeveloperDocumentation/printing_details/","page":"Printing in OSCAR","title":"Printing in OSCAR","text":"At the REPL, this will then be printed as follows:","category":"page"},{"location":"DeveloperDocumentation/printing_details/","page":"Printing in OSCAR","title":"Printing in OSCAR","text":"julia> A(2)\nSomething of type A\n  over 2\n\njulia> A(A(2))\nSomething of type A\n  over something of type A\n    over 2\n\njulia> A(B())\nSomething of type A\n  over Hilbert thing","category":"page"},{"location":"DeveloperDocumentation/printing_details/","page":"Printing in OSCAR","title":"Printing in OSCAR","text":"Moreover, one can control the pluralization of nouns when printing a set of elements with a variable number of objects. For this, one can use ItemQuantity:","category":"page"},{"location":"DeveloperDocumentation/printing_details/#Example-2","page":"Printing in OSCAR","title":"Example","text":"","category":"section"},{"location":"DeveloperDocumentation/printing_details/","page":"Printing in OSCAR","title":"Printing in OSCAR","text":"We illustrate this with an example","category":"page"},{"location":"DeveloperDocumentation/printing_details/","page":"Printing in OSCAR","title":"Printing in OSCAR","text":"julia> struct C{T}\n       x::Vector{T}\n       end\n\njulia> function Base.show(io::IO, c::C{T}) where T\n       x = c.x\n       n = length(x)\n       print(io, \"Something with \", ItemQuantity(n, \"element\"), \" of type $T\")\n       end","category":"page"},{"location":"DeveloperDocumentation/printing_details/","page":"Printing in OSCAR","title":"Printing in OSCAR","text":"At the REPL, this will then be printed as follows:","category":"page"},{"location":"DeveloperDocumentation/printing_details/","page":"Printing in OSCAR","title":"Printing in OSCAR","text":"julia> C(Int[2,3,4])\nSomething with 3 elements of type Int64\n\njulia> C(Int[])\nSomething with 0 elements of type Int64\n\njulia> C(Int[6])\nSomething with 1 element of type Int64","category":"page"},{"location":"DeveloperDocumentation/printing_details/#LaTeX-and-Unicode-printing","page":"Printing in OSCAR","title":"LaTeX and Unicode printing","text":"","category":"section"},{"location":"DeveloperDocumentation/printing_details/#LaTeX-output","page":"Printing in OSCAR","title":"LaTeX output","text":"","category":"section"},{"location":"DeveloperDocumentation/printing_details/","page":"Printing in OSCAR","title":"Printing in OSCAR","text":"Some types support LaTeX output.","category":"page"},{"location":"DeveloperDocumentation/printing_details/","page":"Printing in OSCAR","title":"Printing in OSCAR","text":"julia> Qx, x = QQ[:x];\n\njulia> show(stdout, \"text/latex\", x^2 + 2x + x^10)\nx^{10} + x^{2} + 2 x\n\njulia> show(stdout, \"text/latex\", Qx[x x^2; 1 1])\n\\begin{array}{cc}\nx & x^{2} \\\\\n1 & 1\n\\end{array}","category":"page"},{"location":"DeveloperDocumentation/printing_details/","page":"Printing in OSCAR","title":"Printing in OSCAR","text":"Base.show(io::IOContext, ::MIME\"text/latex\")","category":"page"},{"location":"DeveloperDocumentation/printing_details/#Unicode-printing","page":"Printing in OSCAR","title":"Unicode printing","text":"","category":"section"},{"location":"DeveloperDocumentation/printing_details/","page":"Printing in OSCAR","title":"Printing in OSCAR","text":"Per default output should be ASCII only (no Unicode). Implementors of Base.show and related functions can branch on the output of Oscar.is_unicode_allowed() to display objects using non-ASCII characters. This will then be used for users which enabled Unicode using allow_unicode(true). Note that","category":"page"},{"location":"DeveloperDocumentation/printing_details/","page":"Printing in OSCAR","title":"Printing in OSCAR","text":"there must be a default ASCII only output, since this is the default setting for new users, and\nOSCAR library code is not allowed to call Oscar.allow_unicode.","category":"page"},{"location":"DeveloperDocumentation/printing_details/","page":"Printing in OSCAR","title":"Printing in OSCAR","text":"Objects may follow the value of Oscar.is_unicode_allowed() at the time of their creation for their printing, i.e. ignore later changes of the setting. This is useful for objects storing a string representation of themselves, e.g. generators of a module.","category":"page"},{"location":"DeveloperDocumentation/printing_details/","page":"Printing in OSCAR","title":"Printing in OSCAR","text":"Here is an example with and without output using Unicode:","category":"page"},{"location":"DeveloperDocumentation/printing_details/","page":"Printing in OSCAR","title":"Printing in OSCAR","text":"  struct AtoB\n  end\n\n  function Base.show(io::IO, ::AtoB)\n    if Oscar.is_unicode_allowed()\n      print(io, \"A→B\")\n    else\n      print(io, \"A->B\")\n    end\n  end","category":"page"},{"location":"DeveloperDocumentation/printing_details/#On-using-@show_name,-@show_special,-@show_special_elem","page":"Printing in OSCAR","title":"On using @show_name, @show_special, @show_special_elem","text":"","category":"section"},{"location":"DeveloperDocumentation/printing_details/","page":"Printing in OSCAR","title":"Printing in OSCAR","text":"All show methods for parent objects such as rings or modules should use the @show_name macro. This macro ensures that if the object has a name (including one derived from the name of a Julia REPL variable to which the object is currently assigned) then in a compact or terse io context it is printed using that name. Here is an example illustrating this:\njulia> vector_space(GF(2), 2)\nVector space of dimension 2 over prime field of characteristic 2\n\njulia> K = GF(2)\nFinite field F_2\n\njulia> vector_space(K, 2)\nVector space of dimension 2 over K\nThe documentation for AbstractAlgebra.get_name describes how the name is determined.\nAll show methods for parent objects should also use @show_special. This checks if an attribute :show is present. If so, it has to be a function taking IO, optionally a MIME-type, and the object. This is then called instead of the usual show function.\nSimilarly, all show methods for element objects may use @show_special_elem which checks if an attribute :show_elem is present in the object's parent. The semantics are the same as for @show_special.","category":"page"},{"location":"DeveloperDocumentation/printing_details/","page":"Printing in OSCAR","title":"Printing in OSCAR","text":"For details please consult the Advanced printing section of the AbstractAlgebra documentation.","category":"page"},{"location":"Hecke/manual/abelian/elements/","page":"Elements","title":"Elements","text":"CurrentModule = Hecke\nDocTestSetup = quote\n    using Hecke\nend","category":"page"},{"location":"Hecke/manual/abelian/elements/#Elements","page":"Elements","title":"Elements","text":"","category":"section"},{"location":"Hecke/manual/abelian/elements/","page":"Elements","title":"Elements","text":"Elements in a finitely generated abelian group are of type FinGenAbGroupElem and are always given as a linear combination of the generators. Internally this representation is normliased to have a unique representative.","category":"page"},{"location":"Hecke/manual/abelian/elements/#Creation","page":"Elements","title":"Creation","text":"","category":"section"},{"location":"Hecke/manual/abelian/elements/","page":"Elements","title":"Elements","text":"In addition to the standard function id, zero and one that can be used to create the neutral element, we also support more targeted creation:","category":"page"},{"location":"Hecke/manual/abelian/elements/","page":"Elements","title":"Elements","text":"gens(G::FinGenAbGroup)\nFinGenAbGroup(x::Vector{ZZRingElem})\nFinGenAbGroup(x::ZZMatrix)\ngetindex(A::FinGenAbGroup, i::Int)\nrand(G::FinGenAbGroup)\nrand(G::FinGenAbGroup, B::ZZRingElem)\nparent(x::FinGenAbGroupElem)","category":"page"},{"location":"Hecke/manual/abelian/elements/#gens-Tuple{FinGenAbGroup}","page":"Elements","title":"gens","text":"gens(G::FinGenAbGroup) -> Vector{FinGenAbGroupElem}\n\nThe sequence of generators of G.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/abelian/elements/#FinGenAbGroup-Tuple{Vector{ZZRingElem}}","page":"Elements","title":"FinGenAbGroup","text":"(A::FinGenAbGroup)(x::Vector{ZZRingElem}) -> FinGenAbGroupElem\n\nGiven an array x of elements of type ZZRingElem of the same length as ngens(A), this function returns the element of A with components x.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/abelian/elements/#FinGenAbGroup-Tuple{ZZMatrix}","page":"Elements","title":"FinGenAbGroup","text":"(A::FinGenAbGroup)(x::ZZMatrix) -> FinGenAbGroupElem\n\nGiven a matrix over the integers with either 1 row and ngens(A) columns or ngens(A) rows and 1 column, this function returns the element of A with components x.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/abelian/elements/#getindex-Tuple{FinGenAbGroup, Int64}","page":"Elements","title":"getindex","text":"getindex(A::FinGenAbGroup, i::Int) -> FinGenAbGroupElem\n\nReturns the element of A with components (0dotsc010dotsc0), where the 1 is at the i-th position.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/abelian/elements/#rand-Tuple{FinGenAbGroup}","page":"Elements","title":"rand","text":"rand(G::FinGenAbGroup) -> FinGenAbGroupElem\n\nReturns an element of G chosen uniformly at random.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/abelian/elements/#rand-Tuple{FinGenAbGroup, ZZRingElem}","page":"Elements","title":"rand","text":"rand(G::FinGenAbGroup, B::ZZRingElem) -> FinGenAbGroupElem\n\nFor a (potentially infinite) abelian group G, return an element chosen uniformly at random with coefficients bounded by B.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/abelian/elements/#parent-Tuple{FinGenAbGroupElem}","page":"Elements","title":"parent","text":"parent(x::FinGenAbGroupElem) -> FinGenAbGroup\n\nReturns the parent of x.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/abelian/elements/#Access","page":"Elements","title":"Access","text":"","category":"section"},{"location":"Hecke/manual/abelian/elements/","page":"Elements","title":"Elements","text":"getindex(x::FinGenAbGroupElem, v::AbstractVector{Int})\ngetindex(x::FinGenAbGroupElem, i::Int)","category":"page"},{"location":"Hecke/manual/abelian/elements/#getindex-Tuple{FinGenAbGroupElem, AbstractVector{Int64}}","page":"Elements","title":"getindex","text":"getindex(x::FinGenAbGroupElem, v::AbstractVector{Int}) -> Vector{ZZRingElem}\n\nReturns the i-th components of the element x where i in v.\n\nnote: Note\nThis function is inefficient since the elements are internally stored using ZZMatrix but this function outputs a vector.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/abelian/elements/#getindex-Tuple{FinGenAbGroupElem, Int64}","page":"Elements","title":"getindex","text":"getindex(x::FinGenAbGroupElem, i::Int) -> ZZRingElem\n\nReturns the i-th component of the element x.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/abelian/elements/#Predicates","page":"Elements","title":"Predicates","text":"","category":"section"},{"location":"Hecke/manual/abelian/elements/","page":"Elements","title":"Elements","text":"We have the standard predicates iszero, isone and is_identity to test an element for being trivial.","category":"page"},{"location":"Hecke/manual/abelian/elements/#Invariants","page":"Elements","title":"Invariants","text":"","category":"section"},{"location":"Hecke/manual/abelian/elements/","page":"Elements","title":"Elements","text":"order(A::FinGenAbGroupElem)","category":"page"},{"location":"Hecke/manual/abelian/elements/#order-Tuple{FinGenAbGroupElem}","page":"Elements","title":"order","text":"order(A::FinGenAbGroupElem) -> ZZRingElem\n\nReturns the order of A. It is assumed that the order is finite.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/abelian/elements/#Iterator","page":"Elements","title":"Iterator","text":"","category":"section"},{"location":"Hecke/manual/abelian/elements/","page":"Elements","title":"Elements","text":"One can iterate over the elements of a finite abelian group.","category":"page"},{"location":"Hecke/manual/abelian/elements/","page":"Elements","title":"Elements","text":"using Hecke # hide\nG = abelian_group(ZZRingElem[1 2; 3 4])\nfor g = G\n  println(g)\nend","category":"page"},{"location":"AlgebraicGeometry/AlgebraicSets/AffineAlgebraicSet/","page":"Affine Algebraic Sets","title":"Affine Algebraic Sets","text":"CurrentModule = Oscar\nDocTestSetup = Oscar.doctestsetup()","category":"page"},{"location":"AlgebraicGeometry/AlgebraicSets/AffineAlgebraicSet/#Affine-Algebraic-Sets","page":"Affine Algebraic Sets","title":"Affine Algebraic Sets","text":"","category":"section"},{"location":"AlgebraicGeometry/AlgebraicSets/AffineAlgebraicSet/#Introduction","page":"Affine Algebraic Sets","title":"Introduction","text":"","category":"section"},{"location":"AlgebraicGeometry/AlgebraicSets/AffineAlgebraicSet/","page":"Affine Algebraic Sets","title":"Affine Algebraic Sets","text":"Let mathbbA^n(k)=k^n be the affine space of dimension n over a field k. For finitely many multivariate polynomials f_1 dots f_r in kx_1dots x_n and I = (f_1 dots f_r) subseteq kx_1dots x_n the ideal they generate, we denote by X = V(I) the (affine) algebraic set defined by the ideal I and call k its base field.","category":"page"},{"location":"AlgebraicGeometry/AlgebraicSets/AffineAlgebraicSet/","page":"Affine Algebraic Sets","title":"Affine Algebraic Sets","text":"If k subseteq K is any field extension, we denote the set of K-points of X by","category":"page"},{"location":"AlgebraicGeometry/AlgebraicSets/AffineAlgebraicSet/","page":"Affine Algebraic Sets","title":"Affine Algebraic Sets","text":"beginalignedX(K) =  P in mathbbA^n(K) mid f_1(P)=dots = f_n(P)=0=P in mathbbA^n(K) mid forall fin I  f(P)=0endaligned","category":"page"},{"location":"AlgebraicGeometry/AlgebraicSets/AffineAlgebraicSet/","page":"Affine Algebraic Sets","title":"Affine Algebraic Sets","text":"Most properties of the algebraic set X refer to X(K) where K is an algebraically closed field. For instance is_empty returns whether X(K) = emptyset.","category":"page"},{"location":"AlgebraicGeometry/AlgebraicSets/AffineAlgebraicSet/","page":"Affine Algebraic Sets","title":"Affine Algebraic Sets","text":"Exceptions to the rule, that we refer to X(K), are documented in the respective methods. For example the property of being irreducible depends on k: The algebraic set X = V(x^2+y^2) subseteq mathbbA^2 is irreducible over k = mathbbR. But it is the union of two lines over K = mathbbC, i.e. X is irreducible but geometrically reducible. See is_irreducible(X::AbsAffineScheme{<:Field, <:MPolyAnyRing}) for details.","category":"page"},{"location":"AlgebraicGeometry/AlgebraicSets/AffineAlgebraicSet/#Rational-points","page":"Affine Algebraic Sets","title":"Rational points","text":"","category":"section"},{"location":"AlgebraicGeometry/AlgebraicSets/AffineAlgebraicSet/","page":"Affine Algebraic Sets","title":"Affine Algebraic Sets","text":"To study the k-points, also called k-rational points, of the algebraic set X one first considers the solutions X(K) over an algebraically closed field extension K of k. Then in a second step one studies X(k) as a subset of X(K).","category":"page"},{"location":"AlgebraicGeometry/AlgebraicSets/AffineAlgebraicSet/","page":"Affine Algebraic Sets","title":"Affine Algebraic Sets","text":"The first step involves calculations with ideals. For instance Hilbert's Nullstellensatz implies that X(K) is empty if and only if the ideal I=(1). This is decided by an ideal membership test relying on a Gröbner basis computation of I and can be carried out in kx_1dots x_n without taking any field extensions.","category":"page"},{"location":"AlgebraicGeometry/AlgebraicSets/AffineAlgebraicSet/","page":"Affine Algebraic Sets","title":"Affine Algebraic Sets","text":"The second step involves methods from number theory (if k is a number field) or from real algebraic geometry (if k = mathbbR).","category":"page"},{"location":"AlgebraicGeometry/AlgebraicSets/AffineAlgebraicSet/","page":"Affine Algebraic Sets","title":"Affine Algebraic Sets","text":"Algebraic sets in Oscar are designed for the first step. Most of their properfties should be interpreted as properties of the set X(K) of their K-points over an algebraic closure K.","category":"page"},{"location":"AlgebraicGeometry/AlgebraicSets/AffineAlgebraicSet/#Relation-to-Schemes","page":"Affine Algebraic Sets","title":"Relation to Schemes","text":"","category":"section"},{"location":"AlgebraicGeometry/AlgebraicSets/AffineAlgebraicSet/","page":"Affine Algebraic Sets","title":"Affine Algebraic Sets","text":"One may view an (affine) algebraic set as a geometrically reduced (affine) scheme over a field k.","category":"page"},{"location":"AlgebraicGeometry/AlgebraicSets/AffineAlgebraicSet/","page":"Affine Algebraic Sets","title":"Affine Algebraic Sets","text":"Many constructions involving varieties lead naturally to schemes. For instance the intersection of X = V(x^2 - y) and Y = V(y) as sets is the point (00)=V(xy). As a scheme the intersection is defined by the ideal (x^2 y) which can be interpreted as a point of multiplicity 2 and contains the information that the intersection of X and Y is tangential in (00).","category":"page"},{"location":"AlgebraicGeometry/AlgebraicSets/AffineAlgebraicSet/","page":"Affine Algebraic Sets","title":"Affine Algebraic Sets","text":"Therefore we have two methods","category":"page"},{"location":"AlgebraicGeometry/AlgebraicSets/AffineAlgebraicSet/","page":"Affine Algebraic Sets","title":"Affine Algebraic Sets","text":"set_theoretic_intersection(::AbsAffineAlgebraicSet) which can be thought of as X(K)cap Y(K)\nintersect(::AbsAffineAlgebraicSet) which is the scheme theoretic intersection","category":"page"},{"location":"AlgebraicGeometry/AlgebraicSets/AffineAlgebraicSet/","page":"Affine Algebraic Sets","title":"Affine Algebraic Sets","text":"note: Note\nIf a construction returns a scheme Z, but you want to ignore the scheme structure, call the function algebraic_set(Z) to convert the scheme Z to an affine algebraic set.","category":"page"},{"location":"AlgebraicGeometry/AlgebraicSets/AffineAlgebraicSet/","page":"Affine Algebraic Sets","title":"Affine Algebraic Sets","text":"For example algebraic_set(intersect(X, Y)) is equivalent to set_theoretic_intersection(X, Y).","category":"page"},{"location":"AlgebraicGeometry/AlgebraicSets/AffineAlgebraicSet/","page":"Affine Algebraic Sets","title":"Affine Algebraic Sets","text":"Internally an AffineAlgebraicSet is constructed from a possibly non-reduced affine scheme, which we call the fat_scheme of X as opposed to the reduced_scheme of X which we refer to as the underlying_scheme.","category":"page"},{"location":"AlgebraicGeometry/AlgebraicSets/AffineAlgebraicSet/","page":"Affine Algebraic Sets","title":"Affine Algebraic Sets","text":"fat_ideal(X::AffineAlgebraicSet{<:Field})\nfat_scheme(X::AffineAlgebraicSet)\nunderlying_scheme(X::AffineAlgebraicSet)","category":"page"},{"location":"AlgebraicGeometry/AlgebraicSets/AffineAlgebraicSet/#fat_ideal-Tuple{AffineAlgebraicSet}","page":"Affine Algebraic Sets","title":"fat_ideal","text":"fat_ideal(X::AbsAffineAlgebraicSet) -> Ideal\n\nReturn an ideal whose radical is the vanishing ideal of X.\n\nIf X is constructed from an ideal I this returns I.\n\njulia> A2 = affine_space(QQ, [:x,:y])\nAffine space of dimension 2\n  over rational field\nwith coordinates [x, y]\n\njulia> (x, y) = coordinates(A2);\n\njulia> I = ideal([x^2, y]);\n\njulia> X = algebraic_set(I)\nAffine algebraic set\n  in affine 2-space over QQ with coordinates [x, y]\ndefined by ideal (x^2, y)\n\njulia> fat_ideal(X) === I\ntrue\n\n\n\n\n\n","category":"method"},{"location":"AlgebraicGeometry/AlgebraicSets/AffineAlgebraicSet/#fat_scheme-Tuple{AffineAlgebraicSet}","page":"Affine Algebraic Sets","title":"fat_scheme","text":"fat_scheme(X::AffineAlgebraicSet) -> AbsAffineScheme\n\nReturn a scheme whose reduced subscheme is X.\n\nThis does not trigger any computation and is therefore cheap. Use this instead of underlying_scheme when possible.\n\n\n\n\n\n","category":"method"},{"location":"AlgebraicGeometry/AlgebraicSets/AffineAlgebraicSet/#underlying_scheme-Tuple{AffineAlgebraicSet}","page":"Affine Algebraic Sets","title":"underlying_scheme","text":"underlying_scheme(X::AffineAlgebraicSet) -> AbsAffineScheme\n\nReturn the underlying reduced scheme defining X.\n\nThis is used to forward the AbsAffineScheme functionality to X, but may trigger the computation of a radical ideal. Hence this can be expensive.\n\n\n\n\n\n","category":"method"},{"location":"AlgebraicGeometry/AlgebraicSets/AffineAlgebraicSet/#More-general-affine-algebraic-sets","page":"Affine Algebraic Sets","title":"More general affine algebraic sets","text":"","category":"section"},{"location":"AlgebraicGeometry/AlgebraicSets/AffineAlgebraicSet/","page":"Affine Algebraic Sets","title":"Affine Algebraic Sets","text":"By abuse of terminology we say that a scheme is an affine algebraic set if it is isomorphic to one. For example a hypersurface complement is an affine algebraic set. In particular, we allow affine algebraic sets which are not necessarily Zariski closed in their ambient affine space.","category":"page"},{"location":"AlgebraicGeometry/AlgebraicSets/AffineAlgebraicSet/","page":"Affine Algebraic Sets","title":"Affine Algebraic Sets","text":"AbsAffineAlgebraicSet","category":"page"},{"location":"AlgebraicGeometry/AlgebraicSets/AffineAlgebraicSet/#AbsAffineAlgebraicSet","page":"Affine Algebraic Sets","title":"AbsAffineAlgebraicSet","text":"AbsAffineAlgebraicSet <: AbsAffineScheme\n\nAn affine, geometrically reduced subscheme of an affine space over a field.\n\n\n\n\n\n","category":"type"},{"location":"AlgebraicGeometry/AlgebraicSets/AffineAlgebraicSet/#Constructors","page":"Affine Algebraic Sets","title":"Constructors","text":"","category":"section"},{"location":"AlgebraicGeometry/AlgebraicSets/AffineAlgebraicSet/","page":"Affine Algebraic Sets","title":"Affine Algebraic Sets","text":"One can create an algebraic set from an ideal or a multivariate polynomial.","category":"page"},{"location":"AlgebraicGeometry/AlgebraicSets/AffineAlgebraicSet/","page":"Affine Algebraic Sets","title":"Affine Algebraic Sets","text":"algebraic_set(I::MPolyIdeal{<:MPolyRingElem}; check::Bool=true)\nalgebraic_set(f::MPolyRingElem; check::Bool=true)","category":"page"},{"location":"AlgebraicGeometry/AlgebraicSets/AffineAlgebraicSet/#algebraic_set-Tuple{MPolyIdeal{<:MPolyRingElem}}","page":"Affine Algebraic Sets","title":"algebraic_set","text":"algebraic_set(I::MPolyIdeal; is_radical::Bool=false, check::Bool=true)\n\nReturn the affine algebraic set defined I.\n\nIf is_radical is set, assume that I is a radical ideal.\n\njulia> R, (x,y) = GF(2)[:x,:y];\n\njulia> X = algebraic_set(ideal([y^2+y+x^3+1,x]))\nAffine algebraic set\n  in affine 2-space over GF(2) with coordinates [x, y]\ndefined by ideal (x^3 + y^2 + y + 1, x)\n\n\n\n\n\n\n","category":"method"},{"location":"AlgebraicGeometry/AlgebraicSets/AffineAlgebraicSet/#algebraic_set-Tuple{MPolyRingElem}","page":"Affine Algebraic Sets","title":"algebraic_set","text":"algebraic_set(p::MPolyRingElem)\n\nReturn the affine algebraic set defined by the multivariate polynomial p.\n\njulia> R, (x,y) = QQ[:x,:y];\n\njulia> X = algebraic_set((y^2+y+x^3+1)*x^2)\nAffine algebraic set\n  in affine 2-space over QQ with coordinates [x, y]\ndefined by ideal (x^5 + x^2*y^2 + x^2*y + x^2)\n\njulia> R, (x,y) = GF(2)[:x,:y];\n\njulia> X = algebraic_set((y^2+y+x^3+1)*x^2)\nAffine algebraic set\n  in affine 2-space over GF(2) with coordinates [x, y]\ndefined by ideal (x^5 + x^2*y^2 + x^2*y + x^2)\n\n\n\n\n\n\n","category":"method"},{"location":"AlgebraicGeometry/AlgebraicSets/AffineAlgebraicSet/","page":"Affine Algebraic Sets","title":"Affine Algebraic Sets","text":"Convert an affine scheme to an affine algebraic set in order to ignore its (non-reduced) scheme structure.","category":"page"},{"location":"AlgebraicGeometry/AlgebraicSets/AffineAlgebraicSet/","page":"Affine Algebraic Sets","title":"Affine Algebraic Sets","text":"algebraic_set(X::AffineScheme; check::Bool=true)","category":"page"},{"location":"AlgebraicGeometry/AlgebraicSets/AffineAlgebraicSet/#algebraic_set-Tuple{AffineScheme}","page":"Affine Algebraic Sets","title":"algebraic_set","text":"algebraic_set(X::AffineScheme; is_reduced=false, check=true) -> AffineAlgebraicSet\n\nConvert X to an AffineAlgebraicSet by considering its reduced structure.\n\nIf is_reduced is set, assume that X is already reduced. If is_reduced and check are set, check that X is actually geometrically reduced as claimed.\n\n\n\n\n\n","category":"method"},{"location":"AlgebraicGeometry/AlgebraicSets/AffineAlgebraicSet/","page":"Affine Algebraic Sets","title":"Affine Algebraic Sets","text":"set_theoretic_intersection(X::AbsAffineAlgebraicSet, Y::AbsAffineAlgebraicSet)\nclosure(X::AbsAffineAlgebraicSet{<:Field})","category":"page"},{"location":"AlgebraicGeometry/AlgebraicSets/AffineAlgebraicSet/#set_theoretic_intersection-Tuple{AbsAffineAlgebraicSet, AbsAffineAlgebraicSet}","page":"Affine Algebraic Sets","title":"set_theoretic_intersection","text":"set_theoretic_intersection(X::AbsAffineAlgebraicSet, Y::AbsAffineAlgebraicSet)\n\nReturn the set theoretic intersection of X and Y as an algebraic set.\n\njulia> A = affine_space(QQ, [:x,:y])\nAffine space of dimension 2\n  over rational field\nwith coordinates [x, y]\n\njulia> (x, y) = coordinates(A)\n2-element Vector{QQMPolyRingElem}:\n x\n y\n\njulia> X = algebraic_set(ideal([y - x^2]))\nAffine algebraic set\n  in affine 2-space over QQ with coordinates [x, y]\ndefined by ideal (-x^2 + y)\n\njulia> Y = algebraic_set(ideal([y]))\nAffine algebraic set\n  in affine 2-space over QQ with coordinates [x, y]\ndefined by ideal (y)\n\njulia> Zred = set_theoretic_intersection(X, Y)\nAffine algebraic set\n  in affine 2-space over QQ with coordinates [x, y]\ndefined by ideal (-x^2 + y, y)\n\n\n\nNote that the set theoretic intersection forgets the intersection multiplicities which the scheme theoretic intersection remembers. Therefore they are different.\n\njulia> Z = intersect(X, Y) # a non reduced scheme\nSpectrum\n  of quotient\n    of multivariate polynomial ring in 2 variables x, y\n      over rational field\n    by ideal (x^2 - y, y)\n\njulia> Zred == Z\nfalse\n\njulia> Zred == reduced_scheme(Z)[1]\ntrue\n\n\n\n\n\n\n","category":"method"},{"location":"AlgebraicGeometry/AlgebraicSets/AffineAlgebraicSet/#closure-Tuple{AbsAffineAlgebraicSet}","page":"Affine Algebraic Sets","title":"closure","text":"closure(X::AbsAffineAlgebraicSet)\n\nReturn the closure of X in its ambient affine space.\n\n\n\n\n\n","category":"method"},{"location":"AlgebraicGeometry/AlgebraicSets/AffineAlgebraicSet/#Attributes","page":"Affine Algebraic Sets","title":"Attributes","text":"","category":"section"},{"location":"AlgebraicGeometry/AlgebraicSets/AffineAlgebraicSet/","page":"Affine Algebraic Sets","title":"Affine Algebraic Sets","text":"In addition to the attributes inherited from Affine schemes the following are available.","category":"page"},{"location":"AlgebraicGeometry/AlgebraicSets/AffineAlgebraicSet/","page":"Affine Algebraic Sets","title":"Affine Algebraic Sets","text":"irreducible_components(X::AbsAffineAlgebraicSet)\ngeometric_irreducible_components(X::AbsAffineAlgebraicSet)\nvanishing_ideal(X::AbsAffineAlgebraicSet)","category":"page"},{"location":"AlgebraicGeometry/AlgebraicSets/AffineAlgebraicSet/#irreducible_components-Tuple{AbsAffineAlgebraicSet}","page":"Affine Algebraic Sets","title":"irreducible_components","text":"irreducible_components(X::AbsAffineAlgebraicSet) -> Vector{AffineVariety}\n\nReturn the irreducible components of X defined over the base field of X.\n\nNote that they may be reducible over the algebraic closure. See also geometric_irreducible_components.\n\n\n\n\n\n","category":"method"},{"location":"AlgebraicGeometry/AlgebraicSets/AffineAlgebraicSet/#geometric_irreducible_components-Tuple{AbsAffineAlgebraicSet}","page":"Affine Algebraic Sets","title":"geometric_irreducible_components","text":"geometric_irreducible_components(X::AbsAffineAlgebraicSet)\n\nReturn the geometrically irreducible components of X.\n\nThey are the irreducible components V_ij of X seen over an algebraically closed field and given as a vector of tuples (A_i V_ij d_ij), say, where A_i is an algebraic set which is irreducible over the base field of X and V_ij represents a corresponding class of galois conjugated geometrically irreducible components of A_i defined over a number field of degree d_ij whose generator prints as _a.\n\nThis is expensive and involves taking field extensions.\n\n\n\n\n\n","category":"method"},{"location":"AlgebraicGeometry/AlgebraicSets/AffineAlgebraicSet/#vanishing_ideal-Tuple{AbsAffineAlgebraicSet}","page":"Affine Algebraic Sets","title":"vanishing_ideal","text":"vanishing_ideal(X::AbsAffineAlgebraicSet) -> Ideal\n\nReturn the ideal of all polynomials vanishing in X.\n\nBy Hilbert's Nullstellensatz this is a radical ideal.\n\nnote: Note\nThis triggers the computation of a radical, which is expensive.\n\n\n\n\n\n","category":"method"},{"location":"AlgebraicGeometry/AlgebraicSets/AffineAlgebraicSet/#Methods","page":"Affine Algebraic Sets","title":"Methods","text":"","category":"section"},{"location":"AlgebraicGeometry/AlgebraicSets/AffineAlgebraicSet/","page":"Affine Algebraic Sets","title":"Affine Algebraic Sets","text":"Inherited from Affine schemes","category":"page"},{"location":"AlgebraicGeometry/AlgebraicSets/AffineAlgebraicSet/#Properties","page":"Affine Algebraic Sets","title":"Properties","text":"","category":"section"},{"location":"AlgebraicGeometry/AlgebraicSets/AffineAlgebraicSet/","page":"Affine Algebraic Sets","title":"Affine Algebraic Sets","text":"Inherited from Affine schemes","category":"page"},{"location":"NoncommutativeAlgebra/PBWAlgebras/quotients/","page":"GR-Algebras: Quotients of PBW-Algebras","title":"GR-Algebras: Quotients of PBW-Algebras","text":"CurrentModule = Oscar\nDocTestSetup = Oscar.doctestsetup()","category":"page"},{"location":"NoncommutativeAlgebra/PBWAlgebras/quotients/#GR-Algebras:-Quotients-of-PBW-Algebras","page":"GR-Algebras: Quotients of PBW-Algebras","title":"GR-Algebras: Quotients of PBW-Algebras","text":"","category":"section"},{"location":"NoncommutativeAlgebra/PBWAlgebras/quotients/","page":"GR-Algebras: Quotients of PBW-Algebras","title":"GR-Algebras: Quotients of PBW-Algebras","text":"In analogy to the affine algebras section in the commutative algebra chapter, we describe OSCAR functionality for dealing with quotients of PBW-algebras modulo two-sided ideals.","category":"page"},{"location":"NoncommutativeAlgebra/PBWAlgebras/quotients/","page":"GR-Algebras: Quotients of PBW-Algebras","title":"GR-Algebras: Quotients of PBW-Algebras","text":"note: Note\nQuotients of PBW-algebras modulo two-sided ideals are also known as GR-algebras (here, GR stands for Gröbner-Ready; see [Lev05]).","category":"page"},{"location":"NoncommutativeAlgebra/PBWAlgebras/quotients/#Types","page":"GR-Algebras: Quotients of PBW-Algebras","title":"Types","text":"","category":"section"},{"location":"NoncommutativeAlgebra/PBWAlgebras/quotients/","page":"GR-Algebras: Quotients of PBW-Algebras","title":"GR-Algebras: Quotients of PBW-Algebras","text":"GR-algebras are modeled by objects of type PBWAlgQuo{T, S} <: NCRing, their elements are objects of type PBWAlgQuoElem{T, S} <: NCRingElem. Here,  T is the element type of the field over which the GR-algebra is defined (the type S is added for internal use).","category":"page"},{"location":"NoncommutativeAlgebra/PBWAlgebras/quotients/#Constructors","page":"GR-Algebras: Quotients of PBW-Algebras","title":"Constructors","text":"","category":"section"},{"location":"NoncommutativeAlgebra/PBWAlgebras/quotients/","page":"GR-Algebras: Quotients of PBW-Algebras","title":"GR-Algebras: Quotients of PBW-Algebras","text":"quo(A::PBWAlgRing, I::PBWAlgIdeal)","category":"page"},{"location":"NoncommutativeAlgebra/PBWAlgebras/quotients/#quo-Tuple{PBWAlgRing, Oscar.PBWAlgIdeal}","page":"GR-Algebras: Quotients of PBW-Algebras","title":"quo","text":"quo(A::PBWAlgRing, I::PBWAlgIdeal)\n\nGiven a two-sided ideal I of A, create the quotient algebra AI and return the new algebra together with the quotient map Ato AI.\n\nExamples\n\njulia> R, (x, y, z) = QQ[:x, :y, :z];\n\njulia> L = [-x*y, -x*z, -y*z];\n\njulia> REL = strictly_upper_triangular_matrix(L);\n\njulia> A, (x, y, z) = pbw_algebra(R, REL, deglex(gens(R)))\n(PBW-algebra over rational field in x, y, z with relations y*x = -x*y, z*x = -x*z, z*y = -y*z, PBWAlgElem{QQFieldElem, Singular.n_Q}[x, y, z])\n\njulia> I = two_sided_ideal(A, [x^2, y^2, z^2])\ntwo_sided_ideal(x^2, y^2, z^2)\n\njulia> Q, q = quo(A, I);\n\njulia> Q\n(PBW-algebra over rational field in x, y, z with relations y*x = -x*y, z*x = -x*z, z*y = -y*z)/two_sided_ideal(x^2, y^2, z^2)\n\njulia> q\nMap defined by a julia-function with inverse\n  from PBW-algebra over rational field in x, y, z with relations y*x = -x*y, z*x = -x*z, z*y = -y*z\n  to (PBW-algebra over rational field in x, y, z with relations y*x = -x*y, z*x = -x*z, z*y = -y*z)/two_sided_ideal(x^2, y^2, z^2)\n\nnote: Note\nThe example above, shows one way of constructing the exterior algebra on the variables x, y, z over mathbb Q. For reasons of efficiency, it is recommended to use the built-in constructor exterior_algebra when working with  exterior algebras in OSCAR.\n\n\n\n\n\n","category":"method"},{"location":"NoncommutativeAlgebra/PBWAlgebras/quotients/#Exterior-Algebras","page":"GR-Algebras: Quotients of PBW-Algebras","title":"Exterior Algebras","text":"","category":"section"},{"location":"NoncommutativeAlgebra/PBWAlgebras/quotients/","page":"GR-Algebras: Quotients of PBW-Algebras","title":"GR-Algebras: Quotients of PBW-Algebras","text":"The n-th exterior algebra over a field K is the quotient of the PBW-algebra","category":"page"},{"location":"NoncommutativeAlgebra/PBWAlgebras/quotients/","page":"GR-Algebras: Quotients of PBW-Algebras","title":"GR-Algebras: Quotients of PBW-Algebras","text":"A=K langle e_1dots e_n mid e_i e_j = - e_j e_i  text  for  ineq jrangle","category":"page"},{"location":"NoncommutativeAlgebra/PBWAlgebras/quotients/","page":"GR-Algebras: Quotients of PBW-Algebras","title":"GR-Algebras: Quotients of PBW-Algebras","text":"modulo the two-sided ideal","category":"page"},{"location":"NoncommutativeAlgebra/PBWAlgebras/quotients/","page":"GR-Algebras: Quotients of PBW-Algebras","title":"GR-Algebras: Quotients of PBW-Algebras","text":"langle e_1^2dots e_n^2rangle","category":"page"},{"location":"NoncommutativeAlgebra/PBWAlgebras/quotients/","page":"GR-Algebras: Quotients of PBW-Algebras","title":"GR-Algebras: Quotients of PBW-Algebras","text":"exterior_algebra(::Ring, ::Vector{Symbol})","category":"page"},{"location":"NoncommutativeAlgebra/PBWAlgebras/quotients/#exterior_algebra-Tuple{Ring, Vector{Symbol}}","page":"GR-Algebras: Quotients of PBW-Algebras","title":"exterior_algebra","text":"exterior_algebra(K::Ring, nvars::Int)\nexterior_algebra(K::Ring, varnames::AbstractVector{<:VarName})\n\nGiven a coefficient ring K and variable names, say varnames = [:x1, :x2, ...], return a tuple E, [x1, x2, ...] consisting of the exterior algebra E over the polynomial ring R[x1, x2, ...] and its generators x1, x2, ....\n\nIf K is a field, this function will use a special implementation in Singular.\n\nnote: Note\nCreating an exterior_algebra with many variables will create an object occupying a lot of memory (probably cubic in nvars).\n\nExamples\n\njulia> E, (x1,x2)  =  exterior_algebra(QQ, 2);\n\njulia> x2*x1\n-x1*x2\n\njulia> (x1+x2)^2  # over fields, result is automatically reduced!\n0\n\njulia> E, (x,y)  =  exterior_algebra(QQ, [\"x\",\"y\"]);\n\njulia> y*x\n-x*y\n\nwarning: Experimental\nThis function is part of the experimental code in Oscar. Please read here for more details.\n\n\n\n\n\n","category":"method"},{"location":"NoncommutativeAlgebra/PBWAlgebras/quotients/#Data-Associated-to-Affine-GR-Algebras","page":"GR-Algebras: Quotients of PBW-Algebras","title":"Data Associated to Affine GR-Algebras","text":"","category":"section"},{"location":"NoncommutativeAlgebra/PBWAlgebras/quotients/#Basic-Data","page":"GR-Algebras: Quotients of PBW-Algebras","title":"Basic Data","text":"","category":"section"},{"location":"NoncommutativeAlgebra/PBWAlgebras/quotients/","page":"GR-Algebras: Quotients of PBW-Algebras","title":"GR-Algebras: Quotients of PBW-Algebras","text":"If Q=A/I is the quotient ring of a PBW-algebra A modulo a two-sided ideal I of A, then","category":"page"},{"location":"NoncommutativeAlgebra/PBWAlgebras/quotients/","page":"GR-Algebras: Quotients of PBW-Algebras","title":"GR-Algebras: Quotients of PBW-Algebras","text":"base_ring(Q) refers to A,\nmodulus(Q) to I,\ngens(Q) to the generators of Q,\nnumber_of_generators(Q) / ngens(Q) to the number of these generators, and\ngen(Q, i) as well as Q[i] to the i-th such generator.","category":"page"},{"location":"NoncommutativeAlgebra/PBWAlgebras/quotients/#Examples","page":"GR-Algebras: Quotients of PBW-Algebras","title":"Examples","text":"","category":"section"},{"location":"NoncommutativeAlgebra/PBWAlgebras/quotients/","page":"GR-Algebras: Quotients of PBW-Algebras","title":"GR-Algebras: Quotients of PBW-Algebras","text":"julia> R, (x, y, z) = QQ[:x, :y, :z];\n\njulia> L = [-x*y, -x*z, -y*z];\n\njulia> REL = strictly_upper_triangular_matrix(L);\n\njulia> A, (x, y, z) = pbw_algebra(R, REL, deglex(gens(R)));\n\njulia> I = two_sided_ideal(A, [x^2, y^2, z^2]);\n\njulia> Q, q = quo(A, I);\n\njulia> base_ring(Q)\nPBW-algebra over rational field in x, y, z with relations y*x = -x*y, z*x = -x*z, z*y = -y*z\n\njulia> modulus(Q)\ntwo_sided_ideal(x^2, y^2, z^2)\n\njulia> gens(Q)\n3-element Vector{PBWAlgQuoElem{QQFieldElem, Singular.n_Q}}:\n x\n y\n z\n\njulia> number_of_generators(Q)\n3\n\njulia> gen(Q, 2)\ny","category":"page"},{"location":"NoncommutativeAlgebra/PBWAlgebras/quotients/#Elements-of-GR-Algebras","page":"GR-Algebras: Quotients of PBW-Algebras","title":"Elements of GR-Algebras","text":"","category":"section"},{"location":"NoncommutativeAlgebra/PBWAlgebras/quotients/#Types-2","page":"GR-Algebras: Quotients of PBW-Algebras","title":"Types","text":"","category":"section"},{"location":"NoncommutativeAlgebra/PBWAlgebras/quotients/","page":"GR-Algebras: Quotients of PBW-Algebras","title":"GR-Algebras: Quotients of PBW-Algebras","text":"The OSCAR type for elements of quotient rings of  multivariate polynomial rings PBW-algebras is of parametrized form PBWAlgQuoElem{T, S}, where T is the element type  of the field over which the GR-algebra is defined (the type S is added for internal use).","category":"page"},{"location":"NoncommutativeAlgebra/PBWAlgebras/quotients/#Creating-Elements-of-GR-Algebras","page":"GR-Algebras: Quotients of PBW-Algebras","title":"Creating Elements of GR-Algebras","text":"","category":"section"},{"location":"NoncommutativeAlgebra/PBWAlgebras/quotients/","page":"GR-Algebras: Quotients of PBW-Algebras","title":"GR-Algebras: Quotients of PBW-Algebras","text":"Elements of a GR-algebra Q = AI are created as images of elements of A under the projection map or by directly coercing elements of A into Q. The function simplify reduces a given element with regard to the modulus I.","category":"page"},{"location":"NoncommutativeAlgebra/PBWAlgebras/quotients/#Examples-2","page":"GR-Algebras: Quotients of PBW-Algebras","title":"Examples","text":"","category":"section"},{"location":"NoncommutativeAlgebra/PBWAlgebras/quotients/","page":"GR-Algebras: Quotients of PBW-Algebras","title":"GR-Algebras: Quotients of PBW-Algebras","text":"julia> R, (x, y, z) = QQ[:x, :y, :z];\n\njulia> L = [-x*y, -x*z, -y*z];\n\njulia> REL = strictly_upper_triangular_matrix(L);\n\njulia> A, (x, y, z) = pbw_algebra(R, REL, deglex(gens(R)));\n\njulia> I = two_sided_ideal(A, [x^2, y^2, z^2]);\n\njulia> Q, q = quo(A, I);\n\njulia> f = q(y*x+z^2)\n-x*y + z^2\n\njulia> typeof(f)\nPBWAlgQuoElem{QQFieldElem, Singular.n_Q}\n\njulia> simplify(f);\n\njulia> f\n-x*y\n\njulia> g = Q(y*x+x^2)\nx^2 - x*y\n\njulia> f == g\ntrue","category":"page"},{"location":"NoncommutativeAlgebra/PBWAlgebras/quotients/#Data-associated-to-Elements-of-GR-Algebras","page":"GR-Algebras: Quotients of PBW-Algebras","title":"Data associated to Elements of GR-Algebras","text":"","category":"section"},{"location":"NoncommutativeAlgebra/PBWAlgebras/quotients/","page":"GR-Algebras: Quotients of PBW-Algebras","title":"GR-Algebras: Quotients of PBW-Algebras","text":"Given an element f of an affine  GR-algebra Q, ","category":"page"},{"location":"NoncommutativeAlgebra/PBWAlgebras/quotients/","page":"GR-Algebras: Quotients of PBW-Algebras","title":"GR-Algebras: Quotients of PBW-Algebras","text":"parent(f) refers to Q.","category":"page"},{"location":"NoncommutativeAlgebra/PBWAlgebras/quotients/#Ideals-in-GR-Algebras","page":"GR-Algebras: Quotients of PBW-Algebras","title":"Ideals in GR-Algebras","text":"","category":"section"},{"location":"LinearAlgebra/intro/","page":"Introduction","title":"Introduction","text":"CurrentModule = Oscar\nDocTestSetup = Oscar.doctestsetup()","category":"page"},{"location":"LinearAlgebra/intro/#linear_algebra","page":"Introduction","title":"Introduction","text":"","category":"section"},{"location":"LinearAlgebra/intro/","page":"Introduction","title":"Introduction","text":"The linear algebra part of OSCAR provides functionality for handling","category":"page"},{"location":"LinearAlgebra/intro/","page":"Introduction","title":"Introduction","text":"vectors and matrices\nmodules and vector spaces,\nvector spaces over fields\nmatrix spaces and matrix algebras","category":"page"},{"location":"LinearAlgebra/intro/","page":"Introduction","title":"Introduction","text":"General textbooks offering details on theory and algorithms include:","category":"page"},{"location":"LinearAlgebra/intro/","page":"Introduction","title":"Introduction","text":"...","category":"page"},{"location":"LinearAlgebra/intro/#Contact","page":"Introduction","title":"Contact","text":"","category":"section"},{"location":"LinearAlgebra/intro/","page":"Introduction","title":"Introduction","text":"Please direct questions about this part of OSCAR to the following people:","category":"page"},{"location":"LinearAlgebra/intro/","page":"Introduction","title":"Introduction","text":"Claus Fieker,\nTommy Hofmann.","category":"page"},{"location":"LinearAlgebra/intro/","page":"Introduction","title":"Introduction","text":"You can ask questions in the OSCAR Slack.","category":"page"},{"location":"LinearAlgebra/intro/","page":"Introduction","title":"Introduction","text":"Alternatively, you can raise an issue on github.","category":"page"},{"location":"PolyhedralGeometry/Polyhedra/constructions/","page":"Constructions","title":"Constructions","text":"CurrentModule = Oscar\nDocTestSetup = Oscar.doctestsetup()","category":"page"},{"location":"PolyhedralGeometry/Polyhedra/constructions/#Constructions","page":"Constructions","title":"Constructions","text":"","category":"section"},{"location":"PolyhedralGeometry/Polyhedra/constructions/","page":"Constructions","title":"Constructions","text":"The standard way to define a polyhedron is by either giving a V-representation or an H-representation.  But polyhedra may also be constructed through other means: by name, via operations on other polyhedra, or from other objects in OSCAR.","category":"page"},{"location":"PolyhedralGeometry/Polyhedra/constructions/#H-and-V-representations","page":"Constructions","title":"H- and V-representations","text":"","category":"section"},{"location":"PolyhedralGeometry/Polyhedra/constructions/#Intersecting-halfspaces:-H-representation","page":"Constructions","title":"Intersecting halfspaces: H-representation","text":"","category":"section"},{"location":"PolyhedralGeometry/Polyhedra/constructions/","page":"Constructions","title":"Constructions","text":"polyhedron(::Oscar.scalar_type_or_field, A::AnyVecOrMat, b::AbstractVector)\npolyhedron(::Oscar.scalar_type_or_field, I::Union{Nothing, AbstractCollection[AffineHalfspace]}, E::Union{Nothing, AbstractCollection[AffineHyperplane]} = nothing)","category":"page"},{"location":"PolyhedralGeometry/Polyhedra/constructions/#polyhedron-Tuple{Union{Field, Type{<:Union{Float64, FieldElem}}}, Union{MatElem, AbstractVecOrMat}, AbstractVector}","page":"Constructions","title":"polyhedron","text":"polyhedron([::Union{Type{T}, Field},] A::AnyVecOrMat, b) where T<:scalar_types\n\nThe (convex) polyhedron defined by\n\nP(Ab) =  x   Ax  b \n\nsee Def. 3.35 and Section 4.1. of [JT13]\n\nThe first argument either specifies the Type of its coefficients or their parent Field.\n\nExamples\n\nThe following lines define the square 01^2 subset mathbbR^2:\n\njulia> A = [1 0; 0 1; -1 0 ; 0 -1];\n\njulia> b = [1, 1, 0, 0];\n\njulia> polyhedron(A,b)\nPolyhedron in ambient dimension 2\n\n\n\n\n\n","category":"method"},{"location":"PolyhedralGeometry/Polyhedra/constructions/#polyhedron","page":"Constructions","title":"polyhedron","text":"polyhedron(::Union{Type{T}, Field}, I::Union{Nothing, AbstractCollection[AffineHalfspace]}, E::Union{Nothing, AbstractCollection[AffineHyperplane]} = nothing) where T<:scalar_types\n\nThe (convex) polyhedron obtained intersecting the halfspaces I (inequalities) and the hyperplanes E (equations). The first argument either specifies the Type of its coefficients or their parent Field.\n\nExamples\n\nThe following lines define the square 01^2 subset mathbbR^2:\n\njulia> A = [1 0; 0 1; -1 0 ; 0 -1];\n\njulia> b = [1, 1, 0, 0];\n\njulia> polyhedron((A,b))\nPolyhedron in ambient dimension 2\n\nAs an example for a polyhedron constructed from both inequalities and equations, we construct the polytope 01times0subsetmathbbR^2\n\njulia> P = polyhedron(([-1 0; 1 0], [0,1]), ([0 1], [0]))\nPolyhedron in ambient dimension 2\n\njulia> is_feasible(P)\ntrue\n\njulia> dim(P)\n1\n\njulia> vertices(P)\n2-element SubObjectIterator{PointVector{QQFieldElem}}:\n [1, 0]\n [0, 0]\n\n\n\n\n\n","category":"function"},{"location":"PolyhedralGeometry/Polyhedra/constructions/","page":"Constructions","title":"Constructions","text":"The complete H-representation can be retrieved using facets and affine_hull:","category":"page"},{"location":"PolyhedralGeometry/Polyhedra/constructions/","page":"Constructions","title":"Constructions","text":"julia> P = polyhedron(([-1 0; 1 0], [0,1]), ([0 1], [0]))\nPolyhedron in ambient dimension 2\n\njulia> facets(P)\n2-element SubObjectIterator{AffineHalfspace{QQFieldElem}} over the halfspaces of R^2 described by:\n-x_1 <= 0\nx_1 <= 1\n\n\njulia> affine_hull(P)\n1-element SubObjectIterator{AffineHyperplane{QQFieldElem}} over the hyperplanes of R^2 described by:\nx_2 = 0\n\n\njulia> Q0 = polyhedron(facets(P))\nPolyhedron in ambient dimension 2\n\njulia> P == Q0\nfalse\n\njulia> Q1 = polyhedron(facets(P), affine_hull(P))\nPolyhedron in ambient dimension 2\n\njulia> P == Q1\ntrue","category":"page"},{"location":"PolyhedralGeometry/Polyhedra/constructions/#Computing-convex-hulls:-V-representation","page":"Constructions","title":"Computing convex hulls: V-representation","text":"","category":"section"},{"location":"PolyhedralGeometry/Polyhedra/constructions/","page":"Constructions","title":"Constructions","text":"convex_hull(::Oscar.scalar_type_or_field, ::AnyVecOrMat; non_redundant::Bool=false)","category":"page"},{"location":"PolyhedralGeometry/Polyhedra/constructions/#convex_hull-Tuple{Union{Field, Type{<:Union{Float64, FieldElem}}}, Union{MatElem, AbstractVecOrMat}}","page":"Constructions","title":"convex_hull","text":"convex_hull([::Union{Type{T}, Field} = QQFieldElem,] V [, R [, L]]; non_redundant::Bool = false)\n\nConstruct the convex hull of the vertices V, rays R, and lineality L. If R or L are omitted, then they are assumed to be zero.\n\nArguments\n\nThe first argument either specifies the Type of its coefficients or their\n\nparent Field.\n\nV::AbstractCollection[PointVector]: Points whose convex hull is to be computed.\nR::AbstractCollection[RayVector]: Rays completing the set of points.\nL::AbstractCollection[RayVector]: Generators of the Lineality space.\n\nIf an argument is given as a matrix, its content has to be encoded row-wise.\n\nR can be given as an empty matrix or as nothing if the user wants to compute the convex hull only from V and L.\n\nIf it is known that V and R only contain extremal points and that the description of the lineality space is complete, set non_redundant = true to avoid unnecessary redundancy checks.\n\nSee Def. 2.11 and Def. 3.1  of [JT13].\n\nExamples\n\nThe following lines define the square 01^2 subset mathbbR^2:\n\njulia> Square = convex_hull([0 0; 0 1; 1 0; 1 1])\nPolyhedron in ambient dimension 2\n\nTo construct the positive orthant, rays have to be passed:\n\njulia> V = [0 0];\n\njulia> R = [1 0; 0 1];\n\njulia> PO = convex_hull(V, R)\nPolyhedron in ambient dimension 2\n\nThe closed-upper half plane can be constructed by passing rays and a lineality space:\n\njulia> V = [0 0];\n\njulia> R = [0 1];\n\njulia> L = [1 0];\n\njulia> UH = convex_hull(V, R, L)\nPolyhedron in ambient dimension 2\n\nTo obtain the x-axis in mathbbR^2:\n\njulia> V = [0 0];\n\njulia> R = nothing;\n\njulia> L = [1 0];\n\njulia> XA = convex_hull(V, R, L)\nPolyhedron in ambient dimension 2\n\n\n\n\n\n","category":"method"},{"location":"PolyhedralGeometry/Polyhedra/constructions/","page":"Constructions","title":"Constructions","text":"This is a standard triangle, defined via a (redundant) V-representation  and its unique minimal H-representation:","category":"page"},{"location":"PolyhedralGeometry/Polyhedra/constructions/","page":"Constructions","title":"Constructions","text":"julia> T = convex_hull([ 0 0 ; 1 0 ; 0 1; 0 1//2 ])\nPolyhedron in ambient dimension 2\n\njulia> halfspace_matrix_pair(facets(T))\n(A = [-1 0; 0 -1; 1 1], b = QQFieldElem[0, 0, 1])\n","category":"page"},{"location":"PolyhedralGeometry/Polyhedra/constructions/","page":"Constructions","title":"Constructions","text":"The complete V-representation can be retrieved using minimal_faces, rays_modulo_lineality and lineality_space:","category":"page"},{"location":"PolyhedralGeometry/Polyhedra/constructions/","page":"Constructions","title":"Constructions","text":"julia> P = convex_hull([0 0], [1 0], [0 1])\nPolyhedron in ambient dimension 2\n\njulia> Q0 = convex_hull(vertices(P))\nPolyhedron in ambient dimension 2\n\njulia> P == Q0\nfalse\n\njulia> mfP = minimal_faces(P)\n(base_points = PointVector{QQFieldElem}[[0, 0]], lineality_basis = RayVector{QQFieldElem}[[0, 1]])\n\njulia> rmlP = rays_modulo_lineality(P)\n(rays_modulo_lineality = RayVector{QQFieldElem}[[1, 0]], lineality_basis = RayVector{QQFieldElem}[[0, 1]])\n\njulia> Q1 = convex_hull(mfP.base_points, rmlP.rays_modulo_lineality)\nPolyhedron in ambient dimension 2\n\njulia> P == Q1\nfalse\n\njulia> Q0 == Q1\nfalse\n\njulia> Q2 = convex_hull(mfP.base_points, rmlP.rays_modulo_lineality, lineality_space(P))\nPolyhedron in ambient dimension 2\n\njulia> P == Q2\ntrue","category":"page"},{"location":"PolyhedralGeometry/Polyhedra/constructions/#Regular-polytopes","page":"Constructions","title":"Regular polytopes","text":"","category":"section"},{"location":"PolyhedralGeometry/Polyhedra/constructions/","page":"Constructions","title":"Constructions","text":"A polytope is regular, in the strict sense, if it admits a flag-transitive group of (linear) automorphisms. There are three infinite families of regular polytopes which exist in each dimension: the (regular) simplices, cubes and cross polytopes. In addition there are two exceptional regular 3-polytopes (dodecahedron and icosahedron) plus three exceptional regular 4-polytopes (24-cell, 120-cell and 600-cell).","category":"page"},{"location":"PolyhedralGeometry/Polyhedra/constructions/","page":"Constructions","title":"Constructions","text":"The regular 3-polytopes are also known as the Platonic solids. Here we also list the Archimedean, Catalan and Johnson solids, which form various generalizations of the Platonic solids. However, here we implement \"disjoint families\", i.e., the proper Archimedean solids exclude the Platonic solids; similarly, the proper Johnson solids exclude the Archimedean solids.","category":"page"},{"location":"PolyhedralGeometry/Polyhedra/constructions/","page":"Constructions","title":"Constructions","text":"simplex\ncross_polytope\ncube\ntetrahedron\ndodecahedron\nicosahedron\nplatonic_solid\narchimedean_solid\njohnson_solid\ncatalan_solid\nregular_24_cell\nregular_120_cell\nregular_600_cell","category":"page"},{"location":"PolyhedralGeometry/Polyhedra/constructions/#simplex","page":"Constructions","title":"simplex","text":"simplex([::Union{Type{T}, Field} = QQFieldElem,] d::Int [,n])\n\nConstruct the simplex which is the convex hull of the standard basis vectors along with the origin in mathbbR^d, scaled by n. The first argument either specifies the Type of its coefficients or their parent Field.\n\nExamples\n\nHere we take a look at the facets of the 7-simplex and a scaled 7-simplex:\n\njulia> s = simplex(7)\nPolytope in ambient dimension 7\n\njulia> facets(s)\n8-element SubObjectIterator{AffineHalfspace{QQFieldElem}} over the halfspaces of R^7 described by:\n-x_1 <= 0\n-x_2 <= 0\n-x_3 <= 0\n-x_4 <= 0\n-x_5 <= 0\n-x_6 <= 0\n-x_7 <= 0\nx_1 + x_2 + x_3 + x_4 + x_5 + x_6 + x_7 <= 1\n\njulia> t = simplex(7, 5)\nPolytope in ambient dimension 7\n\njulia> facets(t)\n8-element SubObjectIterator{AffineHalfspace{QQFieldElem}} over the halfspaces of R^7 described by:\n-x_1 <= 0\n-x_2 <= 0\n-x_3 <= 0\n-x_4 <= 0\n-x_5 <= 0\n-x_6 <= 0\n-x_7 <= 0\nx_1 + x_2 + x_3 + x_4 + x_5 + x_6 + x_7 <= 5\n\n\n\n\n\n","category":"function"},{"location":"PolyhedralGeometry/Polyhedra/constructions/#cross_polytope","page":"Constructions","title":"cross_polytope","text":"cross_polytope([::Union{Type{T}, Field} = QQFieldElem,] d::Int [,n])\n\nConstruct a d-dimensional cross polytope around origin with vertices located at pm e_i for each unit vector e_i of R^d, scaled by n. The first argument either specifies the Type of its coefficients or their parent Field.\n\nExamples\n\nHere we print the facets of a non-scaled and a scaled 3-dimensional cross polytope:\n\njulia> C = cross_polytope(3)\nPolytope in ambient dimension 3\n\njulia> facets(C)\n8-element SubObjectIterator{AffineHalfspace{QQFieldElem}} over the halfspaces of R^3 described by:\nx_1 + x_2 + x_3 <= 1\n-x_1 + x_2 + x_3 <= 1\nx_1 - x_2 + x_3 <= 1\n-x_1 - x_2 + x_3 <= 1\nx_1 + x_2 - x_3 <= 1\n-x_1 + x_2 - x_3 <= 1\nx_1 - x_2 - x_3 <= 1\n-x_1 - x_2 - x_3 <= 1\n\njulia> D = cross_polytope(3, 2)\nPolytope in ambient dimension 3\n\njulia> facets(D)\n8-element SubObjectIterator{AffineHalfspace{QQFieldElem}} over the halfspaces of R^3 described by:\nx_1 + x_2 + x_3 <= 2\n-x_1 + x_2 + x_3 <= 2\nx_1 - x_2 + x_3 <= 2\n-x_1 - x_2 + x_3 <= 2\nx_1 + x_2 - x_3 <= 2\n-x_1 + x_2 - x_3 <= 2\nx_1 - x_2 - x_3 <= 2\n-x_1 - x_2 - x_3 <= 2\n\n\n\n\n\n","category":"function"},{"location":"PolyhedralGeometry/Polyhedra/constructions/#cube","page":"Constructions","title":"cube","text":"cube([::Union{Type{T}, Field} = QQFieldElem,] d::Int , [l::Rational = -1, u::Rational = 1])\n\nConstruct the lu-cube in dimension d. The first argument either specifies the Type of its coefficients or their parent Field.\n\nExamples\n\nIn this example the 5-dimensional unit cube is constructed to ask for one of its properties:\n\njulia> C = cube(5,0,1);\n\njulia> normalized_volume(C)\n120\n\n\n\n\n\n","category":"function"},{"location":"PolyhedralGeometry/Polyhedra/constructions/#tetrahedron","page":"Constructions","title":"tetrahedron","text":"tetrahedron()\n\nConstruct the regular tetrahedron, one of the Platonic solids.\n\n\n\n\n\n","category":"function"},{"location":"PolyhedralGeometry/Polyhedra/constructions/#dodecahedron","page":"Constructions","title":"dodecahedron","text":"dodecahedron()\n\nConstruct the regular dodecahedron, one out of two Platonic solids.\n\n\n\n\n\n","category":"function"},{"location":"PolyhedralGeometry/Polyhedra/constructions/#icosahedron","page":"Constructions","title":"icosahedron","text":"icosahedron()\n\nConstruct the regular icosahedron, one out of two exceptional Platonic solids.\n\n\n\n\n\n","category":"function"},{"location":"PolyhedralGeometry/Polyhedra/constructions/#platonic_solid","page":"Constructions","title":"platonic_solid","text":"platonic_solid(s)\n\nConstruct a Platonic solid with the name given by String s from the list below.\n\nSee also is_platonic_solid.\n\nArguments\n\ns::String: The name of the desired Platonic solid.   Possible values:\n\"tetrahedron\" : Tetrahedron.     Regular polytope with four triangular facets.\n\"cube\" : Cube.     Regular polytope with six square facets.\n\"octahedron\" : Octahedron.     Regular polytope with eight triangular facets.\n\"dodecahedron\" : Dodecahedron.     Regular polytope with 12 pentagonal facets.\n\"icosahedron\" : Icosahedron.     Regular polytope with 20 triangular facets.\n\nExamples\n\njulia> T = platonic_solid(\"icosahedron\")\nPolytope in ambient dimension 3 with EmbeddedAbsSimpleNumFieldElem type coefficients\n\njulia> n_facets(T)\n20\n\n\n\n\n\n","category":"function"},{"location":"PolyhedralGeometry/Polyhedra/constructions/#archimedean_solid","page":"Constructions","title":"archimedean_solid","text":"archimedean_solid(s)\n\nConstruct an Archimedean solid with the name given by String s from the list below.\n\nSee also is_archimedean_solid.\n\nArguments\n\ns::String: The name of the desired Archimedean solid.   Possible values:\n\"truncated_tetrahedron\" : Truncated tetrahedron.     Regular polytope with four triangular and four hexagonal facets.\n\"cuboctahedron\" : Cuboctahedron.     Regular polytope with eight triangular and six square facets.\n\"truncated_cube\" : Truncated cube.     Regular polytope with eight triangular and six octagonal facets.\n\"truncated_octahedron\" : Truncated octahedron.     Regular polytope with six square and eight hexagonal facets.\n\"rhombicuboctahedron\" : Rhombicuboctahedron.     Regular polytope with eight triangular and 18 square facets.\n\"truncated_cuboctahedron\" : Truncated cuboctahedron.     Regular polytope with 12 square, eight hexagonal and six octagonal     facets.\n\"snub_cube\" : Snub cube.     Regular polytope with 32 triangular and six square facets.     This is a chiral polytope.\n\"icosidodecahedron\" : Icosidodecahedon.     Regular polytope with 20 triangular and 12 pentagonal facets.\n\"truncated_dodecahedron\" : Truncated dodecahedron.     Regular polytope with 20 triangular and 12 decagonal facets.\n\"truncated_icosahedron\" : Truncated icosahedron.     Regular polytope with 12 pentagonal and 20 hexagonal facets.\n\"rhombicosidodecahedron\" : Rhombicosidodecahedron.     Regular polytope with 20 triangular, 30 square and 12 pentagonal     facets.\n\"truncated_icosidodecahedron\" : Truncated icosidodecahedron.     Regular polytope with 30 square, 20 hexagonal and 12 decagonal     facets.\n\"snub_dodecahedron\" : Snub dodecahedron.     Regular polytope with 80 triangular and 12 pentagonal facets.     This is a chiral polytope.\n\nExamples\n\njulia> T = archimedean_solid(\"cuboctahedron\")\nPolytope in ambient dimension 3\n\njulia> sum([n_vertices(F) for F in faces(T, 2)] .== 3)\n8\n\njulia> sum([n_vertices(F) for F in faces(T, 2)] .== 4)\n6\n\njulia> n_facets(T)\n14\n\n\n\n\n\n","category":"function"},{"location":"PolyhedralGeometry/Polyhedra/constructions/#johnson_solid","page":"Constructions","title":"johnson_solid","text":"johnson_solid(i::Int)\n\nConstruct the i-th proper Johnson solid.\n\nA Johnson solid is a 3-polytope whose facets are regular polygons, of various gonalities. It is proper if it is not an Archimedean solid.  Up to scaling there are exactly 92 proper Johnson solids.   See the Polytope Wiki\n\nSee also is_johnson_solid.\n\n\n\n\n\n","category":"function"},{"location":"PolyhedralGeometry/Polyhedra/constructions/#catalan_solid","page":"Constructions","title":"catalan_solid","text":"catalan_solid(s::String)\n\nConstruct a Catalan solid with the name s from the list below.\n\nArguments\n\ns::String: The name of the desired Archimedean solid.   Possible values:\n\"triakis_tetrahedron\" : Triakis tetrahedron.     Dual polytope to the truncated tetrahedron, made of 12 isosceles     triangular facets.\n\"triakis_octahedron\" : Triakis octahedron.     Dual polytope to the truncated cube, made of 24 isosceles triangular     facets.\n\"rhombic_dodecahedron\" : Rhombic dodecahedron.     Dual polytope to the cuboctahedron, made of 12 rhombic facets.\n\"tetrakis_hexahedron\" : Tetrakis hexahedron.     Dual polytope to the truncated octahedron, made of 24 isosceles     triangluar facets.\n\"disdyakis_dodecahedron\" : Disdyakis dodecahedron.     Dual polytope to the truncated cuboctahedron, made of 48 scalene     triangular facets.\n\"pentagonal_icositetrahedron\" : Pentagonal icositetrahedron.     Dual polytope to the snub cube, made of 24 irregular pentagonal facets.\n\"pentagonal_hexecontahedron\" : Pentagonal hexecontahedron.     Dual polytope to the snub dodecahedron, made of 60 irregular pentagonal     facets.\n\"rhombic_triacontahedron\" : Rhombic triacontahedron.     Dual polytope to the icosidodecahedron, made of 30 rhombic facets.\n\"triakis_icosahedron\" : Triakis icosahedron.     Dual polytope to the icosidodecahedron, made of 30 rhombic facets.\n\"deltoidal_icositetrahedron\" : Deltoidal icositetrahedron.     Dual polytope to the rhombicubaoctahedron, made of 24 kite facets.\n\"pentakis_dodecahedron\" : Pentakis dodecahedron.     Dual polytope to the truncated icosahedron, made of 60 isosceles     triangular facets.\n\"deltoidal_hexecontahedron\" : Deltoidal hexecontahedron.     Dual polytope to the rhombicosidodecahedron, made of 60 kite facets.\n\"disdyakis_triacontahedron\" : Disdyakis triacontahedron.     Dual polytope to the truncated icosidodecahedron, made of 120 scalene     triangular facets.\n\nExamples\n\njulia> T = catalan_solid(\"triakis_tetrahedron\");\n\njulia> count(F -> n_vertices(F) == 3, faces(T, 2))\n12\n\njulia> n_facets(T)\n12\n\n\n\n\n\n","category":"function"},{"location":"PolyhedralGeometry/Polyhedra/constructions/#regular_24_cell","page":"Constructions","title":"regular_24_cell","text":"regular_24_cell()\n\nConstruct the regular 24-cell, one out of three exceptional regular 4-polytopes.\n\n\n\n\n\n","category":"function"},{"location":"PolyhedralGeometry/Polyhedra/constructions/#regular_120_cell","page":"Constructions","title":"regular_120_cell","text":"regular_120_cell()\n\nConstruct the regular 120-cell, one out of three exceptional regular 4-polytopes.\n\n\n\n\n\n","category":"function"},{"location":"PolyhedralGeometry/Polyhedra/constructions/#regular_600_cell","page":"Constructions","title":"regular_600_cell","text":"regular_600_cell()\n\nConstruct the regular 600-cell, one out of three exceptional regular 4-polytopes.\n\n\n\n\n\n","category":"function"},{"location":"PolyhedralGeometry/Polyhedra/constructions/","page":"Constructions","title":"Constructions","text":"Like some of the Johnson solids, the following four Archimedean and Catalan solids are constructed using serialized data. In order to properly document the respective sources, they also come as separate functions.","category":"page"},{"location":"PolyhedralGeometry/Polyhedra/constructions/","page":"Constructions","title":"Constructions","text":"snub_cube\nsnub_dodecahedron\npentagonal_icositetrahedron\npentagonal_hexecontahedron","category":"page"},{"location":"PolyhedralGeometry/Polyhedra/constructions/#snub_cube","page":"Constructions","title":"snub_cube","text":"  snub_cube()\n\nConstruct the snub cube, an Archimedean solid. See the Polytope Wiki\n\nSee also archimedean_solid.\n\n\n\n\n\n","category":"function"},{"location":"PolyhedralGeometry/Polyhedra/constructions/#snub_dodecahedron","page":"Constructions","title":"snub_dodecahedron","text":"  snub_dodecahedron()\n\nConstruct the snub dodecahedron, an Archimedean solid. See the Polytope Wiki\n\nSee also archimedean_solid.\n\n\n\n\n\n","category":"function"},{"location":"PolyhedralGeometry/Polyhedra/constructions/#pentagonal_icositetrahedron","page":"Constructions","title":"pentagonal_icositetrahedron","text":"  pentagonal_icositetrahedron()\n\nConstruct the pentagonal icositetrahedron, a Catalan solid. See the Wikipedia entry\n\nSee also catalan_solid.\n\n\n\n\n\n","category":"function"},{"location":"PolyhedralGeometry/Polyhedra/constructions/#pentagonal_hexecontahedron","page":"Constructions","title":"pentagonal_hexecontahedron","text":"  pentagonal_hexecontahedron()\n\nConstruct the pentagonal hexecontahedron, a Catalan solid. See the Visual Polyhedra entry\n\nSee also catalan_solid.\n\n\n\n\n\n","category":"function"},{"location":"PolyhedralGeometry/Polyhedra/constructions/#Other-polytope-constructions","page":"Constructions","title":"Other polytope constructions","text":"","category":"section"},{"location":"PolyhedralGeometry/Polyhedra/constructions/","page":"Constructions","title":"Constructions","text":"SIM_body_polytope\nassociahedron\nbillera_lee_polytope\nbinary_markov_graph_polytope\nbirkhoff_polytope\ncyclic_caratheodory_polytope\ncyclic_polytope\ndel_pezzo_polytope\ndwarfed_cube\ndwarfed_product_polygons\nexplicit_zonotope\nfano_simplex\nfractional_cut_polytope\nfractional_knapsack_polytope\nfractional_matching_polytope\ngelfand_tsetlin_polytope\ngoldfarb_cube\ngoldfarb_sit_cube\nhypersimplex\nhypertruncated_cube\nk_cyclic_polytope\nklee_minty_cube\nlecture_hall_simplex\nmax_GC_rank_polytope\nn_gon\nnewton_polytope\norbit_polytope\npermutahedron\npile_polytope\npitman_stanley_polytope\nperles_nonrational_8_polytope\npseudo_del_pezzo_polytope\nrand01_polytope\nrand_box_polytope\nrand_cyclic_polytope\nrand_metric\nrand_metric_int\nrand_normal_polytope\nrand_spherical_polytope\nrand_subpolytope\nrss_associahedron\nsigned_permutahedron\nstable_set_polytope\ntransportation_polytope\nzonotope\nzonotope_vertices_fukuda_matrix","category":"page"},{"location":"PolyhedralGeometry/Polyhedra/constructions/#SIM_body_polytope","page":"Constructions","title":"SIM_body_polytope","text":"SIM_body_polytope(alpha::AbstractVector)\n\nProduce an n-dimensional SIM-body as generalized permutahedron in  (n+1)-space. SIM-bodies are defined in [GK14], but the input needs to  be descending instead of ascending, as used in [JKS22], i.e. alpha has parameters (a_1dotsa_n) such that a_1 geq dots geq a_n geq 0.  \n\nExamples\n\nTo produce a 2-dimensional SIM-body, use for example the following code.  Note that the polytope lives in 3-space, so we project it down to 2-space  by eliminating the last coordinate. \n\njulia> s = SIM_body_polytope([3,1])\nPolyhedron in ambient dimension 3\n\njulia> p = convex_hull(map(x->x[1:dim(s)],vertices(s)))\nPolyhedron in ambient dimension 2\n\njulia> vertices(p) \n5-element SubObjectIterator{PointVector{QQFieldElem}}:\n [0, 0]\n [3, 0]\n [3, 1]\n [0, 3]\n [1, 3]\n\n\n\n\n\n","category":"function"},{"location":"PolyhedralGeometry/Polyhedra/constructions/#associahedron","page":"Constructions","title":"associahedron","text":"associahedron(d::Int)\n\nProduce a d-dimensional associahedron (or Stasheff polytope).  We use the facet description given in section 9.2. of [Zie95].\n\nNote that in polymake, this function has an optional Boolean parameter group, to also construct the symmetry group of the polytope. For details, see [CSZ15].\n\nExamples\n\nProduce the 2-dimensional associahedron is a polygon in mathbbR⁴ having 5 vertices and 5 facets.\n\njulia> A =  associahedron(2)\nPolyhedron in ambient dimension 4\n\njulia> vertices(A)\n5-element SubObjectIterator{PointVector{QQFieldElem}}:\n [9, 4, 1, 10]\n [10, 1, 4, 9]\n [1, 10, 1, 9]\n [1, 4, 9, 6]\n [4, 1, 10, 6]\n\njulia> facets(A)\n5-element SubObjectIterator{AffineHalfspace{QQFieldElem}} over the halfspaces of R^4 described by:\n-x_1 <= -1\n-2*x_1 - 2*x_2 <= -10\n-x_2 <= -1\n-2*x_2 - 2*x_3 <= -10\n-x_3 <= -1\n\n\n\n\n\n","category":"function"},{"location":"PolyhedralGeometry/Polyhedra/constructions/#billera_lee_polytope","page":"Constructions","title":"billera_lee_polytope","text":"billera_lee_polytope(h::AbstractVector)\n\nConstruct a simplicial polytope whose h-vector is h. The corresponding g-vector must be an M-sequence. The ambient dimension equals the length of h, and the polytope lives in codimension one.\n\n[BL81]\n\nExamples\n\njulia> BL = billera_lee_polytope([1,3,3,1])\nPolyhedron in ambient dimension 4\n\njulia> f_vector(BL)\n3-element Vector{ZZRingElem}:\n 6\n 12\n 8\n\n\n\n\n\n\n","category":"function"},{"location":"PolyhedralGeometry/Polyhedra/constructions/#binary_markov_graph_polytope","page":"Constructions","title":"binary_markov_graph_polytope","text":"binary_markov_graph_polytope(observation::AbstractVector)\n\nDefines a very simple graph for a polytope propagation related to a Hidden  Markov Model. The length of observation is the number of possible oberservations. Its elements are of types Bool or Int.  The propagated polytope is always a polygon. For a detailed  description see [Jos05].\n\nExamples\n\njulia> P = binary_markov_graph_polytope([1,1,1,1])\nPolyhedron in ambient dimension 2\n\njulia> vertices(P)\n4-element SubObjectIterator{PointVector{QQFieldElem}}:\n [3, 0]\n [1, 1]\n [0, 2]\n [0, 7]\n\n\n\n\n\n","category":"function"},{"location":"PolyhedralGeometry/Polyhedra/constructions/#birkhoff_polytope","page":"Constructions","title":"birkhoff_polytope","text":"birkhoff_polytope(n::Integer, even::Bool = false)\n\nConstruct the Birkhoff polytope of dimension n^2.\n\nThis is the polytope of n times n stochastic matrices (encoded as row vectors of length n^2), i.e., the matrices with non-negative real entries whose row and column entries sum up to one. Its vertices are the permutation matrices.\n\nUse even = true to get the vertices only for the even permutation matrices.\n\nExamples\n\njulia> b = birkhoff_polytope(3)\nPolytope in ambient dimension 9\n\njulia> vertices(b)\n6-element SubObjectIterator{PointVector{QQFieldElem}}:\n [1, 0, 0, 0, 1, 0, 0, 0, 1]\n [0, 1, 0, 1, 0, 0, 0, 0, 1]\n [0, 0, 1, 1, 0, 0, 0, 1, 0]\n [1, 0, 0, 0, 0, 1, 0, 1, 0]\n [0, 1, 0, 0, 0, 1, 1, 0, 0]\n [0, 0, 1, 0, 1, 0, 1, 0, 0]\n\n\n\n\n\n","category":"function"},{"location":"PolyhedralGeometry/Polyhedra/constructions/#cyclic_caratheodory_polytope","page":"Constructions","title":"cyclic_caratheodory_polytope","text":"cyclic_caratheodory_polytope(d::Int, n::Int)\n\nProduce a d-dimensional cyclic polytope with n points. Clearly ngeq d is required.  It is a prototypical example of a neighborly polytope whose combinatorics completely known  due to Gale's evenness criterion. The coordinates are chosen on the trigonometric moment curve.\n\nExamples\n\njulia> C= cyclic_caratheodory_polytope(4,5)\nPolytope in ambient dimension 4\n\njulia> vertices(C)\n5-element SubObjectIterator{PointVector{QQFieldElem}}:\n [1, 0, 1, 0]\n [347922205179541//1125899906842624, 8566355544790271//9007199254740992, -7286977268806823//9007199254740992, 5294298886396511//9007199254740992]\n [-7286977268806823//9007199254740992, 5294298886396511//9007199254740992, 1391688820718163//4503599627370496, -33462326346837//35184372088832]\n [-7286977268806825//9007199254740992, -5294298886396509//9007199254740992, 5566755282872661//18014398509481984, 8566355544790271//9007199254740992]\n [1391688820718163//4503599627370496, -33462326346837//35184372088832, -3643488634403413//4503599627370496, -5294298886396507//9007199254740992]\n\n\n\n\n\n","category":"function"},{"location":"PolyhedralGeometry/Polyhedra/constructions/#cyclic_polytope","page":"Constructions","title":"cyclic_polytope","text":"cyclic_polytope(d::Int, n::Int)\n\nConstruct the cyclic polytope that is the convex hull of n points on the moment curve in dimension d.\n\nExamples\n\njulia> cp = cyclic_polytope(3, 20)\nPolytope in ambient dimension 3\n\njulia> n_vertices(cp)\n20\n\n\n\n\n\n","category":"function"},{"location":"PolyhedralGeometry/Polyhedra/constructions/#del_pezzo_polytope","page":"Constructions","title":"del_pezzo_polytope","text":"del_pezzo_polytope(d::Int)\n\nProduce the d-dimensional del Pezzo polytope, which is the convex hull of the cross polytope together with the all-ones and minus all-ones vector.\n\nExamples\n\njulia> DP = del_pezzo_polytope(4)\nPolytope in ambient dimension 4\n\njulia> f_vector(DP)\n4-element Vector{ZZRingElem}:\n 10\n 40\n 60\n 30\n\n\n\n\n\n","category":"function"},{"location":"PolyhedralGeometry/Polyhedra/constructions/#dwarfed_cube","page":"Constructions","title":"dwarfed_cube","text":"dwarfed_cube(d::Int)\n\nProduce the d-dimensional dwarfed cube as defined in [ABS97]. \n\nExamples\n\nThe 3-dimensional dwarfed cube is illustrated in [Jos03].\n\njulia> c = dwarfed_cube(3)\nPolytope in ambient dimension 3\n\njulia> vertices(c)\n10-element SubObjectIterator{PointVector{QQFieldElem}}:\n [1//2, 0, 1]\n [1//2, 1, 0]\n [1, 0, 1//2]\n [1, 1//2, 0]\n [1, 0, 0]\n [0, 0, 0]\n [0, 1, 0]\n [0, 1//2, 1]\n [0, 0, 1]\n [0, 1, 1//2]\n\n\n\n\n\n","category":"function"},{"location":"PolyhedralGeometry/Polyhedra/constructions/#dwarfed_product_polygons","page":"Constructions","title":"dwarfed_product_polygons","text":"dwarfed_product_polygons(d::Int, s::Int)\n\nProduce a d-dimensional dwarfed product of polygons of size s as defined in [ABS97]. It must be dgeq4 and even as well as sgeq 3.\n\nExamples\n\njulia> p = dwarfed_product_polygons(4,3)\nPolytope in ambient dimension 4\n\njulia> vertices(p)\n11-element SubObjectIterator{PointVector{QQFieldElem}}:\n [5, 3, 0, 0]\n [5, 0, 0, 0]\n [2, 0, 3, 9]\n [0, 0, 5, 3]\n [0, 0, 3, 9]\n [2, 6, 3, 9]\n [0, 0, 5, 0]\n [0, 0, 0, 0]\n [3, 9, 2, 6]\n [3, 9, 2, 0]\n [3, 9, 0, 0]\n\n\n\n\n\n","category":"function"},{"location":"PolyhedralGeometry/Polyhedra/constructions/#explicit_zonotope","page":"Constructions","title":"explicit_zonotope","text":"explicit_zonotope(zones::Matrix; rows_are_points::Bool=true)\n\nProduce the points of a zonotope as the iterated Minkowski sum of all intervals -xx,  where x ranges over the rows of the input matrix zones.  If rows_are_points is true (default), the rows of the input matrix represent affine points,  otherwise they represent linear vectors.\n\nExamples\n\njulia> Z = explicit_zonotope([1 1; 1 -1], rows_are_points=false)\nPolyhedron in ambient dimension 2\n\njulia> vertices(Z)\n4-element SubObjectIterator{PointVector{QQFieldElem}}:\n [2, 0]\n [0, -2]\n [0, 2]\n [-2, 0]\n\n\n\n\n\n","category":"function"},{"location":"PolyhedralGeometry/Polyhedra/constructions/#fano_simplex","page":"Constructions","title":"fano_simplex","text":"fano_simplex(d::Int)\n\nConstruct a lattice simplex such that the origin is the unique interior lattice point. The normal toric variety associated with its face fan is smooth.\n\nKeywords\n\nd::Int: the dimension.\n\nExamples\n\njulia> S = fano_simplex(3)\nPolytope in ambient dimension 3\n\njulia> X = normal_toric_variety(face_fan(S))\nNormal toric variety\n\njulia> is_smooth(X)\ntrue\n\n\n\n\n\n","category":"function"},{"location":"PolyhedralGeometry/Polyhedra/constructions/#fractional_cut_polytope","page":"Constructions","title":"fractional_cut_polytope","text":"fractional_cut_polytope(G::Graph{Undirected})\n\nConstruct the fractional cut polytope of the graph G.\n\nExamples\n\njulia> G = complete_graph(4);\n\njulia> fractional_cut_polytope(G)\nPolytope in ambient dimension 6\n\n\n\n\n\n","category":"function"},{"location":"PolyhedralGeometry/Polyhedra/constructions/#fractional_knapsack_polytope","page":"Constructions","title":"fractional_knapsack_polytope","text":"fractional_knapsack_polytope(b::AbstractVector{<:Base.Number})\n\nProduce a knapsack polytope defined by one linear inequality (and non-negativity constraints).\n\nExample\n\njulia> f = fractional_knapsack_polytope([10,-2,-3,-5])\nPolytope in ambient dimension 3\n\njulia> print_constraints(f)\n2*x_1 + 3*x_2 + 5*x_3 <= 10\n-x_1 <= 0\n-x_2 <= 0\n-x_3 <= 0\n\n\n\n\n\n","category":"function"},{"location":"PolyhedralGeometry/Polyhedra/constructions/#fractional_matching_polytope","page":"Constructions","title":"fractional_matching_polytope","text":"fractional_matching_polytope(G::Graph{Undirected})\n\nConstruct the fractional matching polytope of the graph G.\n\nExamples\n\njulia> G = complete_graph(4);\n\njulia> fractional_matching_polytope(G)\nPolytope in ambient dimension 6\n\n\n\n\n\n","category":"function"},{"location":"PolyhedralGeometry/Polyhedra/constructions/#gelfand_tsetlin_polytope","page":"Constructions","title":"gelfand_tsetlin_polytope","text":"gelfand_tsetlin_polytope(lambda::AbstractVector)\n\nConstruct the Gelfand-Tsetlin polytope indexed by a weakly decreasing vector lambda.\n\nExamples\n\njulia> P = gelfand_tsetlin_polytope([5,3,2])\nPolyhedron in ambient dimension 6\n\njulia> is_fulldimensional(P)\nfalse\n\njulia> p = project_full(P)\nPolyhedron in ambient dimension 3\n\njulia> is_fulldimensional(p)\ntrue\n\njulia> volume(p)\n3\n\n\n\n\n\ngelfand_tsetlin_polytope(lambda::AbstractVector, sigma::PermGroupElem)\n\nConstruct the generalized Gelfand-Tsetlin polytope indexed by a weakly decreasing vector lambda and a permutation  sigma. \n\n[PS09]\n\njulia> P = gelfand_tsetlin_polytope([5,3,2], @perm (1,3,2))\nPolyhedron in ambient dimension 6\n\n\n\n\n\n","category":"function"},{"location":"PolyhedralGeometry/Polyhedra/constructions/#goldfarb_cube","page":"Constructions","title":"goldfarb_cube","text":"goldfarb_cube(d::Int, e::Number, g::Number)\n\nProduce a d-dimensional Goldfarb cube.  The first parameter of deformation e must be frac12,  the second parameter of deformation d must be geq fractexttte4. \n\nThe Goldfarb cube is a combinatorial cube and yields a bad example for the  Simplex Algorithm using the Shadow Vertex Pivoting Strategy.  Here we use the description as a deformed product due to [AZ99].  For g=0 we obtain a Klee-Minty cube,  in particular for e=g=0 we obtain the standard cube. \n\nExamples\n\nThe following produces a 3-dimensional Klee-Minty cube for e=frac13.\n\njulia> c = goldfarb_cube(3,1//3,0)\nPolytope in ambient dimension 3\n\njulia> vertices(c)\n8-element SubObjectIterator{PointVector{QQFieldElem}}:\n [1, 1//3, 8//9]\n [1, 2//3, 7//9]\n [1, 2//3, 2//9]\n [1, 1//3, 1//9]\n [0, 0, 0]\n [0, 1, 1//3]\n [0, 1, 2//3]\n [0, 0, 1]\n\n\n\n\n\n","category":"function"},{"location":"PolyhedralGeometry/Polyhedra/constructions/#goldfarb_sit_cube","page":"Constructions","title":"goldfarb_sit_cube","text":"goldfarb_sit_cube(d::Int, eps::Number, delta::Number)\n\nProduces a d-dimensional variation of the Klee-Minty cube, which is scaled in direction x_d-i  by eps*delta^i.  The first parameter of deformation eps must be frac12,  the second parameter of deformation delta must be geq frac12.  This cube is a combinatorial cube and yields a bad example for the Simplex Algorithm using the  Steepest Edge Pivoting Strategy. Here we use a scaled description of the construction of Goldfarb and Sit,  see [GS79].\n\nExamples\n\njulia> c = goldfarb_sit_cube(3,1//3,1//2)\nPolytope in ambient dimension 3\n\njulia> vertices(c) \n8-element SubObjectIterator{PointVector{QQFieldElem}}:\n [1//36, 1//18, 8//9]\n [1//36, 1//9, 7//9]\n [1//36, 1//9, 2//9]\n [1//36, 1//18, 1//9]\n [0, 0, 0]\n [0, 1//6, 1//3]\n [0, 1//6, 2//3]\n [0, 0, 1]\n\n\n\n\n\n","category":"function"},{"location":"PolyhedralGeometry/Polyhedra/constructions/#hypersimplex","page":"Constructions","title":"hypersimplex","text":"hypersimplex(k::Int, d::Int; no_vertices::Bool=false, no_facets::Bool=false, no_vif::Bool=false)\n\nProduce the hypersimplex Delta(kd), that is the the convex hull of all 01-vector in mathbbR^d with exactly k ones. Note that the output is never full-dimensional.\n\nOptional Arguments\n\nno_vertices::Bool: If set equal to true, vertices of the underlying polymake object are not computed.\nno_facets::Bool: If set equal to true, facets of the underlying polymake object are not computed.\nno_vif::Bool: If set equal to true, vertices in facets of the underlying polymake object are not computed.\n\nExamples\n\njulia> H = hypersimplex(3,4)\nPolytope in ambient dimension 4\n\njulia> G = hypersimplex(3,4,no_facets=true)\nPolytope in ambient dimension 4\n\njulia> facets(G)\n4-element SubObjectIterator{AffineHalfspace{QQFieldElem}} over the halfspaces of R^4 described by:\nx_4 <= 1\nx_3 <= 1\n-x_1 - x_3 - x_4 <= -2\nx_1 <= 1\n\njulia> facets(H)\n4-element SubObjectIterator{AffineHalfspace{QQFieldElem}} over the halfspaces of R^4 described by:\nx_4 <= 1\nx_3 <= 1\n-x_1 - x_3 - x_4 <= -2\nx_1 <= 1\n\n\n\n\n\n","category":"function"},{"location":"PolyhedralGeometry/Polyhedra/constructions/#hypertruncated_cube","page":"Constructions","title":"hypertruncated_cube","text":"hypertruncated_cube(d::Int, k::Number, lambda::Number)\n\nProduce a d-dimensional hypertruncated cube with symmetric linear objective function (111).\n\nArguments\n\nk: cutoff parameter\nlambda: scaling of extra vertex\n\nExamples\n\njulia> H = hypertruncated_cube(3,2,3)\nPolytope in ambient dimension 3\n\njulia> print_constraints(H)\n-x_1 <= 0\n-x_2 <= 0\n-x_3 <= 0\nx_1 <= 1\nx_2 <= 1\nx_3 <= 1\n5*x_1 - 2*x_2 - 2*x_3 <= 3\n-2*x_1 + 5*x_2 - 2*x_3 <= 3\n-2*x_1 - 2*x_2 + 5*x_3 <= 3\n\n\n\n\n\n","category":"function"},{"location":"PolyhedralGeometry/Polyhedra/constructions/#k_cyclic_polytope","page":"Constructions","title":"k_cyclic_polytope","text":"k_cyclic_polytope(n::Int, s::Vector)\n\nProduce a (rounded) 2*k-dimensional k-cyclic polytope with n points,  where k is the length of the input vector s.  Special cases are the bicyclic (k=2) and tricyclic (k=3) polytopes.  Only possible in even dimensions. \n\nThe parameters texttts_i can be integers, floating-points or rational numbers.  The i-th vertex then is: (cos(texttts_1 * 2pi itextttn) sin(texttts_1 * 2pi itextttn)   cos(texttts_k * 2pi itextttn) sin(texttts_k * 2pi itextttn)).\n\nWarning: Some of the k-cyclic polytopes are not simplicial.  Since the components are rounded, this function might output a polytope which is  not a k-cyclic polytope! More information see [Sch95].\n\nExamples\n\nTo produce a (not exactly) regular pentagon, type this:\n\njulia> p = k_cyclic_polytope(5,[1])\nPolytope in ambient dimension 2\n\njulia> dim(p) \n2\n\njulia> n_vertices(p)\n5\n\n\n\n\n\n","category":"function"},{"location":"PolyhedralGeometry/Polyhedra/constructions/#klee_minty_cube","page":"Constructions","title":"klee_minty_cube","text":"klee_minty_cube(d::Int, e::Number)\n\nProduces a d-dimensional Klee-Minty-cube if texttte  12.  Uses the goldfarb_cube method with the argument textttg = 0.\n\n#Example\n\njulia> k = klee_minty_cube(3,1//8)\nPolytope in ambient dimension 3\n\njulia> print_constraints(k)\n-x_1 <= 0\nx_1 <= 1\n1//8*x_1 - x_2 <= 0\n1//8*x_1 + x_2 <= 1\n1//8*x_2 - x_3 <= 0\n1//8*x_2 + x_3 <= 1\n\n\n\n\n\n","category":"function"},{"location":"PolyhedralGeometry/Polyhedra/constructions/#lecture_hall_simplex","page":"Constructions","title":"lecture_hall_simplex","text":"lecture_hall_simplex(d::Int)\n\nProduce the d-dimensional lecture hall simplex for the sequence (s_i)=i for 1geq i geq d as defined in [SS12].\n\nNote that in polymake, this function has an optional Boolean parameter group, to also construct the symmetry group of the simplex.  \n\nExamples\n\nThe 3-dimensional lecture hall simplex:\n\njulia> S = lecture_hall_simplex(3) \nPolytope in ambient dimension 3\n\njulia> vertices(S)\n4-element SubObjectIterator{PointVector{QQFieldElem}}:\n [0, 0, 0]\n [0, 0, 3]\n [0, 2, 3]\n [1, 2, 3]\n\n\n\n\n\n","category":"function"},{"location":"PolyhedralGeometry/Polyhedra/constructions/#max_GC_rank_polytope","page":"Constructions","title":"max_GC_rank_polytope","text":"max_GC_rank_polytope(d::Int)\n\nProduce a d-dimensional polytope of maximal Gomory-Chvatal rank Omega(dlog(d)),  integrally infeasible. With symmetric linear objective function (111).  Construction due to Pokutta and Schulz, see [PS11].\n\nExamples\n\njulia> c = max_GC_rank_polytope(3)\nPolytope in ambient dimension 3\n\njulia> vertices(c)\n6-element SubObjectIterator{PointVector{QQFieldElem}}:\n [0, 1//2, 1//2]\n [1//2, 0, 1//2]\n [1//2, 1//2, 0]\n [1//2, 1, 1//2]\n [1//2, 1//2, 1]\n [1, 1//2, 1//2]\n\n\n\n\n\n","category":"function"},{"location":"PolyhedralGeometry/Polyhedra/constructions/#n_gon","page":"Constructions","title":"n_gon","text":"n_gon(n::Int; r::RationalUnion=1, alpha_0::RationalUnion=0)\n\nProduce a regular n-gon. All vertices lie on a circle of radius r (defaults to 1)  and initial angle divided by pi alpha_0 (defaults to 0).\n\nExamples\n\nTo store the regular pentagon in the variable p, do this:\n\njulia> p = n_gon(3)\nPolytope in ambient dimension 2 with QQBarFieldElem type coefficients\n\njulia> volume(n_gon(4, r=2, alpha_0=1//4))\nRoot 8.00000 of x - 8\n\n\n\n\n\n","category":"function"},{"location":"PolyhedralGeometry/Polyhedra/constructions/#newton_polytope","page":"Constructions","title":"newton_polytope","text":"newton_polytope(poly::Polynomial)\n\nCompute the Newton polytope of the multivariate polynomial poly.\n\nExamples\n\njulia> S, (x, y) = polynomial_ring(ZZ, [:x, :y])\n(Multivariate polynomial ring in 2 variables over ZZ, ZZMPolyRingElem[x, y])\n\njulia> f = x^3*y + 3x*y^2 + 1\nx^3*y + 3*x*y^2 + 1\n\njulia> NP = newton_polytope(f)\nPolyhedron in ambient dimension 2\n\njulia> vertices(NP)\n3-element SubObjectIterator{PointVector{QQFieldElem}}:\n [3, 1]\n [1, 2]\n [0, 0]\n\n\n\n\n\n","category":"function"},{"location":"PolyhedralGeometry/Polyhedra/constructions/#orbit_polytope","page":"Constructions","title":"orbit_polytope","text":"orbit_polytope(V::AbstractCollection[PointVector], G::PermGroup)\n\nConstruct the convex hull of the orbit of one or several points (given row-wise in V) under the action of G.\n\nExamples\n\nThis will construct the 3-dimensional permutahedron:\n\njulia> V = [1 2 3];\n\njulia> G = symmetric_group(3);\n\njulia> P = orbit_polytope(V, G)\nPolyhedron in ambient dimension 3\n\njulia> vertices(P)\n6-element SubObjectIterator{PointVector{QQFieldElem}}:\n [1, 2, 3]\n [1, 3, 2]\n [2, 1, 3]\n [2, 3, 1]\n [3, 1, 2]\n [3, 2, 1]\n\n\n\n\n\n","category":"function"},{"location":"PolyhedralGeometry/Polyhedra/constructions/#permutahedron","page":"Constructions","title":"permutahedron","text":"permutahedron(d::Int)\n\nProduce a d-dimensional permutahedron.  The vertices correspond to the elements of the symmetric group of degree d+1.\n\n#Example\n\njulia> p = permutahedron(2)\nPolytope in ambient dimension 3\n\njulia> vertices(p)\n6-element SubObjectIterator{PointVector{QQFieldElem}}:\n [1, 2, 3]\n [1, 3, 2]\n [2, 1, 3]\n [2, 3, 1]\n [3, 1, 2]\n [3, 2, 1]\n\n\n\n\n\n","category":"function"},{"location":"PolyhedralGeometry/Polyhedra/constructions/#pile_polytope","page":"Constructions","title":"pile_polytope","text":"pile_polytope(sizes::Vector{Int})\n\nProduce a (d+1)-dimensional polytope from a pile of cubes. Start with a d-dimensional pile of cubes.  Take a generic convex function to lift this polytopal complex to the boundary of a (d+1)–polytope. The argument sizes is a vector (s_1s_d) where s_i specifies the number of boxes in the i-th dimension.\n\n\n\n\n\n","category":"function"},{"location":"PolyhedralGeometry/Polyhedra/constructions/#pitman_stanley_polytope","page":"Constructions","title":"pitman_stanley_polytope","text":"pitman_stanley_polytope(y::AbstractVector)\n\nProduce a Pitman-Stanley polytope of dimension n-1, where  y is a  Vector of n positive parameters. Does not check if the parameters are actually positive; negative values are legal but that do not yield a Pitman-Stanley polytope. Zeros just reduce the dimension; negative numbers may produce unbounded polyhedra. \n\nExample:\n\nPitman-Stanley polytopes are combinatorial cubes:\n\njulia> p = pitman_stanley_polytope([1,2,3])\nPolyhedron in ambient dimension 3\n\njulia> f_vector(p) \n2-element Vector{ZZRingElem}:\n 4\n 4\n\n\n\n\n\n","category":"function"},{"location":"PolyhedralGeometry/Polyhedra/constructions/#perles_nonrational_8_polytope","page":"Constructions","title":"perles_nonrational_8_polytope","text":"perles_nonrational_8_polytope()\n\nCreate an 8-dimensional polytope without rational realizations due to Perles. See [Gru03].\n\nExamples\n\njulia> perles_nonrational_8_polytope()\nPolytope in ambient dimension 8 with EmbeddedAbsSimpleNumFieldElem type coefficients\n\n\n\n\n\n","category":"function"},{"location":"PolyhedralGeometry/Polyhedra/constructions/#pseudo_del_pezzo_polytope","page":"Constructions","title":"pseudo_del_pezzo_polytope","text":"pseudo_del_pezzo_polytope(d::Int)\n\nProduce a d-dimensional del-Pezzo polytope, which is the convex hull of the cross polytope  together with the all-ones vector. All coordinates are plus or minus one.\n\nExamples\n\njulia> DP = pseudo_del_pezzo_polytope(4)\nPolytope in ambient dimension 4\n\njulia> f_vector(DP)\n4-element Vector{ZZRingElem}:\n 9\n 32\n 46\n 23\n\n\n\n\n\n","category":"function"},{"location":"PolyhedralGeometry/Polyhedra/constructions/#rand01_polytope","page":"Constructions","title":"rand01_polytope","text":"rand01_polytope(d::Int, n::Int; seed=nothing)\n\nProduce a d-dimensional 01-polytope with n random vertices. Uniform distribution.\n\nOptional Argument\n\n-seed::Int: Seed for random number generation\n\nExamples\n\njulia> s = rand01_polytope(2, 4; seed=3)\nPolytope in ambient dimension 2\n\njulia> vertices(s)\n4-element SubObjectIterator{PointVector{QQFieldElem}}:\n [1, 1]\n [1, 0]\n [0, 0]\n [0, 1]\n\n\n\n\n\n","category":"function"},{"location":"PolyhedralGeometry/Polyhedra/constructions/#rand_box_polytope","page":"Constructions","title":"rand_box_polytope","text":"rand_box_polytope(d::Int, n::Int, b::Int; seed::Int=nothing)\n\nComputes the convex hull of n points sampled uniformly at random from the integer  points in the cube 0textttb^textttd.\n\nOptional Argument\n\n-seed: Seed for random number generation.\n\nExamples\n\njulia> r = rand_box_polytope(3, 10, 3, seed=1)\nPolyhedron in ambient dimension 3\n\njulia> vertices(r) \n8-element SubObjectIterator{PointVector{QQFieldElem}}:\n [3, 2, 3]\n [0, 3, 0]\n [3, 3, 0]\n [3, 0, 1]\n [1, 1, 0]\n [2, 0, 3]\n [0, 3, 3]\n [0, 1, 2]\n\n\n\n\n\n","category":"function"},{"location":"PolyhedralGeometry/Polyhedra/constructions/#rand_cyclic_polytope","page":"Constructions","title":"rand_cyclic_polytope","text":"rand_cyclic_polytope(d::Int, n::Int; seed::Int=nothing)\n\nComputes a random instance of a cyclic polytope of dimension d on n vertices by randomly  generating a Gale diagram whose cocircuits have alternating signs.\n\nOptional Argument\n\n-seed: Seed for random number generation\n\nExamples\n\njulia> r = rand_cyclic_polytope(3, 5)\nPolytope in ambient dimension 3\n\njulia> f_vector(r)\n3-element Vector{ZZRingElem}:\n 5\n 9\n 6\n\n\n\n\n\n","category":"function"},{"location":"PolyhedralGeometry/Polyhedra/constructions/#rand_metric","page":"Constructions","title":"rand_metric","text":"rand_metric(n::Int; seed=nothing)\n\nProduce a rational n-point metric with random distances.  The values are uniformily distributed in 1 2.\n\nExamples\n\njulia> rand_metric(3, seed=132)\n[                               0   260222460282405//140737488355328   371474612593257//281474976710656]\n[260222460282405//140737488355328                                  0   388326899436839//281474976710656]\n[371474612593257//281474976710656   388326899436839//281474976710656                                  0]\n\n\n\n\n\n\n","category":"function"},{"location":"PolyhedralGeometry/Polyhedra/constructions/#rand_metric_int","page":"Constructions","title":"rand_metric_int","text":"rand_metric_int(n::Int, digits::Int; seed=nothing)\n\nProduce a n-point metric with random integral distances.  The values are uniformily distributed in 1 2. The distances are integers and lie in 10^digits 10^(digits+1).\n\n\n\n\n\n","category":"function"},{"location":"PolyhedralGeometry/Polyhedra/constructions/#rand_normal_polytope","page":"Constructions","title":"rand_normal_polytope","text":"rand_normal_polytope(d::Int, n::Int; seed=nothing, precision=nothing)\n\nProduce a rational d-dimensional polytope from n random points approximately  normally distributed in the unit ball.\n\nOptional Arguments\n\n-seed: controls the outcome of the random number generator; fixing a seed number guarantees the same outcome -precision: number of bits for MPFR sphere approximation\n\nExamples\n\njulia> rnp = rand_normal_polytope(2,4; seed=42, precision=4)\nPolytope in ambient dimension 2\n\njulia> is_simplicial(rnp)\ntrue\n\njulia> sort(map(x->dot(x,x), vertices(rnp)))\n4-element Vector{QQFieldElem}:\n 1417//4096\n 481//1024\n 225//256\n 101//32\n\n\n\n\n\n","category":"function"},{"location":"PolyhedralGeometry/Polyhedra/constructions/#rand_spherical_polytope","page":"Constructions","title":"rand_spherical_polytope","text":"rand_spherical_polytope([rng::AbstractRNG,] d::Int, n::Int;\ndistribution=:uniform, precision=nothing, seed=nothing)\n\nConstruct the convex hull of n points on the unit sphere in mathbbR^d. Almost surely this is a simplicial polytope.\n\nKeywords\n\ndistribution::Symbol: One of the following two options:\n:uniform (default): Use intermediate floating point numbers for an almost                       uniform distribution on the sphere.                       The points will not be exactly on the sphere.\n:exact:             Create exact rational points on the unit sphere, this                       works at the expense of both uniformity and log-height                       of the points.\nprecision::Int64:     Precision in bits during floating point approximation                         for uniform distribution.\nseed::Int64:          Seed for random number generation. Cannot be used                         together with the AbstractRNG argument.\n\nExamples\n\njulia> rsph = rand_spherical_polytope(3, 20)\nPolytope in ambient dimension 3\n\njulia> is_simplicial(rsph)\ntrue\n\njulia> rsph = rand_spherical_polytope(3, 4; precision=5, seed=132)\nPolytope in ambient dimension 3\n\njulia> map(x->dot(x,x), vertices(rsph))\n4-element Vector{QQFieldElem}:\n 4306545//4194304\n 15849//16384\n 4165//4096\n 8281//8192\n\njulia> rsph = rand_spherical_polytope(3, 4; distribution=:exact)\nPolytope in ambient dimension 3\n\njulia> map(x->dot(x,x), vertices(rsph))\n4-element Vector{QQFieldElem}:\n 1\n 1\n 1\n 1\n\n\n\n\n\n\n","category":"function"},{"location":"PolyhedralGeometry/Polyhedra/constructions/#rand_subpolytope","page":"Constructions","title":"rand_subpolytope","text":"rand_subpolytope(P::Polyhedron, n::Int; seed=nothing)\n\nConstruct a subpolytope of P as the convex hull of n vertices, chosen uniformly at random. The polyhedron P must be bounded, and the number n must not exceed the number of vertices.\n\nKeywords\n\nseed::Int64:          Seed for random number generation.\n\nExamples\n\njulia> n_vertices(rand_subpolytope(cube(3), 5))\n5\n\n\n\n\n\n\n","category":"function"},{"location":"PolyhedralGeometry/Polyhedra/constructions/#rss_associahedron","page":"Constructions","title":"rss_associahedron","text":"rss_associahedron(n::Int)\n\nProduce a polytope of constrained expansions in ambient dimension n according to [RSS03].\n\nExamples:\n\nTo produce a 3-dimensional associahedron in 5-space, do: \n\njulia> a= rss_associahedron(5)\nPolyhedron in ambient dimension 5\n\njulia> vertices(a)\n14-element SubObjectIterator{PointVector{QQFieldElem}}:\n [0, 1, 12, 13, 16]\n [0, 7, 8, 11, 16]\n [0, 1, 4, 9, 16]\n [0, 3, 4, 9, 16]\n [0, 5, 6, 9, 16]\n [0, 5, 8, 9, 16]\n [0, 1, 8, 9, 16]\n [0, 7, 10, 11, 16]\n [0, 7, 12, 13, 16]\n [0, 7, 12, 15, 16]\n [0, 1, 12, 15, 16]\n [0, 7, 8, 15, 16]\n [0, 1, 4, 15, 16]\n [0, 3, 4, 15, 16]\n\njulia> facets(a) \n9-element SubObjectIterator{AffineHalfspace{QQFieldElem}} over the halfspaces of R^5 described by:\nx_1 - x_2 <= -1\nx_1 - x_3 <= -4\nx_1 - x_4 <= -9\nx_2 - x_3 <= -1\nx_2 - x_4 <= -4\nx_2 - x_5 <= -9\nx_3 - x_4 <= -1\nx_3 - x_5 <= -4\nx_4 - x_5 <= -1\n\n\n\n\n\n","category":"function"},{"location":"PolyhedralGeometry/Polyhedra/constructions/#signed_permutahedron","page":"Constructions","title":"signed_permutahedron","text":"signed_permutahedron(d::Int)\n\nProduce the d-dimensional signed permutahedron. I.e. for all possible permutations of the vector (1dotsd), all possible sign patterns define vertices of this polytope.  Contrary to the classical permutahedron, the signed permutahedron is full-dimensional. \n\nExamples:\n\nTo produce the 2-dimensional signed permutahedron, do: \n\njulia> P = signed_permutahedron(2)\nPolytope in ambient dimension 2\n\njulia> vertices(P)\n8-element SubObjectIterator{PointVector{QQFieldElem}}:\n [1, 2]\n [-1, 2]\n [1, -2]\n [-1, -2]\n [2, 1]\n [-2, 1]\n [2, -1]\n [-2, -1]\n\n\n\n\n\n","category":"function"},{"location":"PolyhedralGeometry/Polyhedra/constructions/#stable_set_polytope","page":"Constructions","title":"stable_set_polytope","text":"stable_set_polytope(G::Graph{Undirected})\n\nProduces the stable set polytope from an undirected graph G=(VE).  The stable set Polytope has the following inequalities:  x_i + x_j leq 1 forall ij in E,   x_i geq 0 forall i in V and x_i leq 1 forall i in V text with  mathrmdeg(i)=0 \n\nExample:\n\nThe following produces first the standard cube in 3 dimensions, and then  a bipyramid over the convex hull of the unit vectors. \n\njulia> G = Graph{Undirected}(3)\nUndirected graph with 3 nodes and no edges\n\njulia> S = stable_set_polytope(G)\nPolytope in ambient dimension 3\n\njulia> vertices(S)\n8-element SubObjectIterator{PointVector{QQFieldElem}}:\n [1, 0, 0]\n [1, 1, 0]\n [1, 1, 1]\n [1, 0, 1]\n [0, 0, 1]\n [0, 0, 0]\n [0, 1, 0]\n [0, 1, 1]\n\njulia> add_edge!(G, 1, 2);\n\njulia> add_edge!(G, 1, 3);\n\njulia> add_edge!(G, 2, 3);\n\njulia> S = stable_set_polytope(G)\nPolytope in ambient dimension 3\n\njulia> vertices(S)\n5-element SubObjectIterator{PointVector{QQFieldElem}}:\n [0, 0, 1]\n [0, 1, 0]\n [1, 0, 0]\n [1//2, 1//2, 1//2]\n [0, 0, 0]\n\n\n\n\n\n","category":"function"},{"location":"PolyhedralGeometry/Polyhedra/constructions/#transportation_polytope","page":"Constructions","title":"transportation_polytope","text":"transportation_polytope(r::AbstractVector, c::AbstractVector)\n\nProduce the transportation polytope from two vectors r of length m and c of length n,  i.e. all positive mtimes n Matrizes with row sums equal to r and column sums equal to c. \n\nExample:\n\nWe can see that the set of 3times 3 magic squares with magic constant 15 is a 4-dimensional  polytope. \n\njulia> r = c = [15,15,15]\n3-element Vector{Int64}:\n 15\n 15\n 15\n\njulia> t = transportation_polytope(r,c) \nPolytope in ambient dimension 9\n\njulia> dim(t) \n4\n\njulia> is_bounded(t) \ntrue\n\n\n\n\n\n","category":"function"},{"location":"PolyhedralGeometry/Polyhedra/constructions/#zonotope","page":"Constructions","title":"zonotope","text":"zonotope(M::Matrix{<:Number}; centered::Bool=true)\n\nCreate a zonotope from a matrix whose rows are input points.\n\nOptional Arguments\n\ncentered::Bool: This is true if the output should be centered; the default is true.\n\nExamples\n\nThe following produces a parallelogram with the origin as its vertex barycenter: \n\njulia> Z = zonotope([1 0; 1 1])\nPolyhedron in ambient dimension 2\n\njulia> vertices(Z)\n4-element SubObjectIterator{PointVector{QQFieldElem}}:\n [-1, -1//2]\n [0, -1//2]\n [0, 1//2]\n [1, 1//2]\n\nThe following produces a parallelogram with the origin being a vertex (not centered case): \n\njulia> Z = zonotope([1 0; 1 1], centered = false)\nPolyhedron in ambient dimension 2\n\njulia> vertices(Z)\n4-element SubObjectIterator{PointVector{QQFieldElem}}:\n [0, 0]\n [1, 0]\n [1, 1]\n [2, 1]\n\n\n\n\n\n","category":"function"},{"location":"PolyhedralGeometry/Polyhedra/constructions/#zonotope_vertices_fukuda_matrix","page":"Constructions","title":"zonotope_vertices_fukuda_matrix","text":"zonotope_vertices_fukuda(M::Matrix)\n\nCreate the vertices of a zonotope from a matrix whose rows are input points or vectors. \n\nExamples\n\nThe following creates the vertices of a parallelogram with the origin as its vertex barycenter.\n\njulia> zonotope_vertices_fukuda_matrix([1 1 0; 1 1 1])\npm::Matrix<pm::Rational>\n-1 -1 -1/2\n0 0 -1/2\n0 0 1/2\n1 1 1/2\n\n\n\n\n\n","category":"function"},{"location":"PolyhedralGeometry/Polyhedra/constructions/#Operations-on-polyhedra","page":"Constructions","title":"Operations on polyhedra","text":"","category":"section"},{"location":"PolyhedralGeometry/Polyhedra/constructions/","page":"Constructions","title":"Constructions","text":"Polyhedra can be produced through operations on other polyhedra. For example, they can be added using Minkowski addition or scaled; each of which results in a new polyhedron.","category":"page"},{"location":"PolyhedralGeometry/Polyhedra/constructions/","page":"Constructions","title":"Constructions","text":"+(::Polyhedron{T}, ::Polyhedron{U}) where {T<:scalar_types, U<:scalar_types}\n*(::Number, ::Polyhedron{T}) where T<:scalar_types\n*(::Polyhedron{T}, ::Polyhedron{U})  where {T<:scalar_types, U<:scalar_types}\nbipyramid\nintersect(::Polyhedron...)\npyramid\nvertex_figure","category":"page"},{"location":"PolyhedralGeometry/Polyhedra/constructions/#+-Union{Tuple{U}, Tuple{T}, Tuple{Polyhedron{T}, Polyhedron{U}}} where {T<:Union{Float64, FieldElem}, U<:Union{Float64, FieldElem}}","page":"Constructions","title":"+","text":"+(P::Polyhedron, Q::Polyhedron)\n\nReturn the Minkowski sum P + Q =  x+y  xP yQ of P and Q (see also minkowski_sum).\n\nExamples\n\nThe Minkowski sum of a square and the 2-dimensional cross-polytope is an octagon:\n\njulia> P = cube(2);\n\njulia> Q = cross_polytope(2);\n\njulia> M = minkowski_sum(P, Q)\nPolyhedron in ambient dimension 2\n\njulia> n_vertices(M)\n8\n\n\n\n\n\n","category":"method"},{"location":"PolyhedralGeometry/Polyhedra/constructions/#*-Union{Tuple{T}, Tuple{Number, Polyhedron{T}}} where T<:Union{Float64, FieldElem}","page":"Constructions","title":"*","text":"*(k::Union{Number, FieldElem}, Q::Polyhedron)\n\nReturn the scaled polyhedron kQ =  kx  xQ.\n\nNote that k*Q = Q*k.\n\nExamples\n\nScaling an n-dimensional bounded polyhedron by the factor k results in the volume being scaled by k^n. This example confirms the statement for the 6-dimensional cube and k = 2.\n\njulia> C = cube(6);\n\njulia> SC = 2*C\nPolyhedron in ambient dimension 6\n\njulia> volume(SC)//volume(C)\n64\n\n\n\n\n\n","category":"method"},{"location":"PolyhedralGeometry/Polyhedra/constructions/#*-Union{Tuple{U}, Tuple{T}, Tuple{Polyhedron{T}, Polyhedron{U}}} where {T<:Union{Float64, FieldElem}, U<:Union{Float64, FieldElem}}","page":"Constructions","title":"*","text":"*(P::Polyhedron, Q::Polyhedron)\n\nReturn the Cartesian product of P and Q (see also product).\n\nExamples\n\nThe Cartesian product of a triangle and a line segment is a triangular prism.\n\njulia> T=simplex(2)\nPolytope in ambient dimension 2\n\njulia> S=cube(1)\nPolytope in ambient dimension 1\n\njulia> length(vertices(T*S))\n6\n\n\n\n\n\n","category":"method"},{"location":"PolyhedralGeometry/Polyhedra/constructions/#bipyramid","page":"Constructions","title":"bipyramid","text":"bipyramid(P::Polyhedron, z::Union{Number, FieldElem} = 1, z_prime::Union{Number, FieldElem} = -z)\n\nMake a bipyramid over a pointed polyhedron P.\n\nThe bipyramid is the convex hull of the input polyhedron P and two apexes (v, z), (v, z_prime) on both sides of the affine span of P. For bounded polyhedra, the projections of the apexes v to the affine span of P is the vertex barycenter of P.\n\nExamples\n\njulia> c = cube(2)\nPolytope in ambient dimension 2\n\njulia> vertices(bipyramid(c,2))\n6-element SubObjectIterator{PointVector{QQFieldElem}}:\n [-1, -1, 0]\n [1, -1, 0]\n [-1, 1, 0]\n [1, 1, 0]\n [0, 0, 2]\n [0, 0, -2]\n\n\n\n\n\n\n","category":"function"},{"location":"PolyhedralGeometry/Polyhedra/constructions/#intersect-Tuple{Vararg{Polyhedron}}","page":"Constructions","title":"intersect","text":"intersect(P::Polyhedron...)\n\nReturn the intersection bigcaplimits_p in P p.\n\nExamples\n\nThe positive orthant of the plane is the intersection of the two halfspaces with x0 and y0 respectively.\n\njulia> UH1 = convex_hull([0 0],[1 0],[0 1]);\n\njulia> UH2 = convex_hull([0 0],[0 1],[1 0]);\n\njulia> PO = intersect(UH1, UH2)\nPolyhedron in ambient dimension 2\n\njulia> rays(PO)\n2-element SubObjectIterator{RayVector{QQFieldElem}}:\n [1, 0]\n [0, 1]\n\n\n\n\n\n","category":"method"},{"location":"PolyhedralGeometry/Polyhedra/constructions/#pyramid","page":"Constructions","title":"pyramid","text":"pyramid(P::Polyhedron, z::Union{Number, FieldElem} = 1)\n\nMake a pyramid over the given polyhedron P.\n\nThe pyramid is the convex hull of the input polyhedron P and a point v outside the affine span of P. For bounded polyhedra, the projection of v to the affine span of P coincides with the vertex barycenter of P. The scalar z is the distance between the vertex barycenter and v.\n\nExamples\n\njulia> c = cube(2)\nPolytope in ambient dimension 2\n\njulia> vertices(pyramid(c,5))\n5-element SubObjectIterator{PointVector{QQFieldElem}}:\n [-1, -1, 0]\n [1, -1, 0]\n [-1, 1, 0]\n [1, 1, 0]\n [0, 0, 5]\n\n\n\n\n\n","category":"function"},{"location":"PolyhedralGeometry/Polyhedra/constructions/#vertex_figure","page":"Constructions","title":"vertex_figure","text":"vertex_figure(P::Polyhedron, n::Int; cutoff=1//2)\n\nConstruct the vertex figure of the vertex n of a bounded polytope. The vertex figure is dual to a facet of the dual polytope. \n\nOptional Arguments\n\ncutoff::Number: controls the exact location of the cutting hyperplane. It should lie in the open Interval (01).  Value 0 would let the hyperplane go through the chosen vertex, thus degenerating the vertex figure to a single point.  Value 1 would let the hyperplane touch the nearest neighbor vertex of a polyhedron. Default value is frac12. \n\nExamples\n\nTo produce a triangular vertex figure of a 3-dimensional cube in the positive orthant, do: \n\njulia> T = vertex_figure(cube(3), 8) \nPolyhedron in ambient dimension 3\n\njulia> vertices(T)\n3-element SubObjectIterator{PointVector{QQFieldElem}}:\n [1, 1, 0]\n [1, 0, 1]\n [0, 1, 1]\n\njulia> T = vertex_figure(cube(3), 8, cutoff = 1/4)\nPolyhedron in ambient dimension 3\n\njulia> vertices(T)\n3-element SubObjectIterator{PointVector{QQFieldElem}}:\n [1, 1, 1//2]\n [1, 1//2, 1]\n [1//2, 1, 1]\n\n\n\n\n\n","category":"function"},{"location":"PolyhedralGeometry/Polyhedra/constructions/","page":"Constructions","title":"Constructions","text":"The convex hull of two polytopes can be computed via convex_hull.","category":"page"},{"location":"PolyhedralGeometry/Polyhedra/constructions/","page":"Constructions","title":"Constructions","text":"convex_hull(::Polyhedron...)","category":"page"},{"location":"PolyhedralGeometry/Polyhedra/constructions/#convex_hull-Tuple{Vararg{Polyhedron}}","page":"Constructions","title":"convex_hull","text":"convex_hull(P::Polyhedron, Q::Polyhedron)\n\nReturn the convex_hull of P and Q.\n\nExamples\n\nThe convex hull of the following two line segments in R^3 is a tetrahedron.\n\njulia> L₁ = convex_hull([-1 0 0; 1 0 0])\nPolyhedron in ambient dimension 3\n\njulia> L₂ = convex_hull([0 -1 0; 0 1 0])\nPolyhedron in ambient dimension 3\n\njulia> T=convex_hull(L₁,L₂);\n\njulia> f_vector(T)\n2-element Vector{ZZRingElem}:\n 4\n 4\n\n\n\n\n\n","category":"method"},{"location":"StraightLinePrograms/gapslps/#GAP's-SLPs","page":"GAP's SLPs","title":"GAP's SLPs","text":"","category":"section"},{"location":"StraightLinePrograms/gapslps/","page":"GAP's SLPs","title":"GAP's SLPs","text":"There are two other available SLP types: GAPSLProgram and AtlasSLProgram, and related GAPSLDecision and AtlasSLDecision, which are constructed similarly as in GAP:","category":"page"},{"location":"StraightLinePrograms/gapslps/","page":"GAP's SLPs","title":"GAP's SLPs","text":"julia> prg = GAPSLProgram( [ [1,2,2,3], [3,-1] ], 2 )\n# input:\nr = [ g1, g2 ]\n# program:\nr[3] = r[1]^2*r[2]^3\nr[4] = r[3]^-1\n# return value:\nr[4]\n\njulia> SLP.evaluate(prg, [perm1, perm2])\n(1,3,4,2)\n\njulia> SLP.evaluate(prg, [x, y])\n#1 = ^  x  2  ==>  x^2\n#2 = ^  y  3  ==>  y^3\n#3 = * #1 #2  ==>  (x^2y^3)\n#4 = ^ #3 -1  ==>  (x^2y^3)^-1\nreturn: #4\n\njulia> SLProgram(prg) # direct compilation (with room for optimizations obviously)\n#1 =    x     ==>  x\n#2 =    y     ==>  y\n#3 = ^ #1  2  ==>  x^2\n#4 = ^ #2  3  ==>  y^3\n#5 = * #3 #4  ==>  (x^2y^3)\n#3 =   #5     ==>  (x^2y^3)\nkeep: #1..#3\n#4 = ^ #3 -1  ==>  (x^2y^3)^-1\nkeep: #1..#4\nreturn: #4\n\njulia> GAPSLProgram( [ [2,3], [ [3,1,1,4], [1,2,3,1] ] ], 2 )\n# input:\nr = [ g1, g2 ]\n# program:\nr[3] = r[2]^3\n# return values:\n[ r[3]*r[1]^4, r[1]^2*r[3] ]\n\njulia> GAPSLDecision([ [ [ 1, 1, 2, 1 ], 3 ], [ \"Order\", 1, 2 ], [ \"Order\", 2, 3 ], [ \"Order\", 3, 5 ] ] )\n# input:\nr = [ g1, g2 ]\n# program:\nr[3] = r[1]*r[2]\norder( r[1] ) == 2 || return false\norder( r[2] ) == 3 || return false\norder( r[3] ) == 5 || return false\n# return value:\ntrue\n\njulia> SLProgram(ans)\n#1 =    x     ==>  x\n#2 =    y     ==>  y\n#3 = * #1 #2  ==>  (xy)\nkeep: #1..#3\ntest: order(#1) == 2 || return false\ntest: order(#2) == 3 || return false\ntest: order(#3) == 5 || return false\nreturn: true\n\njulia> d = AtlasSLDecision(\"inp 2\\nchor 1 2\\nchor 2 3\\nmu 1 2 3\\nchor 3 5\")\ninp 2\nchor 1 2\nchor 2 3\nmu 1 2 3\nchor 3 5\n\n376> SLP.evaluate(d, [perm1, perm2])\nfalse\n\njulia> GAPSLDecision(d)\n# input:\nr = [ g1, g2 ]\n# program:\norder( r[1] ) == 2 || return false\norder( r[2] ) == 3 || return false\nr[3] = r[1]*r[2]\norder( r[3] ) == 5 || return false\n# return value:\ntrue\n\njulia> SLProgram(d)\n#1 =    x     ==>  x\n#2 =    y     ==>  y\ntest: order(#1) == 2 || return false\ntest: order(#2) == 3 || return false\n#3 = * #1 #2  ==>  (xy)\nkeep: #1..#3\ntest: order(#3) == 5 || return false\nreturn: true","category":"page"},{"location":"TropicalGeometry/intro/","page":"Introduction","title":"Introduction","text":"CurrentModule = Oscar","category":"page"},{"location":"TropicalGeometry/intro/#Introduction","page":"Introduction","title":"Introduction","text":"","category":"section"},{"location":"TropicalGeometry/intro/","page":"Introduction","title":"Introduction","text":"The tropical geometry part of OSCAR provides functionality for","category":"page"},{"location":"TropicalGeometry/intro/","page":"Introduction","title":"Introduction","text":"tropical min-plus and max-plus semirings,\nmatrices and polynomials thereover,\ntropical varieties, hypersurfaces, curves, and linear spaces.","category":"page"},{"location":"TropicalGeometry/intro/","page":"Introduction","title":"Introduction","text":"General textbooks offering details on theory and algorithms include:","category":"page"},{"location":"TropicalGeometry/intro/","page":"Introduction","title":"Introduction","text":"Maclagan, Sturmfels: Introduction to Tropical Geometry [MS15]\nJoswig: Essentials of Tropical Combinatorics [Jos21]","category":"page"},{"location":"TropicalGeometry/intro/","page":"Introduction","title":"Introduction","text":"Like [MS15], OSCAR follows the min-convention by default and unless specified otherwise.","category":"page"},{"location":"TropicalGeometry/intro/#Contact","page":"Introduction","title":"Contact","text":"","category":"section"},{"location":"TropicalGeometry/intro/","page":"Introduction","title":"Introduction","text":"Please direct questions about this part of OSCAR to:","category":"page"},{"location":"TropicalGeometry/intro/","page":"Introduction","title":"Introduction","text":"Yue Ren.","category":"page"},{"location":"TropicalGeometry/intro/","page":"Introduction","title":"Introduction","text":"You can also ask questions in the OSCAR Slack or raise an issue on github.","category":"page"},{"location":"CommutativeAlgebra/intro/","page":"Introduction","title":"Introduction","text":"CurrentModule = Oscar","category":"page"},{"location":"CommutativeAlgebra/intro/#commutative_algebra","page":"Introduction","title":"Introduction","text":"","category":"section"},{"location":"CommutativeAlgebra/intro/","page":"Introduction","title":"Introduction","text":"The commutative algebra part of OSCAR provides functionality for dealing with","category":"page"},{"location":"CommutativeAlgebra/intro/","page":"Introduction","title":"Introduction","text":"multivariate polynomial rings and their ideals,\nquotients of multivariate polynomial rings modulo ideals and ideals of such quotients,\nlocalizations of the above rings and ideals of such localizations, and \nmodules over all rings above.","category":"page"},{"location":"CommutativeAlgebra/intro/","page":"Introduction","title":"Introduction","text":"We use affine algebra as a synonym for quotient of a multivariate polynomial ring modulo an ideal.","category":"page"},{"location":"CommutativeAlgebra/intro/","page":"Introduction","title":"Introduction","text":"Fundamental to computational commutative algebra is the concept of standard bases. Each such basis is defined relative to a monomial ordering. If this ordering is a well-ordering, a standard basis is also called a Gröbner basis. We refer to the corresponding section in this chapter for details.","category":"page"},{"location":"CommutativeAlgebra/intro/","page":"Introduction","title":"Introduction","text":"note: Note\nEach multivariate polynomial ring in OSCAR comes equipped with a monomial ordering according to which the polynomials are stored and displayed. Independently of this ordering, standard bases can be computed with respect to any monomial ordering: The groebner_basis and standard_basis functions provided by OSCAR allow one to specify the desired monomial ordering as a key word argument. Typically, however, the user does not have to worry about Gröbner (standard) bases: The functions discussed in this chapter compute such bases behind the scenes when needed. Once computed, each such basis is cached for later reuse.","category":"page"},{"location":"CommutativeAlgebra/intro/","page":"Introduction","title":"Introduction","text":"note: Note\nIn Oscar, it is possible to equip multivariate polynomial rings with gradings by finitely presented groups.  Most functions related to multivariate polynomial rings discussed in this chapter apply to both the ungraded and graded case. However, for simplicity of the presentation, in this documentation, the functions are often only illustrated by examples with focus on the former case, but work similarly for homogeneous ideals and graded modules in the latter case.","category":"page"},{"location":"CommutativeAlgebra/intro/","page":"Introduction","title":"Introduction","text":"note: Note\nOur main focus in this chapter is on multivariate polynomial rings over fields (exact fields supported by OSCAR). Where not indicated otherwise, the presented functions also apply to polynomial rings over mathbb Z. ","category":"page"},{"location":"CommutativeAlgebra/intro/","page":"Introduction","title":"Introduction","text":"General textbooks offering details on theory and algorithms include: ","category":"page"},{"location":"CommutativeAlgebra/intro/","page":"Introduction","title":"Introduction","text":"[GP08]\n[DL06]\n[DP13]","category":"page"},{"location":"CommutativeAlgebra/intro/#Contact","page":"Introduction","title":"Contact","text":"","category":"section"},{"location":"CommutativeAlgebra/intro/","page":"Introduction","title":"Introduction","text":"Please direct questions about this part of OSCAR to the following people:","category":"page"},{"location":"CommutativeAlgebra/intro/","page":"Introduction","title":"Introduction","text":"Wolfram Decker.","category":"page"},{"location":"CommutativeAlgebra/intro/","page":"Introduction","title":"Introduction","text":"You can ask questions in the OSCAR Slack.","category":"page"},{"location":"CommutativeAlgebra/intro/","page":"Introduction","title":"Introduction","text":"Alternatively, you can raise an issue on github.","category":"page"},{"location":"CommutativeAlgebra/ModulesOverMultivariateRings/hom_operations/","page":"Operations on Module Maps","title":"Operations on Module Maps","text":"CurrentModule = Oscar","category":"page"},{"location":"CommutativeAlgebra/ModulesOverMultivariateRings/hom_operations/#Operations-on-Module-Maps","page":"Operations on Module Maps","title":"Operations on Module Maps","text":"","category":"section"},{"location":"CommutativeAlgebra/ModulesOverMultivariateRings/hom_operations/","page":"Operations on Module Maps","title":"Operations on Module Maps","text":"If module homomorphisms a and b with codomain(a) === domain(b) are given, then compose(a, b) refers to the composition b circ a. If an isomorphism of modules a is given, then inv(a) refers to its inverse.","category":"page"},{"location":"CommutativeAlgebra/ModulesOverMultivariateRings/hom_operations/","page":"Operations on Module Maps","title":"Operations on Module Maps","text":"hom_product(M::ModuleFP, N::ModuleFP, A::Matrix{<:ModuleFPHom{<:ModuleFP, <:ModuleFP, Nothing}})","category":"page"},{"location":"CommutativeAlgebra/ModulesOverMultivariateRings/hom_operations/#hom_product-Tuple{ModuleFP, ModuleFP, Matrix{<:ModuleFPHom{<:ModuleFP, <:ModuleFP, Nothing}}}","page":"Operations on Module Maps","title":"hom_product","text":"hom_product(M::ModuleFP, N::ModuleFP, A::Matrix{<:ModuleFPHom{<:ModuleFP, <:ModuleFP, Nothing}})\n\nGiven modules M and N which are products with r respective s factors,   say M = prod_i=1^r M_i, N = prod_j=1^s N_j, and given a r times s matrix  A of homomorphisms a_ij  M_i to N_j, return the homomorphism M to N with ij-components a_ij.\n\n\n\n\n\n","category":"method"},{"location":"CommutativeAlgebra/ModulesOverMultivariateRings/hom_operations/","page":"Operations on Module Maps","title":"Operations on Module Maps","text":"hom_tensor(M::ModuleFP, N::ModuleFP, V::Vector{<:ModuleFPHom})","category":"page"},{"location":"CommutativeAlgebra/ModulesOverMultivariateRings/hom_operations/#hom_tensor-Tuple{ModuleFP, ModuleFP, Vector{<:ModuleFPHom}}","page":"Operations on Module Maps","title":"hom_tensor","text":"hom_tensor(M::ModuleFP, N::ModuleFP, V::Vector{<:ModuleFPHom})\n\nGiven modules M, N which are tensor products with the same number of factors, say M = M_1 otimes cdots otimes M_r, N = N_1 otimes cdots otimes N_r, and given a vector V of homomorphisms a_i  M_i to N_i, return  a_1 otimes cdots otimes a_r.\n\n\n\n\n\n","category":"method"},{"location":"CommutativeAlgebra/ModulesOverMultivariateRings/hom_operations/","page":"Operations on Module Maps","title":"Operations on Module Maps","text":"lift_homomorphism_contravariant(Hom_MP::ModuleFP, Hom_NP::ModuleFP, phi:: ModuleFPHom)","category":"page"},{"location":"CommutativeAlgebra/ModulesOverMultivariateRings/hom_operations/#lift_homomorphism_contravariant-Tuple{ModuleFP, ModuleFP, ModuleFPHom}","page":"Operations on Module Maps","title":"lift_homomorphism_contravariant","text":"lift_homomorphism_contravariant(Hom_MP::ModuleFP, Hom_NP::ModuleFP, a::ModuleFPHom)\n\nGiven modules of homomorphism, say, Hom_MP = textHom(MP) and Hom_NP = textHom(NP),  and given a homomorphism a  N to M, return the induced homomorphism textHom(MP) to textHom(NP).\n\n\n\n\n\n","category":"method"},{"location":"CommutativeAlgebra/ModulesOverMultivariateRings/hom_operations/","page":"Operations on Module Maps","title":"Operations on Module Maps","text":"lift_homomorphism_covariant(Hom_PM::ModuleFP, Hom_PN::ModuleFP, phi:: ModuleFPHom)","category":"page"},{"location":"CommutativeAlgebra/ModulesOverMultivariateRings/hom_operations/#lift_homomorphism_covariant-Tuple{ModuleFP, ModuleFP, ModuleFPHom}","page":"Operations on Module Maps","title":"lift_homomorphism_covariant","text":"lift_homomorphism_covariant(Hom_PM::ModuleFP, Hom_PN::ModuleFP, a::ModuleFPHom)\n\nGiven modules of homomorphism, say, Hom_PM = textHom(PM) and Hom_PN = textHom(PN), and given a homomorphism a  M to N, return the induced homomorphism textHom(PM) to textHom(PN).\n\n\n\n\n\n","category":"method"},{"location":"Rings/intro/","page":"Introduction","title":"Introduction","text":"CurrentModule = Oscar\nDocTestSetup = Oscar.doctestsetup()","category":"page"},{"location":"Rings/intro/#rings","page":"Introduction","title":"Introduction","text":"","category":"section"},{"location":"Rings/intro/","page":"Introduction","title":"Introduction","text":"The rings part of OSCAR provides functionality for handling various kinds of rings: ","category":"page"},{"location":"Rings/intro/","page":"Introduction","title":"Introduction","text":"the ring of integers\npolynomial rings (univariate and multivariate, see Generic univariate polynomial types and Generic sparse distributed multivariable polynomial types),\norders in number fields\nseries rings","category":"page"},{"location":"Rings/intro/","page":"Introduction","title":"Introduction","text":"General textbooks offering details on theory and algorithms include:","category":"page"},{"location":"Rings/intro/","page":"Introduction","title":"Introduction","text":"...","category":"page"},{"location":"Rings/intro/#Contact","page":"Introduction","title":"Contact","text":"","category":"section"},{"location":"Rings/intro/","page":"Introduction","title":"Introduction","text":"Please direct questions about this part of OSCAR to the following people:","category":"page"},{"location":"Rings/intro/","page":"Introduction","title":"Introduction","text":"Claus Fieker,\nTommy Hofmann.","category":"page"},{"location":"Rings/intro/","page":"Introduction","title":"Introduction","text":"You can ask questions in the OSCAR Slack.","category":"page"},{"location":"Rings/intro/","page":"Introduction","title":"Introduction","text":"Alternatively, you can raise an issue on github.","category":"page"},{"location":"PolyhedralGeometry/intro/","page":"Introduction","title":"Introduction","text":"CurrentModule = Oscar\nDocTestSetup = Oscar.doctestsetup()","category":"page"},{"location":"PolyhedralGeometry/intro/#Introduction","page":"Introduction","title":"Introduction","text":"","category":"section"},{"location":"PolyhedralGeometry/intro/","page":"Introduction","title":"Introduction","text":"The polyhedral geometry part of OSCAR provides functionality for handling","category":"page"},{"location":"PolyhedralGeometry/intro/","page":"Introduction","title":"Introduction","text":"convex polytopes, unbounded polyhedra and cones\npolyhedral fans\nlinear programs","category":"page"},{"location":"PolyhedralGeometry/intro/","page":"Introduction","title":"Introduction","text":"General textbooks offering details on theory and algorithms include:","category":"page"},{"location":"PolyhedralGeometry/intro/","page":"Introduction","title":"Introduction","text":"[JT13]\n[Zie95]","category":"page"},{"location":"PolyhedralGeometry/intro/#Scalar-types","page":"Introduction","title":"Scalar types","text":"","category":"section"},{"location":"PolyhedralGeometry/intro/","page":"Introduction","title":"Introduction","text":"The objects from polyhedral geometry operate on a given type, which (usually) resembles a field. This is indicated by the template parameter, e.g. the properties of a Polyhedron{QQFieldElem} are rational numbers of type QQFieldElem, if applicable. Supported scalar types are FieldElem and Float64, but some functionality might not work properly if the parent Field does not satisfy certain mathematic conditions, like being ordered. When constructing a polyhedral object from scratch, for the \"simpler\" types QQFieldElem and Float64 it suffices to pass the Type, but more complex FieldElems require a parent Field object. This can be set by either passing the desired Field instead of the type, or by inserting the type and have a matching FieldElem in your input data. If no type or field is given, the scalar type defaults to QQFieldElem.","category":"page"},{"location":"PolyhedralGeometry/intro/","page":"Introduction","title":"Introduction","text":"The parent Field of the coefficients of an object O with coefficients of type T can be retrieved with the coefficient_field function, and it holds elem_type(coefficient_field(O)) == T.","category":"page"},{"location":"PolyhedralGeometry/intro/","page":"Introduction","title":"Introduction","text":"coefficient_field(x::PolyhedralObject)","category":"page"},{"location":"PolyhedralGeometry/intro/#coefficient_field-Tuple{Oscar.PolyhedralObject}","page":"Introduction","title":"coefficient_field","text":"coefficient_field(P::Union{Polyhedron{T}, Cone{T}, PolyhedralFan{T}, PolyhedralComplex{T}) where T<:scalar_types\n\nReturn the parent Field of the coefficients of P.\n\nExamples\n\njulia> c = cross_polytope(2)\nPolytope in ambient dimension 2\n\njulia> coefficient_field(c)\nRational field\n\n\n\n\n\n","category":"method"},{"location":"PolyhedralGeometry/intro/","page":"Introduction","title":"Introduction","text":"warning: Warning\nSupport for fields other than the rational numbers is currently in an experimental stage.","category":"page"},{"location":"PolyhedralGeometry/intro/","page":"Introduction","title":"Introduction","text":"These three lines result in the same polytope over rational numbers. Besides the general support mentioned above, naming a Field explicitly is encouraged because it allows user control and increases efficiency.","category":"page"},{"location":"PolyhedralGeometry/intro/","page":"Introduction","title":"Introduction","text":"julia> P = convex_hull(QQ, [1 0 0; 0 0 1]) # passing a `Field` always works\nPolyhedron in ambient dimension 3\n\njulia> P == convex_hull(QQFieldElem, [1 0 0; 0 0 1]) # passing the type works for `QQFieldElem` and `Float64` only\ntrue\n\njulia> P == convex_hull([1 0 0; 0 0 1]) # `Field` defaults to `QQ`\ntrue\n","category":"page"},{"location":"PolyhedralGeometry/intro/#Type-compatibility","page":"Introduction","title":"Type compatibility","text":"","category":"section"},{"location":"PolyhedralGeometry/intro/","page":"Introduction","title":"Introduction","text":"When working in polyhedral geometry it can prove advantageous to have various input formats for the same kind of re-occurring quantitative input information. This example shows three different ways to write the points whose convex hull is to be computed, all resulting in identical Polyhedron objects:","category":"page"},{"location":"PolyhedralGeometry/intro/","page":"Introduction","title":"Introduction","text":"julia> P = convex_hull([1 0 0; 0 0 1])\nPolyhedron in ambient dimension 3\n\njulia> P == convex_hull([[1, 0, 0], [0, 0, 1]])\ntrue\n\njulia> P == convex_hull(vertices(P))\ntrue","category":"page"},{"location":"PolyhedralGeometry/intro/","page":"Introduction","title":"Introduction","text":"convex_hull is only one of many functions and constructors supporting this behavior, and there are also more types that can be described this way besides PointVector. Whenever the docs state an argument is required to be of type AbstractCollection[ElType] (where ElType is the Oscar type of single instances described in this collection), the user can choose the input to follow any of the corresponding notions below.","category":"page"},{"location":"PolyhedralGeometry/intro/#Vectors","page":"Introduction","title":"Vectors","text":"","category":"section"},{"location":"PolyhedralGeometry/intro/","page":"Introduction","title":"Introduction","text":"There are two specialized Vector-like types, PointVector and RayVector, which commonly are returned by functions from Polyhedral Geometry. These can also be manually constructed:","category":"page"},{"location":"PolyhedralGeometry/intro/","page":"Introduction","title":"Introduction","text":"point_vector\nray_vector","category":"page"},{"location":"PolyhedralGeometry/intro/#point_vector","page":"Introduction","title":"point_vector","text":"point_vector(p = QQ, v::AbstractVector)\n\nReturn a PointVector resembling a point whose coordinates equal the entries of v. p specifies the Field or Type of its coefficients.\n\n\n\n\n\n","category":"function"},{"location":"PolyhedralGeometry/intro/#ray_vector","page":"Introduction","title":"ray_vector","text":"ray_vector(p = QQ, v::AbstractVector)\n\nReturn a RayVector resembling a ray from the origin through the point whose coordinates equal the entries of v. p specifies the Field or Type of its coefficients.\n\n\n\n\n\n","category":"function"},{"location":"PolyhedralGeometry/intro/","page":"Introduction","title":"Introduction","text":"While RayVectors can not be used do describe PointVectors (and vice versa), matrices are generally allowed.","category":"page"},{"location":"PolyhedralGeometry/intro/","page":"Introduction","title":"Introduction","text":"AbstractCollection[PointVector] can be given as:","category":"page"},{"location":"PolyhedralGeometry/intro/","page":"Introduction","title":"Introduction","text":"Type A PointVector corresponds to...\nAbstractVector{<:PointVector} an element of the vector.\nAbstractVector{<:AbstractVector} an element of the vector.\nAbstractMatrix/MatElem a row of the matrix.\nAbstractVector/PointVector the vector itself (only one PointVector is described).\nSubObjectIterator{<:PointVector} an element of the iterator.","category":"page"},{"location":"PolyhedralGeometry/intro/","page":"Introduction","title":"Introduction","text":"AbstractCollection[RayVector] can be given as:","category":"page"},{"location":"PolyhedralGeometry/intro/","page":"Introduction","title":"Introduction","text":"Type A RayVector corresponds to...\nAbstractVector{<:RayVector} an element of the vector.\nAbstractVector{<:AbstractVector} an element of the vector.\nAbstractMatrix/MatElem a row of the matrix.\nAbstractVector/RayVector the vector itself (only one RayVector is described).\nSubObjectIterator{<:RayVector} an element of the iterator.","category":"page"},{"location":"PolyhedralGeometry/intro/#Halfspaces-and-Hyperplanes","page":"Introduction","title":"Halfspaces and Hyperplanes","text":"","category":"section"},{"location":"PolyhedralGeometry/intro/","page":"Introduction","title":"Introduction","text":"Similar to points and rays, there are types AffineHalfspace, LinearHalfspace, AffineHyperplane and LinearHyperplane:","category":"page"},{"location":"PolyhedralGeometry/intro/","page":"Introduction","title":"Introduction","text":"affine_halfspace\nlinear_halfspace\naffine_hyperplane\nlinear_hyperplane","category":"page"},{"location":"PolyhedralGeometry/intro/#affine_halfspace","page":"Introduction","title":"affine_halfspace","text":"affine_halfspace(p = QQ, a, b)\n\nReturn the Oscar.AffineHalfspace H(a,b), which is given by a vector a and a value b such that H(ab) =  x  ax  b  p specifies the Field or Type of its coefficients.\n\n\n\n\n\n","category":"function"},{"location":"PolyhedralGeometry/intro/#linear_halfspace","page":"Introduction","title":"linear_halfspace","text":"linear_halfspace(p = QQ, a, b)\n\nReturn the Oscar.LinearHalfspace H(a), which is given by a vector a such that H(ab) =  x  ax  0  p specifies the Field or Type of its coefficients.\n\n\n\n\n\n","category":"function"},{"location":"PolyhedralGeometry/intro/#affine_hyperplane","page":"Introduction","title":"affine_hyperplane","text":"affine_hyperplane(p = QQ, a, b)\n\nReturn the Oscar.AffineHyperplane H(a,b), which is given by a vector a and a value b such that H(ab) =  x  ax = b  p specifies the Field or Type of its coefficients.\n\n\n\n\n\n","category":"function"},{"location":"PolyhedralGeometry/intro/#linear_hyperplane","page":"Introduction","title":"linear_hyperplane","text":"linear_hyperplane(p = QQ, a, b)\n\nReturn the Oscar.LinearHyperplane H(a), which is given by a vector a such that H(ab) =  x  ax = 0  p specifies the Field or Type of its coefficients.\n\n\n\n\n\n","category":"function"},{"location":"PolyhedralGeometry/intro/","page":"Introduction","title":"Introduction","text":"These collections allow to mix up affine halfspaces/hyperplanes and their linear counterparts, but note that an error will be produced when trying to convert an affine description with bias not equal to zero to a linear description.","category":"page"},{"location":"PolyhedralGeometry/intro/","page":"Introduction","title":"Introduction","text":"AbstractCollection[LinearHalfspace] can be given as:","category":"page"},{"location":"PolyhedralGeometry/intro/","page":"Introduction","title":"Introduction","text":"Type A LinearHalfspace corresponds to...\nAbstractVector{<:Halfspace} an element of the vector.\nAbstractMatrix/MatElem A the halfspace with normal vector A[i, :].\nAbstractVector{<:AbstractVector} A the halfspace with normal vector A[i].\nSubObjectIterator{<:Halfspace} an element of the iterator.","category":"page"},{"location":"PolyhedralGeometry/intro/","page":"Introduction","title":"Introduction","text":"AbstractCollection[LinearHyperplane] can be given as:","category":"page"},{"location":"PolyhedralGeometry/intro/","page":"Introduction","title":"Introduction","text":"Type A LinearHyperplane corresponds to...\nAbstractVector{<:Hyperplane} an element of the vector.\nAbstractMatrix/MatElem A the hyperplane with normal vector A[i, :].\nAbstractVector{<:AbstractVector} A the hyperplane with normal vector A[i].\nSubObjectIterator{<:Hyperplane} an element of the iterator.","category":"page"},{"location":"PolyhedralGeometry/intro/","page":"Introduction","title":"Introduction","text":"AbstractCollection[AffineHalfspace] can be given as:","category":"page"},{"location":"PolyhedralGeometry/intro/","page":"Introduction","title":"Introduction","text":"Type An AffineHalfspace corresponds to...\nAbstractVector{<:Halfspace} an element of the vector.\nTuple over matrix A and vector b the affine halfspace with normal vector A[i, :] and bias b[i].\nSubObjectIterator{<:Halfspace} an element of the iterator.","category":"page"},{"location":"PolyhedralGeometry/intro/","page":"Introduction","title":"Introduction","text":"AbstractCollection[AffineHyperplane] can be given as:","category":"page"},{"location":"PolyhedralGeometry/intro/","page":"Introduction","title":"Introduction","text":"Type An AffineHyperplane corresponds to...\nAbstractVector{<:Hyperplane} an element of the vector.\nTuple over matrix A and vector b the affine hyperplane with normal vector A[i, :] and bias b[i].\nSubObjectIterator{<:Hyperplane} an element of the iterator.","category":"page"},{"location":"PolyhedralGeometry/intro/#IncidenceMatrix","page":"Introduction","title":"IncidenceMatrix","text":"","category":"section"},{"location":"PolyhedralGeometry/intro/","page":"Introduction","title":"Introduction","text":"Some methods will require input or return output in form of an IncidenceMatrix.","category":"page"},{"location":"PolyhedralGeometry/intro/","page":"Introduction","title":"Introduction","text":"IncidenceMatrix","category":"page"},{"location":"PolyhedralGeometry/intro/#IncidenceMatrix","page":"Introduction","title":"IncidenceMatrix","text":"IncidenceMatrix\n\nA matrix with boolean entries. Each row corresponds to a fixed element of a collection of mathematical objects and the same holds for the columns and a second (possibly equal) collection. A 1 at entry (i, j) is interpreted as an incidence between object i of the first collection and object j of the second one.\n\nExamples\n\nNote that the input of this example and the print of an IncidenceMatrix list the non-zero indices for each row.\n\njulia> IM = incidence_matrix([[1,2,3],[4,5,6]])\n2×6 IncidenceMatrix\n[1, 2, 3]\n[4, 5, 6]\n\n\njulia> IM[1, 2]\ntrue\n\njulia> IM[2, 3]\nfalse\n\njulia> IM[:, 4]\n2-element SparseVectorBool\n[2]\n\n\n\n\n\n","category":"type"},{"location":"PolyhedralGeometry/intro/","page":"Introduction","title":"Introduction","text":"The unique nature of the IncidenceMatrix allows for different ways of construction:","category":"page"},{"location":"PolyhedralGeometry/intro/","page":"Introduction","title":"Introduction","text":"incidence_matrix","category":"page"},{"location":"PolyhedralGeometry/intro/#incidence_matrix","page":"Introduction","title":"incidence_matrix","text":"incidence_matrix(r::Base.Integer, c::Base.Integer)\n\nReturn an IncidenceMatrix of size r x c whose entries are all false.\n\nExamples\n\njulia> IM = incidence_matrix(8, 5)\n8×5 IncidenceMatrix\n[]\n[]\n[]\n[]\n[]\n[]\n[]\n[]\n\n\n\n\n\n\nincidence_matrix(mat::Union{AbstractMatrix{Bool}, IncidenceMatrix})\n\nConvert mat to an IncidenceMatrix.\n\nExamples\n\njulia> IM = incidence_matrix([true false true false true false; false true false true false true])\n2×6 IncidenceMatrix\n[1, 3, 5]\n[2, 4, 6]\n\n\n\n\n\n\nincidence_matrix(mat::AbstractMatrix)\n\nConvert the 0/1 matrix mat to an IncidenceMatrix. Entries become true if the initial entry is 1 and false if the initial entry is 0.\n\nExamples\n\njulia> IM = incidence_matrix([1 0 1 0 1 0; 0 1 0 1 0 1])\n2×6 IncidenceMatrix\n[1, 3, 5]\n[2, 4, 6]\n\n\n\n\n\n\nincidence_matrix(r::Base.Integer, c::Base.Integer, incidenceRows::AbstractVector{<:AbstractVector{<:Base.Integer}})\n\nReturn an IncidenceMatrix of size r x c. The i-th element of incidenceRows lists the indices of the true entries of the i-th row.\n\nExamples\n\njulia> IM = incidence_matrix(3, 4, [[2, 3], [1]])\n3×4 IncidenceMatrix\n[2, 3]\n[1]\n[]\n\n\n\n\n\n\nincidence_matrix(incidenceRows::AbstractVector{<:AbstractVector{<:Base.Integer}})\n\nReturn an IncidenceMatrix where the i-th element of incidenceRows lists the indices of the true entries of the i-th row. The dimensions of the result are the smallest possible row and column count that can be deduced from the input.\n\nExamples\n\njulia> IM = incidence_matrix([[2, 3], [1]])\n2×3 IncidenceMatrix\n[2, 3]\n[1]\n\n\n\n\n\n\nincidence_matrix(g::Graph{T}) where {T <: Union{Directed, Undirected}}\n\nReturn an unsigned (boolean) incidence matrix representing a graph g.\n\nExamples\n\njulia> g = Graph{Directed}(5);\n\njulia> add_edge!(g, 1, 3);\n\njulia> add_edge!(g, 3, 4);\n\njulia> incidence_matrix(g)\n5×2 IncidenceMatrix\n[1]\n[]\n[1, 2]\n[2]\n[]\n\n\n\n\n\n","category":"function"},{"location":"PolyhedralGeometry/intro/","page":"Introduction","title":"Introduction","text":"From the examples it can be seen that this type supports julia's matrix functionality. There are also functions to retrieve specific rows or columns as a Set over the non-zero indices.","category":"page"},{"location":"PolyhedralGeometry/intro/","page":"Introduction","title":"Introduction","text":"row(i::IncidenceMatrix, n::Int)\ncolumn(i::IncidenceMatrix, n::Int)","category":"page"},{"location":"PolyhedralGeometry/intro/#row-Tuple{IncidenceMatrix, Int64}","page":"Introduction","title":"row","text":"row(i::IncidenceMatrix, n::Int)\n\nReturn the indices where the n-th row of i is true, as a Set{Int}.\n\nExamples\n\njulia> IM = incidence_matrix([[1,2,3],[4,5,6]])\n2×6 IncidenceMatrix\n[1, 2, 3]\n[4, 5, 6]\n\n\njulia> row(IM, 2)\nSet{Int64} with 3 elements:\n  5\n  4\n  6\n\n\n\n\n\n","category":"method"},{"location":"PolyhedralGeometry/intro/#column-Tuple{IncidenceMatrix, Int64}","page":"Introduction","title":"column","text":"column(i::IncidenceMatrix, n::Int)\n\nReturn the indices where the n-th column of i is true, as a Set{Int}.\n\nExamples\n\njulia> IM = incidence_matrix([[1,2,3],[4,5,6]])\n2×6 IncidenceMatrix\n[1, 2, 3]\n[4, 5, 6]\n\n\njulia> column(IM, 5)\nSet{Int64} with 1 element:\n  2\n\n\n\n\n\n","category":"method"},{"location":"PolyhedralGeometry/intro/","page":"Introduction","title":"Introduction","text":"A typical application is the assignment of rays to the cones of a polyhedral fan for its construction, see polyhedral_fan.","category":"page"},{"location":"PolyhedralGeometry/intro/#Visualization","page":"Introduction","title":"Visualization","text":"","category":"section"},{"location":"PolyhedralGeometry/intro/","page":"Introduction","title":"Introduction","text":"Lower dimensional polyhedral objects can be visualized through polymake's backend.","category":"page"},{"location":"PolyhedralGeometry/intro/","page":"Introduction","title":"Introduction","text":"visualize(P::Union{Polyhedron{<:Union{Float64,FieldElem}}, Cone{<:Union{Float64,FieldElem}}, PolyhedralFan{<:Union{Float64,FieldElem}}, PolyhedralComplex{<:Union{Float64,FieldElem}}, SubdivisionOfPoints{<:Union{Float64,FieldElem}}, Graph, SimplicialComplex}; kwargs...)","category":"page"},{"location":"PolyhedralGeometry/intro/#visualize-Tuple{Union{SimplicialComplex, Cone{<:Union{Float64, FieldElem}}, Graph, PolyhedralComplex{<:Union{Float64, FieldElem}}, PolyhedralFan{<:Union{Float64, FieldElem}}, Polyhedron, SubdivisionOfPoints{<:Union{Float64, FieldElem}}}}","page":"Introduction","title":"visualize","text":"visualize(P::Union{Polyhedron{T}, Cone{T}, PolyhedralFan{T}, PolyhedralComplex{T}, SubdivisionOfPoints{T}}; kwargs...) where T<:Union{FieldElem, Float64}\n\nVisualize a polyhedral object of dimension at most four (in 3-space). In dimensions up to 3 a usual embedding is shown. Four-dimensional polytopes are visualized as a Schlegel diagram, which is a projection onto one of the facets; e.g., see Chapter 5 of [Zie95].\n\nIn higher dimensions there is no standard method; use projections to lower dimensions or try ideas from [GJRW10].\n\nExtended help\n\nKeyword Arguments\n\nColors\n\nColors can be given as\n\na literal String, e.g. \"green\".\na String of the format \"r g b\" where r g b in 0 dots 255 are integers corresponding to the R/G/B values of the color.\na String of the format \"r g b\" where r g b in 0 1 are decimal values corresponding to the R/G/B values of the color.\n\nPossible arguments are:\n\nFacetColor: Filling color of the polygons.\nEdgeColor: Color of the boundary lines.\nPointColor/VertexColor: Color of the spheres or rectangles representing the points.\n\nScaling and other gradient properties\n\nThese arguments can be given as a floating point number:\n\nFacetTransparency: Transparency factor of the polygons between 0 (opaque) and 1 (completely translucent).\nEdgeThickness: Scaling factor for the thickness of the boundary lines.\nPointThickness/VertexThickness`: Scaling factor for the size of the spheres or rectangles representing the points.\n\nCamera\n\nThese arguments can be given as a 3-element vector over floating point numbers:\n\nViewPoint: Position of the camera.\nViewDirection: Direction of the camera.\n\nAppearance and Texts\n\nThese arguments can be given as a string:\n\nFacetStyle: If set to \"hidden\", the inner area of the polygons are not rendered at all.\nFacetLabels: If set to \"hidden\", the facet labels are not displayed (in the most cases this is the default behavior). TODO\nEdgeStyle: If set to \"hidden\", the boundary lines are not rendered.\nName: The name of this visual object in the drawing.\nPointLabels/VertexLabels: If set to \"hidden\", no point labels are displayed.\nPointStyle/VertexStyle: If set to \"hidden\", neither point nor its label is rendered.\nLabelAlignment: Defines the alignment of the vertex labels: \"left\", \"right\" or \"center\".\n\n\n\n\n\n","category":"method"},{"location":"PolyhedralGeometry/intro/#Serialization","page":"Introduction","title":"Serialization","text":"","category":"section"},{"location":"PolyhedralGeometry/intro/","page":"Introduction","title":"Introduction","text":"Most objects from the polyhedral geometry section can be saved through the polymake interface in the background. These functions are documented in the subsections on the different objects. The format of the files is JSON and you can find details of the specification here.","category":"page"},{"location":"PolyhedralGeometry/intro/","page":"Introduction","title":"Introduction","text":"More details on the serialization, albeit concerning the older XML format, can be found in [GHJ16]. Even though the underlying format changed to JSON, the abstract mathematical structure of the data files is still the same.","category":"page"},{"location":"PolyhedralGeometry/intro/#Contact","page":"Introduction","title":"Contact","text":"","category":"section"},{"location":"PolyhedralGeometry/intro/","page":"Introduction","title":"Introduction","text":"Please direct questions about this part of OSCAR to the following people:","category":"page"},{"location":"PolyhedralGeometry/intro/","page":"Introduction","title":"Introduction","text":"Taylor Brysiewicz,\nMichael Joswig,\nLars Kastner,\nBenjamin Lorenz.","category":"page"},{"location":"PolyhedralGeometry/intro/","page":"Introduction","title":"Introduction","text":"You can ask questions in the OSCAR Slack.","category":"page"},{"location":"PolyhedralGeometry/intro/","page":"Introduction","title":"Introduction","text":"Alternatively, you can raise an issue on github.","category":"page"},{"location":"PolyhedralGeometry/subdivisions_of_points/","page":"Subdivisions of Points","title":"Subdivisions of Points","text":"CurrentModule = Oscar\nDocTestSetup = Oscar.doctestsetup()","category":"page"},{"location":"PolyhedralGeometry/subdivisions_of_points/#Subdivisions-of-Points","page":"Subdivisions of Points","title":"Subdivisions of Points","text":"","category":"section"},{"location":"PolyhedralGeometry/subdivisions_of_points/#Introduction","page":"Subdivisions of Points","title":"Introduction","text":"","category":"section"},{"location":"PolyhedralGeometry/subdivisions_of_points/","page":"Subdivisions of Points","title":"Subdivisions of Points","text":"Let mathbbF be an ordered field; the default is that mathbbF=mathbbQ is the field of rational numbers and other fields are not yet supported everywhere in the implementation.","category":"page"},{"location":"PolyhedralGeometry/subdivisions_of_points/","page":"Subdivisions of Points","title":"Subdivisions of Points","text":"A subdivision of points consists of","category":"page"},{"location":"PolyhedralGeometry/subdivisions_of_points/","page":"Subdivisions of Points","title":"Subdivisions of Points","text":"a finite set mathcalPsubseteqmathbbF^n of points; and\na finite set of cells mathcalSsubseteq 2^mathcalP.","category":"page"},{"location":"PolyhedralGeometry/subdivisions_of_points/","page":"Subdivisions of Points","title":"Subdivisions of Points","text":"The cells are only allowed to intersect in common faces. In contrast to the maximal cones of a polyhedral fan or the maximal polytopes of a polyhedral complex, cells are allowed to have interior points here, i.e. they are not given in terms of their vertices.","category":"page"},{"location":"PolyhedralGeometry/subdivisions_of_points/#Construction","page":"Subdivisions of Points","title":"Construction","text":"","category":"section"},{"location":"PolyhedralGeometry/subdivisions_of_points/","page":"Subdivisions of Points","title":"Subdivisions of Points","text":"There are two ways to construct a subdivision of points. First, one can specify the cells directly. Second, one can assign a weight or height to every point, take the convex hull and take the cells corresponding to facets visible from below (\"lower envelope\"). Not every subdivision of points comes from a weight vector, but if it does, it is called regular.","category":"page"},{"location":"PolyhedralGeometry/subdivisions_of_points/","page":"Subdivisions of Points","title":"Subdivisions of Points","text":"subdivision_of_points(::Oscar.scalar_type_or_field, Points::Union{Oscar.MatElem,AbstractMatrix}, Incidence::IncidenceMatrix)\nsubdivision_of_points(::Oscar.scalar_type_or_field, Points::Union{Oscar.MatElem,AbstractMatrix}, Weights::AbstractVector)","category":"page"},{"location":"PolyhedralGeometry/subdivisions_of_points/#subdivision_of_points-Tuple{Union{Field, Type{<:Union{Float64, FieldElem}}}, Union{MatElem, AbstractMatrix}, IncidenceMatrix}","page":"Subdivisions of Points","title":"subdivision_of_points","text":"subdivision_of_points([f = QQFieldElem,] points, cells)\n\nArguments\n\nf::Union{Type{T}, Field}: either specifies the Type of its coefficients or their\n\nparent Field.\n\npoints::AbstractCollection[PointVector]: Points generating the cells of the subdivision; encoded row-wise as representative vectors.\ncells::IncidenceMatrix: An incidence matrix; there is a 1 at position (i,j) if cell i contains point j, and 0 otherwise.\n\nA subdivision of points formed from points and cells made of these points. The cells are given as an IncidenceMatrix, where the columns represent the points and the rows represent the cells.\n\nwarning: Warning\nIt is required, but not checked, that the cells cover the convex hull of the points. Likewise it is not checked that the cells form a proper polyhedral complex.\n\nExamples\n\nThe following is the famous \"mother of all examples\" (MOAE) non-regular triangulation.\n\njulia> moaepts = [4 0 0; 0 4 0; 0 0 4; 2 1 1; 1 2 1; 1 1 2];\n\njulia> moaeimnonreg0 = incidence_matrix([[4,5,6],[1,4,2],[2,4,5],[2,3,5],[3,5,6],[1,3,6],[1,4,6]]);\n\njulia> MOAE = subdivision_of_points(moaepts, moaeimnonreg0)\nSubdivision of points in ambient dimension 3\n\n\n\n\n\n","category":"method"},{"location":"PolyhedralGeometry/subdivisions_of_points/#subdivision_of_points-Tuple{Union{Field, Type{<:Union{Float64, FieldElem}}}, Union{MatElem, AbstractMatrix}, AbstractVector}","page":"Subdivisions of Points","title":"subdivision_of_points","text":"subdivision_of_points([f = QQFieldElem,] points, weights)\n\nArguments\n\nf::Union{Type{T}, Field}: either specifies the Type of its coefficients or their\n\nparent Field.\n\npoints::AbstractCollection[PointVector]: Points generating the cells of the subdivision; encoded row-wise as representative vectors.\nweights::AbstractVector: A vector with one entry for every point indicating the height of this point.\n\nA subdivision of points formed by placing every point at the corresponding height, then taking the convex hull and then only considering those cells corresponding to faces visible from below (\"lower envelope\").\n\nExamples\n\nWe use the MOAE points, but give a weight vector instead of cells:\n\njulia> moaepts = [4 0 0; 0 4 0; 0 0 4; 2 1 1; 1 2 1; 1 1 2];\n\njulia> SOP = subdivision_of_points(moaepts, [1,1,1,1,1,1])\nSubdivision of points in ambient dimension 3\n\njulia> n_maximal_cells(SOP)\n1\n\n\n\n\n\n","category":"method"},{"location":"PolyhedralGeometry/subdivisions_of_points/","page":"Subdivisions of Points","title":"Subdivisions of Points","text":"From a subdivision of points one can construct the secondary_cone(SOP::SubdivisionOfPoints), i.e. the cone that is the closure of the set of all weight vectors realizing that subdivision.","category":"page"},{"location":"PolyhedralGeometry/subdivisions_of_points/#Auxiliary-functions","page":"Subdivisions of Points","title":"Auxiliary functions","text":"","category":"section"},{"location":"PolyhedralGeometry/subdivisions_of_points/","page":"Subdivisions of Points","title":"Subdivisions of Points","text":"ambient_dim(SOP::SubdivisionOfPoints)\nis_regular(SOP::SubdivisionOfPoints)\nmaximal_cells\nmin_weights\nn_maximal_cells(SOP::SubdivisionOfPoints)\npoints(SOP::SubdivisionOfPoints{T}) where T<:scalar_types\nsecondary_cone","category":"page"},{"location":"PolyhedralGeometry/subdivisions_of_points/#ambient_dim-Tuple{SubdivisionOfPoints}","page":"Subdivisions of Points","title":"ambient_dim","text":"ambient_dim(SOP::SubdivisionOfPoints)\n\nReturn the ambient dimension SOP, which is the dimension of the embedding space.\n\nExamples\n\nThe ambient dimension of the MOAE is 3, independent of the subdivision chosen.\n\njulia> moaepts = [4 0 0; 0 4 0; 0 0 4; 2 1 1; 1 2 1; 1 1 2];\n\njulia> SOP = subdivision_of_points(moaepts, [1,1,1,1,1,1]);\n\njulia> ambient_dim(SOP)\n3\n\n\n\n\n\n","category":"method"},{"location":"PolyhedralGeometry/subdivisions_of_points/#is_regular-Tuple{SubdivisionOfPoints}","page":"Subdivisions of Points","title":"is_regular","text":"is_regular(SOP::SubdivisionOfPoints)\n\nDetermine whether SOP is regular, i.e. can be given via a height function.\n\nExamples\n\nThis is the so-called \"mother of all examples\", a very famous non-regular triangulation of six points.\n\njulia> moaepts = [4 0 0; 0 4 0; 0 0 4; 2 1 1; 1 2 1; 1 1 2];\n\njulia> moaeimnonreg0 = incidence_matrix([[4,5,6],[1,4,2],[2,4,5],[2,3,5],[3,5,6],[1,3,6],[1,4,6]]);\n\njulia> MOAE = subdivision_of_points(moaepts, moaeimnonreg0);\n\njulia> is_regular(MOAE)\nfalse\n\njulia> SOP = subdivision_of_points(moaepts, [1,1,1,1,1,1]);\n\njulia> is_regular(SOP)\ntrue\n\n\n\n\n\n","category":"method"},{"location":"PolyhedralGeometry/subdivisions_of_points/#maximal_cells","page":"Subdivisions of Points","title":"maximal_cells","text":"maximal_cells(SOP::SubdivisionOfPoints)\n\nReturn an iterator over the maximal cells of SOP.\n\nOptionally IncidenceMatrix can be passed as a first argument to return the incidence matrix specifying the maximal cells of SOP.\n\nExamples\n\nDisplay the cells of the \"mother of all examples\" non-regular triangulation.\n\njulia> moaepts = [4 0 0; 0 4 0; 0 0 4; 2 1 1; 1 2 1; 1 1 2]\n6×3 Matrix{Int64}:\n 4  0  0\n 0  4  0\n 0  0  4\n 2  1  1\n 1  2  1\n 1  1  2\n\njulia> moaeimnonreg0 = incidence_matrix([[4,5,6],[1,4,2],[2,4,5],[2,3,5],[3,5,6],[1,3,6],[1,4,6]])\n7×6 IncidenceMatrix\n[4, 5, 6]\n[1, 2, 4]\n[2, 4, 5]\n[2, 3, 5]\n[3, 5, 6]\n[1, 3, 6]\n[1, 4, 6]\n\n\njulia> MOAE = subdivision_of_points(moaepts, moaeimnonreg0);\n\njulia> maximal_cells(MOAE)\n7-element SubObjectIterator{Vector{Int64}}:\n [4, 5, 6]\n [1, 2, 4]\n [2, 4, 5]\n [2, 3, 5]\n [3, 5, 6]\n [1, 3, 6]\n [1, 4, 6]\n\njulia> maximal_cells(IncidenceMatrix, MOAE)\n7×6 IncidenceMatrix\n[4, 5, 6]\n[1, 2, 4]\n[2, 4, 5]\n[2, 3, 5]\n[3, 5, 6]\n[1, 3, 6]\n[1, 4, 6]\n\n\n\n\n\nmaximal_cells(IncidenceMatrix, SOP::SubdivisionOfPoints)\n\nReturn the maximal cells of SOP as an incidence matrix.\n\nThe rows of the output correspond to the maximal cells and the columns correspond to the cells.\n\nExamples\n\nIf we give all points the same weight there is only one cell containing all points.\n\njulia> moaepts = [4 0 0; 0 4 0; 0 0 4; 2 1 1; 1 2 1; 1 1 2]\n6×3 Matrix{Int64}:\n 4  0  0\n 0  4  0\n 0  0  4\n 2  1  1\n 1  2  1\n 1  1  2\n\njulia> SOP = subdivision_of_points(moaepts, [1,1,1,1,1,1])\nSubdivision of points in ambient dimension 3\n\njulia> maximal_cells(IncidenceMatrix, SOP)\n1×6 IncidenceMatrix\n[1, 2, 3, 4, 5, 6]\n\n\n\n\n\n","category":"function"},{"location":"PolyhedralGeometry/subdivisions_of_points/#min_weights","page":"Subdivisions of Points","title":"min_weights","text":"min_weights(SOP::SubdivisionOfPoints)\n\nReturn the minimal weights inducing a subdivision of points. This method will give an error if the input subdivision is non-regular.\n\nExamples\n\nIf all points have the same weight, then the 0-vector is minimal.\n\njulia> moaepts = [4 0 0; 0 4 0; 0 0 4; 2 1 1; 1 2 1; 1 1 2];\n\njulia> SOP = subdivision_of_points(moaepts, [1,1,1,1,1,1]);\n\njulia> min_weights(SOP)\n6-element Vector{Int64}:\n 0\n 0\n 0\n 0\n 0\n 0\n\n\n\n\n\n","category":"function"},{"location":"PolyhedralGeometry/subdivisions_of_points/#n_maximal_cells-Tuple{SubdivisionOfPoints}","page":"Subdivisions of Points","title":"n_maximal_cells","text":"n_maximal_cells(SOP::SubdivisionOfPoints)\n\nReturn the number of maximal cells of SOP.\n\nExamples\n\nIf all points have the same weight, there is only one cell.\n\njulia> moaepts = [4 0 0; 0 4 0; 0 0 4; 2 1 1; 1 2 1; 1 1 2];\n\njulia> SOP = subdivision_of_points(moaepts, [1,1,1,1,1,1]);\n\njulia> n_maximal_cells(SOP)\n1\n\n\n\n\n\n","category":"method"},{"location":"PolyhedralGeometry/subdivisions_of_points/#points-Union{Tuple{SubdivisionOfPoints{T}}, Tuple{T}} where T<:Union{Float64, FieldElem}","page":"Subdivisions of Points","title":"points","text":"points(SOP::SubdivisionOfPoints)\n\nReturn the points of the subdivision of points, SOP.\n\nExamples\n\nDisplay the points of the \"mother of all examples\" non-regular triangulation.\n\njulia> moaepts = [4 0 0; 0 4 0; 0 0 4; 2 1 1; 1 2 1; 1 1 2];\n\njulia> moaeimnonreg0 = incidence_matrix([[4,5,6],[1,4,2],[2,4,5],[2,3,5],[3,5,6],[1,3,6],[1,4,6]]);\n\njulia> MOAE = subdivision_of_points(moaepts, moaeimnonreg0);\n\njulia> points(MOAE)\n6-element SubObjectIterator{PointVector{QQFieldElem}}:\n [4, 0, 0]\n [0, 4, 0]\n [0, 0, 4]\n [2, 1, 1]\n [1, 2, 1]\n [1, 1, 2]\n\n\n\n\n\n","category":"method"},{"location":"PolyhedralGeometry/subdivisions_of_points/#secondary_cone","page":"Subdivisions of Points","title":"secondary_cone","text":"secondary_cone(SOP::SubdivisionOfPoints)\n\nReturn the secondary cone of a subdivision of points, the closure of all the weight vectors inducing the given subdivision of points.\n\nExamples\n\nFor a non-regular subdivision, the secondary cone can still contain non-trivial weights, but it will not be full-dimensional.\n\njulia> moaepts = [4 0 0; 0 4 0; 0 0 4; 2 1 1; 1 2 1; 1 1 2];\n\njulia> moaeimnonreg0 = incidence_matrix([[4,5,6],[1,4,2],[2,4,5],[2,3,5],[3,5,6],[1,3,6],[1,4,6]]);\n\njulia> MOAE = subdivision_of_points(moaepts, moaeimnonreg0)\nSubdivision of points in ambient dimension 3\n\njulia> C = secondary_cone(MOAE)\nPolyhedral cone in ambient dimension 6\n\njulia> dim(C)\n4\n\n\n\n\n\n","category":"function"},{"location":"Rings/rational/","page":"Rationals","title":"Rationals","text":"CurrentModule = Oscar\nDocTestSetup = Oscar.doctestsetup()","category":"page"},{"location":"Rings/rational/#Rationals","page":"Rationals","title":"Rationals","text":"","category":"section"},{"location":"Rings/rational/","page":"Rationals","title":"Rationals","text":"Fractions are created in Julia with the double slash operator //. If a fraction is created from Julia integers, a Julia fraction results, and if either the numerator or denominator is an OSCAR integer of type ZZRingElem, an OSCAR fraction of type QQFieldElem results.","category":"page"},{"location":"Rings/rational/","page":"Rationals","title":"Rationals","text":"Julia has its own parameterised type Rational{T} for its own fractions, where T is the integer type of the numerator and denominator, e.g. Rational{Int} and Rational{BigInt}. Unlike with Int, all of the basic arithmetic operations on Julia's Rational{Int} are checked for overflow in the numerator and denominator.","category":"page"},{"location":"Rings/rational/#The-field-of-rationals","page":"Rationals","title":"The field of rationals","text":"","category":"section"},{"location":"Rings/rational/","page":"Rationals","title":"Rationals","text":"The parent of an OSCAR rational number is the field of rationals. It can be constructed from the ring of integers ZZ using the fraction_field constructor.","category":"page"},{"location":"Rings/rational/","page":"Rationals","title":"Rationals","text":"For convenience, QQ is already defined to be the field of rational numbers.","category":"page"},{"location":"Rings/rational/","page":"Rationals","title":"Rationals","text":"julia> S = fraction_field(ZZ)\nRational field\n\njulia> QQ\nRational field\n","category":"page"},{"location":"Rings/rational/#Integer-constructors","page":"Rationals","title":"Integer constructors","text":"","category":"section"},{"location":"Rings/rational/","page":"Rationals","title":"Rationals","text":"OSCAR rationals can be created using QQ. Two arguments can be passed to specify numerator and denominator. If a single argument is passed, the denominator is set to 1.","category":"page"},{"location":"Rings/rational/","page":"Rationals","title":"Rationals","text":"For convenience, QQ also accepts Julia integers and rationals, but will always construct an OSCAR rational.","category":"page"},{"location":"Rings/rational/","page":"Rationals","title":"Rationals","text":"Naturally, Julia's double slash operator can also be used to construct fractions. However, unlike QQ, the double slash operator only constructs an OSCAR rational if either the numerator or denominator is an OSCAR integer.","category":"page"},{"location":"Rings/rational/","page":"Rationals","title":"Rationals","text":"An exception is raised if a fraction is constructed with denominator zero.","category":"page"},{"location":"Rings/rational/","page":"Rationals","title":"Rationals","text":"julia> QQ(1, 2)\n1//2\n\njulia> QQ(5)\n5\n\njulia> ZZ(3)//5\n3//5\n\njulia> 1//ZZ(7)\n1//7\n\njulia> QQ(2//3)\n2//3\n\njulia> ZZ(3)//0\nERROR: DivideError: integer division error\n","category":"page"},{"location":"Rings/rational/","page":"Rationals","title":"Rationals","text":"One can also construct the rational number 0 with the empty constructor:","category":"page"},{"location":"Rings/rational/","page":"Rationals","title":"Rationals","text":"julia> QQ()\n0\n","category":"page"},{"location":"Rings/rational/","page":"Rationals","title":"Rationals","text":"The following special constructors are also provided:","category":"page"},{"location":"Rings/rational/","page":"Rationals","title":"Rationals","text":"zero(QQ)\none(QQ)","category":"page"},{"location":"Rings/rational/","page":"Rationals","title":"Rationals","text":"julia> zero(QQ)\n0\n\njulia> one(QQ)\n1\n","category":"page"},{"location":"Rings/rational/#Predicates","page":"Rationals","title":"Predicates","text":"","category":"section"},{"location":"Rings/rational/","page":"Rationals","title":"Rationals","text":"iszero(n::QQFieldElem) -> Bool\nisone(n::QQFieldElem) -> Bool\nis_unit(n::QQFieldElem) -> Bool","category":"page"},{"location":"Rings/rational/","page":"Rationals","title":"Rationals","text":"The is_unit function will return true iff n neq 0.","category":"page"},{"location":"Rings/rational/","page":"Rationals","title":"Rationals","text":"julia> iszero(QQ())\ntrue\n\njulia> isone(one(QQ))\ntrue\n\njulia> is_unit(QQ(-2, 3))\ntrue\n","category":"page"},{"location":"Rings/rational/#Properties","page":"Rationals","title":"Properties","text":"","category":"section"},{"location":"Rings/rational/","page":"Rationals","title":"Rationals","text":"numerator(n::QQFieldElem) -> ZZRingElem\ndenominator(n::QQFieldElem) -> ZZRingElem","category":"page"},{"location":"Rings/rational/","page":"Rationals","title":"Rationals","text":"Return the numerator and denominator respectively, of n.","category":"page"},{"location":"Rings/rational/","page":"Rationals","title":"Rationals","text":"sign(n::QQFieldElem) -> QQFieldElem","category":"page"},{"location":"Rings/rational/","page":"Rationals","title":"Rationals","text":"Return the sign of n, i.e. nn if n neq 0, or 0 otherwise.","category":"page"},{"location":"Rings/rational/","page":"Rationals","title":"Rationals","text":"julia> sign(QQ(2, 3))\n1\n\njulia> sign(QQ())\n0\n\njulia> sign(QQ(-1))\n-1\n","category":"page"},{"location":"Rings/rational/","page":"Rationals","title":"Rationals","text":"abs(n::QQFieldElem) -> QQFieldElem","category":"page"},{"location":"Rings/rational/","page":"Rationals","title":"Rationals","text":"Return the absolute value of n, i.e. n if n geq 0 and -n otherwise.","category":"page"},{"location":"Rings/rational/","page":"Rationals","title":"Rationals","text":"julia> abs(QQ(-3, 2))\n3//2\n","category":"page"},{"location":"Rings/rational/","page":"Rationals","title":"Rationals","text":"height(n::QQFieldElem) -> ZZRingElem","category":"page"},{"location":"Rings/rational/","page":"Rationals","title":"Rationals","text":"Return the maximum of the absolute values of the numerator and denominator of n.","category":"page"},{"location":"Rings/rational/","page":"Rationals","title":"Rationals","text":"julia> height(QQ(324987329, -8372492324))\n8372492324\n","category":"page"},{"location":"Rings/rational/","page":"Rationals","title":"Rationals","text":"floor(n::QQFieldElem) -> QQFieldElem","category":"page"},{"location":"Rings/rational/","page":"Rationals","title":"Rationals","text":"Return the greatest integer m (as a rational number) such that m leq n.","category":"page"},{"location":"Rings/rational/","page":"Rationals","title":"Rationals","text":"ceil(n::QQFieldElem) -> QQFieldElem","category":"page"},{"location":"Rings/rational/","page":"Rationals","title":"Rationals","text":"Return the least integer m (as a rational number) such that m geq n.","category":"page"},{"location":"Rings/rational/","page":"Rationals","title":"Rationals","text":"julia> floor(QQ(-2, 3))\n-1\n\njulia> ceil(QQ(7, 2))\n4\n\njulia> typeof(ans)\nQQFieldElem\n\njulia> ceil(QQ(5))\n5\n","category":"page"},{"location":"Rings/rational/","page":"Rationals","title":"Rationals","text":"floor(ZZRingElem, n::QQFieldElem) -> ZZRingElem","category":"page"},{"location":"Rings/rational/","page":"Rationals","title":"Rationals","text":"Return the greatest integer m such that m leq n.","category":"page"},{"location":"Rings/rational/","page":"Rationals","title":"Rationals","text":"ceil(ZZRingElem, n::QQFieldElem) -> ZZRingElem","category":"page"},{"location":"Rings/rational/","page":"Rationals","title":"Rationals","text":"Return the least integer m such that m geq n.","category":"page"},{"location":"Rings/rational/","page":"Rationals","title":"Rationals","text":"julia> floor(ZZRingElem, QQ(-2, 3))\n-1\n\njulia> ceil(ZZRingElem, QQ(7, 2))\n4\n\njulia> typeof(ans)\nZZRingElem\n\njulia> ceil(ZZRingElem, QQ(5))\n5\n","category":"page"},{"location":"Rings/rational/#Basic-arithmetic","page":"Rationals","title":"Basic arithmetic","text":"","category":"section"},{"location":"Rings/rational/","page":"Rationals","title":"Rationals","text":"OSCAR provides the basic arithmetic operations +, - and * and comparison operators ==, !=, <, <=, >, >=, including mixed operations between Julia and OSCAR rationals and integers.","category":"page"},{"location":"Rings/rational/#[Exact-Division]","page":"Rationals","title":"[Exact Division]","text":"","category":"section"},{"location":"Rings/rational/","page":"Rationals","title":"Rationals","text":"divexact(a::QQFieldElem, b::QQFieldElem) -> QQFieldElem\ndivexact(a::QQFieldElem, b::Union{ZZRingElem,Base.Integer,Base.Rational}) -> QQFieldElem\ndivexact(a::Union{ZZRingElem,Base.Integer,Base.Rational}, b::QQFieldElem) -> QQFieldElem","category":"page"},{"location":"Rings/rational/","page":"Rationals","title":"Rationals","text":"Return the quotient of a by b. Exact division raises an exception if division by zero is attempted.","category":"page"},{"location":"Rings/rational/","page":"Rationals","title":"Rationals","text":"julia> divexact(QQ(2, 3), QQ(3, 5))\n10//9\n\njulia> divexact(QQ(1, 3), ZZ(0))\nERROR: DivideError: integer division error\n\njulia> divexact(QQ(3, 4), ZZ(5))\n3//20\n\njulia> divexact(ZZ(6), QQ(2, 3))\n9\n\njulia> divexact(QQ(1, 3), 5)\n1//15\n","category":"page"},{"location":"Rings/rational/#Powering","page":"Rationals","title":"Powering","text":"","category":"section"},{"location":"Rings/rational/","page":"Rationals","title":"Rationals","text":"^(a::QQFieldElem, b::Int) -> QQFieldElem","category":"page"},{"location":"Rings/rational/","page":"Rationals","title":"Rationals","text":"Return the result of powering a by b.","category":"page"},{"location":"Rings/rational/","page":"Rationals","title":"Rationals","text":"julia> QQ(5, 7)^32\n23283064365386962890625//1104427674243920646305299201\n\njulia> QQ(1, 2)^(-2)\n4\n","category":"page"},{"location":"Rings/rational/","page":"Rationals","title":"Rationals","text":"The following is allowed for convenience.","category":"page"},{"location":"Rings/rational/","page":"Rationals","title":"Rationals","text":"julia> QQ(0)^0\n1\n","category":"page"},{"location":"Rings/rational/","page":"Rationals","title":"Rationals","text":"note: Note\nIn Julia, the rational number 01 when raised to a negative power returns 10 to indicate that the value is undefined. OSCAR raises an exception.","category":"page"},{"location":"Rings/rational/","page":"Rationals","title":"Rationals","text":"julia> QQ(0)^-2\nERROR: DivideError: integer division error\n","category":"page"},{"location":"Rings/rational/","page":"Rationals","title":"Rationals","text":"is_power(a::QQFieldElem, b::Int) -> Bool, QQFieldElem","category":"page"},{"location":"Rings/rational/","page":"Rationals","title":"Rationals","text":"Test if a is an n-th power. If so, return true and the root, false and any rational otherwise.","category":"page"},{"location":"Rings/rational/","page":"Rationals","title":"Rationals","text":"is_perfect_power_with_data(a::QQFieldElem) -> Int, QQFieldElem","category":"page"},{"location":"Rings/rational/","page":"Rationals","title":"Rationals","text":"Find the largest n such that a is an n-th power. Return n and the root.","category":"page"},{"location":"Rings/rational/","page":"Rationals","title":"Rationals","text":"root(a::QQFieldElem, b::Int) -> QQFieldElem","category":"page"},{"location":"Rings/rational/","page":"Rationals","title":"Rationals","text":"Compute an n-th root of a, raises an error if a is not an n-th power.","category":"page"},{"location":"Rings/rational/","page":"Rationals","title":"Rationals","text":"julia> is_power(QQ(8), 3)\n(true, 2)\n\njulia> is_power(QQ(8), 2)\n(false, 8)\n\njulia> is_perfect_power_with_data(QQ(9//16))\n(2, 3//4)\n\njulia> root(QQ(25//9), 2)\n5//3\n","category":"page"},{"location":"AlgebraicGeometry/Surfaces/K3Surfaces/","page":"Automorphism Groups of  K3 surfaces","title":"Automorphism Groups of  K3 surfaces","text":"CurrentModule = Oscar","category":"page"},{"location":"AlgebraicGeometry/Surfaces/K3Surfaces/#Automorphism-Groups-of-K3-surfaces","page":"Automorphism Groups of  K3 surfaces","title":"Automorphism Groups of  K3 surfaces","text":"","category":"section"},{"location":"AlgebraicGeometry/Surfaces/K3Surfaces/","page":"Automorphism Groups of  K3 surfaces","title":"Automorphism Groups of  K3 surfaces","text":"A complex K3 surface is a compact complex surface X with vanishing irregularity h^1(X mathcalO_X)=0 and trivial canonical bundle mathcalO_Xcong omega_X.","category":"page"},{"location":"AlgebraicGeometry/Surfaces/K3Surfaces/","page":"Automorphism Groups of  K3 surfaces","title":"Automorphism Groups of  K3 surfaces","text":"Much of the theory of (complex) K3 surfaces is governed by its Hodge structure and the mathbbZ-lattices NS(X) subseteq H^2(X mathbbZ).","category":"page"},{"location":"AlgebraicGeometry/Surfaces/K3Surfaces/","page":"Automorphism Groups of  K3 surfaces","title":"Automorphism Groups of  K3 surfaces","text":"See [Huy16] for the theory of K3 surfaces.","category":"page"},{"location":"AlgebraicGeometry/Surfaces/K3Surfaces/#Automorphisms","page":"Automorphism Groups of  K3 surfaces","title":"Automorphisms","text":"","category":"section"},{"location":"AlgebraicGeometry/Surfaces/K3Surfaces/","page":"Automorphism Groups of  K3 surfaces","title":"Automorphism Groups of  K3 surfaces","text":"K3_surface_automorphism_group(S::ZZLat)\nborcherds_method\nK3Chamber\nchamber(data::BorcherdsCtx, weyl_vector::ZZMatrix, parent_wall::ZZMatrix=zero_matrix(ZZ, 0, 0))\nweyl_vector(D::K3Chamber)\nwalls(::K3Chamber)\ninner_point(::K3Chamber)\nrays(::K3Chamber)\naut(::K3Chamber)\nhom(::K3Chamber,::K3Chamber)\nadjacent_chamber(D::K3Chamber, v::ZZMatrix)\nseparating_hyperplanes(S::ZZLat, v::QQMatrix, h::QQMatrix, d)\nhas_zero_entropy","category":"page"},{"location":"AlgebraicGeometry/Surfaces/K3Surfaces/#K3_surface_automorphism_group-Tuple{ZZLat}","page":"Automorphism Groups of  K3 surfaces","title":"K3_surface_automorphism_group","text":"K3_surface_automorphism_group(S::ZZLat [, ample_class]) -> generators, rational curves, chambers\n\nCompute the automorphism group of a very-general S-polarized K3 surface.\n\nFurther return representatives of the mathrmAut(X)-orbits of (-2)-curves on X and a fundamental domain for the action of mathrmAut(X) on the set of nef L|S chambers. This is almost a fundamental domain for mathrmAut(X) on the nef cone.\n\nHere very general means that Num(X) is isomorphic to S and the image of mathrmAut(X) to H^0(XOmega^2_X) is pm 1.\n\nThe function returns generators for the image of\n\nfcolon mathrmAut(X) to O(Num(X))\n\nThe output is represented with respect to  the basis of S.\n\nNote that under our genericity assumptions the kernel of f is of order at most 2 and it is equal to 2 if and only if S is 2-elementary. If an ample class is given, then the generators returned preserve it.\n\nThis kind of computation can be very expensive. To print progress information use set_verbosity_level(:K3Auto, 2) or higher.\n\nInput\n\nS: a hyperbolic lattice\nample: a row matrix or a vector given with respect to the ambient space of S.\n\n\n\n\n\n","category":"method"},{"location":"AlgebraicGeometry/Surfaces/K3Surfaces/#borcherds_method","page":"Automorphism Groups of  K3 surfaces","title":"borcherds_method","text":"borcherds_method(S::ZZLat, n::Integer; compute_OR=true, entropy_abort=false, max_nchambers=-1)\nborcherds_method(L::ZZLat, S::ZZLat, w::QQMatrix; compute_OR=true, entropy_abort=false, max_nchambers=-1)\n\nCompute the symmetry group of a Weyl chamber up to finite index.\n\nArguments\n\nw:  initial Weyl row vector represented with respect to the basis of L;\nL:  even, unimodular, hyperbolic lattice of rank n=10,18 or 26;\nS:  a primitive sublattice of L;\ncompute_OR=true: if false take as G all isometries of S extending to L;\nmax_nchambers: break the computation after max_nchambers are found;\nentropy_abort abort if an automorphism of positive entropy is found.\n\n\n\n\n\n","category":"function"},{"location":"AlgebraicGeometry/Surfaces/K3Surfaces/#K3Chamber","page":"Automorphism Groups of  K3 surfaces","title":"K3Chamber","text":"K3Chamber\n\nThe LS chamber induced from a Weyl vector in L.\n\nLet L be an even, unimodular and hyperbolic lattice of rank 10, 18 or 26 and S be a primitive sublattice. Any Weyl vector w of L defines a Weyl chamber C(w) in the positive cone of L. The Weyl chamber is a rational locally polyhedral cone with infinitely many facets, i.e. walls. It is the intersection of the positive half-spaces defined by Delta_L(w) = r in L  r^2=-2 rw = 1. We have\n\nC(w)=x in mathcalP_L  forall r in Delta_L(w)  xr geq 0\n\nThe Weyl chamber is a fundamental domain for the action of the Weyl group on the positive cone. We say that S otimes mathbbR cap C(w) is the LS-chamber induced by w.\n\nNote that two Weyl vectors induce the same chamber if and only if their orthogonal projections to S coincide.\n\n\n\n\n\n","category":"type"},{"location":"AlgebraicGeometry/Surfaces/K3Surfaces/#chamber","page":"Automorphism Groups of  K3 surfaces","title":"chamber","text":"chamber(data::BorcherdsCtx, weyl_vector::ZZMatrix, [parent_wall::ZZMatrix, walls::Vector{ZZMatrix}])\n\nReturn the LS-chamber with the given Weyl vector.\n\nThe lattices L and S are stored in data. Via the parent walls we can obtain a spanning tree of the chamber graph.\n\n\n\n\n\n","category":"function"},{"location":"AlgebraicGeometry/Surfaces/K3Surfaces/#weyl_vector-Tuple{K3Chamber}","page":"Automorphism Groups of  K3 surfaces","title":"weyl_vector","text":"weyl_vector(D::K3Chamber) -> ZZMatrix\n\nReturn the Weyl vector defining this chamber.\n\n\n\n\n\n","category":"method"},{"location":"AlgebraicGeometry/Surfaces/K3Surfaces/#walls-Tuple{K3Chamber}","page":"Automorphism Groups of  K3 surfaces","title":"walls","text":"walls(D::K3Chamber) -> Vector{ZZMatrix}\n\nReturn the walls of the chamber D, i.e. its facets.\n\nThe corresponding half space of the wall defined by v in walls(D) is\n\nx in S otimes mathbbR   langle xv rangle  geq 0\n\nv is given with respect to the basis of S and is primitive in S.\n\nNote that [Shi15] follows a different convention and takes v primitive in S^\\vee.\n\n\n\n\n\n","category":"method"},{"location":"AlgebraicGeometry/Surfaces/K3Surfaces/#inner_point-Tuple{K3Chamber}","page":"Automorphism Groups of  K3 surfaces","title":"inner_point","text":"inner_point(L::ZZLat, S::ZZLat, w::QQMatrix)\ninner_point(C::K3Chamber)\n\nReturn a reasonably small integer inner point of the given L|S chamber.\n\n\n\n\n\n","category":"method"},{"location":"AlgebraicGeometry/Surfaces/K3Surfaces/#rays-Tuple{K3Chamber}","page":"Automorphism Groups of  K3 surfaces","title":"rays","text":"rays(D::K3Chamber)\n\nReturn the rays of the chamber D.\n\nThey are represented as primitive row vectors with respect to the basis of S.\n\n\n\n\n\n","category":"method"},{"location":"AlgebraicGeometry/Surfaces/K3Surfaces/#aut-Tuple{K3Chamber}","page":"Automorphism Groups of  K3 surfaces","title":"aut","text":"aut(E::K3Chamber) -> Vector{ZZMatrix}\n\nReturn the stabilizer mathrmAut_G(E) of E in G.\n\nThe elements are represented with respect to the basis of S.\n\n\n\n\n\n","category":"method"},{"location":"AlgebraicGeometry/Surfaces/K3Surfaces/#hom-Tuple{K3Chamber, K3Chamber}","page":"Automorphism Groups of  K3 surfaces","title":"hom","text":"hom(D::K3Chamber, E::K3Chamber) -> Vector{ZZMatrix}\n\nReturn the set mathrmHom_G(D E) of elements of G mapping D to E.\n\nThe elements are represented with respect to the basis of S.\n\n\n\n\n\n","category":"method"},{"location":"AlgebraicGeometry/Surfaces/K3Surfaces/#adjacent_chamber-Tuple{K3Chamber, ZZMatrix}","page":"Automorphism Groups of  K3 surfaces","title":"adjacent_chamber","text":"adjacent_chamber(D::K3Chamber, v::ZZMatrix) -> K3Chamber\n\nReturn return the LS chamber adjacent to D via the wall defined by v.\n\n\n\n\n\n","category":"method"},{"location":"AlgebraicGeometry/Surfaces/K3Surfaces/#separating_hyperplanes-Tuple{ZZLat, QQMatrix, QQMatrix, Any}","page":"Automorphism Groups of  K3 surfaces","title":"separating_hyperplanes","text":"separating_hyperplanes(S::ZZLat, v::QQMatrix, h::QQMatrix, d)\n\nReturn x in S  x^2=d xv0 xh0.\n\nArguments\n\nS:  a hyperbolic lattice\nd: a negative integer\nv,h: vectors of positive square\n\n\n\n\n\n","category":"method"},{"location":"AlgebraicGeometry/Surfaces/K3Surfaces/#has_zero_entropy","page":"Automorphism Groups of  K3 surfaces","title":"has_zero_entropy","text":"has_zero_entropy(S::ZZLat; rank_unimod=26) ->\n\nCompute if the symmetry group of a Weyl chamber is elliptic, parabolic or hyperbolic.\n\nOutput\n\n1 - elliptic – the symmetry group is finite\n0 - parabolic – there is a unique cusp with infinite stabilizer\n-1 - hyperbolic – positive entropy\n\nThis calls borcherds_method and breaks the computation as soon as a symmetry of a Weyl chamber with positive entrop is found.\n\n\n\n\n\n","category":"function"},{"location":"AlgebraicGeometry/Surfaces/K3Surfaces/#Contact","page":"Automorphism Groups of  K3 surfaces","title":"Contact","text":"","category":"section"},{"location":"AlgebraicGeometry/Surfaces/K3Surfaces/","page":"Automorphism Groups of  K3 surfaces","title":"Automorphism Groups of  K3 surfaces","text":"Please direct questions about this part of OSCAR to the following people:","category":"page"},{"location":"AlgebraicGeometry/Surfaces/K3Surfaces/","page":"Automorphism Groups of  K3 surfaces","title":"Automorphism Groups of  K3 surfaces","text":"Simon Brandhorst.\nMatthias Zach,","category":"page"},{"location":"AlgebraicGeometry/Surfaces/K3Surfaces/","page":"Automorphism Groups of  K3 surfaces","title":"Automorphism Groups of  K3 surfaces","text":"You can ask questions in the OSCAR Slack.","category":"page"},{"location":"AlgebraicGeometry/Surfaces/K3Surfaces/","page":"Automorphism Groups of  K3 surfaces","title":"Automorphism Groups of  K3 surfaces","text":"Alternatively, you can raise an issue on github.","category":"page"},{"location":"Combinatorics/EnumerativeCombinatorics/tableaux/#Tableaux","page":"Tableaux","title":"Tableaux","text":"","category":"section"},{"location":"Combinatorics/EnumerativeCombinatorics/tableaux/","page":"Tableaux","title":"Tableaux","text":"A Young diagram is a diagram of finitely many empty \"boxes\" arranged in left-justified rows, with the row lengths in non-increasing order. The box in row i and and column j has the coordinates (i j). Listing the number of boxes in each row gives a partition lambda of a non-negative integer n (the total number of boxes of the diagram). The diagram is then said to be of shape lambda. Conversely, one can associate to any partition lambda a Young diagram in the obvious way, so Young diagrams are just another way to look at partitions.","category":"page"},{"location":"Combinatorics/EnumerativeCombinatorics/tableaux/","page":"Tableaux","title":"Tableaux","text":"A Young tableau of shape lambda is a filling of the boxes of the Young diagram of lambda with elements from some set. After relabeling we can (and will) assume that we fill from a set of integers from 1 up to some number, which in applications is often equal to n.","category":"page"},{"location":"Combinatorics/EnumerativeCombinatorics/tableaux/","page":"Tableaux","title":"Tableaux","text":"In OSCAR, a tableau is internally stored as an array of arrays and is represented by the type YoungTableau{T} which is a subtype of AbstractVector{AbstractVector{T}}, where T is the integer type of the filling. As for partitions, one may increase performance by casting into smaller integer types, e.g. Int8.","category":"page"},{"location":"Combinatorics/EnumerativeCombinatorics/tableaux/","page":"Tableaux","title":"Tableaux","text":"young_tableau","category":"page"},{"location":"Combinatorics/EnumerativeCombinatorics/tableaux/#young_tableau","page":"Tableaux","title":"young_tableau","text":"young_tableau([::Type{T}], v::Vector{Vector{<:IntegerUnion}}; check::Bool = true) where T <: IntegerUnion\n\nReturn the Young tableau given by v as an object of type YoungTableau{T}.\n\nThe element type T may be optionally specified, see also the examples below.\n\nIf check is true (default), it is checked whether v defines a tableau, that is, whether the structure of v defines a partition.\n\nExamples\n\njulia> young_tableau([[1, 2, 3], [4, 5], [6]])\n+---+---+---+\n| 1 | 2 | 3 |\n+---+---+---+\n| 4 | 5 |\n+---+---+\n| 6 |\n+---+\n\njulia> young_tableau(Int8, [[1, 2, 3], [4, 5], [6]]) # save the elements in 8-bit integers\n+---+---+---+\n| 1 | 2 | 3 |\n+---+---+---+\n| 4 | 5 |\n+---+---+\n| 6 |\n+---+\n\n\n\n\n\n","category":"function"},{"location":"Combinatorics/EnumerativeCombinatorics/tableaux/#Operations","page":"Tableaux","title":"Operations","text":"","category":"section"},{"location":"Combinatorics/EnumerativeCombinatorics/tableaux/","page":"Tableaux","title":"Tableaux","text":"hook_length\nhook_lengths\nshape\nweight\nreading_word","category":"page"},{"location":"Combinatorics/EnumerativeCombinatorics/tableaux/#hook_length","page":"Tableaux","title":"hook_length","text":"hook_length(tab::YoungTableau, i::Integer, j::Integer)\nhook_length(lambda::Partition, i::Integer, j::Integer)\n\nReturn the hook length of the box with coordinates (i, j) in the Young tableau tab respectively the Young diagram of shape lambda.\n\nThe hook length of a box is the number of boxes to the right in the same row + the number of boxes below in the same column + 1.\n\nSee also hook_lengths.\n\n\n\n\n\n","category":"function"},{"location":"Combinatorics/EnumerativeCombinatorics/tableaux/#hook_lengths","page":"Tableaux","title":"hook_lengths","text":"hook_lengths(lambda::Partition)\n\nReturn the Young tableau of shape lambda in which the entry at position (i, j) is equal to the hook length of the corresponding box.\n\nSee also hook_length.\n\n\n\n\n\n","category":"function"},{"location":"Combinatorics/EnumerativeCombinatorics/tableaux/#shape","page":"Tableaux","title":"shape","text":"shape(tab::YoungTableau)\n\nReturn the shape of the tableau tab, i.e. the partition given by the lengths of the rows of the tableau.\n\n\n\n\n\n","category":"function"},{"location":"Combinatorics/EnumerativeCombinatorics/tableaux/#weight","page":"Tableaux","title":"weight","text":"weight(tab::YoungTableau)\n\nReturn the weight sequence of the tableau tab as an array whose i-th element gives the number of times the integer i appears in the tableau.\n\n\n\n\n\n","category":"function"},{"location":"Combinatorics/EnumerativeCombinatorics/tableaux/#reading_word","page":"Tableaux","title":"reading_word","text":"reading_word(tab::YoungTableau)\n\nReturn the reading word of the tableau tab as an array, i.e. the word obtained by concatenating the fillings of the rows, starting from the bottom row.\n\nExamples\n\njulia> reading_word(young_tableau([[1, 2, 3], [4, 5], [6]]))\n6-element Vector{Int64}:\n 6\n 4\n 5\n 1\n 2\n 3\n\n\n\n\n\n","category":"function"},{"location":"Combinatorics/EnumerativeCombinatorics/tableaux/#Semistandard-tableaux","page":"Tableaux","title":"Semistandard tableaux","text":"","category":"section"},{"location":"Combinatorics/EnumerativeCombinatorics/tableaux/","page":"Tableaux","title":"Tableaux","text":"is_semistandard\nsemistandard_tableaux","category":"page"},{"location":"Combinatorics/EnumerativeCombinatorics/tableaux/#is_semistandard","page":"Tableaux","title":"is_semistandard","text":"is_semistandard(tab::YoungTableau)\n\nReturn true if the tableau tab is semistandard and false otherwise.\n\nA tableau is called semistandard if the entries weakly increase along each row and strictly increase down each column.\n\nSee also is_standard.\n\n\n\n\n\n","category":"function"},{"location":"Combinatorics/EnumerativeCombinatorics/tableaux/#semistandard_tableaux","page":"Tableaux","title":"semistandard_tableaux","text":"semistandard_tableaux(shape::Partition{T}, max_val::T = sum(shape)) where T <: IntegerUnion\nsemistandard_tableaux(shape::Vector{T}, max_val::T = sum(shape)) where T <: IntegerUnion\n\nReturn an iterator over all semistandard Young tableaux of given shape shape and filling elements bounded by max_val.\n\nBy default, max_val is equal to the sum of the shape partition (the number of boxes in the Young diagram).\n\nThe list of tableaux is in lexicographic order from left to right and top to bottom.\n\n\n\n\n\nsemistandard_tableaux(box_num::T, max_val::T = box_num) where T <: Integer\n\nReturn an iterator over all semistandard Young tableaux consisting of box_num boxes and filling elements bounded by max_val.\n\n\n\n\n\nsemistandard_tableaux(s::Partition{T}, weight::Vector{T}) where T <: Integer\nsemistandard_tableaux(s::Vector{T}, weight::Vector{T}) where T <: Integer\n\nReturn an iterator over all semistandard Young tableaux with shape s and given weight. This requires that sum(s) = sum(weight).\n\n\n\n\n\n","category":"function"},{"location":"Combinatorics/EnumerativeCombinatorics/tableaux/#Standard-tableaux","page":"Tableaux","title":"Standard tableaux","text":"","category":"section"},{"location":"Combinatorics/EnumerativeCombinatorics/tableaux/","page":"Tableaux","title":"Tableaux","text":"is_standard\nstandard_tableaux","category":"page"},{"location":"Combinatorics/EnumerativeCombinatorics/tableaux/#is_standard","page":"Tableaux","title":"is_standard","text":"is_standard(tab::YoungTableau)\n\nReturn true if the tableau tab is standard and false otherwise.\n\nA tableau is called standard if it is semistandard and the entries are in bijection with 1, ..., n, where n is the number of boxes.\n\nSee also is_semistandard.\n\n\n\n\n\n","category":"function"},{"location":"Combinatorics/EnumerativeCombinatorics/tableaux/#standard_tableaux","page":"Tableaux","title":"standard_tableaux","text":"standard_tableaux(s::Partition)\nstandard_tableaux(s::Vector{Integer})\n\nReturn an iterator over all standard Young tableaux of a given shape s.\n\n\n\n\n\nstandard_tableaux(n::IntegerUnion)\n\nReturn an iterator over all standard Young tableaux with n boxes.\n\n\n\n\n\n","category":"function"},{"location":"Combinatorics/EnumerativeCombinatorics/tableaux/","page":"Tableaux","title":"Tableaux","text":"number_of_standard_tableaux","category":"page"},{"location":"Combinatorics/EnumerativeCombinatorics/tableaux/#number_of_standard_tableaux","page":"Tableaux","title":"number_of_standard_tableaux","text":"number_of_standard_tableaux(lambda::Partition)\n\nReturn the number of standard Young tableaux of shape lambda.\n\n\n\n\n\n","category":"function"},{"location":"Combinatorics/EnumerativeCombinatorics/tableaux/","page":"Tableaux","title":"Tableaux","text":"The number f^lambda of standard Young tableaux of shape lambda is computed using the hook length formula","category":"page"},{"location":"Combinatorics/EnumerativeCombinatorics/tableaux/","page":"Tableaux","title":"Tableaux","text":"f^lambda = fracnprod_i j h_lambda(i j)","category":"page"},{"location":"Combinatorics/EnumerativeCombinatorics/tableaux/","page":"Tableaux","title":"Tableaux","text":"where the product is taken over all boxes in the Young diagram of lambda and h_lambda denotes the hook length of the box (i j).","category":"page"},{"location":"Combinatorics/EnumerativeCombinatorics/tableaux/","page":"Tableaux","title":"Tableaux","text":"schensted\nbump!","category":"page"},{"location":"Combinatorics/EnumerativeCombinatorics/tableaux/#schensted","page":"Tableaux","title":"schensted","text":"schensted(sigma::Vector{<:IntegerUnion})\nschensted(sigma::PermGroupElem)\n\nReturn the pair of standard Young tableaux (the insertion and the recording tableau) corresponding to the permutation sigma under the Robinson-Schensted correspondence.\n\nExamples\n\njulia> P, Q = schensted([3, 1, 6, 2, 5, 4]);\n\njulia> P\n+---+---+---+\n| 1 | 2 | 4 |\n+---+---+---+\n| 3 | 5 |\n+---+---+\n| 6 |\n+---+\n\njulia> Q\n+---+---+---+\n| 1 | 3 | 5 |\n+---+---+---+\n| 2 | 4 |\n+---+---+\n| 6 |\n+---+\n\n\n\n\n\n\n","category":"function"},{"location":"Combinatorics/EnumerativeCombinatorics/tableaux/#bump!","page":"Tableaux","title":"bump!","text":"bump!(tab::YoungTableau, x::Int)\n\nInsert the integer x into the tableau tab according to the bumping algorithm by applying the Schensted insertion.\n\n\n\n\n\nbump!(tab::YoungTableau, x::Integer, Q::YoungTableau, y::Integer)\n\nInsert the integer x into tab according to the bumping algorithm by applying the Schensted insertion and insert the integer y into Q at the same position as x in tab.\n\n\n\n\n\n","category":"function"},{"location":"Hecke/manual/quad_forms/discriminant_group/#Discriminant-Groups","page":"Discriminant Groups","title":"Discriminant Groups","text":"","category":"section"},{"location":"Hecke/manual/quad_forms/discriminant_group/","page":"Discriminant Groups","title":"Discriminant Groups","text":"CurrentModule = Hecke\nDocTestSetup = quote\n    using Hecke\n  end","category":"page"},{"location":"Hecke/manual/quad_forms/discriminant_group/#Torsion-Quadratic-Modules","page":"Discriminant Groups","title":"Torsion Quadratic Modules","text":"","category":"section"},{"location":"Hecke/manual/quad_forms/discriminant_group/","page":"Discriminant Groups","title":"Discriminant Groups","text":"A torsion quadratic module is the quotient MN of two quadratic integer lattices N subseteq M in the quadratic space (VPhi). It inherits a bilinear form","category":"page"},{"location":"Hecke/manual/quad_forms/discriminant_group/","page":"Discriminant Groups","title":"Discriminant Groups","text":"b MN times MN to mathbbQ  n mathbbZ","category":"page"},{"location":"Hecke/manual/quad_forms/discriminant_group/","page":"Discriminant Groups","title":"Discriminant Groups","text":"as well as a quadratic form","category":"page"},{"location":"Hecke/manual/quad_forms/discriminant_group/","page":"Discriminant Groups","title":"Discriminant Groups","text":"q MN to mathbbQ  m mathbbZ","category":"page"},{"location":"Hecke/manual/quad_forms/discriminant_group/","page":"Discriminant Groups","title":"Discriminant Groups","text":"where n mathbbZ = Phi(MN) and m mathbbZ = 2nmathbbZ + sum_x in N mathbbZ Phi (xx).","category":"page"},{"location":"Hecke/manual/quad_forms/discriminant_group/","page":"Discriminant Groups","title":"Discriminant Groups","text":"torsion_quadratic_module(M::ZZLat, N::ZZLat)","category":"page"},{"location":"Hecke/manual/quad_forms/discriminant_group/#torsion_quadratic_module-Tuple{ZZLat, ZZLat}","page":"Discriminant Groups","title":"torsion_quadratic_module","text":"torsion_quadratic_module(M::ZZLat, N::ZZLat; gens::Union{Nothing, Vector{<:Vector}} = nothing,\n                                             snf::Bool = true,\n                                             modulus::RationalUnion = QQFieldElem(0),\n                                             modulus_qf::RationalUnion = QQFieldElem(0),\n                                             check::Bool = true) -> TorQuadModule\n\nGiven a Z-lattice M and a sublattice N of M, return the torsion quadratic module MN.\n\nIf gens is set, the images of gens will be used as the generators of the abelian group MN.\n\nIf snf is true, the underlying abelian group will be in Smith normal form. Otherwise, the images of the basis of M will be used as the generators.\n\nOne can decide on the modulus for the associated finite bilinear and quadratic forms by setting modulus and modulus_qf respectively to the desired values.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/quad_forms/discriminant_group/#The-underlying-Type","page":"Discriminant Groups","title":"The underlying Type","text":"","category":"section"},{"location":"Hecke/manual/quad_forms/discriminant_group/","page":"Discriminant Groups","title":"Discriminant Groups","text":"TorQuadModule","category":"page"},{"location":"Hecke/manual/quad_forms/discriminant_group/#TorQuadModule","page":"Discriminant Groups","title":"TorQuadModule","text":"TorQuadModule\n\nExamples\n\njulia> A = matrix(ZZ, [[2,0,0,-1],[0,2,0,-1],[0,0,2,-1],[-1,-1,-1,2]]);\n\njulia> L = integer_lattice(gram = A);\n\njulia> T = Hecke.discriminant_group(L)\nFinite quadratic module\n  over integer ring\nAbelian group: (Z/2)^2\nBilinear value module: Q/Z\nQuadratic value module: Q/2Z\nGram matrix quadratic form:\n[   1   1//2]\n[1//2      1]\n\nWe represent torsion quadratic modules as quotients of mathbbZ-lattices by a full rank sublattice.\n\nWe store them as a mathbbZ-lattice M together with a projection p : M -> A onto an abelian group A. The bilinear structure of A is induced via p, that is <a, b> = <p^-1(a), p^-1(a)> with values in mathbbQnmathbbZ, where n is the modulus and depends on the kernel of p.\n\nElements of A are basically just elements of the underlying abelian group. To move between M and A, we use the lift function lift : M -> A and coercion A(m).\n\nExamples\n\njulia> R = rescale(root_lattice(:D,4),2);\n\njulia> D = discriminant_group(R);\n\njulia> A = abelian_group(D)\n(Z/2)^2 x (Z/4)^2\n\njulia> d = D[1]\nElement\n  of finite quadratic module: (Z/2)^2 x (Z/4)^2 -> Q/2Z\nwith components [1 0 0 0]\n\njulia> d == D(A(d))\ntrue\n\njulia> lift(d)\n4-element Vector{QQFieldElem}:\n 1\n 1\n 3//2\n 1\n\nN.B. Since there are no elements of mathbbZ-lattices, we think of elements of M as elements of the ambient vector space. Thus if v::Vector is such an element then the coordinates with respec to the basis of M are given by solve(basis_matrix(M), v; side = :left).\n\n\n\n\n\n","category":"type"},{"location":"Hecke/manual/quad_forms/discriminant_group/","page":"Discriminant Groups","title":"Discriminant Groups","text":"Most of the functionality mirrors that of AbGrp its elements and homomorphisms. Here we display the part that is specific to elements of torsion quadratic modules.","category":"page"},{"location":"Hecke/manual/quad_forms/discriminant_group/#Attributes","page":"Discriminant Groups","title":"Attributes","text":"","category":"section"},{"location":"Hecke/manual/quad_forms/discriminant_group/","page":"Discriminant Groups","title":"Discriminant Groups","text":"abelian_group(T::TorQuadModule)\ncover(T::TorQuadModule)\nrelations(T::TorQuadModule)\nvalue_module(T::TorQuadModule)\nvalue_module_quadratic_form(T::TorQuadModule)\ngram_matrix_bilinear(T::TorQuadModule)\ngram_matrix_quadratic(T::TorQuadModule)\nmodulus_bilinear_form(T::TorQuadModule)\nmodulus_quadratic_form(T::TorQuadModule)","category":"page"},{"location":"Hecke/manual/quad_forms/discriminant_group/#abelian_group-Tuple{TorQuadModule}","page":"Discriminant Groups","title":"abelian_group","text":"abelian_group(T::TorQuadModule) -> FinGenAbGroup\n\nReturn the underlying abelian group of T.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/quad_forms/discriminant_group/#cover-Tuple{TorQuadModule}","page":"Discriminant Groups","title":"cover","text":"cover(T::TorQuadModule) -> ZZLat\n\nFor T=MN this returns M.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/quad_forms/discriminant_group/#relations-Tuple{TorQuadModule}","page":"Discriminant Groups","title":"relations","text":"relations(T::TorQuadModule) -> ZZLat\n\nFor T=MN this returns N.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/quad_forms/discriminant_group/#value_module-Tuple{TorQuadModule}","page":"Discriminant Groups","title":"value_module","text":"value_module(T::TorQuadModule) -> QmodnZ\n\nReturn the value module Q/nZ of the bilinear form of T.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/quad_forms/discriminant_group/#value_module_quadratic_form-Tuple{TorQuadModule}","page":"Discriminant Groups","title":"value_module_quadratic_form","text":"value_module_quadratic_form(T::TorQuadModule) -> QmodnZ\n\nReturn the value module Q/mZ of the quadratic form of T.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/quad_forms/discriminant_group/#gram_matrix_bilinear-Tuple{TorQuadModule}","page":"Discriminant Groups","title":"gram_matrix_bilinear","text":"gram_matrix_bilinear(T::TorQuadModule) -> QQMatrix\n\nReturn the gram matrix of the bilinear form of T.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/quad_forms/discriminant_group/#gram_matrix_quadratic-Tuple{TorQuadModule}","page":"Discriminant Groups","title":"gram_matrix_quadratic","text":"gram_matrix_quadratic(T::TorQuadModule) -> QQMatrix\n\nReturn the 'gram matrix' of the quadratic form of T.\n\nThe off diagonal entries are given by the bilinear form whereas the diagonal entries are given by the quadratic form.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/quad_forms/discriminant_group/#modulus_bilinear_form-Tuple{TorQuadModule}","page":"Discriminant Groups","title":"modulus_bilinear_form","text":"modulus_bilinear_form(T::TorQuadModule) -> QQFieldElem\n\nReturn the modulus of the value module of the bilinear form ofT.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/quad_forms/discriminant_group/#modulus_quadratic_form-Tuple{TorQuadModule}","page":"Discriminant Groups","title":"modulus_quadratic_form","text":"modulus_quadratic_form(T::TorQuadModule) -> QQFieldElem\n\nReturn the modulus of the value module of the quadratic form of T.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/quad_forms/discriminant_group/#Elements","page":"Discriminant Groups","title":"Elements","text":"","category":"section"},{"location":"Hecke/manual/quad_forms/discriminant_group/","page":"Discriminant Groups","title":"Discriminant Groups","text":"quadratic_product(a::TorQuadModuleElem)\ninner_product(a::TorQuadModuleElem, b::TorQuadModuleElem)","category":"page"},{"location":"Hecke/manual/quad_forms/discriminant_group/#quadratic_product-Tuple{TorQuadModuleElem}","page":"Discriminant Groups","title":"quadratic_product","text":"quadratic_product(a::TorQuadModuleElem) -> QmodnZElem\n\nReturn the quadratic product of a.\n\nIt is defined in terms of a representative: for b + M in MN=T, this returns Phi(bb) + n mathbbZ.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/quad_forms/discriminant_group/#inner_product-Tuple{TorQuadModuleElem, TorQuadModuleElem}","page":"Discriminant Groups","title":"inner_product","text":"inner_product(a::TorQuadModuleElem, b::TorQuadModuleElem) -> QmodnZElem\n\nReturn the inner product of a and b.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/quad_forms/discriminant_group/#Lift-to-the-cover","page":"Discriminant Groups","title":"Lift to the cover","text":"","category":"section"},{"location":"Hecke/manual/quad_forms/discriminant_group/","page":"Discriminant Groups","title":"Discriminant Groups","text":"lift(a::TorQuadModuleElem)\nrepresentative(::TorQuadModuleElem)","category":"page"},{"location":"Hecke/manual/quad_forms/discriminant_group/#lift-Tuple{TorQuadModuleElem}","page":"Discriminant Groups","title":"lift","text":"lift(a::TorQuadModuleElem) -> Vector{QQFieldElem}\n\nLift a to the ambient space of cover(parent(a)).\n\nFor a + N in MN this returns the representative a.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/quad_forms/discriminant_group/#representative-Tuple{TorQuadModuleElem}","page":"Discriminant Groups","title":"representative","text":"representative(a::TorQuadModuleElem) -> Vector{QQFieldElem}\n\nFor a + N in MN this returns the representative a. An alias for lift(a).\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/quad_forms/discriminant_group/#Orthogonal-submodules","page":"Discriminant Groups","title":"Orthogonal submodules","text":"","category":"section"},{"location":"Hecke/manual/quad_forms/discriminant_group/","page":"Discriminant Groups","title":"Discriminant Groups","text":"orthogonal_submodule(T::TorQuadModule, S::TorQuadModule)","category":"page"},{"location":"Hecke/manual/quad_forms/discriminant_group/#orthogonal_submodule-Tuple{TorQuadModule, TorQuadModule}","page":"Discriminant Groups","title":"orthogonal_submodule","text":"orthogonal_submodule(T::TorQuadModule, S::TorQuadModule)-> TorQuadModule\n\nReturn the orthogonal submodule to the submodule S of T.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/quad_forms/discriminant_group/#Isometry","page":"Discriminant Groups","title":"Isometry","text":"","category":"section"},{"location":"Hecke/manual/quad_forms/discriminant_group/","page":"Discriminant Groups","title":"Discriminant Groups","text":"is_isometric_with_isometry(T::TorQuadModule, U::TorQuadModule)\nis_anti_isometric_with_anti_isometry(T::TorQuadModule, U::TorQuadModule)","category":"page"},{"location":"Hecke/manual/quad_forms/discriminant_group/#is_isometric_with_isometry-Tuple{TorQuadModule, TorQuadModule}","page":"Discriminant Groups","title":"is_isometric_with_isometry","text":"is_isometric_with_isometry(T::TorQuadModule, U::TorQuadModule)\n                                               -> Bool, TorQuadModuleMap\n\nReturn whether the torsion quadratic modules T and U are isometric. If yes, it also returns an isometry T to U.\n\nIf T and U are not semi-regular it requires that they both split into a direct sum of their respective quadratic radical (see radical_quadratic).\n\nIt requires that both T and U have modulus 1: in case one of them do not, they should be rescaled (see rescale).\n\nExamples\n\njulia> T = torsion_quadratic_module(QQ[2//3 2//3    0    0    0;\n                                       2//3 2//3 2//3    0 2//3;\n                                          0 2//3 2//3 2//3    0;\n                                          0    0 2//3 2//3    0;\n                                          0 2//3    0    0 2//3])\nFinite quadratic module\n  over integer ring\nAbelian group: (Z/3)^5\nBilinear value module: Q/Z\nQuadratic value module: Q/2Z\nGram matrix quadratic form:\n[2//3   2//3      0      0      0]\n[2//3   2//3   2//3      0   2//3]\n[   0   2//3   2//3   2//3      0]\n[   0      0   2//3   2//3      0]\n[   0   2//3      0      0   2//3]\n\njulia> U = torsion_quadratic_module(QQ[4//3    0    0    0    0;\n                                          0 4//3    0    0    0;\n                                          0    0 4//3    0    0;\n                                          0    0    0 4//3    0;\n                                          0    0    0    0 4//3])\nFinite quadratic module\n  over integer ring\nAbelian group: (Z/3)^5\nBilinear value module: Q/Z\nQuadratic value module: Q/2Z\nGram matrix quadratic form:\n[4//3      0      0      0      0]\n[   0   4//3      0      0      0]\n[   0      0   4//3      0      0]\n[   0      0      0   4//3      0]\n[   0      0      0      0   4//3]\n\njulia> bool, phi = is_isometric_with_isometry(T,U)\n(true, Map: finite quadratic module -> finite quadratic module)\n\njulia> is_bijective(phi)\ntrue\n\njulia> T2, _ = sub(T, [-T[4], T[2]+T[3]+T[5]])\n(Finite quadratic module: (Z/3)^2 -> Q/2Z, Map: finite quadratic module -> finite quadratic module)\n\njulia> U2, _ = sub(T, [T[4], T[2]+T[3]+T[5]])\n(Finite quadratic module: (Z/3)^2 -> Q/2Z, Map: finite quadratic module -> finite quadratic module)\n\njulia> bool, phi = is_isometric_with_isometry(U2, T2)\n(true, Map: finite quadratic module -> finite quadratic module)\n\njulia> is_bijective(phi)\ntrue\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/quad_forms/discriminant_group/#is_anti_isometric_with_anti_isometry-Tuple{TorQuadModule, TorQuadModule}","page":"Discriminant Groups","title":"is_anti_isometric_with_anti_isometry","text":"is_anti_isometric_with_anti_isometry(T::TorQuadModule, U::TorQuadModule)\n                                                 -> Bool, TorQuadModuleMap\n\nReturn whether there exists an anti-isometry between the torsion quadratic modules T and U. If yes, it returns such an anti-isometry T to U.\n\nIf T and U are not semi-regular it requires that they both split into a direct sum of their respective quadratic radical (see radical_quadratic).\n\nIt requires that both T and U have modulus 1: in case one of them do not, they should be rescaled (see rescale).\n\nExamples\n\njulia> T = torsion_quadratic_module(QQ[4//5;])\nFinite quadratic module\n  over integer ring\nAbelian group: Z/5\nBilinear value module: Q/Z\nQuadratic value module: Q/2Z\nGram matrix quadratic form:\n[4//5]\n\njulia> bool, phi = is_anti_isometric_with_anti_isometry(T, T)\n(true, Map: finite quadratic module -> finite quadratic module)\n\njulia> a = gens(T)[1];\n\njulia> a*a == -phi(a)*phi(a)\ntrue\n\njulia> G = matrix(QQ, 6, 6 , [3 3 0 0 0  0;\n                                   3 3 3 0 3  0;\n                                   0 3 3 3 0  0;\n                                   0 0 3 3 0  0;\n                                   0 3 0 0 3  0;\n                                   0 0 0 0 0 10]);\n\njulia> V = quadratic_space(QQ, G);\n\njulia> B = matrix(QQ, 6, 6 , [1    0    0    0    0    0;\n                              0 1//3 1//3 2//3 1//3    0;\n                              0    0    1    0    0    0;\n                              0    0    0    1    0    0;\n                              0    0    0    0    1    0;\n                              0    0    0    0    0 1//5]);\n\n\njulia> M = lattice(V, B);\n\njulia> B2 = matrix(QQ, 6, 6 , [ 1  0 -1  1  0 0;\n                                     0  0  1 -1  0 0;\n                                    -1  1  1 -1 -1 0;\n                                     1 -1 -1  2  1 0;\n                                     0  0 -1  1  1 0;\n                                     0  0  0  0  0 1]);\n\njulia> N = lattice(V, B2);\n\njulia> T = torsion_quadratic_module(M, N)\nFinite quadratic module\n  over integer ring\nAbelian group: Z/15\nBilinear value module: Q/Z\nQuadratic value module: Q/Z\nGram matrix quadratic form:\n[3//5]\n\njulia> bool, phi = is_anti_isometric_with_anti_isometry(T,T)\n(true, Map: finite quadratic module -> finite quadratic module)\n\njulia> a = gens(T)[1];\n\njulia> a*a == -phi(a)*phi(a)\ntrue\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/quad_forms/discriminant_group/#Primary-and-elementary-modules","page":"Discriminant Groups","title":"Primary and elementary modules","text":"","category":"section"},{"location":"Hecke/manual/quad_forms/discriminant_group/","page":"Discriminant Groups","title":"Discriminant Groups","text":"is_primary_with_prime(T::TorQuadModule)\nis_primary(T::TorQuadModule, p::Union{Integer, ZZRingElem})\nis_elementary_with_prime(T::TorQuadModule)\nis_elementary(T::TorQuadModule, p::Union{Integer, ZZRingElem})","category":"page"},{"location":"Hecke/manual/quad_forms/discriminant_group/#is_primary_with_prime-Tuple{TorQuadModule}","page":"Discriminant Groups","title":"is_primary_with_prime","text":"is_primary_with_prime(T::TorQuadModule) -> Bool, ZZRingElem\n\nGiven a torsion quadratic module T, return whether the underlying (finite) abelian group of T (see abelian_group) is a p-group for some prime number p. In case it is, p is also returned as second output.\n\nNote that in the case of trivial groups, this function returns (true, 1). If T is not primary, the second return value is -1 by default.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/quad_forms/discriminant_group/#is_primary-Tuple{TorQuadModule, Union{Integer, ZZRingElem}}","page":"Discriminant Groups","title":"is_primary","text":"is_primary(T::TorQuadModule, p::Union{Integer, ZZRingElem}) -> Bool\n\nGiven a torsion quadratic module T and a prime number p, return whether the underlying (finite) abelian group of T (see abelian_group) is a p-group.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/quad_forms/discriminant_group/#is_elementary_with_prime-Tuple{TorQuadModule}","page":"Discriminant Groups","title":"is_elementary_with_prime","text":"is_elementary_with_prime(T::TorQuadModule) -> Bool, ZZRingElem\n\nGiven a torsion quadratic module T, return whether the underlying (finite) abelian group of T (see abelian_group) is an elementary p-group, for some prime number p. In case it is, p is also returned as second output.\n\nNote that in the case of trivial groups, this function returns (true, 1). If T is not elementary, the second return value is -1 by default.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/quad_forms/discriminant_group/#is_elementary-Tuple{TorQuadModule, Union{Integer, ZZRingElem}}","page":"Discriminant Groups","title":"is_elementary","text":"is_elementary(T::TorQuadModule, p::Union{Integer, ZZRingElem}) -> Bool\n\nGiven a torsion quadratic module T and a prime number p, return whether the underlying (finite) abelian group of T (see abelian_group) is an elementary p-group.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/quad_forms/discriminant_group/#Smith-normal-form","page":"Discriminant Groups","title":"Smith normal form","text":"","category":"section"},{"location":"Hecke/manual/quad_forms/discriminant_group/","page":"Discriminant Groups","title":"Discriminant Groups","text":"snf(T::TorQuadModule)\nis_snf(T::TorQuadModule)","category":"page"},{"location":"Hecke/manual/quad_forms/discriminant_group/#snf-Tuple{TorQuadModule}","page":"Discriminant Groups","title":"snf","text":"snf(T::TorQuadModule) -> TorQuadModule, TorQuadModuleMap\n\nGiven a torsion quadratic module T, return a torsion quadratic module S, isometric to T, such that the underlying abelian group of S is in canonical Smith normal form. It comes with an isometry f  S to T.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/quad_forms/discriminant_group/#is_snf-Tuple{TorQuadModule}","page":"Discriminant Groups","title":"is_snf","text":"is_snf(T::TorQuadModule) -> Bool\n\nGiven a torsion quadratic module T, return whether its underlying abelian group is in Smith normal form.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/quad_forms/discriminant_group/#Discriminant-Groups-2","page":"Discriminant Groups","title":"Discriminant Groups","text":"","category":"section"},{"location":"Hecke/manual/quad_forms/discriminant_group/","page":"Discriminant Groups","title":"Discriminant Groups","text":"See [Nik79] for the general theory of discriminant groups. They are particularly useful to work with primitive embeddings of integral integer quadratic lattices.","category":"page"},{"location":"Hecke/manual/quad_forms/discriminant_group/#From-a-lattice","page":"Discriminant Groups","title":"From a lattice","text":"","category":"section"},{"location":"Hecke/manual/quad_forms/discriminant_group/","page":"Discriminant Groups","title":"Discriminant Groups","text":"discriminant_group(::ZZLat)","category":"page"},{"location":"Hecke/manual/quad_forms/discriminant_group/#discriminant_group-Tuple{ZZLat}","page":"Discriminant Groups","title":"discriminant_group","text":"discriminant_group(L::ZZLat) -> TorQuadModule\n\nReturn the discriminant group of L.\n\nThe discriminant group of an integral lattice L is the finite abelian group D = dual(L)/L.\n\nIt comes equipped with the discriminant bilinear form\n\nD times D to mathbbQ  mathbbZ qquad (xy) mapsto Phi(xy) + mathbbZ\n\nIf L is even, then the discriminant group is equipped with the discriminant quadratic form D to mathbbQ  2 mathbbZ x mapsto Phi(xx) + 2mathbbZ.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/quad_forms/discriminant_group/#From-a-matrix","page":"Discriminant Groups","title":"From a matrix","text":"","category":"section"},{"location":"Hecke/manual/quad_forms/discriminant_group/","page":"Discriminant Groups","title":"Discriminant Groups","text":"torsion_quadratic_module(q::QQMatrix)","category":"page"},{"location":"Hecke/manual/quad_forms/discriminant_group/#torsion_quadratic_module-Tuple{QQMatrix}","page":"Discriminant Groups","title":"torsion_quadratic_module","text":"torsion_quadratic_module(q::QQMatrix) -> TorQuadModule\n\nReturn a torsion quadratic module with gram matrix given by q and value module Q/Z. If all the diagonal entries of q have: either even numerator or even denominator, then the value module of the quadratic form is Q/2Z\n\nExample\n\njulia> torsion_quadratic_module(QQ[1//6;])\nFinite quadratic module\n  over integer ring\nAbelian group: Z/6\nBilinear value module: Q/Z\nQuadratic value module: Q/2Z\nGram matrix quadratic form:\n[1//6]\n\njulia> torsion_quadratic_module(QQ[1//2;])\nFinite quadratic module\n  over integer ring\nAbelian group: Z/2\nBilinear value module: Q/Z\nQuadratic value module: Q/2Z\nGram matrix quadratic form:\n[1//2]\n\njulia> torsion_quadratic_module(QQ[3//2;])\nFinite quadratic module\n  over integer ring\nAbelian group: Z/2\nBilinear value module: Q/Z\nQuadratic value module: Q/2Z\nGram matrix quadratic form:\n[3//2]\n\njulia> torsion_quadratic_module(QQ[1//3;])\nFinite quadratic module\n  over integer ring\nAbelian group: Z/3\nBilinear value module: Q/Z\nQuadratic value module: Q/Z\nGram matrix quadratic form:\n[1//3]\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/quad_forms/discriminant_group/#Rescaling-the-form","page":"Discriminant Groups","title":"Rescaling the form","text":"","category":"section"},{"location":"Hecke/manual/quad_forms/discriminant_group/","page":"Discriminant Groups","title":"Discriminant Groups","text":"rescale(T::TorQuadModule, k::RingElement)","category":"page"},{"location":"Hecke/manual/quad_forms/discriminant_group/#rescale-Tuple{TorQuadModule, RingElement}","page":"Discriminant Groups","title":"rescale","text":"rescale(T::TorQuadModule, k::RingElement) -> TorQuadModule\n\nReturn the torsion quadratic module with quadratic form scaled by k, where k is a non-zero rational number. If the old form was defined modulo n, then the new form is defined modulo n k.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/quad_forms/discriminant_group/#Invariants","page":"Discriminant Groups","title":"Invariants","text":"","category":"section"},{"location":"Hecke/manual/quad_forms/discriminant_group/","page":"Discriminant Groups","title":"Discriminant Groups","text":"is_degenerate(T::TorQuadModule)\nis_semi_regular(T::TorQuadModule)\nradical_bilinear(T::TorQuadModule)\nradical_quadratic(T::TorQuadModule)\nnormal_form(T::TorQuadModule; partial=false)","category":"page"},{"location":"Hecke/manual/quad_forms/discriminant_group/#is_degenerate-Tuple{TorQuadModule}","page":"Discriminant Groups","title":"is_degenerate","text":"is_degenerate(T::TorQuadModule) -> Bool\n\nReturn true if the underlying bilinear form is degenerate.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/quad_forms/discriminant_group/#is_semi_regular-Tuple{TorQuadModule}","page":"Discriminant Groups","title":"is_semi_regular","text":"is_semi_regular(T::TorQuadModule) -> Bool\n\nReturn whether T is semi-regular, that is its quadratic radical is trivial (see radical_quadratic).\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/quad_forms/discriminant_group/#radical_bilinear-Tuple{TorQuadModule}","page":"Discriminant Groups","title":"radical_bilinear","text":"radical_bilinear(T::TorQuadModule) -> TorQuadModule, TorQuadModuleMap\n\nReturn the radical \\{x \\in T | b(x,T) = 0\\} of the bilinear form b on T.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/quad_forms/discriminant_group/#radical_quadratic-Tuple{TorQuadModule}","page":"Discriminant Groups","title":"radical_quadratic","text":"radical_quadratic(T::TorQuadModule) -> TorQuadModule, TorQuadModuleMap\n\nReturn the radical \\{x \\in T | b(x,T) = 0 and q(x)=0\\} of the quadratic form q on T.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/quad_forms/discriminant_group/#normal_form-Tuple{TorQuadModule}","page":"Discriminant Groups","title":"normal_form","text":"normal_form(T::TorQuadModule; partial=false) -> TorQuadModule, TorQuadModuleMap\n\nReturn the normal form N of the given torsion quadratic module T along with the projection T -> N.\n\nLet K be the radical of the quadratic form of T. Then N = T/K is half-regular. Two half-regular torsion quadratic modules are isometric if and only if they have equal normal forms.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/quad_forms/discriminant_group/#Genus","page":"Discriminant Groups","title":"Genus","text":"","category":"section"},{"location":"Hecke/manual/quad_forms/discriminant_group/","page":"Discriminant Groups","title":"Discriminant Groups","text":"genus(T::TorQuadModule, signature_pair::Tuple{Int, Int})\nbrown_invariant(T::TorQuadModule)\nis_genus(T::TorQuadModule, signature_pair::Tuple{Int, Int})","category":"page"},{"location":"Hecke/manual/quad_forms/discriminant_group/#genus-Tuple{TorQuadModule, Tuple{Int64, Int64}}","page":"Discriminant Groups","title":"genus","text":"genus(T::TorQuadModule, signature_pair::Tuple{Int, Int};\n                        parity::RationalUnion = modulus_quadratic_form(T))\n                                                                -> ZZGenus\n\nReturn the genus of an integer lattice whose discriminant group has the bilinear form of T, the given signature_pair and the given parity.\n\nThe argument parity is one of the following: either parity == 1 for genera of odd lattices, or parity == 2 for even lattices. By default, parity is set to be as the parity of the quadratic form on T\n\nIf no such genus exists, raise an error.\n\nReference\n\n[Nik79] Corollary 1.9.4 and 1.16.3.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/quad_forms/discriminant_group/#brown_invariant-Tuple{TorQuadModule}","page":"Discriminant Groups","title":"brown_invariant","text":"brown_invariant(self::TorQuadModule) -> Nemo.zzModRingElem\n\nReturn the Brown invariant of this torsion quadratic form.\n\nLet (D,q) be a torsion quadratic module with values in Q / 2Z. The Brown invariant Br(D,q) in Z/8Z is defined by the equation\n\nexp left( frac2 pi i 8 Br(q)right) =\n  frac1sqrtD sum_x in D exp(i pi q(x))\n\nThe Brown invariant is additive with respect to direct sums of torsion quadratic modules.\n\nExamples\n\njulia> L = integer_lattice(gram=matrix(ZZ, [[2,-1,0,0],[-1,2,-1,-1],[0,-1,2,0],[0,-1,0,2]]));\n\njulia> T = Hecke.discriminant_group(L);\n\njulia> brown_invariant(T)\n4\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/quad_forms/discriminant_group/#is_genus-Tuple{TorQuadModule, Tuple{Int64, Int64}}","page":"Discriminant Groups","title":"is_genus","text":"is_genus(T::TorQuadModule, signature_pair::Tuple{Int, Int};\n                           parity::RationalUnion = modulus_quadratic_form(T)) -> Bool\n\nReturn if there is an integral lattice whose discriminant form has the bilinear form of T, whose signatures match signature_pair and which is of parity parity.\n\nThe argument parity is one of the following: either parity == 1 for genera of odd lattices, or parity == 2 for even lattices. By default, parity is set to be as the parity of the quadratic form on T\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/quad_forms/discriminant_group/#Categorical-constructions","page":"Discriminant Groups","title":"Categorical constructions","text":"","category":"section"},{"location":"Hecke/manual/quad_forms/discriminant_group/","page":"Discriminant Groups","title":"Discriminant Groups","text":"direct_sum(x::Vector{TorQuadModule})\ndirect_product(x::Vector{TorQuadModule})\nbiproduct(x::Vector{TorQuadModule})","category":"page"},{"location":"Hecke/manual/quad_forms/discriminant_group/#direct_sum-Tuple{Vector{TorQuadModule}}","page":"Discriminant Groups","title":"direct_sum","text":"direct_sum(x::Vararg{TorQuadModule}) -> TorQuadModule, Vector{TorQuadModuleMap}\ndirect_sum(x::Vector{TorQuadModule}) -> TorQuadModule, Vector{TorQuadModuleMap}\n\nGiven a collection of torsion quadratic modules T_1 ldots T_n, return their direct sum T = T_1oplus ldots oplus T_n, together with the injections T_i to T.\n\nFor objects of type TorQuadModule, finite direct sums and finite direct products agree and they are therefore called biproducts. If one wants to obtain T as a direct product with the projections T to T_i, one should call direct_product(x). If one wants to obtain T as a biproduct with the injections T_i to T and the projections T to T_i, one should call biproduct(x).\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/quad_forms/discriminant_group/#direct_product-Tuple{Vector{TorQuadModule}}","page":"Discriminant Groups","title":"direct_product","text":"direct_product(x::Vararg{TorQuadModule}) -> TorQuadModule, Vector{TorQuadModuleMap}\ndirect_product(x::Vector{TorQuadModule}) -> TorQuadModule, Vector{TorQuadModuleMap}\n\nGiven a collection of torsion quadratic modules T_1 ldots T_n, return their direct product T = T_1times ldots times T_n, together with the projections T to T_i.\n\nFor objects of type TorQuadModule, finite direct sums and finite direct products agree and they are therefore called biproducts. If one wants to obtain T as a direct sum with the inctions T_i to T, one should call direct_sum(x). If one wants to obtain T as a biproduct with the injections T_i to T and the projections T to T_i, one should call biproduct(x).\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/quad_forms/discriminant_group/#biproduct-Tuple{Vector{TorQuadModule}}","page":"Discriminant Groups","title":"biproduct","text":"biproduct(x::Vararg{TorQuadModule}) -> TorQuadModule, Vector{TorQuadModuleMap}, Vector{TorQuadModuleMap}\nbiproduct(x::Vector{TorQuadModule}) -> TorQuadModule, Vector{TorQuadModuleMap}, Vector{TorQuadModuleMap}\n\nGiven a collection of torsion quadratic modules T_1 ldots T_n, return their biproduct T = T_1oplus ldots oplus T_n, together with the injections T_i to T and the projections T to T_i.\n\nFor objects of type TorQuadModule, finite direct sums and finite direct products agree and they are therefore called biproducts. If one wants to obtain T as a direct sum with the inctions T_i to T, one should call direct_sum(x). If one wants to obtain T as a direct product with the projections T to T_i, one should call direct_product(x).\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/quad_forms/discriminant_group/#Submodules","page":"Discriminant Groups","title":"Submodules","text":"","category":"section"},{"location":"Hecke/manual/quad_forms/discriminant_group/","page":"Discriminant Groups","title":"Discriminant Groups","text":"submodules(::TorQuadModule)\nstable_submodules(::TorQuadModule, ::Vector{TorQuadModuleMap})","category":"page"},{"location":"Hecke/manual/quad_forms/discriminant_group/#submodules-Tuple{TorQuadModule}","page":"Discriminant Groups","title":"submodules","text":"submodules(T::TorQuadModule; kw...)\n\nReturn the submodules of T as an iterator. Possible keyword arguments to restrict the submodules:\n\norder::Int: only submodules of order order,\nindex::Int: only submodules of index index,\nsubtype::Vector{Int}: only submodules which are isomorphic as an abelian group to abelian_group(subtype),\nquotype::Vector{Int}: only submodules whose quotient are isomorphic as an abelian to abelian_group(quotype).\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/quad_forms/discriminant_group/#stable_submodules-Tuple{TorQuadModule, Vector{TorQuadModuleMap}}","page":"Discriminant Groups","title":"stable_submodules","text":"stable_submodules(T::TorQuadModule, act::Vector{TorQuadModuleMap}; kw...)\n\nReturn the submodules of T stable under the endomorphisms in act as an iterator. Possible keyword arguments to restrict the submodules:\n\nquotype::Vector{Int}: only submodules whose quotient are isomorphic as an abelian group to abelian_group(quotype).\n\n\n\n\n\n","category":"method"},{"location":"AbstractAlgebra/ring/#Ring-functionality","page":"Ring functionality","title":"Ring functionality","text":"","category":"section"},{"location":"AbstractAlgebra/ring/","page":"Ring functionality","title":"Ring functionality","text":"AbstractAlgebra has both commutative and noncommutative rings. Together we refer to them below as rings.","category":"page"},{"location":"AbstractAlgebra/ring/#Abstract-types-for-rings","page":"Ring functionality","title":"Abstract types for rings","text":"","category":"section"},{"location":"AbstractAlgebra/ring/","page":"Ring functionality","title":"Ring functionality","text":"All commutative ring types in AbstractAlgebra belong to the Ring abstract type and commutative ring elements belong to the RingElem abstract type.","category":"page"},{"location":"AbstractAlgebra/ring/","page":"Ring functionality","title":"Ring functionality","text":"Noncommutative ring types belong to the NCRing abstract type and their elements to NCRingElem.","category":"page"},{"location":"AbstractAlgebra/ring/","page":"Ring functionality","title":"Ring functionality","text":"As Julia types cannot belong to our RingElem type hierarchy, we also provide the union type RingElement which includes RingElem in union with the Julia types Integer, Rational and AbstractFloat.","category":"page"},{"location":"AbstractAlgebra/ring/","page":"Ring functionality","title":"Ring functionality","text":"Similarly NCRingElement includes the Julia types just mentioned in union with NCRingElem.","category":"page"},{"location":"AbstractAlgebra/ring/","page":"Ring functionality","title":"Ring functionality","text":"Note that","category":"page"},{"location":"AbstractAlgebra/ring/","page":"Ring functionality","title":"Ring functionality","text":"Ring <: NCRing\nRingElem <: NCRingElem\nRingElement <: NCRingElement","category":"page"},{"location":"AbstractAlgebra/ring/#Functions-for-types-and-parents-of-rings","page":"Ring functionality","title":"Functions for types and parents of rings","text":"","category":"section"},{"location":"AbstractAlgebra/ring/","page":"Ring functionality","title":"Ring functionality","text":"parent_type(::Type{T}) where T <: NCRingElement\nelem_type(::Type{T}) where T <: NCRing","category":"page"},{"location":"AbstractAlgebra/ring/","page":"Ring functionality","title":"Ring functionality","text":"Return the type of the parent (resp. element) type corresponding to the given ring element (resp. parent) type.","category":"page"},{"location":"AbstractAlgebra/ring/","page":"Ring functionality","title":"Ring functionality","text":"base_ring(R::NCRing)\nbase_ring(a::NCRingElement)","category":"page"},{"location":"AbstractAlgebra/ring/","page":"Ring functionality","title":"Ring functionality","text":"For generic ring constructions over a base ring (e.g. polynomials over a coefficient ring), return the parent object of that base ring.","category":"page"},{"location":"AbstractAlgebra/ring/","page":"Ring functionality","title":"Ring functionality","text":"parent(a::NCRingElement)","category":"page"},{"location":"AbstractAlgebra/ring/","page":"Ring functionality","title":"Ring functionality","text":"Return the parent of the given ring element.","category":"page"},{"location":"AbstractAlgebra/ring/","page":"Ring functionality","title":"Ring functionality","text":"is_domain_type(::Type{T}) where T <: NCRingElement\nis_exact_type(::Type{T}) where T <: NCRingElement","category":"page"},{"location":"AbstractAlgebra/ring/","page":"Ring functionality","title":"Ring functionality","text":"Return true if the given ring element type can only belong to elements of an integral domain or exact ring respectively. (An exact ring is one whose elements are represented exactly in the system without approximation.)","category":"page"},{"location":"AbstractAlgebra/ring/","page":"Ring functionality","title":"Ring functionality","text":"The following function is implemented where mathematically and algorithmically possible.","category":"page"},{"location":"AbstractAlgebra/ring/","page":"Ring functionality","title":"Ring functionality","text":"characteristic(R::NCRing)","category":"page"},{"location":"AbstractAlgebra/ring/#Constructors","page":"Ring functionality","title":"Constructors","text":"","category":"section"},{"location":"AbstractAlgebra/ring/","page":"Ring functionality","title":"Ring functionality","text":"If R is a parent object of a ring in AbstractAlgebra, it can always be used to construct certain objects in that ring.","category":"page"},{"location":"AbstractAlgebra/ring/","page":"Ring functionality","title":"Ring functionality","text":"(R::NCRing)() # constructs zero\n(R::NCRing)(c::Integer)\n(R::NCRing)(c::elem_type(R))\n(R::NCRing{T})(a::T) where T <: RingElement","category":"page"},{"location":"AbstractAlgebra/ring/#Basic-functions","page":"Ring functionality","title":"Basic functions","text":"","category":"section"},{"location":"AbstractAlgebra/ring/","page":"Ring functionality","title":"Ring functionality","text":"All rings in AbstractAlgebra are expected to implement basic ring operations, unary minus, binary addition, subtraction and multiplication, equality testing, powering.","category":"page"},{"location":"AbstractAlgebra/ring/","page":"Ring functionality","title":"Ring functionality","text":"In addition, the following are implemented for parents/elements just as they would be in Julia for types/objects.","category":"page"},{"location":"AbstractAlgebra/ring/","page":"Ring functionality","title":"Ring functionality","text":"zero(R::NCRing)\none(R::NCRing)\niszero(a::NCRingElement)\nisone(a::NCRingElement)","category":"page"},{"location":"AbstractAlgebra/ring/","page":"Ring functionality","title":"Ring functionality","text":"In addition, the following are implemented where it is mathematically/algorithmically viable to do so.","category":"page"},{"location":"AbstractAlgebra/ring/","page":"Ring functionality","title":"Ring functionality","text":"is_unit(a::NCRingElement)\nis_zero_divisor(a::NCRingElement)\nis_zero_divisor_with_annihilator(a::NCRingElement)","category":"page"},{"location":"AbstractAlgebra/ring/","page":"Ring functionality","title":"Ring functionality","text":"The following standard Julia functions are also implemented for all ring elements.","category":"page"},{"location":"AbstractAlgebra/ring/","page":"Ring functionality","title":"Ring functionality","text":"hash(f::RingElement, h::UInt)\ndeepcopy_internal(a::RingElement, dict::IdDict)\nshow(io::IO, R::NCRing)\nshow(io::IO, a::NCRingElement)","category":"page"},{"location":"AbstractAlgebra/ring/#Basic-functionality-for-inexact-rings-only","page":"Ring functionality","title":"Basic functionality for inexact rings only","text":"","category":"section"},{"location":"AbstractAlgebra/ring/","page":"Ring functionality","title":"Ring functionality","text":"By default, inexact ring elements in AbstractAlgebra compare equal if they are the same to the minimum precision of the two elements. However, we also provide the following more strict notion of equality, which also requires the precisions to be the same.","category":"page"},{"location":"AbstractAlgebra/ring/","page":"Ring functionality","title":"Ring functionality","text":"isequal(a::T, b::T) where T <: NCRingElement","category":"page"},{"location":"AbstractAlgebra/ring/","page":"Ring functionality","title":"Ring functionality","text":"For floating point and ball arithmetic it is sometimes useful to be able to check if two elements are approximately equal, e.g. to suppress numerical noise in comparisons. For this, the following are provided.","category":"page"},{"location":"AbstractAlgebra/ring/","page":"Ring functionality","title":"Ring functionality","text":"isapprox(a::T, b::T; atol::Real=sqrt(eps())) where T <: RingElement","category":"page"},{"location":"AbstractAlgebra/ring/","page":"Ring functionality","title":"Ring functionality","text":"Similarly, for a parameterised ring with type MyElem{T} over such an inexact ring we have the following.","category":"page"},{"location":"AbstractAlgebra/ring/","page":"Ring functionality","title":"Ring functionality","text":"isapprox(a::MyElem{T}, b::T; atol::Real=sqrt(eps())) where T <: RingElement\nisapprox(a::T, b::MyElem{T}; atol::Real=sqrt(eps())) where T <: RingElement","category":"page"},{"location":"AbstractAlgebra/ring/","page":"Ring functionality","title":"Ring functionality","text":"These notionally perform a coercion into the parameterised ring before doing the approximate equality test.","category":"page"},{"location":"AbstractAlgebra/ring/#Basic-functionality-for-commutative-rings-only","page":"Ring functionality","title":"Basic functionality for commutative rings only","text":"","category":"section"},{"location":"AbstractAlgebra/ring/","page":"Ring functionality","title":"Ring functionality","text":"divexact(a::T, b::T) where T <: RingElement\ninv(a::T)","category":"page"},{"location":"AbstractAlgebra/ring/","page":"Ring functionality","title":"Ring functionality","text":"Return a/b or 1/a respectively, where the slash here refers to the mathematical notion of division in the ring, not Julia's floating point division operator.","category":"page"},{"location":"AbstractAlgebra/ring/#Basic-functionality-for-noncommutative-rings-only","page":"Ring functionality","title":"Basic functionality for noncommutative rings only","text":"","category":"section"},{"location":"AbstractAlgebra/ring/","page":"Ring functionality","title":"Ring functionality","text":"divexact_left(a::T, b::T) where T <: NCRingElement\ndivexact_right(a::T, b::T) where T <: NCRingElement","category":"page"},{"location":"AbstractAlgebra/ring/","page":"Ring functionality","title":"Ring functionality","text":"As per divexact above, except that division by b happens on the left or right, respectively, of a.","category":"page"},{"location":"AbstractAlgebra/ring/#Unsafe-ring-operators","page":"Ring functionality","title":"Unsafe ring operators","text":"","category":"section"},{"location":"AbstractAlgebra/ring/","page":"Ring functionality","title":"Ring functionality","text":"To speed up polynomial and matrix arithmetic, it sometimes makes sense to mutate values in place rather than replace them with a newly created object every time they are modified.","category":"page"},{"location":"AbstractAlgebra/ring/","page":"Ring functionality","title":"Ring functionality","text":"For this purpose, certain mutating operators are required. In order to support immutable types (struct in Julia) and systems that don't have in-place operators, all unsafe operators must return the (ostensibly) mutated value. Only the returned value is used in computations, so this lifts the requirement that the unsafe operators actually mutate the value.","category":"page"},{"location":"AbstractAlgebra/ring/","page":"Ring functionality","title":"Ring functionality","text":"Note the exclamation point is a convention, which indicates that the object may be mutated in-place.","category":"page"},{"location":"AbstractAlgebra/ring/","page":"Ring functionality","title":"Ring functionality","text":"To make use of these functions, one must be certain that no other references are held to the object being mutated, otherwise those values will also be changed!","category":"page"},{"location":"AbstractAlgebra/ring/","page":"Ring functionality","title":"Ring functionality","text":"The results of deepcopy and all arithmetic operations, including powering and division can be assumed to be new objects without other references being held, as can objects returned from constructors.","category":"page"},{"location":"AbstractAlgebra/ring/","page":"Ring functionality","title":"Ring functionality","text":"note: Note\nIt is important to recognise that R(a) where R is the ring a belongs to, does not create a new value. For this case, use deepcopy(a).","category":"page"},{"location":"AbstractAlgebra/ring/","page":"Ring functionality","title":"Ring functionality","text":"zero!\none!\nadd!\nsub!\nmul!\nneg!\ninv!\naddmul!\nsubmul!\ndivexact!\ndiv!\nrem!\nmod!\ngcd!\nlcm!","category":"page"},{"location":"AbstractAlgebra/ring/#zero!","page":"Ring functionality","title":"zero!","text":"zero!(a)\n\nReturn zero(parent(a)), possibly modifying the object a in the process.\n\n\n\n\n\n","category":"function"},{"location":"AbstractAlgebra/ring/#one!","page":"Ring functionality","title":"one!","text":"one!(a)\n\nReturn one(parent(a)), possibly modifying the object a in the process.\n\n\n\n\n\n","category":"function"},{"location":"AbstractAlgebra/ring/#add!","page":"Ring functionality","title":"add!","text":"add!(z, a, b)\nadd!(a, b)\n\nReturn a + b, possibly modifying the object z in the process. Aliasing is permitted. The two argument version is a shorthand for add!(a, a, b).\n\n\n\n\n\n","category":"function"},{"location":"AbstractAlgebra/ring/#sub!","page":"Ring functionality","title":"sub!","text":"sub!(z, a, b)\nsub!(a, b)\n\nReturn a - b, possibly modifying the object z in the process. Aliasing is permitted. The two argument version is a shorthand for sub!(a, a, b).\n\n\n\n\n\n","category":"function"},{"location":"AbstractAlgebra/ring/#mul!","page":"Ring functionality","title":"mul!","text":"mul!(z, a, b)\nmul!(a, b)\n\nReturn a * b, possibly modifying the object z in the process. Aliasing is permitted. The two argument version is a shorthand for mul!(a, a, b).\n\n\n\n\n\n","category":"function"},{"location":"AbstractAlgebra/ring/#neg!","page":"Ring functionality","title":"neg!","text":"neg!(z, a)\nneg!(a)\n\nReturn -a, possibly modifying the object z in the process. Aliasing is permitted. The unary version is a shorthand for neg!(a, a).\n\n\n\n\n\n","category":"function"},{"location":"AbstractAlgebra/ring/#inv!","page":"Ring functionality","title":"inv!","text":"inv!(z, a)\ninv!(a)\n\nReturn AbstractAlgebra.inv(a), possibly modifying the object z in the process. Aliasing is permitted. The unary version is a shorthand for inv!(a, a).\n\nnote: Note\nAbstractAlgebra.inv and Base.inv differ only in their behavior on julia types like Integer and Rational{Int}. The former makes it adhere to the Ring interface.\n\n\n\n\n\n","category":"function"},{"location":"AbstractAlgebra/ring/#addmul!","page":"Ring functionality","title":"addmul!","text":"addmul!(z, a, b, t)\naddmul!(z, a, b)\n\nReturn z + a * b, possibly modifying the objects z and t in the process.\n\nThe second version is usually a shorthand for addmul!(z, a, b, parent(z)()), but in some cases may be more efficient. For multiple operations in a row that use temporary storage, it is still best to use the four argument version.\n\n\n\n\n\n","category":"function"},{"location":"AbstractAlgebra/ring/#submul!","page":"Ring functionality","title":"submul!","text":"submul!(z, a, b, t)\nsubmul!(z, a, b)\n\nReturn z - a * b, possibly modifying the objects z and t in the process.\n\nThe second version is usually a shorthand for submul!(z, a, b, parent(z)()), but in some cases may be more efficient. For multiple operations in a row that use temporary storage, it is still best to use the four argument version.\n\n\n\n\n\n","category":"function"},{"location":"AbstractAlgebra/ring/#divexact!","page":"Ring functionality","title":"divexact!","text":"divexact!(A::Generic.Mat{AbsSimpleNumFieldElem}, p::ZZRingElem)\n\nInplace: divide each entry of A by p.\n\n\n\n\n\ndivexact!(z, a, b)\ndivexact!(a, b)\n\nReturn divexact(a, b), possibly modifying the object z in the process. Aliasing is permitted. The two argument version is a shorthand for divexact(a, a, b).\n\n\n\n\n\n","category":"function"},{"location":"AbstractAlgebra/ring/#div!","page":"Ring functionality","title":"div!","text":"div!(z, a, b)\ndiv!(a, b)\n\nReturn div(a, b), possibly modifying the object z in the process. Aliasing is permitted. The two argument version is a shorthand for div(a, a, b).\n\nnote: Note\nAbstractAlgebra.div and Base.div differ only in their behavior on julia types like Integer and Rational{Int}. The former makes it adhere to the Ring interface.\n\n\n\n\n\n","category":"function"},{"location":"AbstractAlgebra/ring/#rem!","page":"Ring functionality","title":"rem!","text":"rem!(z, a, b)\nrem!(a, b)\n\nReturn rem(a, b), possibly modifying the object z in the process. Aliasing is permitted. The two argument version is a shorthand for rem(a, a, b).\n\n\n\n\n\n","category":"function"},{"location":"AbstractAlgebra/ring/#mod!","page":"Ring functionality","title":"mod!","text":"mod!(M::ZZMatrix, p::ZZRingElem)\n\nReduces every entry modulo p in-place, i.e. applies the mod function to every entry. Positive residue system.\n\n\n\n\n\nmod!(A::Generic.Mat{AbsSimpleNumFieldElem}, m::ZZRingElem)\n\nInplace: reduce all entries of A modulo m, into the positive residue system.\n\n\n\n\n\nmod!(z, a, b)\nmod!(a, b)\n\nReturn mod(a, b), possibly modifying the object z in the process. Aliasing is permitted. The two argument version is a shorthand for mod(a, a, b).\n\n\n\n\n\nmod!(A::SRow{ZZRingElem}, n::Integer) -> SRow{ZZRingElem}\n\nInplace reduction of all entries of A modulo n to the positive residue system.\n\n\n\n\n\nmod!(A::SRow{ZZRingElem}, n::ZZRingElem) -> SRow{ZZRingElem}\n\nInplace reduction of all entries of A modulo n to the positive residue system.\n\n\n\n\n\n","category":"function"},{"location":"AbstractAlgebra/ring/#gcd!","page":"Ring functionality","title":"gcd!","text":"gcd!(z, a, b)\ngcd!(a, b)\n\nReturn gcd(a, b), possibly modifying the object z in the process. Aliasing is permitted. The two argument version is a shorthand for gcd(a, a, b).\n\n\n\n\n\n","category":"function"},{"location":"AbstractAlgebra/ring/#lcm!","page":"Ring functionality","title":"lcm!","text":"lcm!(z, a, b)\nlcm!(a, b)\n\nReturn lcm(a, b), possibly modifying the object z in the process. Aliasing is permitted. The two argument version is a shorthand for lcm(a, a, b).\n\n\n\n\n\n","category":"function"},{"location":"AbstractAlgebra/ring/#Random-generation","page":"Ring functionality","title":"Random generation","text":"","category":"section"},{"location":"AbstractAlgebra/ring/","page":"Ring functionality","title":"Ring functionality","text":"The Julia random interface is implemented for all ring parents (instead of for types). The exact interface differs depending on the ring, but the parameters supplied are usually ranges, e.g. -1:10 for the range of allowed degrees for a univariate polynomial.","category":"page"},{"location":"AbstractAlgebra/ring/","page":"Ring functionality","title":"Ring functionality","text":"rand(R::NCRing, v...)","category":"page"},{"location":"AbstractAlgebra/ring/#Factorization","page":"Ring functionality","title":"Factorization","text":"","category":"section"},{"location":"AbstractAlgebra/ring/","page":"Ring functionality","title":"Ring functionality","text":"For commutative rings supporting factorization and irreducibility testing, the following optional functions may be implemented.","category":"page"},{"location":"AbstractAlgebra/ring/","page":"Ring functionality","title":"Ring functionality","text":"is_irreducible(a::T) where T <: RingElement\nis_squarefree(a::T) where T <: RingElement","category":"page"},{"location":"AbstractAlgebra/ring/#is_irreducible-Tuple{T} where T<:RingElement","page":"Ring functionality","title":"is_irreducible","text":"is_irreducible(a::RingElement)\n\nReturn true if a is irreducible, else return false. Zero and units are by definition never irreducible.\n\n\n\n\n\n","category":"method"},{"location":"AbstractAlgebra/ring/#is_squarefree-Tuple{T} where T<:RingElement","page":"Ring functionality","title":"is_squarefree","text":"is_squarefree(a::RingElement)\n\nReturn true if a is squarefree, else return false. An element is squarefree if it it is not divisible by any squares except the squares of units.\n\n\n\n\n\n","category":"method"},{"location":"AbstractAlgebra/ring/","page":"Ring functionality","title":"Ring functionality","text":"factor(a::T) where T <: RingElement\nfactor_squarefree(a::T) where T <: RingElement","category":"page"},{"location":"AbstractAlgebra/ring/","page":"Ring functionality","title":"Ring functionality","text":"Return a factorization into irreducible or squarefree elements, respectively. The return is an object of type Fac{T}.","category":"page"},{"location":"AbstractAlgebra/ring/","page":"Ring functionality","title":"Ring functionality","text":"Fac\nunit(a::Fac)\nevaluate(a::Fac)\ngetindex(a::Fac, b)\nsetindex!(a::Fac{Int}, c::Int, b::Int)","category":"page"},{"location":"AbstractAlgebra/ring/#Fac","page":"Ring functionality","title":"Fac","text":"Fac{T <: RingElement}\n\nType for factored ring elements. The structure holds a unit of type T and is an iterable collection of T => Int pairs for the factors and exponents.\n\nSee unit(a::Fac), evaluate(a::Fac).\n\n\n\n\n\n","category":"type"},{"location":"AbstractAlgebra/ring/#unit-Tuple{Fac}","page":"Ring functionality","title":"unit","text":"unit(a::Fac{T}) -> T\n\nReturn the unit of the factorization.\n\n\n\n\n\n","category":"method"},{"location":"AbstractAlgebra/ring/#evaluate-Tuple{Fac}","page":"Ring functionality","title":"evaluate","text":"evaluate(a::Fac{T}) -> T\n\nMultiply out the factorization into a single element.\n\n\n\n\n\n","category":"method"},{"location":"AbstractAlgebra/ring/#getindex-Tuple{Fac, Any}","page":"Ring functionality","title":"getindex","text":"getindex(a::Fac, b) -> Int\n\nIf b is a factor of a, the corresponding exponent is returned. Otherwise an error is thrown.\n\n\n\n\n\n","category":"method"},{"location":"AbstractAlgebra/ring/#setindex!-Tuple{Fac{Int64}, Int64, Int64}","page":"Ring functionality","title":"setindex!","text":"setindex!(a::Fac{T}, c::Int, b::T)\n\nIf b is a factor of a, the corresponding entry is set to c.\n\n\n\n\n\n","category":"method"},{"location":"NumberTheory/vinberg/","page":"Vinberg's algorithm","title":"Vinberg's algorithm","text":"CurrentModule = Oscar\nDocTestSetup = Oscar.doctestsetup()","category":"page"},{"location":"NumberTheory/vinberg/#Vinberg's-algorithm","page":"Vinberg's algorithm","title":"Vinberg's algorithm","text":"","category":"section"},{"location":"NumberTheory/vinberg/","page":"Vinberg's algorithm","title":"Vinberg's algorithm","text":"A Lorentzian lattice L is an integral Z-lattice of signature (s_+ s_-) with s_+=1 and s_-0.   A root of r in L is a primitive vector s.t. reflection in the hyperplane r^perp maps L to itself.  Let W(L)leq O(L) be the Weyl group, that is the group generated by reflections in the root hyperplanes of L.   We say that L is reflective if W(L) is of finite index in O(L).   For xy in L we write xy=Phi(xy) and x^2=Phi(xx) for the symmetric bilinear form in L.","category":"page"},{"location":"NumberTheory/vinberg/","page":"Vinberg's algorithm","title":"Vinberg's algorithm","text":"See for example [Tur18] for the theory of Arithmetic Reflection Groups and Reflective Lorentzian Lattices.","category":"page"},{"location":"NumberTheory/vinberg/#Description","page":"Vinberg's algorithm","title":"Description","text":"","category":"section"},{"location":"NumberTheory/vinberg/","page":"Vinberg's algorithm","title":"Vinberg's algorithm","text":"Vinberg's algorithm constructs a fundamental polyhedron P for a Lorentzian lattice L by computing its fundamental roots r, i.e. the roots r which are perpendicular to the faces of P and which have inner product at least 0 with the elements of P.  Choose v_0 in L primitive with v_0^2  0 as a point that P should contain.","category":"page"},{"location":"NumberTheory/vinberg/","page":"Vinberg's algorithm","title":"Vinberg's algorithm","text":"Let Q be the Gram matrix of L with respect to some basis. A vector r is a fundamental root, if","category":"page"},{"location":"NumberTheory/vinberg/","page":"Vinberg's algorithm","title":"Vinberg's algorithm","text":"the vector r is primitive,\nreflection by r preserves the lattice, i.e. frac2r^2 r Q is an integer matrix,\nthe pair (r v_0) is positive oriented, i.e. r v_0  0,\nthe product r r geq  0 for all roots r already found.","category":"page"},{"location":"NumberTheory/vinberg/","page":"Vinberg's algorithm","title":"Vinberg's algorithm","text":"This implies that r^2 divides 2 i for i being the level of Q, i.e. the last invariant of the Smith normal form of Q. ","category":"page"},{"location":"NumberTheory/vinberg/","page":"Vinberg's algorithm","title":"Vinberg's algorithm","text":"P can be constructed by solving rv_0 = n and r^2 = k by increasing order of the value fracn^2k and r satisfying the above conditions.","category":"page"},{"location":"NumberTheory/vinberg/","page":"Vinberg's algorithm","title":"Vinberg's algorithm","text":"If v_0 lies on a root hyperplane, then P is not uniquely determined.  In that case we need a direction vector v_1 which satisfies v v_1 neq 0   for all possible roots v with v_0 v = 0  ","category":"page"},{"location":"NumberTheory/vinberg/","page":"Vinberg's algorithm","title":"Vinberg's algorithm","text":"With v_0 and v_1 fixed P is uniquely determined for any choice of root lengths and maximal distance v_0r.  We choose the first roots r by increasing order of the value fracr v_1r^2 for all possible roots v with v_0 v = 0.  For any other root length we continue as stated above.","category":"page"},{"location":"NumberTheory/vinberg/","page":"Vinberg's algorithm","title":"Vinberg's algorithm","text":"For proofs of the statements above and further explanations see [Vin75].","category":"page"},{"location":"NumberTheory/vinberg/#Function","page":"Vinberg's algorithm","title":"Function","text":"","category":"section"},{"location":"NumberTheory/vinberg/","page":"Vinberg's algorithm","title":"Vinberg's algorithm","text":"vinberg_algorithm","category":"page"},{"location":"NumberTheory/vinberg/#vinberg_algorithm","page":"Vinberg's algorithm","title":"vinberg_algorithm","text":"vinberg_algorithm(Q::ZZMatrix, upper_bound; v0::ZZMatrix, root_lengths::Vector{ZZRingElem}, direction_vector::ZZMatrix) -> Vector{ZZMatrix}\n\nReturn the fundamental roots r of a given hyperbolic reflection lattice with standard basis represented by its corresponding Gram matrix Q with  squared length contained in root_lengths and by increasing order of the value fracrv_0)^2r^2, stopping at upper_bound. If root_lengths is not defined it takes all possible values of r^2. If v0 lies on a root hyperplane and if there is no given direction_vector it is a random choice which reflection chamber next to v0 will be computed.\n\nArguments\n\nQ: symmetric Z matrix of signature (1 n) – the corresponding Gram matrix\nupper_bound: the upper bound of the value frac(rv_0^2r^2\nv0: primitive row vector with v_0^2  0\nroot_lengths: the possible integer values of r^2\ndirection_vector: row vector v1 with v_0v_1 = 0 and vv_1 neq 0 for all possible roots v with vv_0 = 0\n\n\n\n\n\nvinberg_algorithm(S::ZZLat, upper_bound; v0::ZZMatrix, root_lengths::Vector{ZZRingElem}, direction_vector::ZZMatrix) -> Vector{ZZMatrix}\n\nReturn the fundamental roots r of a given hyperbolic reflection lattice S with standard basis with squared length contained  in root_lengths and by increasing order of the value fracrv_0)^2r^2, stopping at upper_bound. If root_lengths is not defined it takes all possible values of r^2. If v0 lies on a root hyperplane and if there is no given direction_vector,  then it is a random choice which reflection chamber next to v0 will be computed.\n\nArguments\n\nS: a hyperbolic Z-lattice of signature (10n).\nupper_bound: the upper bound of the value frac(rv_0^2r^2\nv0: primitive row vector with v_0^2  0 given w.r.t. the ambient space\nroot_lengths: the possible integer values of r^2\ndirection_vector: row vector v1 with v_0v_1 = 0 and vv_1 neq 0 for all possible roots v with vv_0 = 0, given w.r.t. the ambient space\ndivisibilities: a dictionary; The keys are the root lengths and the values are the divisibilities for the given root length. If given requires that a fundamental root r has one of the specified divisibilities.\n\n\n\n\n\n","category":"function"},{"location":"NumberTheory/vinberg/#Contact","page":"Vinberg's algorithm","title":"Contact","text":"","category":"section"},{"location":"NumberTheory/vinberg/","page":"Vinberg's algorithm","title":"Vinberg's algorithm","text":"Please direct questions about this part of OSCAR to the following people:","category":"page"},{"location":"NumberTheory/vinberg/","page":"Vinberg's algorithm","title":"Vinberg's algorithm","text":"Simon Brandhorst.\nStevell Muller,","category":"page"},{"location":"NumberTheory/vinberg/","page":"Vinberg's algorithm","title":"Vinberg's algorithm","text":"You can ask questions in the OSCAR Slack.","category":"page"},{"location":"NumberTheory/vinberg/","page":"Vinberg's algorithm","title":"Vinberg's algorithm","text":"Alternatively, you can raise an issue on github.","category":"page"},{"location":"CommutativeAlgebra/ModulesOverMultivariateRings/module_operations/","page":"Operations on Modules","title":"Operations on Modules","text":"CurrentModule = Oscar","category":"page"},{"location":"CommutativeAlgebra/ModulesOverMultivariateRings/module_operations/#Operations-on-Modules","page":"Operations on Modules","title":"Operations on Modules","text":"","category":"section"},{"location":"CommutativeAlgebra/ModulesOverMultivariateRings/module_operations/#Subquotients-Related-to-Homomorphisms","page":"Operations on Modules","title":"Subquotients Related to Homomorphisms","text":"","category":"section"},{"location":"CommutativeAlgebra/ModulesOverMultivariateRings/module_operations/#Kernel","page":"Operations on Modules","title":"Kernel","text":"","category":"section"},{"location":"CommutativeAlgebra/ModulesOverMultivariateRings/module_operations/","page":"Operations on Modules","title":"Operations on Modules","text":"kernel(a::ModuleFPHom)","category":"page"},{"location":"CommutativeAlgebra/ModulesOverMultivariateRings/module_operations/#kernel-Tuple{ModuleFPHom}","page":"Operations on Modules","title":"kernel","text":"kernel(a::ModuleFPHom)\n\nReturn the kernel of a as an object of type SubquoModule.\n\nAdditionally, if K denotes this object, return the inclusion map K to domain(a).\n\nExamples\n\njulia> R, (x, y, z) = polynomial_ring(QQ, [:x, :y, :z]);\n\njulia> F = free_module(R, 3);\n\njulia> G = free_module(R, 2);\n\njulia> W = R[y 0; x y; 0 z]\n[y   0]\n[x   y]\n[0   z]\n\njulia> a = hom(F, G, W);\n\njulia> K, incl = kernel(a);\n\njulia> K\nSubmodule with 1 generator\n  1: x*z*e[1] - y*z*e[2] + y^2*e[3]\nrepresented as subquotient with no relations\n\njulia> incl\nModule homomorphism\n  from K\n  to F\n\njulia> R, (x, y, z) = polynomial_ring(QQ, [:x, :y, :z]);\n\njulia> F = free_module(R, 1);\n\njulia> A = R[x; y]\n[x]\n[y]\n\njulia> B = R[x^2; y^3; z^4]\n[x^2]\n[y^3]\n[z^4]\n\njulia> M = SubquoModule(F, A, B)\nSubquotient of submodule with 2 generators\n  1: x*e[1]\n  2: y*e[1]\nby submodule with 3 generators\n  1: x^2*e[1]\n  2: y^3*e[1]\n  3: z^4*e[1]\n\njulia> N = M;\n\njulia> V = [y^2*N[1], x*N[2]]\n2-element Vector{SubquoModuleElem{QQMPolyRingElem}}:\n x*y^2*e[1]\n x*y*e[1]\n\njulia> a = hom(M, N, V);\n\njulia> K, incl = kernel(a);\n\njulia> K\nSubquotient of submodule with 3 generators\n  1: (-x + y^2)*e[1]\n  2: x*y*e[1]\n  3: -x*y*e[1]\nby submodule with 3 generators\n  1: x^2*e[1]\n  2: y^3*e[1]\n  3: z^4*e[1]\n\njulia> incl\nModule homomorphism\n  from K\n  to M\n\njulia> Rg, (x, y, z) = graded_polynomial_ring(QQ, [:x, :y, :z]);\n\njulia> F = graded_free_module(Rg, 1);\n\njulia> A = Rg[x; y];\n\njulia> B = Rg[x^2; y^3; z^4];\n\njulia> M = SubquoModule(F, A, B)\nGraded subquotient of graded submodule of F with 2 generators\n  1: x*e[1]\n  2: y*e[1]\nby graded submodule of F with 3 generators\n  1: x^2*e[1]\n  2: y^3*e[1]\n  3: z^4*e[1]\n\njulia> N = M;\n\njulia> V = [y^2*N[1], x^2*N[2]];\n\njulia> a = hom(M, N, V)\nGraded module homomorphism of degree [2]\n  from M\n  to M\ndefined by\n  x*e[1] -> x*y^2*e[1]\n  y*e[1] -> x^2*y*e[1]\n\njulia> kernel(a)\n(Graded subquotient of graded submodule of F with 2 generators\n  1: y*e[1]\n  2: -x*y*e[1]\nby graded submodule of F with 3 generators\n  1: x^2*e[1]\n  2: y^3*e[1]\n  3: z^4*e[1], Hom: graded subquotient of graded submodule of F with 2 generators\n  1: y*e[1]\n  2: -x*y*e[1]\nby graded submodule of F with 3 generators\n  1: x^2*e[1]\n  2: y^3*e[1]\n  3: z^4*e[1] -> M)\n\n\n\n\n\n\n","category":"method"},{"location":"CommutativeAlgebra/ModulesOverMultivariateRings/module_operations/#Image","page":"Operations on Modules","title":"Image","text":"","category":"section"},{"location":"CommutativeAlgebra/ModulesOverMultivariateRings/module_operations/","page":"Operations on Modules","title":"Operations on Modules","text":"image(a::ModuleFPHom)","category":"page"},{"location":"CommutativeAlgebra/ModulesOverMultivariateRings/module_operations/#image-Tuple{ModuleFPHom}","page":"Operations on Modules","title":"image","text":"image(a::ModuleFPHom)\n\nReturn the image of a as an object of type SubquoModule.\n\nAdditionally, if I denotes this object, return the inclusion map I to codomain(a).\n\nExamples\n\njulia> R, (x, y, z) = polynomial_ring(QQ, [:x, :y, :z]);\n\njulia> F = free_module(R, 3);\n\njulia> G = free_module(R, 2);\n\njulia> W = R[y 0; x y; 0 z]\n[y   0]\n[x   y]\n[0   z]\n\njulia> a = hom(F, G, W);\n\njulia> I, incl = image(a);\n\njulia> I\nSubmodule with 3 generators\n  1: y*e[1]\n  2: x*e[1] + y*e[2]\n  3: z*e[2]\nrepresented as subquotient with no relations\n\njulia> incl\nModule homomorphism\n  from I\n  to G\n\njulia> R, (x, y, z) = polynomial_ring(QQ, [:x, :y, :z]);\n\njulia> F = free_module(R, 1);\n\njulia> A = R[x; y]\n[x]\n[y]\n\njulia> B = R[x^2; y^3; z^4]\n[x^2]\n[y^3]\n[z^4]\n\njulia> M = SubquoModule(F, A, B)\nSubquotient of submodule with 2 generators\n  1: x*e[1]\n  2: y*e[1]\nby submodule with 3 generators\n  1: x^2*e[1]\n  2: y^3*e[1]\n  3: z^4*e[1]\n\njulia> N = M;\n\njulia> V = [y^2*N[1], x*N[2]]\n2-element Vector{SubquoModuleElem{QQMPolyRingElem}}:\n x*y^2*e[1]\n x*y*e[1]\n\njulia> a = hom(M, N, V);\n\njulia> I, incl = image(a);\n\njulia> I\nSubquotient of submodule with 2 generators\n  1: x*y^2*e[1]\n  2: x*y*e[1]\nby submodule with 3 generators\n  1: x^2*e[1]\n  2: y^3*e[1]\n  3: z^4*e[1]\n\njulia> incl\nModule homomorphism\n  from I\n  to M\n\njulia> Rg, (x, y, z) = graded_polynomial_ring(QQ, [:x, :y, :z]);\n\njulia> F = graded_free_module(Rg, 1);\n\njulia> A = Rg[x; y];\n\njulia> B = Rg[x^2; y^3; z^4];\n\njulia> M = SubquoModule(F, A, B)\nGraded subquotient of graded submodule of F with 2 generators\n  1: x*e[1]\n  2: y*e[1]\nby graded submodule of F with 3 generators\n  1: x^2*e[1]\n  2: y^3*e[1]\n  3: z^4*e[1]\n\njulia> N = M;\n\njulia> V = [y^2*N[1], x^2*N[2]];\n\njulia> a = hom(M, N, V)\nGraded module homomorphism of degree [2]\n  from M\n  to M\ndefined by\n  x*e[1] -> x*y^2*e[1]\n  y*e[1] -> x^2*y*e[1]\n\njulia> image(a)\n(Graded subquotient of graded submodule of F with 2 generators\n  1: x*y^2*e[1]\n  2: x^2*y*e[1]\nby graded submodule of F with 3 generators\n  1: x^2*e[1]\n  2: y^3*e[1]\n  3: z^4*e[1], Hom: graded subquotient of graded submodule of F with 2 generators\n  1: x*y^2*e[1]\n  2: x^2*y*e[1]\nby graded submodule of F with 3 generators\n  1: x^2*e[1]\n  2: y^3*e[1]\n  3: z^4*e[1] -> M)\n\n\n\n\n\n","category":"method"},{"location":"CommutativeAlgebra/ModulesOverMultivariateRings/module_operations/#Cokernel","page":"Operations on Modules","title":"Cokernel","text":"","category":"section"},{"location":"CommutativeAlgebra/ModulesOverMultivariateRings/module_operations/","page":"Operations on Modules","title":"Operations on Modules","text":"cokernel(a::ModuleFPHom)","category":"page"},{"location":"CommutativeAlgebra/ModulesOverMultivariateRings/module_operations/#cokernel-Tuple{ModuleFPHom}","page":"Operations on Modules","title":"cokernel","text":"cokernel(a::ModuleFPHom)\n\nReturn the cokernel of a as an object of type SubquoModule.\n\nExamples\n\njulia> R, (x, y, z) = polynomial_ring(QQ, [:x, :y, :z]);\n\njulia> F = free_module(R, 3);\n\njulia> G = free_module(R, 2);\n\njulia> W = R[y 0; x y; 0 z]\n[y   0]\n[x   y]\n[0   z]\n\njulia> a = hom(F, G, W);\n\njulia> cokernel(a)\nSubquotient of submodule with 2 generators\n  1: e[1]\n  2: e[2]\nby submodule with 3 generators\n  1: y*e[1]\n  2: x*e[1] + y*e[2]\n  3: z*e[2]\n\njulia> R, (x, y, z) = polynomial_ring(QQ, [:x, :y, :z]);\n\njulia> F = free_module(R, 1);\n\njulia> A = R[x; y]\n[x]\n[y]\n\njulia> B = R[x^2; y^3; z^4]\n[x^2]\n[y^3]\n[z^4]\n\njulia> M = SubquoModule(F, A, B)\nSubquotient of submodule with 2 generators\n  1: x*e[1]\n  2: y*e[1]\nby submodule with 3 generators\n  1: x^2*e[1]\n  2: y^3*e[1]\n  3: z^4*e[1]\n\njulia> N = M;\n\njulia> V = [y^2*N[1], x*N[2]]\n2-element Vector{SubquoModuleElem{QQMPolyRingElem}}:\n x*y^2*e[1]\n x*y*e[1]\n\njulia> a = hom(M, N, V);\n\njulia> cokernel(a)\nSubquotient of submodule with 2 generators\n  1: x*e[1]\n  2: y*e[1]\nby submodule with 5 generators\n  1: x^2*e[1]\n  2: y^3*e[1]\n  3: z^4*e[1]\n  4: x*y^2*e[1]\n  5: x*y*e[1]\n\njulia> Rg, (x, y, z) = graded_polynomial_ring(QQ, [:x, :y, :z]);\n\njulia> F = graded_free_module(Rg, 3);\n\njulia> G = graded_free_module(Rg, 2);\n\njulia> W = Rg[y 0; x y; 0 z]\n[y   0]\n[x   y]\n[0   z]\n\njulia> a = hom(F, G, W)\nGraded module homomorphism of degree [1]\n  from F\n  to G\ndefined by\n  e[1] -> y*e[1]\n  e[2] -> x*e[1] + y*e[2]\n  e[3] -> z*e[2]\n\njulia> M = cokernel(a)\nGraded subquotient of graded submodule of G with 2 generators\n  1: e[1]\n  2: e[2]\nby graded submodule of G with 3 generators\n  1: y*e[1]\n  2: x*e[1] + y*e[2]\n  3: z*e[2]\n\n\n\n\n\n\ncokernel(F::FreeMod{R}, A::MatElem{R}) where R\n\nReturn the cokernel of A as an object of type SubquoModule with ambient free module F.\n\nExamples\n\njulia> R, (x,y,z) = polynomial_ring(QQ, [:x, :y, :z]);\n\njulia> F = free_module(R, 2)\nFree module of rank 2 over R\n\njulia> A = R[x y; 2*x^2 3*y^2]\n[    x       y]\n[2*x^2   3*y^2]\n \njulia> M = cokernel(F, A)\nSubquotient of submodule with 2 generators\n  1: e[1]\n  2: e[2]\nby submodule with 2 generators\n  1: x*e[1] + y*e[2]\n  2: 2*x^2*e[1] + 3*y^2*e[2]\n\njulia> ambient_free_module(M) === F\ntrue\n\n\njulia> Rg, (x, y, z) = graded_polynomial_ring(QQ, [:x, :y, :z]);\n\njulia> F = graded_free_module(Rg, [8,8])\nGraded free module Rg^2([-8]) of rank 2 over Rg\n\njulia> A = Rg[x y; 2*x^2 3*y^2]\n[    x       y]\n[2*x^2   3*y^2]\n \njulia> M = cokernel(F, A)\nGraded subquotient of graded submodule of F with 2 generators\n  1: e[1]\n  2: e[2]\nby graded submodule of F with 2 generators\n  1: x*e[1] + y*e[2]\n  2: 2*x^2*e[1] + 3*y^2*e[2]\n\njulia> ambient_free_module(M) === F\ntrue\n\njulia> degrees_of_generators(M)\n2-element Vector{FinGenAbGroupElem}:\n [8]\n [8]\n\n\n\n\n\n","category":"method"},{"location":"CommutativeAlgebra/ModulesOverMultivariateRings/module_operations/#Direct-Sums-and-Products","page":"Operations on Modules","title":"Direct Sums and Products","text":"","category":"section"},{"location":"CommutativeAlgebra/ModulesOverMultivariateRings/module_operations/","page":"Operations on Modules","title":"Operations on Modules","text":"direct_sum(M::ModuleFP{T}...; task::Symbol = :sum) where T","category":"page"},{"location":"CommutativeAlgebra/ModulesOverMultivariateRings/module_operations/#direct_sum-Union{Tuple{Vararg{ModuleFP{T}}}, Tuple{T}} where T","page":"Operations on Modules","title":"direct_sum","text":"direct_sum(M::ModuleFP{T}...; task::Symbol = :sum) where T\n\nGiven modules M_1dots M_n, say, return the direct sum bigoplus_i=1^n M_i.  \n\nAdditionally, return \n\na vector containing the canonical injections  M_itobigoplus_i=1^n M_i if task = :sum (default),\na vector containing the canonical projections  bigoplus_i=1^n M_ito M_i if task = :prod,\ntwo vectors containing the canonical injections and projections, respectively, if task = :both,\nnone of the above maps if task = :none.\n\n\n\n\n\n","category":"method"},{"location":"CommutativeAlgebra/ModulesOverMultivariateRings/module_operations/","page":"Operations on Modules","title":"Operations on Modules","text":"direct_product(M::ModuleFP{T}...; task::Symbol = :prod) where T","category":"page"},{"location":"CommutativeAlgebra/ModulesOverMultivariateRings/module_operations/#direct_product-Union{Tuple{Vararg{ModuleFP{T}}}, Tuple{T}} where T","page":"Operations on Modules","title":"direct_product","text":"direct_product(M::ModuleFP{T}...; task::Symbol = :prod) where T\n\nGiven modules M_1dots M_n, say, return the direct product prod_i=1^n M_i.\n\nAdditionally, return\n\na vector containing the canonical projections  prod_i=1^n M_ito M_i if task = :prod (default),\na vector containing the canonical injections  M_itoprod_i=1^n M_i if task = :sum,\ntwo vectors containing the canonical projections and injections, respectively, if task = :both,\nnone of the above maps if task = :none.\n\n\n\n\n\n","category":"method"},{"location":"CommutativeAlgebra/ModulesOverMultivariateRings/module_operations/#Truncation","page":"Operations on Modules","title":"Truncation","text":"","category":"section"},{"location":"CommutativeAlgebra/ModulesOverMultivariateRings/module_operations/","page":"Operations on Modules","title":"Operations on Modules","text":"truncate(M::ModuleFP, g::FinGenAbGroupElem, task::Symbol=:with_morphism)","category":"page"},{"location":"CommutativeAlgebra/ModulesOverMultivariateRings/module_operations/#truncate","page":"Operations on Modules","title":"truncate","text":"truncate(I::ModuleFP, g::FinGenAbGroupElem, task::Symbol=:with_morphism)\n\nGiven a finitely presented graded module M over a mathbb Z-graded multivariate  polynomial ring with positive weights, return the truncation of M at degree g.\n\nPut more precisely, return the truncation as an object of type SubquoModule. \n\nAdditionally, if N denotes this object,\n\nreturn the inclusion map N to M if task = :with_morphism (default),\nreturn and cache the inclusion map N to M if task = :cache_morphism,\ndo none of the above if task = :none.\n\nIf task = :only_morphism, return only the inclusion map.\n\ntruncate(M::ModuleFP, d::Int, task::Symbol = :with_morphism)\n\nGiven a module M as above, and given an integer d, convert d into an element g of the grading group of base_ring(I) and proceed as above.\n\nExamples\n\njulia> R, (x, y, z) = graded_polynomial_ring(QQ, [:x, :y, :z]);\n\njulia> F = graded_free_module(R, 1)\nGraded free module R^1([0]) of rank 1 over R\n\njulia> V = [x*F[1]; y^4*F[1]; z^5*F[1]];\n\njulia> M, _ = quo(F, V);\n\njulia> M[1]\ne[1]\n\njulia> MT = truncate(M, 3);\n\njulia> MT[1]\nGraded subquotient of graded submodule of F with 10 generators\n  1: z^3*e[1]\n  2: y*z^2*e[1]\n  3: y^2*z*e[1]\n  4: y^3*e[1]\n  5: x*z^2*e[1]\n  6: x*y*z*e[1]\n  7: x*y^2*e[1]\n  8: x^2*z*e[1]\n  9: x^2*y*e[1]\n  10: x^3*e[1]\nby graded submodule of F with 3 generators\n  1: x*e[1]\n  2: y^4*e[1]\n  3: z^5*e[1]\n\n\n\n\n\n","category":"function"},{"location":"CommutativeAlgebra/ModulesOverMultivariateRings/module_operations/#Twists","page":"Operations on Modules","title":"Twists","text":"","category":"section"},{"location":"CommutativeAlgebra/ModulesOverMultivariateRings/module_operations/","page":"Operations on Modules","title":"Operations on Modules","text":"In the graded case, we have:","category":"page"},{"location":"CommutativeAlgebra/ModulesOverMultivariateRings/module_operations/","page":"Operations on Modules","title":"Operations on Modules","text":"twist(M::ModuleFP{T}, g::FinGenAbGroupElem) where {T<:MPolyDecRingElem}","category":"page"},{"location":"CommutativeAlgebra/ModulesOverMultivariateRings/module_operations/#twist-Union{Tuple{T}, Tuple{ModuleFP{T}, FinGenAbGroupElem}} where T<:MPolyDecRingElem","page":"Operations on Modules","title":"twist","text":"twist(M::ModuleFP{T}, g::FinGenAbGroupElem) where {T<:MPolyDecRingElem}\n\nReturn the twisted module M(g).\n\ntwist(M::ModuleFP{T}, W::Vector{<:IntegerUnion}) where {T<:MPolyDecRingElem}\n\nGiven a module M over a mathbb Z^m-graded polynomial ring and a vector W of m integers,  convert W into an element g of the grading group of the ring and proceed as above.\n\ntwist(M::ModuleFP{T}, d::IntegerUnion) where {T<:MPolyDecRingElem}\n\nGiven a module M over a mathbb Z-graded polynomial ring and an integer d,  convert d into an element g of the grading group of the ring and proceed as above.\n\nExamples\n\njulia> R, (x, y) = graded_polynomial_ring(QQ, [:x, :y]);\n\njulia> I = ideal(R, [zero(R)])\nIdeal generated by\n  0\n\njulia> M = quotient_ring_as_module(I)\nGraded submodule of R^1 with 1 generator\n  1: e[1]\nrepresented as subquotient with no relations\n\njulia> degree(gen(M, 1))\n[0]\n\njulia> N = twist(M, 2)\nGraded submodule of R^1 with 1 generator\n  1: e[1]\nrepresented as subquotient with no relations\n\njulia> degree(gen(N, 1))\n[-2]\n\n\n\n\n\n\n","category":"method"},{"location":"DeveloperDocumentation/styleguide/#Developer-Style-Guide","page":"Developer Style Guide","title":"Developer Style Guide","text":"","category":"section"},{"location":"DeveloperDocumentation/styleguide/","page":"Developer Style Guide","title":"Developer Style Guide","text":"In general we aim to follow the Julia Style Guide but there are some exceptions due to our specific needs and a different background.","category":"page"},{"location":"DeveloperDocumentation/styleguide/","page":"Developer Style Guide","title":"Developer Style Guide","text":"The content of this page are merely guidelines. There may be good reasons to deviate from them in some cases; in that case just do so.","category":"page"},{"location":"DeveloperDocumentation/styleguide/#General-styleguide","page":"Developer Style Guide","title":"General styleguide","text":"","category":"section"},{"location":"DeveloperDocumentation/styleguide/","page":"Developer Style Guide","title":"Developer Style Guide","text":"Use Julia conventions where applicable and when they don't contradict our own rules above.\nUnless really really necessary, don't add new dependencies. Every new dependency complicates the development workflow, in that we will need to stay compatible with this package. \nIf already existing types in OSCAR are almost what you need, consider improving them instead of writing your own. While it might be tempting to create a new polynomial ring type for the new application because some feature is missing, it causes a lot of work and compatibility issues: Will the new type support\nnormal functions (gcd, factor),\nquotient fields,\nmodules and residue rings,\nconversion to and from other already existing types?\nWhenever functions return the same mathematical object, but in different mathematical categories, the first argument should be the desired return type. One example is projective_space(NormalToricVariety, *) vs projective_space(ProjectiveScheme, *). However, if the return type is different, even if the result describes the same mathematical object, it should be indicated in the function name, for example automorphism_group vs automorphism_group_generators vs automorphism_list.\nWhenever functions expect a ring, field, algebra, etc. as input they should be passed as the first argument, for example, polynomial_ring(QQ, :x).\nFollow the mathematics. If your function needs a list of points, you should create a point-type (or use the one already there) and then use this. For user-facing functions, please do not use re-purposed lists, arrays, matrices...\nInput sanity checks should be enabled by default, they can then be disabled internally if they are known to be true, and manually by users.\nAll user-facing functions that expect some kind of indeterminant name etc. (like polynomial_ring(QQ, <indeterminant_name>)) should accept a VarName = Union{Symbol, Char, String}, and convert it to a symbol for internal handling. Library and test code should (if possible) call such functions with Symbol arguments, as this is the most efficient way.","category":"page"},{"location":"DeveloperDocumentation/styleguide/#Naming-conventions","page":"Developer Style Guide","title":"Naming conventions","text":"","category":"section"},{"location":"DeveloperDocumentation/styleguide/","page":"Developer Style Guide","title":"Developer Style Guide","text":"The usual Julia naming conventions apply to OSCAR, too (that said, for various reasons our code still violates quite some of them; but in general we strive to reduce these). Here is a summary of the naming convention followed in OSCAR:","category":"page"},{"location":"DeveloperDocumentation/styleguide/","page":"Developer Style Guide","title":"Developer Style Guide","text":"Use CamelCase for types and snake_case for everything else. (Internal functions do not have to follow these rules.) Types (and their constructor) tend to be in CamelCase. However, please also provide the constructor (or a constructor) in snake_case. As a user one usually does not know if something is a constructor or a function.\nFor filenames we recommend using snake_case.jl.\nNoteworthy difference to Julia base is that we do not have exceptions for is* or has* as prefix. It is is_foo instead of isfoo and has_bar instead of hasbar. The main reason is to avoid awkward constructions like isvery_ample, while also being consistent. For compatibility with standard Julia, while staying consistent internally, we also provide aliases (using AbstractAlgebra.@alias) for various standard Julia functions, e.g. is_one as alias for isone.\nA function returning the number of some things should be named number_of_things, alternatively it can be named n_things with an alias to number_of_things. The preferred style should be consistent throughout the corresponding part. For some very common things, like the number of generators, we additionally provide a shorter alias, e.g. ngens for number_of_generators. These aliases should be very short and without underscores.\nFor generic concepts choose generic names, based on general algebraic concepts, preferably not special names from your area of speciality.\nAvoid direct access to members of our objects. This means, do not use something like A.foo, instead use a suitable getter get_foo(A), and if there is none, please write one or request that one be written. Internal member names are free to change at any time, but functions can be deprecated properly.\nIn Julia we have multiple dispatch, so we do not need functions like point_from_matrix as the \"from\" part is clear by the type of the argument. It should be called points(T::Matrix) in some variation. Similarly for matrix_to_points. Of course it is fine to use them internally, where useful.","category":"page"},{"location":"DeveloperDocumentation/styleguide/#Code-formatting","page":"Developer Style Guide","title":"Code formatting","text":"","category":"section"},{"location":"DeveloperDocumentation/styleguide/","page":"Developer Style Guide","title":"Developer Style Guide","text":"Before making some suggestions for code formatting rules, a warning: we deliberately are lax about enforcing these rules, as often contributors (esp. new ones) already struggle enough without being forced to also adhere to specific formatting rules. As long as code is sufficiently readable, we may accept it.","category":"page"},{"location":"DeveloperDocumentation/styleguide/","page":"Developer Style Guide","title":"Developer Style Guide","text":"But in the same vein (i.e., to minimize frictions for others working on OSCAR), we ask everyone to generally refrain from reformatting large chunks of code (even if it is to make it adhere to the rules described below), unless this is carefully coordinated with all stakeholders of the affected code.","category":"page"},{"location":"DeveloperDocumentation/styleguide/","page":"Developer Style Guide","title":"Developer Style Guide","text":"Also, ideally don't mix code reformatting with other changes, as this makes it harder to understand what is going on. At the very least, use different commits for the reformatting changes and the actual changes. But in general you shouldn't reformat code unrelated to the changes you are making.","category":"page"},{"location":"DeveloperDocumentation/styleguide/#Editor-configuration","page":"Developer Style Guide","title":"Editor configuration","text":"","category":"section"},{"location":"DeveloperDocumentation/styleguide/","page":"Developer Style Guide","title":"Developer Style Guide","text":"Please check if your editor can be configured to honor our .editorconfig file, see https://editorconfig.org for more information about this.","category":"page"},{"location":"DeveloperDocumentation/styleguide/#JuliaFormatter","page":"Developer Style Guide","title":"JuliaFormatter","text":"","category":"section"},{"location":"DeveloperDocumentation/styleguide/","page":"Developer Style Guide","title":"Developer Style Guide","text":"There is a .JuliaFormatter.toml in our git repository. To format your files, first add JuliaFormatter.jl in Julia and then use","category":"page"},{"location":"DeveloperDocumentation/styleguide/","page":"Developer Style Guide","title":"Developer Style Guide","text":"using JuliaFormatter\nformat_file(\"path/to/file/file.jl\")","category":"page"},{"location":"DeveloperDocumentation/styleguide/#Unicode","page":"Developer Style Guide","title":"Unicode","text":"","category":"section"},{"location":"DeveloperDocumentation/styleguide/","page":"Developer Style Guide","title":"Developer Style Guide","text":"As most modern programming languages, Julia allows the use of Unicode, e.g., α, in the REPL as well as in source code. As this reduces accessibility to various groups of users and developers, the use of Unicode should be kept to a minimum. Here is a general principle:","category":"page"},{"location":"DeveloperDocumentation/styleguide/","page":"Developer Style Guide","title":"Developer Style Guide","text":"Do not use Unicode characters inside functions. See Unicode printing for the exception concerning printing.","category":"page"},{"location":"DeveloperDocumentation/styleguide/#Whitespace","page":"Developer Style Guide","title":"Whitespace","text":"","category":"section"},{"location":"DeveloperDocumentation/styleguide/","page":"Developer Style Guide","title":"Developer Style Guide","text":"Do not use tabs.\nDo not put spaces \"inside\" parenthesis.\nDo put spaces after commas.","category":"page"},{"location":"DeveloperDocumentation/styleguide/","page":"Developer Style Guide","title":"Developer Style Guide","text":"Good example:","category":"page"},{"location":"DeveloperDocumentation/styleguide/","page":"Developer Style Guide","title":"Developer Style Guide","text":"f(x, y) = x + 1\nprint(f(1, 2))","category":"page"},{"location":"DeveloperDocumentation/styleguide/","page":"Developer Style Guide","title":"Developer Style Guide","text":"Bad example:","category":"page"},{"location":"DeveloperDocumentation/styleguide/","page":"Developer Style Guide","title":"Developer Style Guide","text":"f( x,y ) = x + 1\nprint( f ( 1,2 ) )","category":"page"},{"location":"DeveloperDocumentation/styleguide/#Loops-and-other-control-structures","page":"Developer Style Guide","title":"Loops and other control structures","text":"","category":"section"},{"location":"DeveloperDocumentation/styleguide/","page":"Developer Style Guide","title":"Developer Style Guide","text":"for loops should use in not =\ndon't put spaces around the : in a range","category":"page"},{"location":"DeveloperDocumentation/styleguide/","page":"Developer Style Guide","title":"Developer Style Guide","text":"Good example:","category":"page"},{"location":"DeveloperDocumentation/styleguide/","page":"Developer Style Guide","title":"Developer Style Guide","text":"for i in 1:3\n  println(i)\nend","category":"page"},{"location":"DeveloperDocumentation/styleguide/","page":"Developer Style Guide","title":"Developer Style Guide","text":"Bad example:","category":"page"},{"location":"DeveloperDocumentation/styleguide/","page":"Developer Style Guide","title":"Developer Style Guide","text":"for i = 1 : 3\n  println(i)\nend","category":"page"},{"location":"DeveloperDocumentation/styleguide/#Code-structure","page":"Developer Style Guide","title":"Code structure","text":"","category":"section"},{"location":"DeveloperDocumentation/styleguide/","page":"Developer Style Guide","title":"Developer Style Guide","text":"do not nest loops and if clauses too deeply; if you are using 5 or more levels, then in general that's a hint that you should refactor; e.g.\nby moving parts of the code into a separate function\nby replacing guard constructs like\nfor i in A\n  if flag\n    ...\n  end\nend\nby\nfor i in A\n  if !flag\n    continue\n  end\n  ...\nend\nor\nfor i in A\n  flag || continue\n  ...\nend\nby merging loops: you can replace\nfor i in A\n  for j in B\n    ...\n  end\nend\nby\nfor i in A, j in B\n  ...\nend\nFunctions should not have too many arguments. If you need a bunch arguments, chances are that introducing a new type makes it more readable.\nFunctions should not be too long; very long functions are in general harder to understand; it is also more difficult to see all the code at once. Consider splitting the function into multiple ones, if it is sensibly possible.\nEvery export statement must be confined to a single line; the intention is to make it easy to use tools like git grep to find exports. In general it is recommended export exactly one identifier per export statement. Exceptions may be made for certain tightly related identifiers, e.g. is_finite, set_is_finite and has_is_finite could be put on a single line. In general if multiple export statements appear in sequence, they must be sorted alphabetically.","category":"page"},{"location":"DeveloperDocumentation/styleguide/","page":"Developer Style Guide","title":"Developer Style Guide","text":"However, as always, rules sometimes should be broken.","category":"page"},{"location":"DeveloperDocumentation/styleguide/#Optional-arguments-for-parents-of-return-values","page":"Developer Style Guide","title":"Optional arguments for parents of return values","text":"","category":"section"},{"location":"DeveloperDocumentation/styleguide/","page":"Developer Style Guide","title":"Developer Style Guide","text":"Several objects in OSCAR have parents, e.g. polynomials, group elements, ...  Whenever a function creates such objects from an input which does not involve  the output's parent, we strongly recommend that  the user should have the possibility to pass on this  parent as a keyword argument under the name parent. Beyond that you can make more entry points for such parents available for  the user's convenience.","category":"page"},{"location":"DeveloperDocumentation/styleguide/","page":"Developer Style Guide","title":"Developer Style Guide","text":"Let's see an example. Say, you want to implement the characteristic  polynomial of a matrix. You could do it as follows:","category":"page"},{"location":"DeveloperDocumentation/styleguide/","page":"Developer Style Guide","title":"Developer Style Guide","text":"function characteristic_polynomial(A::MatrixElem)\n  kk = base_ring(A)\n  P, x = kk[:x]\n  AP = change_base_ring(P, A)\n  return det(AP - x*one(AP))\nend","category":"page"},{"location":"DeveloperDocumentation/styleguide/","page":"Developer Style Guide","title":"Developer Style Guide","text":"You can see that the polynomial ring P, i.e. the parent of the output,  is newly created in the body of the function. In particular, calling this  function two times on two different matrices A and B might produce  incompatible polynomials p = det(A - x*one(A)) and q = det(B - x*one(B))  with different parents. Calling p + q will result in an error. ","category":"page"},{"location":"DeveloperDocumentation/styleguide/","page":"Developer Style Guide","title":"Developer Style Guide","text":"To solve this, we should have implemented the function differently:","category":"page"},{"location":"DeveloperDocumentation/styleguide/","page":"Developer Style Guide","title":"Developer Style Guide","text":"# Implementation of the recommended keyword argument signature:\nfunction characteristic_polynomial(\n    A::MatrixElem;\n    parent::AbstractAlgebra.Ring=polynomial_ring(base_ring(A), :t)[1]\n  )\n  AP = change_base_ring(parent, A)\n  x = first(gens(ring))\n  return det(AP - x*one(AP))\nend\n\n# Optional second signature to also allow for the specification of the \n# output's parent as the first argument:\nfunction characteristic_polynomial(\n    P::PolyRing,\n    A::MatrixElem\n  )\n  coefficient_ring(P) === base_ring(A) || error(\"coefficient rings incompatible\")\n  return characteristic_polynomial(A, parent=P)\nend","category":"page"},{"location":"DeveloperDocumentation/styleguide/","page":"Developer Style Guide","title":"Developer Style Guide","text":"In fact this now allows for two different entry points for the parent ring P  of the output: First as the required parent keyword argument and second  as the first argument of a method of characteristic_polynomial with  an extended signature. Note that within the scope of the first method's body  the OSCAR function parent is necessarily overwritten by the name of the  keyword argument. Hence to call the actual parent of any other object, you  must then use Oscar.parent. E.g. to get the MatrixSpace of the  matrix A, write Oscar.parent(A).","category":"page"},{"location":"DeveloperDocumentation/styleguide/#Documentation","page":"Developer Style Guide","title":"Documentation","text":"","category":"section"},{"location":"DeveloperDocumentation/styleguide/","page":"Developer Style Guide","title":"Developer Style Guide","text":"In general we try to follow the list of recommendations in the Documentation section of the Julia manual.\nVia the MathJax integration it is possible to use LaTeX code, and this is the preferred way to denote the mathematical symbols in the docstrings.","category":"page"},{"location":"DeveloperDocumentation/styleguide/#Printing-in-Oscar","page":"Developer Style Guide","title":"Printing in Oscar","text":"","category":"section"},{"location":"DeveloperDocumentation/styleguide/#The-2-1-print-modes-of-Oscar","page":"Developer Style Guide","title":"The 2 + 1 print modes of Oscar","text":"","category":"section"},{"location":"DeveloperDocumentation/styleguide/","page":"Developer Style Guide","title":"Developer Style Guide","text":"Oscar has two user print modes detailed and one line and one internal print mode terse. The latter is for use during recursion, e.g. to print the base_ring(X) when in one line mode. It exists to make sure that one line stays compact and human readable.","category":"page"},{"location":"DeveloperDocumentation/styleguide/","page":"Developer Style Guide","title":"Developer Style Guide","text":"Top-level REPL printing of an object will use detailed mode by default","category":"page"},{"location":"DeveloperDocumentation/styleguide/","page":"Developer Style Guide","title":"Developer Style Guide","text":"julia> X\ndetailed","category":"page"},{"location":"DeveloperDocumentation/styleguide/","page":"Developer Style Guide","title":"Developer Style Guide","text":"Inside nested structures, e.g. inside a Vector, the one line mode is used.","category":"page"},{"location":"DeveloperDocumentation/styleguide/","page":"Developer Style Guide","title":"Developer Style Guide","text":"julia> [X,X]\n3-element Vector{TypeofX{T}}\none line\none line\none line","category":"page"},{"location":"DeveloperDocumentation/styleguide/#An-Example-for-the-2-1-print-modes","page":"Developer Style Guide","title":"An Example for the 2 + 1 print modes","text":"","category":"section"},{"location":"DeveloperDocumentation/styleguide/","page":"Developer Style Guide","title":"Developer Style Guide","text":"# detailed\nGeneral linear group of degree 24\n  over Finite field of degree 7 over GF(29)\n\n# one line\nGeneral linear group of degree 24 over GF(29^7)\n\n# terse\nGeneral linear group","category":"page"},{"location":"DeveloperDocumentation/styleguide/","page":"Developer Style Guide","title":"Developer Style Guide","text":"The print modes are specified as follows","category":"page"},{"location":"DeveloperDocumentation/styleguide/#Detailed-printing","page":"Developer Style Guide","title":"Detailed printing","text":"","category":"section"},{"location":"DeveloperDocumentation/styleguide/","page":"Developer Style Guide","title":"Developer Style Guide","text":"the output must make sense as a standalone without context to non-specialists\nthe number of output lines should fit in the terminal\nif the object is simple enough use only one line\nuse indentation and (usually) one line to print substructures","category":"page"},{"location":"DeveloperDocumentation/styleguide/#One-line-printing","page":"Developer Style Guide","title":"One line printing","text":"","category":"section"},{"location":"DeveloperDocumentation/styleguide/","page":"Developer Style Guide","title":"Developer Style Guide","text":"the output must print in one line\nshould make sense as a standalone without context\nvariable names/generators/relations should not be printed only their number.\nOnly the first word is capitalized e.g. Polynomial ring\none should use terse for nested printing in compact\nnested calls to one line (if you think them really necessary) should be at the end, so that one can read sequentially. Calls to terse can be anywhere.\ncommas must be enclosed in brackets so that printing tuples stays unambiguous","category":"page"},{"location":"DeveloperDocumentation/styleguide/#Terse-printing","page":"Developer Style Guide","title":"Terse printing","text":"","category":"section"},{"location":"DeveloperDocumentation/styleguide/","page":"Developer Style Guide","title":"Developer Style Guide","text":"a user readable version of the main (mathematical) type.\na single term or a symbol/letter mimicking mathematical notation\nshould usually only depend on the type and not of the type parameters or of the concrete instance - exceptions of this rule are possible e.g. for GF(2)\nno nested printing. In particular variable names and base_ring must not be displayed. This ensures that one line and terse stay compact even for complicated things. If you want nested printing use one line or detailed.","category":"page"},{"location":"DeveloperDocumentation/styleguide/","page":"Developer Style Guide","title":"Developer Style Guide","text":"For further information and examples we refer you to our section Details on printing in Oscar.","category":"page"},{"location":"DeveloperDocumentation/styleguide/#Deprecating-functions","page":"Developer Style Guide","title":"Deprecating functions","text":"","category":"section"},{"location":"DeveloperDocumentation/styleguide/","page":"Developer Style Guide","title":"Developer Style Guide","text":"Sometimes it is necessary to rename a function or otherwise change it. To allow for backwards compatibility, please then introduce a new line in the file src/deprecations.jl. If the interface did not change, it is enough to write:","category":"page"},{"location":"DeveloperDocumentation/styleguide/","page":"Developer Style Guide","title":"Developer Style Guide","text":"# Deprecated after CURRENT_RELEASE_VERSION\n@deprecate old_function new_function","category":"page"},{"location":"DeveloperDocumentation/styleguide/","page":"Developer Style Guide","title":"Developer Style Guide","text":"It is possible to transform the arguments too, if the syntax has changed. If this process needs an auxiliary function, which otherwise is unnecessary, please add it above:","category":"page"},{"location":"DeveloperDocumentation/styleguide/","page":"Developer Style Guide","title":"Developer Style Guide","text":"# Deprecated after CURRENT_RELEASE_VERSION\nfunction transform_args_for_new_function(args)\n    # Do something\n    return new_args\nend\n@deprecate old_function(arg1::Type1, arg2::Type2, ...) new_function(transform_args_for_new_function(args))","category":"page"},{"location":"DeveloperDocumentation/styleguide/","page":"Developer Style Guide","title":"Developer Style Guide","text":"In simple cases (like changing the order of arguments), you don't need an auxiliary function:","category":"page"},{"location":"DeveloperDocumentation/styleguide/","page":"Developer Style Guide","title":"Developer Style Guide","text":"@deprecate old_function(arg1::Type1, arg2::Type2) new_function(arg2, arg1)","category":"page"},{"location":"DeveloperDocumentation/styleguide/","page":"Developer Style Guide","title":"Developer Style Guide","text":"The comment about the version number is only necessary if you are the first one adding to deprecations.jl after a release, otherwise please add to the existing block.","category":"page"},{"location":"DeveloperDocumentation/styleguide/","page":"Developer Style Guide","title":"Developer Style Guide","text":"If you renamed a type and want to deprecate the old one, please add a line like","category":"page"},{"location":"DeveloperDocumentation/styleguide/","page":"Developer Style Guide","title":"Developer Style Guide","text":"Base.@deprecate_type OldType NewType","category":"page"},{"location":"DeveloperDocumentation/styleguide/","page":"Developer Style Guide","title":"Developer Style Guide","text":"This makes it still possible to use OldType in signatures and type annotations, but it will throw a deprecation warning (if they are enabled).","category":"page"},{"location":"DeveloperDocumentation/styleguide/","page":"Developer Style Guide","title":"Developer Style Guide","text":"note: Note\nPlease make sure to change to the new function everywhere in the existing OSCAR code base. Even if you think, you were the only one using the function, run a quick grep to make sure. When you are done, deprecations.jl should be the only place mentioning old_function. To make sure, you can start Julia with --depwarn=yes or even --depwarn=error and then run the tests.","category":"page"},{"location":"DeveloperDocumentation/styleguide/#Approved-abbreviations","page":"Developer Style Guide","title":"Approved abbreviations","text":"","category":"section"},{"location":"DeveloperDocumentation/styleguide/","page":"Developer Style Guide","title":"Developer Style Guide","text":"Types for rings/groups/ideals/modules/... end with Ring/Group/Ideal/Module/...\nTypes for elements should have the same name as the type of the parent with Elem added;\nException: MatrixSpace elements end with Matrix.\nWe abbreviate certain parts of type names, according to a fixed set of substitutions; further abbreviations should be carefully decided upon.\nEvery abbreviation must be unique; e.g. Abs stands for Absolute, and so must not be used for e.g. Abstract.\nList of approved abbreviations\nabsolute -> Abs\nabstract -> Abstract\ndecorated -> Dec\ngroup -> Group\nideal -> Ideal\nlocalized -> Loc\nmatrix -> Matrix\nmodule -> Module\nmultivariate polynomial -> MPoly\npolynomial -> Poly\nquotient -> Quo\nrelative -> Rel\nring ->Ring\nsubquotient -> Subquo\nIf a type comes in sparse and dense variants, then call the dense type T and the sparse one SparseT.","category":"page"},{"location":"AlgebraicGeometry/Schemes/MorphismsOfProjectiveSchemes/","page":"Morphisms of projective schemes","title":"Morphisms of projective schemes","text":"CurrentModule = Oscar","category":"page"},{"location":"AlgebraicGeometry/Schemes/MorphismsOfProjectiveSchemes/#Morphisms-of-projective-schemes","page":"Morphisms of projective schemes","title":"Morphisms of projective schemes","text":"","category":"section"},{"location":"AlgebraicGeometry/Schemes/MorphismsOfProjectiveSchemes/","page":"Morphisms of projective schemes","title":"Morphisms of projective schemes","text":"Let Q = By_0 dots y_nJ and P = Ax_0dotsx_mI be  graded affine algebras over base_rings A and B, respectively.  A morphism varphi  mathrmProj(Q) to mathrmProj(P) is modeled  via a morphism of graded algebras varphi^*  P to Q.  In the case of A != B, this involves a non-trivial morphism  of rings A to B.","category":"page"},{"location":"AlgebraicGeometry/Schemes/MorphismsOfProjectiveSchemes/#Abstract-types-and-basic-interface","page":"Morphisms of projective schemes","title":"Abstract types and basic interface","text":"","category":"section"},{"location":"AlgebraicGeometry/Schemes/MorphismsOfProjectiveSchemes/","page":"Morphisms of projective schemes","title":"Morphisms of projective schemes","text":"At the moment we have no abstract type for such morphisms and no interface spelled  out. ","category":"page"},{"location":"AlgebraicGeometry/Schemes/MorphismsOfProjectiveSchemes/#Types","page":"Morphisms of projective schemes","title":"Types","text":"","category":"section"},{"location":"AlgebraicGeometry/Schemes/MorphismsOfProjectiveSchemes/","page":"Morphisms of projective schemes","title":"Morphisms of projective schemes","text":"ProjectiveSchemeMor","category":"page"},{"location":"AlgebraicGeometry/Schemes/MorphismsOfProjectiveSchemes/#ProjectiveSchemeMor","page":"Morphisms of projective schemes","title":"ProjectiveSchemeMor","text":"ProjectiveSchemeMor\n\nA morphism of projective schemes\n\n     ℙˢ(B)     ℙʳ(A)\n       ∪         ∪\n       P    →    Q\n       ↓         ↓\n    Spec(B) → Spec(A)\n\ngiven by means of a commutative diagram of homomorphisms of graded rings\n\n    A[v₀,…,vᵣ] → B[u₀,…,uₛ]\n        ↑            ↑\n        A      →     B\n\nIf no morphism A → B of the base rings is specified, then both P and Q are assumed to be defined in relative projective space over the same ring with the identity on the base.\n\n\n\n\n\n","category":"type"},{"location":"AlgebraicGeometry/Schemes/MorphismsOfProjectiveSchemes/#Constructors","page":"Morphisms of projective schemes","title":"Constructors","text":"","category":"section"},{"location":"AlgebraicGeometry/Schemes/MorphismsOfProjectiveSchemes/","page":"Morphisms of projective schemes","title":"Morphisms of projective schemes","text":"morphism(P::AbsProjectiveScheme, Q::AbsProjectiveScheme, f::Map; check::Bool=true )\nmorphism(P::AbsProjectiveScheme, Q::AbsProjectiveScheme, f::Map, h::SchemeMor; check::Bool=true )\nmorphism(X::AbsProjectiveScheme, Y::AbsProjectiveScheme, a::Vector{<:RingElem})","category":"page"},{"location":"AlgebraicGeometry/Schemes/MorphismsOfProjectiveSchemes/#morphism-Tuple{AbsProjectiveScheme, AbsProjectiveScheme, Map}","page":"Morphisms of projective schemes","title":"morphism","text":"morphism(P::AbsProjectiveScheme, Q::AbsProjectiveScheme, f::Map; check::Bool=true )\n\nGiven a morphism f  T  S of the homogeneous_coordinate_rings of Q and P, respectively,  construct the associated morphism of projective schemes.\n\n\n\n\n\n","category":"method"},{"location":"AlgebraicGeometry/Schemes/MorphismsOfProjectiveSchemes/#morphism-Tuple{AbsProjectiveScheme, AbsProjectiveScheme, Map, SchemeMor}","page":"Morphisms of projective schemes","title":"morphism","text":"morphism(P::AbsProjectiveScheme, Q::AbsProjectiveScheme, f::Map, h::SchemeMor; check::Bool=true )\n\nSuppose P  ℙʳ_A and Q  ℙˢ_B are projective schemes, h  Spec(A)  Spec(B) is a  morphism of their base_schemes, and f  T  S a morphism of the  homogeneous_coordinate_rings of Q and P over h^*  B  A. This constructs the associated morphism of projective schemes.\n\n\n\n\n\n","category":"method"},{"location":"AlgebraicGeometry/Schemes/MorphismsOfProjectiveSchemes/#morphism-Tuple{AbsProjectiveScheme, AbsProjectiveScheme, Vector{<:RingElem}}","page":"Morphisms of projective schemes","title":"morphism","text":"morphism(X::AbsProjectiveScheme, Y::AbsProjectiveScheme, a::Vector{<:RingElem})\n\nSuppose X  ℙʳ and Y  ℙˢ are projective schemes over the same base_scheme. Construct the morphism of projective schemes associated to the morphism of graded rings  which takes the generators of the homogeneous_coordinate_ring of Y to the elements  in a of the homogeneous_coordinate_ring of X.\n\n\n\n\n\n","category":"method"},{"location":"AlgebraicGeometry/Schemes/MorphismsOfProjectiveSchemes/#Attributes","page":"Morphisms of projective schemes","title":"Attributes","text":"","category":"section"},{"location":"AlgebraicGeometry/Schemes/MorphismsOfProjectiveSchemes/","page":"Morphisms of projective schemes","title":"Morphisms of projective schemes","text":"As every instance of Map, a morphism of projective schemes can be asked for its (co-)domain:","category":"page"},{"location":"AlgebraicGeometry/Schemes/MorphismsOfProjectiveSchemes/","page":"Morphisms of projective schemes","title":"Morphisms of projective schemes","text":"domain(phi::ProjectiveSchemeMor) \ncodomain(phi::ProjectiveSchemeMor)","category":"page"},{"location":"AlgebraicGeometry/Schemes/MorphismsOfProjectiveSchemes/","page":"Morphisms of projective schemes","title":"Morphisms of projective schemes","text":"Moreover, we provide getters for the associated morphisms of rings:","category":"page"},{"location":"AlgebraicGeometry/Schemes/MorphismsOfProjectiveSchemes/","page":"Morphisms of projective schemes","title":"Morphisms of projective schemes","text":"pullback(phi::ProjectiveSchemeMor)\nbase_ring_morphism(phi::ProjectiveSchemeMor) \nbase_map(phi::ProjectiveSchemeMor)\nmap_on_affine_cones(phi::ProjectiveSchemeMor)","category":"page"},{"location":"AlgebraicGeometry/Schemes/MorphismsOfProjectiveSchemes/#pullback-Tuple{ProjectiveSchemeMor}","page":"Morphisms of projective schemes","title":"pullback","text":"pullback(phi::ProjectiveSchemeMor)\n\nFor a morphism phi of projective schemes, this returns the associated  morphism of graded affine algebras.\n\n\n\n\n\n","category":"method"},{"location":"AlgebraicGeometry/Schemes/MorphismsOfProjectiveSchemes/#base_ring_morphism-Tuple{ProjectiveSchemeMor}","page":"Morphisms of projective schemes","title":"base_ring_morphism","text":"base_ring_morphism(phi::ProjectiveSchemeMor)\n\nFor a morphism phi : P → Q of relative projective spaces  over psi : Spec(A) → Spec(B) this returns the associated  map B → A.\n\n\n\n\n\n","category":"method"},{"location":"AlgebraicGeometry/Schemes/MorphismsOfProjectiveSchemes/#base_map-Tuple{ProjectiveSchemeMor}","page":"Morphisms of projective schemes","title":"base_map","text":"base_map(phi::ProjectiveSchemeMor)\n\nFor a morphism phi : P → Q of relative projective spaces  over psi : Spec(A) → Spec(B) this returns psi.\n\n\n\n\n\n","category":"method"},{"location":"AlgebraicGeometry/Schemes/MorphismsOfProjectiveSchemes/#map_on_affine_cones-Tuple{ProjectiveSchemeMor}","page":"Morphisms of projective schemes","title":"map_on_affine_cones","text":"map_on_affine_cones(phi::ProjectiveSchemeMor)\n\nFor a morphism phi : X → Y this returns the associated morphism  of the affine_cones C(X)  C(Y).\n\n\n\n\n\n","category":"method"},{"location":"AlgebraicGeometry/Schemes/MorphismsOfProjectiveSchemes/#Methods","page":"Morphisms of projective schemes","title":"Methods","text":"","category":"section"},{"location":"AlgebraicGeometry/Schemes/MorphismsOfProjectiveSchemes/","page":"Morphisms of projective schemes","title":"Morphisms of projective schemes","text":"covered_scheme_morphism(f::AbsProjectiveSchemeMorphism)","category":"page"},{"location":"AlgebraicGeometry/Schemes/MorphismsOfProjectiveSchemes/#covered_scheme_morphism-Tuple{AbsProjectiveSchemeMorphism}","page":"Morphisms of projective schemes","title":"covered_scheme_morphism","text":"covered_scheme_morphism(f::AbsProjectiveSchemeMorphism)\n\nGiven a morphism of ProjectiveSchemes f  X  Y, construct and  return the same morphism as a CoveredSchemeMorphism of the covered_schemes  of X and Y, respectively.\n\nExamples\n\njulia> P, (x, y, z) = graded_polynomial_ring(QQ, [:x, :y, :z]);\n\njulia> I = ideal([x^3-y^2*z]);\n\njulia> Y = proj(P, I);\n\njulia> f = identity_map(Y)\nProjective scheme morphism\n  from projective scheme in IP^2 over QQ\n  to projective scheme in IP^2 over QQ\n\njulia> fcov = covered_scheme_morphism(f);\n\njulia> codomain(fcov)\nScheme\n  over rational field\nwith default covering\n  described by patches\n    1: scheme(-(y//x)^2*(z//x) + 1)\n    2: scheme((x//y)^3 - (z//y))\n    3: scheme((x//z)^3 - (y//z)^2)\n  in the coordinate(s)\n    1: [(y//x), (z//x)]\n    2: [(x//y), (z//y)]\n    3: [(x//z), (y//z)]\n\n\n\n\n\n","category":"method"},{"location":"AlgebraicGeometry/Surfaces/SurfacesP4/","page":"Nongeneral Type Surfaces in mathbb P^4","title":"Nongeneral Type Surfaces in mathbb P^4","text":"CurrentModule = Oscar\nDocTestSetup = Oscar.doctestsetup()","category":"page"},{"location":"AlgebraicGeometry/Surfaces/SurfacesP4/#Nongeneral-Type-Surfaces-in-\\mathbb-P4","page":"Nongeneral Type Surfaces in mathbb P^4","title":"Nongeneral Type Surfaces in mathbb P^4","text":"","category":"section"},{"location":"AlgebraicGeometry/Surfaces/SurfacesP4/","page":"Nongeneral Type Surfaces in mathbb P^4","title":"Nongeneral Type Surfaces in mathbb P^4","text":"Every smooth, projective surface can be embedded in mathbb P^5, but there are constraints on the numerical invariants of a smooth surface in mathbb P^4: The invariants of each such surface S satisfy the double point formula","category":"page"},{"location":"AlgebraicGeometry/Surfaces/SurfacesP4/","page":"Nongeneral Type Surfaces in mathbb P^4","title":"Nongeneral Type Surfaces in mathbb P^4","text":"d^2-5d-10(pi-1)+2(chi(mathcal O_S)-K_S^2) = 0","category":"page"},{"location":"AlgebraicGeometry/Surfaces/SurfacesP4/","page":"Nongeneral Type Surfaces in mathbb P^4","title":"Nongeneral Type Surfaces in mathbb P^4","text":"Here, d is the degree of S, pi its sectional genus, chi(mathcal O_S) its Euler-Poincare characteristic, and K_S its canonical class. The double point  formula is a key ingredient in the proof of a theorem of Ellingsrud and Peskine which states that there are only finitely many families of smooth surfaces in mathbb P^4 which are not of general type. That is, the degree of such surfaces in bounded from above. The best bound known so far is 52, while examples exist up to degree 15.","category":"page"},{"location":"AlgebraicGeometry/Surfaces/SurfacesP4/","page":"Nongeneral Type Surfaces in mathbb P^4","title":"Nongeneral Type Surfaces in mathbb P^4","text":"For details, we refer to","category":"page"},{"location":"AlgebraicGeometry/Surfaces/SurfacesP4/","page":"Nongeneral Type Surfaces in mathbb P^4","title":"Nongeneral Type Surfaces in mathbb P^4","text":"[DES93]\n[Pop93]\n[DS00]","category":"page"},{"location":"AlgebraicGeometry/Surfaces/SurfacesP4/","page":"Nongeneral Type Surfaces in mathbb P^4","title":"Nongeneral Type Surfaces in mathbb P^4","text":"and the references given there.","category":"page"},{"location":"AlgebraicGeometry/Surfaces/SurfacesP4/","page":"Nongeneral Type Surfaces in mathbb P^4","title":"Nongeneral Type Surfaces in mathbb P^4","text":"Below, we present functions which return one hard coded example for each family presented in the first two papers above.  Based on these papers, the existence of further families has been shown. Hard coded OSCAR examples for these surfaces are under construction.","category":"page"},{"location":"AlgebraicGeometry/Surfaces/SurfacesP4/","page":"Nongeneral Type Surfaces in mathbb P^4","title":"Nongeneral Type Surfaces in mathbb P^4","text":"note: Note\nTo ease subsequent computations, all hard coded examples are defined over a finite prime field.","category":"page"},{"location":"AlgebraicGeometry/Surfaces/SurfacesP4/#Rational-Surfaces","page":"Nongeneral Type Surfaces in mathbb P^4","title":"Rational Surfaces","text":"","category":"section"},{"location":"AlgebraicGeometry/Surfaces/SurfacesP4/#A-Rational-Surface-with-d3,-\\pi0","page":"Nongeneral Type Surfaces in mathbb P^4","title":"A Rational Surface with d=3, pi=0","text":"","category":"section"},{"location":"AlgebraicGeometry/Surfaces/SurfacesP4/","page":"Nongeneral Type Surfaces in mathbb P^4","title":"Nongeneral Type Surfaces in mathbb P^4","text":"cubic_scroll()","category":"page"},{"location":"AlgebraicGeometry/Surfaces/SurfacesP4/#cubic_scroll-Tuple{}","page":"Nongeneral Type Surfaces in mathbb P^4","title":"cubic_scroll","text":"cubic_scroll()\n\nReturn a smooth rational surface in mathbb P^4 with degree 3 and sectional genus 0.\n\nThe returned surface is defined over a prime field of characteristic 31991.\n\n\n\n\n\n","category":"method"},{"location":"AlgebraicGeometry/Surfaces/SurfacesP4/#A-Rational-Surface-with-d4,-\\pi0","page":"Nongeneral Type Surfaces in mathbb P^4","title":"A Rational Surface with d=4, pi=0","text":"","category":"section"},{"location":"AlgebraicGeometry/Surfaces/SurfacesP4/","page":"Nongeneral Type Surfaces in mathbb P^4","title":"Nongeneral Type Surfaces in mathbb P^4","text":"veronese()","category":"page"},{"location":"AlgebraicGeometry/Surfaces/SurfacesP4/#veronese-Tuple{}","page":"Nongeneral Type Surfaces in mathbb P^4","title":"veronese","text":"veronese()\n\nReturn a smooth rational surface in mathbb P^4 with degree 4 and sectional genus 0.\n\nThe returned surface is defined over a prime field of characteristic 31991.\n\n\n\n\n\n","category":"method"},{"location":"AlgebraicGeometry/Surfaces/SurfacesP4/#A-Rational-Surface-with-d5,-\\pi2","page":"Nongeneral Type Surfaces in mathbb P^4","title":"A Rational Surface with d=5, pi=2","text":"","category":"section"},{"location":"AlgebraicGeometry/Surfaces/SurfacesP4/","page":"Nongeneral Type Surfaces in mathbb P^4","title":"Nongeneral Type Surfaces in mathbb P^4","text":"castelnuovo()","category":"page"},{"location":"AlgebraicGeometry/Surfaces/SurfacesP4/#castelnuovo-Tuple{}","page":"Nongeneral Type Surfaces in mathbb P^4","title":"castelnuovo","text":"castelnuovo()\n\nReturn a smooth rational surface in mathbb P^4 with degree 5 and sectional genus 2.\n\nThe returned surface is defined over a prime field of characteristic 31991.\n\n\n\n\n\n","category":"method"},{"location":"AlgebraicGeometry/Surfaces/SurfacesP4/#A-Rational-Surface-with-d6,-\\pi3","page":"Nongeneral Type Surfaces in mathbb P^4","title":"A Rational Surface with d=6, pi=3","text":"","category":"section"},{"location":"AlgebraicGeometry/Surfaces/SurfacesP4/","page":"Nongeneral Type Surfaces in mathbb P^4","title":"Nongeneral Type Surfaces in mathbb P^4","text":"bordiga()","category":"page"},{"location":"AlgebraicGeometry/Surfaces/SurfacesP4/#bordiga-Tuple{}","page":"Nongeneral Type Surfaces in mathbb P^4","title":"bordiga","text":"bordiga()\n\nReturn a smooth rational surface in mathbb P^4 with degree 6 and sectional genus 3.\n\nThe returned surface is defined over a prime field of characteristic 31991.\n\n\n\n\n\n","category":"method"},{"location":"AlgebraicGeometry/Surfaces/SurfacesP4/#A-Rational-Surface-with-d7,-\\pi4","page":"Nongeneral Type Surfaces in mathbb P^4","title":"A Rational Surface with d=7, pi=4","text":"","category":"section"},{"location":"AlgebraicGeometry/Surfaces/SurfacesP4/","page":"Nongeneral Type Surfaces in mathbb P^4","title":"Nongeneral Type Surfaces in mathbb P^4","text":"rational_d7_pi4()","category":"page"},{"location":"AlgebraicGeometry/Surfaces/SurfacesP4/#rational_d7_pi4-Tuple{}","page":"Nongeneral Type Surfaces in mathbb P^4","title":"rational_d7_pi4","text":"rational_d7_pi4()\n\nReturn a smooth rational surface in mathbb P^4 with degree 7 and sectional genus 4.\n\nThe returned surface is defined over a prime field of characteristic 31991.\n\n\n\n\n\n","category":"method"},{"location":"AlgebraicGeometry/Surfaces/SurfacesP4/#A-Rational-Surface-with-d8,-\\pi5","page":"Nongeneral Type Surfaces in mathbb P^4","title":"A Rational Surface with d=8, pi=5","text":"","category":"section"},{"location":"AlgebraicGeometry/Surfaces/SurfacesP4/","page":"Nongeneral Type Surfaces in mathbb P^4","title":"Nongeneral Type Surfaces in mathbb P^4","text":"rational_d8_pi5()","category":"page"},{"location":"AlgebraicGeometry/Surfaces/SurfacesP4/#rational_d8_pi5-Tuple{}","page":"Nongeneral Type Surfaces in mathbb P^4","title":"rational_d8_pi5","text":"rational_d8_pi5()\n\nReturn a smooth rational surface in mathbb P^4 with degree 8 and sectional genus 5.\n\nThe returned surface is defined over a prime field of characteristic 31991.\n\n\n\n\n\n","category":"method"},{"location":"AlgebraicGeometry/Surfaces/SurfacesP4/#A-Rational-Surface-with-d8,-\\pi6","page":"Nongeneral Type Surfaces in mathbb P^4","title":"A Rational Surface with d=8, pi=6","text":"","category":"section"},{"location":"AlgebraicGeometry/Surfaces/SurfacesP4/","page":"Nongeneral Type Surfaces in mathbb P^4","title":"Nongeneral Type Surfaces in mathbb P^4","text":"rational_d8_pi6()","category":"page"},{"location":"AlgebraicGeometry/Surfaces/SurfacesP4/#rational_d8_pi6-Tuple{}","page":"Nongeneral Type Surfaces in mathbb P^4","title":"rational_d8_pi6","text":"rational_d8_pi6()\n\nReturn a smooth rational surface in mathbb P^4 with degree 8 and sectional genus 6.\n\nThe returned surface is defined over a prime field of characteristic 31991.\n\n\n\n\n\n","category":"method"},{"location":"AlgebraicGeometry/Surfaces/SurfacesP4/#A-Rational-Surface-with-d9,-\\pi6","page":"Nongeneral Type Surfaces in mathbb P^4","title":"A Rational Surface with d=9, pi=6","text":"","category":"section"},{"location":"AlgebraicGeometry/Surfaces/SurfacesP4/","page":"Nongeneral Type Surfaces in mathbb P^4","title":"Nongeneral Type Surfaces in mathbb P^4","text":"rational_d9_pi6()","category":"page"},{"location":"AlgebraicGeometry/Surfaces/SurfacesP4/#rational_d9_pi6-Tuple{}","page":"Nongeneral Type Surfaces in mathbb P^4","title":"rational_d9_pi6","text":"rational_d9_pi6()\n\nReturn a smooth rational surface in mathbb P^4 with degree 9 and sectional genus 6.\n\nThe returned surface is defined over a prime field of characteristic 31991.\n\n\n\n\n\n","category":"method"},{"location":"AlgebraicGeometry/Surfaces/SurfacesP4/#A-Rational-Surface-with-d9,-\\pi7","page":"Nongeneral Type Surfaces in mathbb P^4","title":"A Rational Surface with d=9, pi=7","text":"","category":"section"},{"location":"AlgebraicGeometry/Surfaces/SurfacesP4/","page":"Nongeneral Type Surfaces in mathbb P^4","title":"Nongeneral Type Surfaces in mathbb P^4","text":"rational_d9_pi7()","category":"page"},{"location":"AlgebraicGeometry/Surfaces/SurfacesP4/#rational_d9_pi7-Tuple{}","page":"Nongeneral Type Surfaces in mathbb P^4","title":"rational_d9_pi7","text":"rational_d9_pi7()\n\nReturn a smooth rational surface in mathbb P^4 with degree 9 and sectional genus 7.\n\nThe returned surface is defined over a prime field of characteristic 31991.\n\n\n\n\n\n","category":"method"},{"location":"AlgebraicGeometry/Surfaces/SurfacesP4/#A-Rational-Surface-with-d10,-\\pi8","page":"Nongeneral Type Surfaces in mathbb P^4","title":"A Rational Surface with d=10, pi=8","text":"","category":"section"},{"location":"AlgebraicGeometry/Surfaces/SurfacesP4/","page":"Nongeneral Type Surfaces in mathbb P^4","title":"Nongeneral Type Surfaces in mathbb P^4","text":"rational_d10_pi8()","category":"page"},{"location":"AlgebraicGeometry/Surfaces/SurfacesP4/#rational_d10_pi8-Tuple{}","page":"Nongeneral Type Surfaces in mathbb P^4","title":"rational_d10_pi8","text":"rational_d10_pi8()\n\nReturn a smooth rational surface in mathbb P^4 with degree 10 and sectional genus 8.\n\nThe returned surface is defined over a prime field of characteristic 31991.\n\n\n\n\n\n","category":"method"},{"location":"AlgebraicGeometry/Surfaces/SurfacesP4/#A-Rational-Surface-with-d10,-\\pi9-which-is-Contained-in-one-Quartic","page":"Nongeneral Type Surfaces in mathbb P^4","title":"A Rational Surface with d=10, pi=9 which is Contained in one Quartic","text":"","category":"section"},{"location":"AlgebraicGeometry/Surfaces/SurfacesP4/","page":"Nongeneral Type Surfaces in mathbb P^4","title":"Nongeneral Type Surfaces in mathbb P^4","text":"rational_d10_pi9_quart_1()","category":"page"},{"location":"AlgebraicGeometry/Surfaces/SurfacesP4/#rational_d10_pi9_quart_1-Tuple{}","page":"Nongeneral Type Surfaces in mathbb P^4","title":"rational_d10_pi9_quart_1","text":"rational_d10_pi9_quart_1()\n\nReturn a smooth rational surface in mathbb P^4 with degree 10 and sectional genus 9 which is contained in precisely one quartic.\n\nThe returned surface is defined over a prime field of characteristic 31991.\n\n\n\n\n\n","category":"method"},{"location":"AlgebraicGeometry/Surfaces/SurfacesP4/#A-Rational-Surface-with-d10,-\\pi9-which-is-Contained-in-a-Pencil-of-Quartics","page":"Nongeneral Type Surfaces in mathbb P^4","title":"A Rational Surface with d=10, pi=9 which is Contained in a Pencil of Quartics","text":"","category":"section"},{"location":"AlgebraicGeometry/Surfaces/SurfacesP4/","page":"Nongeneral Type Surfaces in mathbb P^4","title":"Nongeneral Type Surfaces in mathbb P^4","text":"rational_d10_pi9_quart_2()","category":"page"},{"location":"AlgebraicGeometry/Surfaces/SurfacesP4/#rational_d10_pi9_quart_2-Tuple{}","page":"Nongeneral Type Surfaces in mathbb P^4","title":"rational_d10_pi9_quart_2","text":"rational_d10_pi9_quart_2()\n\nReturn a smooth rational surface in mathbb P^4 with degree 10 and sectional genus 9 which is contained in a pencil of quartics.\n\nThe returned surface is defined over a prime field of characteristic 31991.\n\n\n\n\n\n","category":"method"},{"location":"AlgebraicGeometry/Surfaces/SurfacesP4/#A-Rational-Surface-with-d11,-\\pi11,-and-no-6-Secant","page":"Nongeneral Type Surfaces in mathbb P^4","title":"A Rational Surface with d=11, pi=11, and no 6-Secant","text":"","category":"section"},{"location":"AlgebraicGeometry/Surfaces/SurfacesP4/","page":"Nongeneral Type Surfaces in mathbb P^4","title":"Nongeneral Type Surfaces in mathbb P^4","text":"rational_d11_pi11_ss_0()","category":"page"},{"location":"AlgebraicGeometry/Surfaces/SurfacesP4/#rational_d11_pi11_ss_0-Tuple{}","page":"Nongeneral Type Surfaces in mathbb P^4","title":"rational_d11_pi11_ss_0","text":"rational_d11_pi11_ss_0()\n\nReturn a smooth rational surface in mathbb P^4 with degree 11, sectional genus 11, and no 6-secant.\n\nThe returned surface is defined over a prime field of characteristic 31991.\n\n\n\n\n\n","category":"method"},{"location":"AlgebraicGeometry/Surfaces/SurfacesP4/#A-Rational-Surface-with-d11,-\\pi11,-and-one-6-Secant","page":"Nongeneral Type Surfaces in mathbb P^4","title":"A Rational Surface with d=11, pi=11, and one 6-Secant","text":"","category":"section"},{"location":"AlgebraicGeometry/Surfaces/SurfacesP4/","page":"Nongeneral Type Surfaces in mathbb P^4","title":"Nongeneral Type Surfaces in mathbb P^4","text":"rational_d11_pi11_ss_1()","category":"page"},{"location":"AlgebraicGeometry/Surfaces/SurfacesP4/#rational_d11_pi11_ss_1-Tuple{}","page":"Nongeneral Type Surfaces in mathbb P^4","title":"rational_d11_pi11_ss_1","text":"rational_d11_pi11_ss_1()\n\nReturn a smooth rational surface in mathbb P^4 with degree 11, sectional genus 11, and one 6-secant.\n\nThe returned surface is defined over a prime field of characteristic 31991.\n\n\n\n\n\n","category":"method"},{"location":"AlgebraicGeometry/Surfaces/SurfacesP4/#A-Rational-Surface-with-d11,-\\pi11,-and-Infinitely-Many-6-Secants","page":"Nongeneral Type Surfaces in mathbb P^4","title":"A Rational Surface with d=11, pi=11, and Infinitely Many 6-Secants","text":"","category":"section"},{"location":"AlgebraicGeometry/Surfaces/SurfacesP4/","page":"Nongeneral Type Surfaces in mathbb P^4","title":"Nongeneral Type Surfaces in mathbb P^4","text":"rational_d11_pi11_ss_inf()","category":"page"},{"location":"AlgebraicGeometry/Surfaces/SurfacesP4/#rational_d11_pi11_ss_inf-Tuple{}","page":"Nongeneral Type Surfaces in mathbb P^4","title":"rational_d11_pi11_ss_inf","text":"rational_d11_pi11_ss_inf()\n\nReturn a smooth rational surface in mathbb P^4 with degree 11, sectional genus 11, and infinitely many 6-secants.\n\nThe returned surface is defined over a prime field of characteristic 31991.\n\n\n\n\n\n","category":"method"},{"location":"AlgebraicGeometry/Surfaces/SurfacesP4/#Ruled-Surfaces","page":"Nongeneral Type Surfaces in mathbb P^4","title":"Ruled Surfaces","text":"","category":"section"},{"location":"AlgebraicGeometry/Surfaces/SurfacesP4/#A-Ruled-Surface-with-d5,-\\pi1","page":"Nongeneral Type Surfaces in mathbb P^4","title":"A Ruled Surface with d=5, pi=1","text":"","category":"section"},{"location":"AlgebraicGeometry/Surfaces/SurfacesP4/","page":"Nongeneral Type Surfaces in mathbb P^4","title":"Nongeneral Type Surfaces in mathbb P^4","text":"quintic_elliptic_scroll()","category":"page"},{"location":"AlgebraicGeometry/Surfaces/SurfacesP4/#quintic_elliptic_scroll-Tuple{}","page":"Nongeneral Type Surfaces in mathbb P^4","title":"quintic_elliptic_scroll","text":"quintic_elliptic_scroll()\n\nReturn a smooth ruled surface in mathbb P^4 with degree 5 and sectional genus 1.\n\nThe returned surface is defined over a prime field of characteristic 31991.\n\n\n\n\n\n","category":"method"},{"location":"AlgebraicGeometry/Surfaces/SurfacesP4/#Enriques-Surfaces","page":"Nongeneral Type Surfaces in mathbb P^4","title":"Enriques Surfaces","text":"","category":"section"},{"location":"AlgebraicGeometry/Surfaces/SurfacesP4/#An-Enriques-Surface-with-d9,-\\pi6","page":"Nongeneral Type Surfaces in mathbb P^4","title":"An Enriques Surface with d=9, pi=6","text":"","category":"section"},{"location":"AlgebraicGeometry/Surfaces/SurfacesP4/","page":"Nongeneral Type Surfaces in mathbb P^4","title":"Nongeneral Type Surfaces in mathbb P^4","text":"enriques_d9_pi6()","category":"page"},{"location":"AlgebraicGeometry/Surfaces/SurfacesP4/#enriques_d9_pi6-Tuple{}","page":"Nongeneral Type Surfaces in mathbb P^4","title":"enriques_d9_pi6","text":"enriques_d9_pi6()\n\nReturn a smooth Enriques surface in mathbb P^4 with degree 9 and sectional genus 6.\n\nThe returned surface is defined over a prime field of characteristic 31991.\n\n\n\n\n\n","category":"method"},{"location":"AlgebraicGeometry/Surfaces/SurfacesP4/#An-Enriques-Surface-with-d10,-\\pi8","page":"Nongeneral Type Surfaces in mathbb P^4","title":"An Enriques Surface with d=10, pi=8","text":"","category":"section"},{"location":"AlgebraicGeometry/Surfaces/SurfacesP4/","page":"Nongeneral Type Surfaces in mathbb P^4","title":"Nongeneral Type Surfaces in mathbb P^4","text":"enriques_d10_pi8()","category":"page"},{"location":"AlgebraicGeometry/Surfaces/SurfacesP4/#enriques_d10_pi8-Tuple{}","page":"Nongeneral Type Surfaces in mathbb P^4","title":"enriques_d10_pi8","text":"enriques_d10_pi8()\n\nReturn a smooth Enriques surface in mathbb P^4 with degree 10 and sectional genus 8.\n\nThe returned surface is defined over a prime field of characteristic 31991.\n\n\n\n\n\n","category":"method"},{"location":"AlgebraicGeometry/Surfaces/SurfacesP4/#An-Enriques-Surface-with-d11,-\\pi10","page":"Nongeneral Type Surfaces in mathbb P^4","title":"An Enriques Surface with d=11, pi=10","text":"","category":"section"},{"location":"AlgebraicGeometry/Surfaces/SurfacesP4/","page":"Nongeneral Type Surfaces in mathbb P^4","title":"Nongeneral Type Surfaces in mathbb P^4","text":"enriques_d11_pi10()","category":"page"},{"location":"AlgebraicGeometry/Surfaces/SurfacesP4/#enriques_d11_pi10-Tuple{}","page":"Nongeneral Type Surfaces in mathbb P^4","title":"enriques_d11_pi10","text":"enriques_d11_pi10()\n\nReturn a smooth Enriques surface in mathbb P^4 with degree 11 and sectional genus 10.\n\nThe returned surface is defined over a prime field of characteristic 43.\n\n\n\n\n\n","category":"method"},{"location":"AlgebraicGeometry/Surfaces/SurfacesP4/#An-Enriques-Surface-with-d13,-\\pi16","page":"Nongeneral Type Surfaces in mathbb P^4","title":"An Enriques Surface with d=13, pi=16","text":"","category":"section"},{"location":"AlgebraicGeometry/Surfaces/SurfacesP4/","page":"Nongeneral Type Surfaces in mathbb P^4","title":"Nongeneral Type Surfaces in mathbb P^4","text":"enriques_d13_pi16()","category":"page"},{"location":"AlgebraicGeometry/Surfaces/SurfacesP4/#enriques_d13_pi16-Tuple{}","page":"Nongeneral Type Surfaces in mathbb P^4","title":"enriques_d13_pi16","text":"enriques_d13_pi16()\n\nReturn a smooth Enriques surface in mathbb P^4 with degree 13 and sectional genus 16.\n\nThe returned surface is defined over a prime field of characteristic 31991.\n\n\n\n\n\n","category":"method"},{"location":"AlgebraicGeometry/Surfaces/SurfacesP4/#An-Enriques-Surface-with-d13,-\\pi16-2","page":"Nongeneral Type Surfaces in mathbb P^4","title":"An Enriques Surface with d=13, pi=16","text":"","category":"section"},{"location":"AlgebraicGeometry/Surfaces/SurfacesP4/","page":"Nongeneral Type Surfaces in mathbb P^4","title":"Nongeneral Type Surfaces in mathbb P^4","text":"enriques_d13_pi16_two()","category":"page"},{"location":"AlgebraicGeometry/Surfaces/SurfacesP4/#enriques_d13_pi16_two-Tuple{}","page":"Nongeneral Type Surfaces in mathbb P^4","title":"enriques_d13_pi16_two","text":"enriques_d13_pi16_two()\n\nReturn a smooth Enriques surface in mathbb P^4 with degree 13 and sectional genus 16.\n\nThe returned surface is defined over a prime field of characteristic 31991.\n\n\n\n\n\n","category":"method"},{"location":"AlgebraicGeometry/Surfaces/SurfacesP4/#K3-Surfaces","page":"Nongeneral Type Surfaces in mathbb P^4","title":"K3 Surfaces","text":"","category":"section"},{"location":"AlgebraicGeometry/Surfaces/SurfacesP4/#A-K3-Surface-with-d7,-\\pi5","page":"Nongeneral Type Surfaces in mathbb P^4","title":"A K3 Surface with d=7, pi=5","text":"","category":"section"},{"location":"AlgebraicGeometry/Surfaces/SurfacesP4/","page":"Nongeneral Type Surfaces in mathbb P^4","title":"Nongeneral Type Surfaces in mathbb P^4","text":"k3_d7_pi5","category":"page"},{"location":"AlgebraicGeometry/Surfaces/SurfacesP4/#k3_d7_pi5","page":"Nongeneral Type Surfaces in mathbb P^4","title":"k3_d7_pi5","text":"k3_d7_pi5()\n\nReturn a smooth K3 surface in mathbb P^4 with degree 7 and sectional genus 5.\n\nThe returned surface is defined over a prime field of characteristic 31991.\n\n\n\n\n\n","category":"function"},{"location":"AlgebraicGeometry/Surfaces/SurfacesP4/#A-K3-Surface-with-d8,-\\pi6","page":"Nongeneral Type Surfaces in mathbb P^4","title":"A K3 Surface with d=8, pi=6","text":"","category":"section"},{"location":"AlgebraicGeometry/Surfaces/SurfacesP4/","page":"Nongeneral Type Surfaces in mathbb P^4","title":"Nongeneral Type Surfaces in mathbb P^4","text":"k3_d8_pi6","category":"page"},{"location":"AlgebraicGeometry/Surfaces/SurfacesP4/#k3_d8_pi6","page":"Nongeneral Type Surfaces in mathbb P^4","title":"k3_d8_pi6","text":"k3_d8_pi6()\n\nReturn a smooth K3 surface in mathbb P^4 with degree 8 and sectional genus 6.\n\nThe returned surface is defined over a prime field of characteristic 31991.\n\n\n\n\n\n","category":"function"},{"location":"AlgebraicGeometry/Surfaces/SurfacesP4/#A-K3-Surface-with-d9,-\\pi8","page":"Nongeneral Type Surfaces in mathbb P^4","title":"A K3 Surface with d=9, pi=8","text":"","category":"section"},{"location":"AlgebraicGeometry/Surfaces/SurfacesP4/","page":"Nongeneral Type Surfaces in mathbb P^4","title":"Nongeneral Type Surfaces in mathbb P^4","text":"k3_d9_pi8","category":"page"},{"location":"AlgebraicGeometry/Surfaces/SurfacesP4/#k3_d9_pi8","page":"Nongeneral Type Surfaces in mathbb P^4","title":"k3_d9_pi8","text":"k3_d9_pi8()\n\nReturn a smooth K3 surface in mathbb P^4 with degree 9 and sectional genus 8.\n\nThe returned surface is defined over a prime field of characteristic 31991.\n\n\n\n\n\n","category":"function"},{"location":"AlgebraicGeometry/Surfaces/SurfacesP4/#A-K3-Surface-with-d10,-\\pi9-which-is-Contained-in-one-Quartic","page":"Nongeneral Type Surfaces in mathbb P^4","title":"A K3 Surface with d=10, pi=9 which is Contained in one Quartic","text":"","category":"section"},{"location":"AlgebraicGeometry/Surfaces/SurfacesP4/","page":"Nongeneral Type Surfaces in mathbb P^4","title":"Nongeneral Type Surfaces in mathbb P^4","text":"k3_d10_pi9_quart_1()","category":"page"},{"location":"AlgebraicGeometry/Surfaces/SurfacesP4/#k3_d10_pi9_quart_1-Tuple{}","page":"Nongeneral Type Surfaces in mathbb P^4","title":"k3_d10_pi9_quart_1","text":"k3_d10_pi9_quart_1()\n\nReturn a smooth K3 surface in mathbb P^4 with degree 10 and sectional genus 9 which is contained in precisely one quartic.\n\nThe returned surface is defined over a prime field of characteristic 31991.\n\n\n\n\n\n","category":"method"},{"location":"AlgebraicGeometry/Surfaces/SurfacesP4/#A-K3-Surface-with-d10,-\\pi9-which-is-Contained-in-a-Pencil-of-Quartics","page":"Nongeneral Type Surfaces in mathbb P^4","title":"A K3 Surface with d=10, pi=9 which is Contained in a Pencil of Quartics","text":"","category":"section"},{"location":"AlgebraicGeometry/Surfaces/SurfacesP4/","page":"Nongeneral Type Surfaces in mathbb P^4","title":"Nongeneral Type Surfaces in mathbb P^4","text":"k3_d10_pi9_quart_2()","category":"page"},{"location":"AlgebraicGeometry/Surfaces/SurfacesP4/#k3_d10_pi9_quart_2-Tuple{}","page":"Nongeneral Type Surfaces in mathbb P^4","title":"k3_d10_pi9_quart_2","text":"k3_d10_pi9_quart_2()\n\nReturn a smooth K3 surface in mathbb P^4 with degree 10 and sectional genus 9 which is contained in a pencil of quartics.\n\nThe returned surface is defined over a prime field of characteristic 31991.\n\n\n\n\n\n","category":"method"},{"location":"AlgebraicGeometry/Surfaces/SurfacesP4/#A-K3-Surface-with-d11,-\\pi11-and-no-6-Secant","page":"Nongeneral Type Surfaces in mathbb P^4","title":"A K3 Surface with d=11, pi=11 and no 6-Secant","text":"","category":"section"},{"location":"AlgebraicGeometry/Surfaces/SurfacesP4/","page":"Nongeneral Type Surfaces in mathbb P^4","title":"Nongeneral Type Surfaces in mathbb P^4","text":"k3_d11_pi11_ss_0()","category":"page"},{"location":"AlgebraicGeometry/Surfaces/SurfacesP4/#k3_d11_pi11_ss_0-Tuple{}","page":"Nongeneral Type Surfaces in mathbb P^4","title":"k3_d11_pi11_ss_0","text":"k3_d11_pi11_ss_0()\n\nReturn a smooth K3 surface in mathbb P^4 with degree 11, sectional genus 11, and no 6-secant.\n\nThe returned surface is defined over a prime field of characteristic 31991.\n\n\n\n\n\n","category":"method"},{"location":"AlgebraicGeometry/Surfaces/SurfacesP4/#A-K3-Surface-with-d11,-\\pi11-and-one-6-Secant","page":"Nongeneral Type Surfaces in mathbb P^4","title":"A K3 Surface with d=11, pi=11 and one 6-Secant","text":"","category":"section"},{"location":"AlgebraicGeometry/Surfaces/SurfacesP4/","page":"Nongeneral Type Surfaces in mathbb P^4","title":"Nongeneral Type Surfaces in mathbb P^4","text":"k3_d11_pi11_ss_1()","category":"page"},{"location":"AlgebraicGeometry/Surfaces/SurfacesP4/#k3_d11_pi11_ss_1-Tuple{}","page":"Nongeneral Type Surfaces in mathbb P^4","title":"k3_d11_pi11_ss_1","text":"k3_d11_pi11_ss_1()\n\nReturn a smooth K3 surface in mathbb P^4 with degree 11, sectional genus 11, and one 6-secant.\n\nThe returned surface is defined over a prime field of characteristic 31991.\n\n\n\n\n\n","category":"method"},{"location":"AlgebraicGeometry/Surfaces/SurfacesP4/#A-K3-Surface-with-d11,-\\pi11-and-two-6-Secants","page":"Nongeneral Type Surfaces in mathbb P^4","title":"A K3 Surface with d=11, pi=11 and two 6-Secants","text":"","category":"section"},{"location":"AlgebraicGeometry/Surfaces/SurfacesP4/","page":"Nongeneral Type Surfaces in mathbb P^4","title":"Nongeneral Type Surfaces in mathbb P^4","text":"k3_d11_pi11_ss_2()","category":"page"},{"location":"AlgebraicGeometry/Surfaces/SurfacesP4/#k3_d11_pi11_ss_2-Tuple{}","page":"Nongeneral Type Surfaces in mathbb P^4","title":"k3_d11_pi11_ss_2","text":"k3_d11_pi11_ss_2()\n\nReturn a smooth K3 surface in mathbb P^4 with degree 11, sectional genus 11, and two 6-secants.\n\nThe returned surface is defined over a prime field of characteristic 31991.\n\n\n\n\n\n","category":"method"},{"location":"AlgebraicGeometry/Surfaces/SurfacesP4/#A-K3-Surface-with-d11,-\\pi11-and-three-6-Secants","page":"Nongeneral Type Surfaces in mathbb P^4","title":"A K3 Surface with d=11, pi=11 and three 6-Secants","text":"","category":"section"},{"location":"AlgebraicGeometry/Surfaces/SurfacesP4/","page":"Nongeneral Type Surfaces in mathbb P^4","title":"Nongeneral Type Surfaces in mathbb P^4","text":"k3_d11_pi11_ss_3()","category":"page"},{"location":"AlgebraicGeometry/Surfaces/SurfacesP4/#k3_d11_pi11_ss_3-Tuple{}","page":"Nongeneral Type Surfaces in mathbb P^4","title":"k3_d11_pi11_ss_3","text":"k3_d11_pi11_ss_3()\n\nReturn a smooth K3 surface in mathbb P^4 with degree 11, sectional genus 11, and three 6-secants.\n\nThe returned surface is defined over a prime field of characteristic 31991.\n\n\n\n\n\n","category":"method"},{"location":"AlgebraicGeometry/Surfaces/SurfacesP4/#A-K3-Surface-with-d11,-\\pi12","page":"Nongeneral Type Surfaces in mathbb P^4","title":"A K3 Surface with d=11, pi=12","text":"","category":"section"},{"location":"AlgebraicGeometry/Surfaces/SurfacesP4/","page":"Nongeneral Type Surfaces in mathbb P^4","title":"Nongeneral Type Surfaces in mathbb P^4","text":"k3_d11_pi12()","category":"page"},{"location":"AlgebraicGeometry/Surfaces/SurfacesP4/#k3_d11_pi12-Tuple{}","page":"Nongeneral Type Surfaces in mathbb P^4","title":"k3_d11_pi12","text":"k3_d11_pi12()\n\nReturn a smooth K3 surface in mathbb P^4 with degree 11 and sectional genus 12.\n\nThe returned surface is defined over a prime field of characteristic 31991.\n\n\n\n\n\n","category":"method"},{"location":"AlgebraicGeometry/Surfaces/SurfacesP4/#A-K3-Surface-with-d12,-\\pi14","page":"Nongeneral Type Surfaces in mathbb P^4","title":"A K3 Surface with d=12, pi=14","text":"","category":"section"},{"location":"AlgebraicGeometry/Surfaces/SurfacesP4/","page":"Nongeneral Type Surfaces in mathbb P^4","title":"Nongeneral Type Surfaces in mathbb P^4","text":"k3_d12_pi14()","category":"page"},{"location":"AlgebraicGeometry/Surfaces/SurfacesP4/#k3_d12_pi14-Tuple{}","page":"Nongeneral Type Surfaces in mathbb P^4","title":"k3_d12_pi14","text":"k3_d12_pi14()\n\nReturn a smooth K3 surface in mathbb P^4 with degree 12 and sectional genus 14.\n\nThe returned surface is defined over a prime field of characteristic 31991.\n\n\n\n\n\n","category":"method"},{"location":"AlgebraicGeometry/Surfaces/SurfacesP4/#A-K3-Surface-with-d13,-\\pi16","page":"Nongeneral Type Surfaces in mathbb P^4","title":"A K3 Surface with d=13, pi=16","text":"","category":"section"},{"location":"AlgebraicGeometry/Surfaces/SurfacesP4/","page":"Nongeneral Type Surfaces in mathbb P^4","title":"Nongeneral Type Surfaces in mathbb P^4","text":"k3_d13_pi16()","category":"page"},{"location":"AlgebraicGeometry/Surfaces/SurfacesP4/#k3_d13_pi16-Tuple{}","page":"Nongeneral Type Surfaces in mathbb P^4","title":"k3_d13_pi16","text":"k3_d13_pi16()\n\nReturn a smooth K3 surface in mathbb P^4 with degree 13 and sectional genus 16.\n\nThe returned surface is defined over a prime field of characteristic 31991.\n\n\n\n\n\n","category":"method"},{"location":"AlgebraicGeometry/Surfaces/SurfacesP4/#A-K3-Surface-with-d14,-\\pi19","page":"Nongeneral Type Surfaces in mathbb P^4","title":"A K3 Surface with d=14, pi=19","text":"","category":"section"},{"location":"AlgebraicGeometry/Surfaces/SurfacesP4/","page":"Nongeneral Type Surfaces in mathbb P^4","title":"Nongeneral Type Surfaces in mathbb P^4","text":"k3_d14_pi19()","category":"page"},{"location":"AlgebraicGeometry/Surfaces/SurfacesP4/#k3_d14_pi19-Tuple{}","page":"Nongeneral Type Surfaces in mathbb P^4","title":"k3_d14_pi19","text":"k3_d14_pi19()\n\nReturn a smooth K3 surface in mathbb P^4 with degree 14 and sectional genus 19.\n\nThe returned surface is defined over a prime field of characteristic 31991.\n\n\n\n\n\n","category":"method"},{"location":"AlgebraicGeometry/Surfaces/SurfacesP4/#Bielliptic-Surfaces","page":"Nongeneral Type Surfaces in mathbb P^4","title":"Bielliptic Surfaces","text":"","category":"section"},{"location":"AlgebraicGeometry/Surfaces/SurfacesP4/#A-Bielliptic-Surface-with-d10,-\\pi6","page":"Nongeneral Type Surfaces in mathbb P^4","title":"A Bielliptic Surface with d=10, pi=6","text":"","category":"section"},{"location":"AlgebraicGeometry/Surfaces/SurfacesP4/","page":"Nongeneral Type Surfaces in mathbb P^4","title":"Nongeneral Type Surfaces in mathbb P^4","text":"bielliptic_d10_pi6()","category":"page"},{"location":"AlgebraicGeometry/Surfaces/SurfacesP4/#bielliptic_d10_pi6-Tuple{}","page":"Nongeneral Type Surfaces in mathbb P^4","title":"bielliptic_d10_pi6","text":"bielliptic_d10_pi6()\n\nReturn a smooth bielliptic surface in mathbb P^4 with degree 10 and sectional genus 6.\n\nThe returned surface is defined over a prime field of characteristic 911.\n\n\n\n\n\n","category":"method"},{"location":"AlgebraicGeometry/Surfaces/SurfacesP4/#A-Bielliptic-Surface-with-d15,-\\pi21","page":"Nongeneral Type Surfaces in mathbb P^4","title":"A Bielliptic Surface with d=15, pi=21","text":"","category":"section"},{"location":"AlgebraicGeometry/Surfaces/SurfacesP4/","page":"Nongeneral Type Surfaces in mathbb P^4","title":"Nongeneral Type Surfaces in mathbb P^4","text":"bielliptic_d15_pi21()","category":"page"},{"location":"AlgebraicGeometry/Surfaces/SurfacesP4/#bielliptic_d15_pi21-Tuple{}","page":"Nongeneral Type Surfaces in mathbb P^4","title":"bielliptic_d15_pi21","text":"bielliptic_d15_pi21()\n\nReturn a smooth bielliptic surface in mathbb P^4 with degree 15 and sectional genus 21.\n\nThe returned surface is defined over a prime field of characteristic 911.\n\n\n\n\n\n","category":"method"},{"location":"AlgebraicGeometry/Surfaces/SurfacesP4/#Abelian-Surfaces","page":"Nongeneral Type Surfaces in mathbb P^4","title":"Abelian Surfaces","text":"","category":"section"},{"location":"AlgebraicGeometry/Surfaces/SurfacesP4/#An-Abelian-Surface-with-d10,-\\pi6","page":"Nongeneral Type Surfaces in mathbb P^4","title":"An Abelian Surface with d=10, pi=6","text":"","category":"section"},{"location":"AlgebraicGeometry/Surfaces/SurfacesP4/","page":"Nongeneral Type Surfaces in mathbb P^4","title":"Nongeneral Type Surfaces in mathbb P^4","text":"abelian_d10_pi6()","category":"page"},{"location":"AlgebraicGeometry/Surfaces/SurfacesP4/#abelian_d10_pi6-Tuple{}","page":"Nongeneral Type Surfaces in mathbb P^4","title":"abelian_d10_pi6","text":"abelian_d10_pi6()\n\nReturn a smooth abelian surface in mathbb P^4 with degree 10 and sectional genus 6.\n\nThe returned surface is defined over a prime field of characteristic 31991.\n\n\n\n\n\n","category":"method"},{"location":"AlgebraicGeometry/Surfaces/SurfacesP4/#An-Abelian-Surface-with-d15,-\\pi21-which-is-Contained-in-a-Net-of-Quintics","page":"Nongeneral Type Surfaces in mathbb P^4","title":"An Abelian Surface with d=15, pi=21 which is Contained in a Net of Quintics","text":"","category":"section"},{"location":"AlgebraicGeometry/Surfaces/SurfacesP4/","page":"Nongeneral Type Surfaces in mathbb P^4","title":"Nongeneral Type Surfaces in mathbb P^4","text":"abelian_d15_pi21_quintic_3()","category":"page"},{"location":"AlgebraicGeometry/Surfaces/SurfacesP4/#abelian_d15_pi21_quintic_3-Tuple{}","page":"Nongeneral Type Surfaces in mathbb P^4","title":"abelian_d15_pi21_quintic_3","text":"abelian_d15_pi21_quintic_3()\n\nReturn a smooth abelian surface in mathbb P^4 with degree 15 and sectional genus 21 which is contained in a net of quintics.\n\nThe returned surface is defined over a prime field of characteristic 31991.\n\n\n\n\n\n","category":"method"},{"location":"AlgebraicGeometry/Surfaces/SurfacesP4/#An-Abelian-Surface-with-d15,-\\pi21-which-is-Contained-in-one-Quintic","page":"Nongeneral Type Surfaces in mathbb P^4","title":"An Abelian Surface with d=15, pi=21 which is Contained in one Quintic","text":"","category":"section"},{"location":"AlgebraicGeometry/Surfaces/SurfacesP4/","page":"Nongeneral Type Surfaces in mathbb P^4","title":"Nongeneral Type Surfaces in mathbb P^4","text":"abelian_d15_pi21_quintic_1()","category":"page"},{"location":"AlgebraicGeometry/Surfaces/SurfacesP4/#abelian_d15_pi21_quintic_1-Tuple{}","page":"Nongeneral Type Surfaces in mathbb P^4","title":"abelian_d15_pi21_quintic_1","text":"abelian_d15_pi21_quintic_1()\n\nReturn a smooth abelian surface in mathbb P^4 with degree 15 and sectional genus 21 which is contained in precisely one quintic.\n\nThe returned surface is defined over a prime field of characteristic 31991.\n\n\n\n\n\n","category":"method"},{"location":"AlgebraicGeometry/Surfaces/SurfacesP4/#Elliptic-Surfaces","page":"Nongeneral Type Surfaces in mathbb P^4","title":"Elliptic Surfaces","text":"","category":"section"},{"location":"AlgebraicGeometry/Surfaces/SurfacesP4/#An-Elliptic-Surface-with-d7,-\\pi6","page":"Nongeneral Type Surfaces in mathbb P^4","title":"An Elliptic Surface with d=7, pi=6","text":"","category":"section"},{"location":"AlgebraicGeometry/Surfaces/SurfacesP4/","page":"Nongeneral Type Surfaces in mathbb P^4","title":"Nongeneral Type Surfaces in mathbb P^4","text":"elliptic_d7_pi6()","category":"page"},{"location":"AlgebraicGeometry/Surfaces/SurfacesP4/#elliptic_d7_pi6-Tuple{}","page":"Nongeneral Type Surfaces in mathbb P^4","title":"elliptic_d7_pi6","text":"elliptic_d7_pi6()\n\nReturn a smooth elliptic surface in mathbb P^4 with degree 7 and sectional genus 6.\n\nThe returned surface is defined over a prime field of characteristic 31991.\n\n\n\n\n\n","category":"method"},{"location":"AlgebraicGeometry/Surfaces/SurfacesP4/#An-Elliptic-Surface-with-d8,-\\pi7","page":"Nongeneral Type Surfaces in mathbb P^4","title":"An Elliptic Surface with d=8, pi=7","text":"","category":"section"},{"location":"AlgebraicGeometry/Surfaces/SurfacesP4/","page":"Nongeneral Type Surfaces in mathbb P^4","title":"Nongeneral Type Surfaces in mathbb P^4","text":"elliptic_d8_pi7()","category":"page"},{"location":"AlgebraicGeometry/Surfaces/SurfacesP4/#elliptic_d8_pi7-Tuple{}","page":"Nongeneral Type Surfaces in mathbb P^4","title":"elliptic_d8_pi7","text":"elliptic_d8_pi7()\n\nReturn a smooth elliptic surface in mathbb P^4 with degree 8 and sectional genus 7.\n\nThe returned surface is defined over a prime field of characteristic 31991.\n\n\n\n\n\n","category":"method"},{"location":"AlgebraicGeometry/Surfaces/SurfacesP4/#An-Elliptic-Surface-with-d9,-\\pi7","page":"Nongeneral Type Surfaces in mathbb P^4","title":"An Elliptic Surface with d=9, pi=7","text":"","category":"section"},{"location":"AlgebraicGeometry/Surfaces/SurfacesP4/","page":"Nongeneral Type Surfaces in mathbb P^4","title":"Nongeneral Type Surfaces in mathbb P^4","text":"elliptic_d9_pi7()","category":"page"},{"location":"AlgebraicGeometry/Surfaces/SurfacesP4/#elliptic_d9_pi7-Tuple{}","page":"Nongeneral Type Surfaces in mathbb P^4","title":"elliptic_d9_pi7","text":"elliptic_d9_pi7()\n\nReturn a smooth elliptic surface in mathbb P^4 with degree 9 and sectional genus 7.\n\nThe returned surface is defined over a prime field of characteristic 31991.\n\n\n\n\n\n","category":"method"},{"location":"AlgebraicGeometry/Surfaces/SurfacesP4/#An-Elliptic-Surface-with-d10,-\\pi9","page":"Nongeneral Type Surfaces in mathbb P^4","title":"An Elliptic Surface with d=10, pi=9","text":"","category":"section"},{"location":"AlgebraicGeometry/Surfaces/SurfacesP4/","page":"Nongeneral Type Surfaces in mathbb P^4","title":"Nongeneral Type Surfaces in mathbb P^4","text":"elliptic_d10_pi9()","category":"page"},{"location":"AlgebraicGeometry/Surfaces/SurfacesP4/#elliptic_d10_pi9-Tuple{}","page":"Nongeneral Type Surfaces in mathbb P^4","title":"elliptic_d10_pi9","text":"elliptic_d10_pi9()\n\nReturn a smooth elliptic surface in mathbb P^4 with degree 10 and sectional genus 9.\n\nThe returned surface is defined over a prime field of characteristic 31991.\n\n\n\n\n\n","category":"method"},{"location":"AlgebraicGeometry/Surfaces/SurfacesP4/#An-Elliptic-Surface-with-d10,-\\pi10","page":"Nongeneral Type Surfaces in mathbb P^4","title":"An Elliptic Surface with d=10, pi=10","text":"","category":"section"},{"location":"AlgebraicGeometry/Surfaces/SurfacesP4/","page":"Nongeneral Type Surfaces in mathbb P^4","title":"Nongeneral Type Surfaces in mathbb P^4","text":"elliptic_d10_pi10()","category":"page"},{"location":"AlgebraicGeometry/Surfaces/SurfacesP4/#elliptic_d10_pi10-Tuple{}","page":"Nongeneral Type Surfaces in mathbb P^4","title":"elliptic_d10_pi10","text":"elliptic_d10_pi10()\n\nReturn a smooth elliptic surface in mathbb P^4 with degree 10 and sectional genus 10.\n\nThe returned surface is defined over a prime field of characteristic 31991.\n\n\n\n\n\n","category":"method"},{"location":"AlgebraicGeometry/Surfaces/SurfacesP4/#An-Elliptic-Surface-with-d11,-\\pi12","page":"Nongeneral Type Surfaces in mathbb P^4","title":"An Elliptic Surface with d=11, pi=12","text":"","category":"section"},{"location":"AlgebraicGeometry/Surfaces/SurfacesP4/","page":"Nongeneral Type Surfaces in mathbb P^4","title":"Nongeneral Type Surfaces in mathbb P^4","text":"elliptic_d11_pi12()","category":"page"},{"location":"AlgebraicGeometry/Surfaces/SurfacesP4/#elliptic_d11_pi12-Tuple{}","page":"Nongeneral Type Surfaces in mathbb P^4","title":"elliptic_d11_pi12","text":"elliptic_d11_pi12()\n\nReturn a smooth elliptic surface in mathbb P^4 with degree 11 and sectional genus 12.\n\nThe returned surface is defined over a prime field of characteristic 31991.\n\n\n\n\n\n","category":"method"},{"location":"AlgebraicGeometry/Surfaces/SurfacesP4/#An-Elliptic-Surface-with-d12,-\\pi13","page":"Nongeneral Type Surfaces in mathbb P^4","title":"An Elliptic Surface with d=12, pi=13","text":"","category":"section"},{"location":"AlgebraicGeometry/Surfaces/SurfacesP4/","page":"Nongeneral Type Surfaces in mathbb P^4","title":"Nongeneral Type Surfaces in mathbb P^4","text":"elliptic_d12_pi13()","category":"page"},{"location":"AlgebraicGeometry/Surfaces/SurfacesP4/#elliptic_d12_pi13-Tuple{}","page":"Nongeneral Type Surfaces in mathbb P^4","title":"elliptic_d12_pi13","text":"elliptic_d12_pi13()\n\nReturn a smooth elliptic surface in mathbb P^4 with degree 12 and sectional genus 13.\n\nThe returned surface is defined over a prime field of characteristic 31991.\n\n\n\n\n\n","category":"method"},{"location":"AlgebraicGeometry/Surfaces/SurfacesP4/#An-Elliptic-Surface-with-d12,-\\pi14-and-no-6-Secant","page":"Nongeneral Type Surfaces in mathbb P^4","title":"An Elliptic Surface with d=12, pi=14 and no 6-Secant","text":"","category":"section"},{"location":"AlgebraicGeometry/Surfaces/SurfacesP4/","page":"Nongeneral Type Surfaces in mathbb P^4","title":"Nongeneral Type Surfaces in mathbb P^4","text":"elliptic_d12_pi14_ss_0()","category":"page"},{"location":"AlgebraicGeometry/Surfaces/SurfacesP4/#elliptic_d12_pi14_ss_0-Tuple{}","page":"Nongeneral Type Surfaces in mathbb P^4","title":"elliptic_d12_pi14_ss_0","text":"elliptic_d12_pi14_ss_0()\n\nReturn a smooth elliptic surface in mathbb P^4 with degree 12, sectional genus 14, and no 6-secant.\n\nThe returned surface is defined over a prime field of characteristic 31991.\n\n\n\n\n\n","category":"method"},{"location":"AlgebraicGeometry/Surfaces/SurfacesP4/#An-Elliptic-Surface-with-d12,-\\pi14,-and-Infinitely-Many-6-Secants","page":"Nongeneral Type Surfaces in mathbb P^4","title":"An Elliptic Surface with d=12, pi=14, and Infinitely Many 6-Secants","text":"","category":"section"},{"location":"AlgebraicGeometry/Surfaces/SurfacesP4/","page":"Nongeneral Type Surfaces in mathbb P^4","title":"Nongeneral Type Surfaces in mathbb P^4","text":"elliptic_d12_pi14_ss_inf()","category":"page"},{"location":"AlgebraicGeometry/Surfaces/SurfacesP4/#elliptic_d12_pi14_ss_inf-Tuple{}","page":"Nongeneral Type Surfaces in mathbb P^4","title":"elliptic_d12_pi14_ss_inf","text":"elliptic_d12_pi14_ss_inf()\n\nReturn a smooth elliptic surface in mathbb P^4 with degree 12, sectional genus 14, and infinitely many 6-secants.\n\nThe returned surface is defined over a prime field of characteristic 31991.\n\n\n\n\n\n","category":"method"},{"location":"AlgebraicGeometry/Surfaces/SurfacesP4/#Contact","page":"Nongeneral Type Surfaces in mathbb P^4","title":"Contact","text":"","category":"section"},{"location":"AlgebraicGeometry/Surfaces/SurfacesP4/","page":"Nongeneral Type Surfaces in mathbb P^4","title":"Nongeneral Type Surfaces in mathbb P^4","text":"Please direct questions about this part of OSCAR to the following people:","category":"page"},{"location":"AlgebraicGeometry/Surfaces/SurfacesP4/","page":"Nongeneral Type Surfaces in mathbb P^4","title":"Nongeneral Type Surfaces in mathbb P^4","text":"Wolfram Decker.","category":"page"},{"location":"AlgebraicGeometry/Surfaces/SurfacesP4/","page":"Nongeneral Type Surfaces in mathbb P^4","title":"Nongeneral Type Surfaces in mathbb P^4","text":"You can ask questions in the OSCAR Slack.","category":"page"},{"location":"AlgebraicGeometry/Surfaces/SurfacesP4/","page":"Nongeneral Type Surfaces in mathbb P^4","title":"Nongeneral Type Surfaces in mathbb P^4","text":"Alternatively, you can raise an issue on github.","category":"page"},{"location":"TropicalGeometry/tropicalization/#Tropicalization-of-polynomial-ideals","page":"Tropicalization of polynomial ideals","title":"Tropicalization of polynomial ideals","text":"","category":"section"},{"location":"TropicalGeometry/tropicalization/#Introduction","page":"Tropicalization of polynomial ideals","title":"Introduction","text":"","category":"section"},{"location":"TropicalGeometry/tropicalization/","page":"Tropicalization of polynomial ideals","title":"Tropicalization of polynomial ideals","text":"Tropical varieties can arise as tropicalizations of polynomial ideals. For a general introduction, see","category":"page"},{"location":"TropicalGeometry/tropicalization/","page":"Tropicalization of polynomial ideals","title":"Tropicalization of polynomial ideals","text":"Chapter 3 in [MS15]","category":"page"},{"location":"TropicalGeometry/tropicalization/","page":"Tropicalization of polynomial ideals","title":"Tropicalization of polynomial ideals","text":"For algorithmic details, see","category":"page"},{"location":"TropicalGeometry/tropicalization/","page":"Tropicalization of polynomial ideals","title":"Tropicalization of polynomial ideals","text":"[BJSST07]\n[MR20]","category":"page"},{"location":"TropicalGeometry/tropicalization/#Main-function","page":"Tropicalization of polynomial ideals","title":"Main function","text":"","category":"section"},{"location":"TropicalGeometry/tropicalization/","page":"Tropicalization of polynomial ideals","title":"Tropicalization of polynomial ideals","text":"tropical_variety(I::MPolyIdeal, nu::Union{TropicalSemiringMap,Nothing}=nothing; weighted_polyhedral_complex_only::Bool=false, skip_saturation::Bool=false, skip_primary_decomposition::Bool=false)","category":"page"},{"location":"TropicalGeometry/tropicalization/#tropical_variety","page":"Tropicalization of polynomial ideals","title":"tropical_variety","text":"tropical_variety(I::MPolyIdeal, nu::Union{TropicalSemiringMap,Nothing}=nothing; weighted_polyhedral_complex_only::Bool=false, skip_saturation::Bool=false, skip_primary_decomposition::Bool=false)\n\nReturn the tropicalization of I with respect to nu as a Vector{TropicalVariety}. If nu==nothing, will compute with respect to the trivial valuation and min convention. If weighted_polyhedral_complex_only==true, will not cache any additional information. If skip_saturation==true, will not saturate I with respect to the product of all variables. If skip_primary_decomposition==true, will not decompose I.\n\nwarning: Warning\ntropical_variety is currently under development and only works for ideals that primary decompose into principal, linear, and binomial ideals.\n\nExamples\n\njulia> R,(x,y) = QQ[:x, :y];\n\njulia> I = ideal([(x^2+y)*(x+y^2)*(x+y)]);\n\njulia> tropical_variety(I)\n3-element Vector{TropicalVariety}:\n Min tropical variety\n Min tropical variety\n Min tropical variety\n\n\n\n\n\n\n","category":"function"},{"location":"AlgebraicGeometry/Schemes/Sheaves/","page":"Sheaves on covered schemes","title":"Sheaves on covered schemes","text":"CurrentModule = Oscar","category":"page"},{"location":"AlgebraicGeometry/Schemes/Sheaves/#Sheaves-on-covered-schemes","page":"Sheaves on covered schemes","title":"Sheaves on covered schemes","text":"","category":"section"},{"location":"AlgebraicGeometry/Schemes/Sheaves/","page":"Sheaves on covered schemes","title":"Sheaves on covered schemes","text":"Oscar supports modeling sheaves by means of a covering by affine charts.","category":"page"},{"location":"AlgebraicGeometry/Schemes/Sheaves/#Presheaves","page":"Sheaves on covered schemes","title":"Presheaves","text":"","category":"section"},{"location":"AlgebraicGeometry/Schemes/Sheaves/","page":"Sheaves on covered schemes","title":"Sheaves on covered schemes","text":"AbsPreSheaf\nPreSheafOnScheme","category":"page"},{"location":"AlgebraicGeometry/Schemes/Sheaves/#AbsPreSheaf","page":"Sheaves on covered schemes","title":"AbsPreSheaf","text":"AbsPreSheaf{SpaceType, OpenType, OutputType, RestrictionType}\n\nAbstract type for a sheaf ℱ on a space X.\n\nSpaceType is a parameter for the type of the space X on which ℱ is defined.\nOpenType is a type (most probably abstract!) for the open sets U  X which are admissible as input for ℱ(U).\nOutputType is a type (most probably abstract!) for the values that ℱ takes on admissible open sets U.\nRestrictionType is a parameter for the type of the restriction maps ℱ(V)  ℱ(U) for U  V  X open.\n\nFor any instance F of AbsPreSheaf on a topological space X the following methods are implemented:\n\nF(U) for admissible open subsets U  X: This returns the value ℱ(U) of the sheaf F on U. Note that due to technical limitations, not every type of open subset might be admissible.\nrestriction_map(F, U, V) for admissible open subsets V  U  X: This returns the restriction map ρ  ℱ(U)  ℱ(V). Alternatively, one may also call F(U, V) to get this map.\n\n\n\n\n\n","category":"type"},{"location":"AlgebraicGeometry/Schemes/Sheaves/#PreSheafOnScheme","page":"Sheaves on covered schemes","title":"PreSheafOnScheme","text":"PreSheafOnScheme\n\nA basic minimal implementation of the interface for AbsPreSheaf; to be used internally.\n\n\n\n\n\n","category":"type"},{"location":"AlgebraicGeometry/Schemes/Sheaves/#Structure-sheaves","page":"Sheaves on covered schemes","title":"Structure sheaves","text":"","category":"section"},{"location":"AlgebraicGeometry/Schemes/Sheaves/","page":"Sheaves on covered schemes","title":"Sheaves on covered schemes","text":"StructureSheafOfRings","category":"page"},{"location":"AlgebraicGeometry/Schemes/Sheaves/#StructureSheafOfRings","page":"Sheaves on covered schemes","title":"StructureSheafOfRings","text":"StructureSheafOfRings <: AbsPreSheaf\n\nOn an AbsCoveredScheme X this returns the sheaf 𝒪 of rings of regular functions on X.\n\nNote that due to technical reasons, the admissible open subsets are restricted to the following:\n\nU::AbsAffineScheme among the basic_patches of the default_covering of X;\nU::PrincipalOpenSubset with ambient_scheme(U) in the basic_patches of the default_covering of X;\nW::AffineSchemeOpenSubscheme with ambient_scheme(W) in the basic_patches of the default_covering of X.\n\nOne can call the restriction maps of 𝒪 across charts, implicitly using the identifications given by the gluings in the default_covering.\n\nExamples\n\njulia> IP2 = projective_space(GF(7), [:x, :y, :z])\nProjective space of dimension 2\n  over prime field of characteristic 7\nwith homogeneous coordinates [x, y, z]\n\njulia> X = covered_scheme(IP2)\nScheme\n  over prime field of characteristic 7\nwith default covering\n  described by patches\n    1: affine 2-space\n    2: affine 2-space\n    3: affine 2-space\n  in the coordinate(s)\n    1: [(y//x), (z//x)]\n    2: [(x//y), (z//y)]\n    3: [(x//z), (y//z)]\n\njulia> OOX = OO(X)\nStructure sheaf of rings of regular functions\n  on scheme over GF(7) covered with 3 patches\n    1: [(y//x), (z//x)]   affine 2-space\n    2: [(x//y), (z//y)]   affine 2-space\n    3: [(x//z), (y//z)]   affine 2-space\n\njulia> typeof(OOX)\nStructureSheafOfRings{CoveredScheme{FqField}, Union{AbsAffineScheme, AffineSchemeOpenSubscheme}, Ring, Map}\n\njulia> U, V, W = affine_charts(X)\n3-element Vector{AffineScheme{FqField, FqMPolyRing}}:\n Affine 2-space\n Affine 2-space\n Affine 2-space\n\njulia> glue = default_covering(X)[U, V]\nGluing\n  of affine 2-space\n  and affine 2-space\nalong the open subsets\n  [(y//x), (z//x)]   AA^2 \\ scheme((y//x))\n  [(x//y), (z//y)]   AA^2 \\ scheme((x//y))\ngiven by the pullback function\n  (x//y) -> 1/(y//x)\n  (z//y) -> (z//x)/(y//x)\n\njulia> UV, VU = gluing_domains(glue)\n(AA^2 \\ scheme((y//x)), AA^2 \\ scheme((x//y)))\n\njulia> y, z = gens(OOX(U))\n2-element Vector{FqMPolyRingElem}:\n (y//x)\n (z//x)\n\njulia> pb = OOX(U, VU)\nRing homomorphism\n  from multivariate polynomial ring in 2 variables over GF(7)\n  to localization of multivariate polynomial ring in 2 variables over GF(7) at products of ((x//y))\ndefined by\n  (y//x) -> 1/(x//y)\n  (z//x) -> (z//y)/(x//y)\n\njulia> pb(y^2)\n1/(x//y)^2\n\n\n\n\n\n\n","category":"type"},{"location":"AlgebraicGeometry/Schemes/Sheaves/#Ideal-sheaves","page":"Sheaves on covered schemes","title":"Ideal sheaves","text":"","category":"section"},{"location":"AlgebraicGeometry/Schemes/Sheaves/","page":"Sheaves on covered schemes","title":"Sheaves on covered schemes","text":"AbsIdealSheaf\nIdealSheaf\nPrimeIdealSheafFromChart\nSumIdealSheaf\nProductIdealSheaf\nSimplifiedIdealSheaf\nPullbackIdealSheaf\nRadicalOfIdealSheaf\nToricIdealSheafFromCoxRingIdeal\nSingularLocusIdealSheaf","category":"page"},{"location":"AlgebraicGeometry/Schemes/Sheaves/#AbsIdealSheaf","page":"Sheaves on covered schemes","title":"AbsIdealSheaf","text":"AbsIdealSheaf <: AbsPreSheaf\n\nA sheaf of ideals I on an AbsCoveredScheme X.\n\nFor an affine open subset U  X call I(U) to obtain an ideal  in OO(U) representing I.\n\nExamples\n\njulia> IP2 = projective_space(GF(7), [:x, :y, :z])\nProjective space of dimension 2\n  over prime field of characteristic 7\nwith homogeneous coordinates [x, y, z]\n\njulia> X = covered_scheme(IP2)\nScheme\n  over prime field of characteristic 7\nwith default covering\n  described by patches\n    1: affine 2-space\n    2: affine 2-space\n    3: affine 2-space\n  in the coordinate(s)\n    1: [(y//x), (z//x)]\n    2: [(x//y), (z//y)]\n    3: [(x//z), (y//z)]\n\njulia> S = homogeneous_coordinate_ring(IP2)\nMultivariate polynomial ring in 3 variables over GF(7) graded by\n  x -> [1]\n  y -> [1]\n  z -> [1]\n\njulia> II = ideal_sheaf(IP2, ideal(S, [S[1] + S[2]]))\nSheaf of ideals\n  on scheme over GF(7) covered with 3 patches\n    1: [(y//x), (z//x)]   affine 2-space\n    2: [(x//y), (z//y)]   affine 2-space\n    3: [(x//z), (y//z)]   affine 2-space\nwith restrictions\n  1: Ideal ((y//x) + 1)\n  2: Ideal ((x//y) + 1)\n  3: Ideal ((x//z) + (y//z))\n\njulia> U, V, W = affine_charts(X)\n3-element Vector{AffineScheme{FqField, FqMPolyRing}}:\n Affine 2-space\n Affine 2-space\n Affine 2-space\n\njulia> II(U)\nIdeal generated by\n  (y//x) + 1\n\njulia> II(V)\nIdeal generated by\n  (x//y) + 1\n\njulia> glue = default_covering(X)[U, V];\n\njulia> UV, VU = gluing_domains(glue);\n\njulia> II(U, VU) # transition functions are ring homomorphisms for ideal sheaves!\nRing homomorphism\n  from multivariate polynomial ring in 2 variables over GF(7)\n  to localization of multivariate polynomial ring in 2 variables over GF(7) at products of ((x//y))\ndefined by\n  (y//x) -> 1/(x//y)\n  (z//x) -> (z//y)/(x//y)\n\n\n\n\n\n\n","category":"type"},{"location":"AlgebraicGeometry/Schemes/Sheaves/#IdealSheaf","page":"Sheaves on covered schemes","title":"IdealSheaf","text":"IdealSheaf <: AbsIdealSheaf\n\nA sheaf of ideals ℐ on an AbsCoveredScheme X which is specified  by a collection of concrete ideals on some open covering of X.\n\n\n\n\n\n","category":"type"},{"location":"AlgebraicGeometry/Schemes/Sheaves/#PrimeIdealSheafFromChart","page":"Sheaves on covered schemes","title":"PrimeIdealSheafFromChart","text":"PrimeIdealSheafFromChart\n\nType for sheaves of prime ideals P on a covered scheme X constructed from a prime ideal of the coordinate ring of a chart. Essentially this is a scheme theoretic point.\n\nFor U an affine chart of X, the ideal P(U) is computed using the gluings.  The implementation is lazy.\n\nExamples\n\njulia> IP2 = projective_space(GF(7), [:x, :y, :z])\nProjective space of dimension 2\n  over prime field of characteristic 7\nwith homogeneous coordinates [x, y, z]\n\njulia> X = covered_scheme(IP2)\nScheme\n  over prime field of characteristic 7\nwith default covering\n  described by patches\n    1: affine 2-space\n    2: affine 2-space\n    3: affine 2-space\n  in the coordinate(s)\n    1: [(y//x), (z//x)]\n    2: [(x//y), (z//y)]\n    3: [(x//z), (y//z)]\n\njulia> U, V, W = affine_charts(X);\n\njulia> glue = default_covering(X)[U, V];\n\njulia> y, z = gens(OO(U))\n2-element Vector{FqMPolyRingElem}:\n (y//x)\n (z//x)\n\njulia> P = ideal(OO(U), [y - z])\nIdeal generated by\n  (y//x) + 6*(z//x)\n\njulia> PP = Oscar.PrimeIdealSheafFromChart(X, U, P)\nPrime ideal sheaf on Scheme over GF(7) covered with 3 patches extended from Ideal ((y//x) + 6*(z//x)) on Affine 2-space\n\njulia> PP(W)\nIdeal generated by\n  (y//z) + 6\n\n\n\n\n\n\n","category":"type"},{"location":"AlgebraicGeometry/Schemes/Sheaves/#SumIdealSheaf","page":"Sheaves on covered schemes","title":"SumIdealSheaf","text":"SumIdealSheaf\n\nSum of two or more ideal sheaves.\n\nExamples\n\njulia> IP2 = projective_space(GF(7), [:x, :y, :z])\nProjective space of dimension 2\n  over prime field of characteristic 7\nwith homogeneous coordinates [x, y, z]\n\njulia> X = covered_scheme(IP2)\nScheme\n  over prime field of characteristic 7\nwith default covering\n  described by patches\n    1: affine 2-space\n    2: affine 2-space\n    3: affine 2-space\n  in the coordinate(s)\n    1: [(y//x), (z//x)]\n    2: [(x//y), (z//y)]\n    3: [(x//z), (y//z)]\n\njulia> U, V, W = affine_charts(X);\n\njulia> y, z = gens(OO(U));\n\njulia> P1 = ideal(OO(U), [y - z]);\n\njulia> PP1 = Oscar.PrimeIdealSheafFromChart(X, U, P1);\n\njulia> P2 = ideal(OO(V), [OO(V)[1]]);\n\njulia> PP2 = Oscar.PrimeIdealSheafFromChart(X, V, P2)\nPrime ideal sheaf on Scheme over GF(7) covered with 3 patches extended from Ideal ((x//y)) on Affine 2-space\n\njulia> II = PP1 + PP2\nSum of\n  Prime ideal sheaf on scheme over GF(7) covered with 3 patches extended from ideal ((y//x) + 6*(z//x)) on affine 2-space\n  Prime ideal sheaf on scheme over GF(7) covered with 3 patches extended from ideal ((x//y)) on affine 2-space\n\njulia> typeof(II)\nOscar.SumIdealSheaf{CoveredScheme{FqField}, AbsAffineScheme, Ideal, Map}\n\njulia> II(W)\nIdeal generated by\n  (y//z) + 6\n  (x//z)\n\n\n\n\n\n\n","category":"type"},{"location":"AlgebraicGeometry/Schemes/Sheaves/#ProductIdealSheaf","page":"Sheaves on covered schemes","title":"ProductIdealSheaf","text":"ProductIdealSheaf\n\nProduct of two or more ideal sheaves.\n\nExamples\n\njulia> IP2 = projective_space(GF(7), [:x, :y, :z])\nProjective space of dimension 2\n  over prime field of characteristic 7\nwith homogeneous coordinates [x, y, z]\n\njulia> X = covered_scheme(IP2)\nScheme\n  over prime field of characteristic 7\nwith default covering\n  described by patches\n    1: affine 2-space\n    2: affine 2-space\n    3: affine 2-space\n  in the coordinate(s)\n    1: [(y//x), (z//x)]\n    2: [(x//y), (z//y)]\n    3: [(x//z), (y//z)]\n\njulia> U, V, W = affine_charts(X);\n\njulia> y, z = gens(OO(U));\n\njulia> P1 = ideal(OO(U), [y - z]);\n\njulia> PP1 = Oscar.PrimeIdealSheafFromChart(X, U, P1);\n\njulia> P2 = ideal(OO(V), [OO(V)[1]]);\n\njulia> PP2 = Oscar.PrimeIdealSheafFromChart(X, V, P2)\nPrime ideal sheaf on Scheme over GF(7) covered with 3 patches extended from Ideal ((x//y)) on Affine 2-space\n\njulia> II = PP1 * PP2\nProduct of\n  Prime ideal sheaf on scheme over GF(7) covered with 3 patches extended from ideal ((y//x) + 6*(z//x)) on affine 2-space\n  Prime ideal sheaf on scheme over GF(7) covered with 3 patches extended from ideal ((x//y)) on affine 2-space\n\njulia> typeof(II)\nOscar.ProductIdealSheaf{CoveredScheme{FqField}, AbsAffineScheme, Ideal, Map}\n\njulia> II(W)\nIdeal generated by\n  (x//z)*(y//z) + 6*(x//z)\n\n\n\n\n\n\n","category":"type"},{"location":"AlgebraicGeometry/Schemes/Sheaves/#SimplifiedIdealSheaf","page":"Sheaves on covered schemes","title":"SimplifiedIdealSheaf","text":"SimplifiedIdealSheaf\n\nFor a given AbsIdealSheaf II on an AbsCoveredScheme X this uses a  heuristic to replace the generating set of II(U) by a hopefully smaller  one on every affine chart of X.\n\nExamples\n\njulia> IP2 = projective_space(GF(7), [:x, :y, :z])\nProjective space of dimension 2\n  over prime field of characteristic 7\nwith homogeneous coordinates [x, y, z]\n\njulia> X = covered_scheme(IP2)\nScheme\n  over prime field of characteristic 7\nwith default covering\n  described by patches\n    1: affine 2-space\n    2: affine 2-space\n    3: affine 2-space\n  in the coordinate(s)\n    1: [(y//x), (z//x)]\n    2: [(x//y), (z//y)]\n    3: [(x//z), (y//z)]\n\njulia> U, V, W = affine_charts(X);\n\njulia> y, z = gens(OO(U));\n\njulia> P1 = ideal(OO(U), [y - z]);\n\njulia> PP1 = Oscar.PrimeIdealSheafFromChart(X, U, P1);\n\njulia> P2 = ideal(OO(V), [OO(V)[1], OO(V)[2]]);\n\njulia> PP2 = Oscar.PrimeIdealSheafFromChart(X, V, P2)\nPrime ideal sheaf on Scheme over GF(7) covered with 3 patches extended from Ideal ((x//y), (z//y)) on Affine 2-space\n\njulia> II = PP1 + PP2\nSum of \n  Prime ideal sheaf on scheme over GF(7) covered with 3 patches extended from ideal ((y//x) + \n  6*(z//x)) on affine 2-space\n  Prime ideal sheaf on scheme over GF(7) covered with 3 patches extended from ideal ((x//y), (\n  z//y)) on affine 2-space\n\njulia> JJ = simplify(II)\nSheaf of ideals\n  on scheme over GF(7) covered with 3 patches\n    1: [(y//x), (z//x)]   affine 2-space\n    2: [(x//y), (z//y)]   affine 2-space\n    3: [(x//z), (y//z)]   affine 2-space\nwith restrictions\n  1: Ideal (1)\n  2: Ideal (1)\n  3: Ideal (1)\n\njulia> typeof(JJ)\nOscar.SimplifiedIdealSheaf{CoveredScheme{FqField}, AbsAffineScheme, Ideal, Map}\n\njulia> II(W)\nIdeal generated by\n  (y//z) + 6\n  1\n\njulia> JJ(W)\nIdeal generated by\n  1\n\n\n\n\n\n\n","category":"type"},{"location":"AlgebraicGeometry/Schemes/Sheaves/#PullbackIdealSheaf","page":"Sheaves on covered schemes","title":"PullbackIdealSheaf","text":"PullbackIdealSheaf\n\nGiven an morphism f : X -> Y of AbsCoveredSchemes and an ideal sheaf  II on Y, this computes the pullback f^* II on X.\n\nExamples\n\njulia> IP2 = projective_space(GF(7), [:x, :y, :z])\nProjective space of dimension 2\n  over prime field of characteristic 7\nwith homogeneous coordinates [x, y, z]\n\njulia> Y = covered_scheme(IP2)\nScheme\n  over prime field of characteristic 7\nwith default covering\n  described by patches\n    1: affine 2-space\n    2: affine 2-space\n    3: affine 2-space\n  in the coordinate(s)\n    1: [(y//x), (z//x)]\n    2: [(x//y), (z//y)]\n    3: [(x//z), (y//z)]\n\njulia> U, _ = affine_charts(Y);\n\njulia> y, z = gens(OO(U));\n\njulia> P1 = ideal(OO(U), [y, z]);\n\njulia> PP1 = Oscar.PrimeIdealSheafFromChart(Y, U, P1);\n\njulia> bl = blow_up(PP1);\n\njulia> X = domain(bl);\n\njulia> JJ = pullback(bl, PP1)\nSheaf of ideals\n  on scheme over GF(7) covered with 4 patches\n    1: [(s1//s0), (y//x)]   scheme(0)\n    2: [(s0//s1), (z//x)]   scheme(0)\n    3: [(x//y), (z//y)]     affine 2-space\n    4: [(x//z), (y//z)]     affine 2-space\nwith restrictions\n  1: Ideal ((y//x), (s1//s0)*(y//x))\n  2: Ideal ((s0//s1)*(z//x), (z//x))\n  3: Ideal (1)\n  4: Ideal (1)\n\njulia> typeof(JJ)\nOscar.PullbackIdealSheaf{CoveredScheme{FqField}, AbsAffineScheme, Ideal, Map}\n\n\n\n\n\n\n","category":"type"},{"location":"AlgebraicGeometry/Schemes/Sheaves/#RadicalOfIdealSheaf","page":"Sheaves on covered schemes","title":"RadicalOfIdealSheaf","text":"RadicalOfIdealSheaf\n\nGiven an AbsIdealSheaf II on an AbsCoveredScheme X, this computes  the sheaf associated to the radicals of the ideals on the charts.\n\nExamples\n\njulia> IP2 = projective_space(GF(7), [:x, :y, :z])\nProjective space of dimension 2\n  over prime field of characteristic 7\nwith homogeneous coordinates [x, y, z]\n\njulia> Y = covered_scheme(IP2)\nScheme\n  over prime field of characteristic 7\nwith default covering\n  described by patches\n    1: affine 2-space\n    2: affine 2-space\n    3: affine 2-space\n  in the coordinate(s)\n    1: [(y//x), (z//x)]\n    2: [(x//y), (z//y)]\n    3: [(x//z), (y//z)]\n\njulia> U, _ = affine_charts(Y);\n\njulia> y, z = gens(OO(U));\n\njulia> P1 = ideal(OO(U), [y, z]);\n\njulia> PP1 = Oscar.PrimeIdealSheafFromChart(Y, U, P1);\n\njulia> PP1_squared = PP1^2;\n\njulia> JJ = radical(PP1_squared);\n\njulia> typeof(JJ)\nOscar.RadicalOfIdealSheaf{CoveredScheme{FqField}, AbsAffineScheme, Ideal, Map}\n\njulia> PP1_squared(U)\nIdeal generated by\n  (y//x)^2\n  (y//x)*(z//x)\n  (z//x)^2\n\njulia> JJ(U)\nIdeal generated by\n  (z//x)\n  (y//x)\n\n\n\n\n\n\n","category":"type"},{"location":"AlgebraicGeometry/Schemes/Sheaves/#ToricIdealSheafFromCoxRingIdeal","page":"Sheaves on covered schemes","title":"ToricIdealSheafFromCoxRingIdeal","text":"ToricIdealSheafFromCoxRingIdeal\n\nThis is the ideal sheaf associated to a NormalToricVariety X  with cox_ring S and an ideal I of S.\n\nExamples\n\njulia> IP2 = projective_space(NormalToricVariety, 2)\nNormal toric variety\n\njulia> S = cox_ring(IP2)\nMultivariate polynomial ring in 3 variables over QQ graded by\n  x1 -> [1]\n  x2 -> [1]\n  x3 -> [1]\n\njulia> x, y, z = gens(S);\n\njulia> I = ideal(S, x^2 - y*z);\n\njulia> II = ideal_sheaf(IP2, I)\nSheaf of ideals\n  on normal toric variety\nwith restrictions\n  1: Ideal (x_1_1^2 - x_2_1)\n  2: Ideal (x_1_2*x_2_2 - 1)\n  3: Ideal (x_1_3^2 - x_2_3)\n\njulia> typeof(II)\nOscar.ToricIdealSheafFromCoxRingIdeal{NormalToricVariety, AbsAffineScheme, Ideal, Map}\n\n\n\n\n\n\n","category":"type"},{"location":"AlgebraicGeometry/Schemes/Sheaves/#SingularLocusIdealSheaf","page":"Sheaves on covered schemes","title":"SingularLocusIdealSheaf","text":"SingularLocusIdealSheaf\n\nThis is the (radical) ideal sheaf for the singular locus of an  AbsCoveredScheme X.\n\nExamples\n\njulia> IP2 = projective_space(NormalToricVariety, 2)\nNormal toric variety\n\njulia> S = cox_ring(IP2)\nMultivariate polynomial ring in 3 variables over QQ graded by\n  x1 -> [1]\n  x2 -> [1]\n  x3 -> [1]\n\njulia> x, y, z = gens(S);\n\njulia> I = ideal(S, x^3 - y*z^2);\n\njulia> II = ideal_sheaf(IP2, I);\n\njulia> X, inc_X = sub(II);\n\njulia> JJ = Oscar.ideal_sheaf_of_singular_locus(X)\nSheaf of ideals\n  on scheme over QQ covered with 3 patches\n    1: [x_1_1, x_2_1]   scheme(x_1_1^3 - x_2_1)\n    2: [x_1_2, x_2_2]   scheme(x_1_2^2*x_2_2 - 1)\n    3: [x_1_3, x_2_3]   scheme(x_1_3^3 - x_2_3^2)\nwith restrictions\n  1: Ideal (1)\n  2: Ideal (1)\n  3: Ideal (x_2_3, x_1_3)\n\njulia> typeof(JJ)\nOscar.SingularLocusIdealSheaf{CoveredScheme{QQField}, AbsAffineScheme, Ideal, Map}\n\n\n\n\n\n\n","category":"type"},{"location":"AlgebraicGeometry/Schemes/Sheaves/#Coherent-sheaves-of-modules","page":"Sheaves on covered schemes","title":"Coherent sheaves of modules","text":"","category":"section"},{"location":"AlgebraicGeometry/Schemes/Sheaves/","page":"Sheaves on covered schemes","title":"Sheaves on covered schemes","text":"These are some types for coherent sheaves.","category":"page"},{"location":"AlgebraicGeometry/Schemes/Sheaves/","page":"Sheaves on covered schemes","title":"Sheaves on covered schemes","text":"SheafOfModules\nHomSheaf\nPushforwardSheaf\nPullbackSheaf\nDirectSumSheaf","category":"page"},{"location":"AlgebraicGeometry/Schemes/Sheaves/#SheafOfModules","page":"Sheaves on covered schemes","title":"SheafOfModules","text":"SheafOfModules <: AbsPreSheaf\n\nA sheaf of modules ℳ on an AbsCoveredScheme X.\n\nNote that due to technical reasons, the admissible open subsets are restricted to the following:\n\nU::AbsAffineScheme among the basic_patches of the default_covering of X;\nU::PrincipalOpenSubset with ambient_scheme(U) in the basic_patches of the default_covering of X.\n\nOne can call the restriction maps of ℳ across charts implicitly using the identifications given by the gluings in the default_covering.\n\n\n\n\n\n","category":"type"},{"location":"AlgebraicGeometry/Schemes/Sheaves/#HomSheaf","page":"Sheaves on covered schemes","title":"HomSheaf","text":"HomSheaf\n\nFor two AbsCoherentSheafs F and G on an AbsCoveredScheme X  this computes the sheaf associated to U -> Hom(F(U), G(U)).\n\nExamples\n\njulia> IP1 = projective_space(GF(7), [:x, :y])\nProjective space of dimension 1\n  over prime field of characteristic 7\nwith homogeneous coordinates [x, y]\n\njulia> Y = covered_scheme(IP1);\n\njulia> Omega = cotangent_sheaf(Y)\nCoherent sheaf of modules\n  on scheme over GF(7) covered with 2 patches\n    1: [(y//x)]   affine 1-space\n    2: [(x//y)]   affine 1-space\nwith restrictions\n  1: free module of rank 1 over multivariate polynomial ring in 1 variable over GF(7)\n  2: free module of rank 1 over multivariate polynomial ring in 1 variable over GF(7)\n\njulia> F = free_module(OO(Y), 1)\nCoherent sheaf of modules\n  on scheme over GF(7) covered with 2 patches\n    1: [(y//x)]   affine 1-space\n    2: [(x//y)]   affine 1-space\nwith restrictions\n  1: free module of rank 1 over multivariate polynomial ring in 1 variable over GF(7)\n  2: free module of rank 1 over multivariate polynomial ring in 1 variable over GF(7)\n\njulia> T = Oscar.HomSheaf(Omega, F)\nCoherent sheaf of modules\n  on scheme over GF(7) covered with 2 patches\n    1: [(y//x)]   affine 1-space\n    2: [(x//y)]   affine 1-space\nwith restrictions\n  1: hom of (Multivariate polynomial ring in 1 variable over GF(7)^1, Multivariate polynomial ring in 1 variable over GF(7)^1)\n  2: hom of (Multivariate polynomial ring in 1 variable over GF(7)^1, Multivariate polynomial ring in 1 variable over GF(7)^1)\n\njulia> typeof(T)\nOscar.HomSheaf{CoveredScheme{FqField}, AbsAffineScheme, ModuleFP, Map}\n\n\n\n\n\n\n\n","category":"type"},{"location":"AlgebraicGeometry/Schemes/Sheaves/#PushforwardSheaf","page":"Sheaves on covered schemes","title":"PushforwardSheaf","text":"PushforwardSheaf\n\nFor a CoveredClosedEmbedding i : X -> Y and an AbsCoherentSheaf F on X this computes the coherent sheaf i_* F on Y.\n\nExamples\n\njulia> IP2 = projective_space(NormalToricVariety, 2)\nNormal toric variety\n\njulia> S = cox_ring(IP2)\nMultivariate polynomial ring in 3 variables over QQ graded by\n  x1 -> [1]\n  x2 -> [1]\n  x3 -> [1]\n\njulia> x, y, z = gens(S);\n\njulia> I = ideal(S, x^3 - y*z^2);\n\njulia> II = ideal_sheaf(IP2, I);\n\njulia> X, inc_X = sub(II);\n\njulia> F = cotangent_sheaf(X)\nCoherent sheaf of modules\n  on scheme over QQ covered with 3 patches\n    1: [x_1_1, x_2_1]   scheme(x_1_1^3 - x_2_1)\n    2: [x_1_2, x_2_2]   scheme(x_1_2^2*x_2_2 - 1)\n    3: [x_1_3, x_2_3]   scheme(x_1_3^3 - x_2_3^2)\nwith restrictions\n  1: subquotient of submodule with 2 generators\n    1: dx_1_1\n    2: dx_2_1\n  by submodule with 1 generator\n    1: 3*x_1_1^2*dx_1_1 - dx_2_1\n  2: subquotient of submodule with 2 generators\n    1: dx_1_2\n    2: dx_2_2\n  by submodule with 1 generator\n    1: 2*x_1_2*x_2_2*dx_1_2 + x_1_2^2*dx_2_2\n  3: subquotient of submodule with 2 generators\n    1: dx_1_3\n    2: dx_2_3\n  by submodule with 1 generator\n    1: 3*x_1_3^2*dx_1_3 - 2*x_2_3*dx_2_3\n\njulia> inc_F = Oscar.PushforwardSheaf(inc_X, F)\nCoherent sheaf of modules\n  on normal toric variety\nwith restrictions\n  1: subquotient of submodule with 2 generators\n    1: dx_1_1\n    2: dx_2_1\n  by submodule with 5 generators\n    1: (x_1_1^3 - x_2_1)*dx_1_1\n    2: (x_1_1^3 - x_2_1)*dx_2_1\n    3: 3*x_1_1^2*dx_1_1 - dx_2_1\n    4: (x_1_1^3 - x_2_1)*dx_1_1\n    5: (x_1_1^3 - x_2_1)*dx_2_1\n  2: subquotient of submodule with 2 generators\n    1: dx_1_2\n    2: dx_2_2\n  by submodule with 5 generators\n    1: (x_1_2^2*x_2_2 - 1)*dx_1_2\n    2: (x_1_2^2*x_2_2 - 1)*dx_2_2\n    3: 2*x_1_2*x_2_2*dx_1_2 + x_1_2^2*dx_2_2\n    4: (x_1_2^2*x_2_2 - 1)*dx_1_2\n    5: (x_1_2^2*x_2_2 - 1)*dx_2_2\n  3: subquotient of submodule with 2 generators\n    1: dx_1_3\n    2: dx_2_3\n  by submodule with 5 generators\n    1: (x_1_3^3 - x_2_3^2)*dx_1_3\n    2: (x_1_3^3 - x_2_3^2)*dx_2_3\n    3: 3*x_1_3^2*dx_1_3 - 2*x_2_3*dx_2_3\n    4: (x_1_3^3 - x_2_3^2)*dx_1_3\n    5: (x_1_3^3 - x_2_3^2)*dx_2_3\n\njulia> typeof(inc_F)\nPushforwardSheaf{NormalToricVariety, AbsAffineScheme, ModuleFP, Map}\n\n\n\n\n\n\n","category":"type"},{"location":"AlgebraicGeometry/Schemes/Sheaves/#PullbackSheaf","page":"Sheaves on covered schemes","title":"PullbackSheaf","text":"PullbackSheaf\n\nFor a morphism f : X -> Y of AbsCoveredSchemes and a coherent  sheaf F on Y this computes the pullback f^* F on X.\n\nExamples\n\njulia> IP2 = projective_space(NormalToricVariety, 2)\nNormal toric variety\n\njulia> S = cox_ring(IP2)\nMultivariate polynomial ring in 3 variables over QQ graded by\n  x1 -> [1]\n  x2 -> [1]\n  x3 -> [1]\n\njulia> x, y, z = gens(S);\n\njulia> I = ideal(S, x^3 - y*z^2);\n\njulia> II = ideal_sheaf(IP2, I);\n\njulia> X, inc_X = sub(II);\n\njulia> F = cotangent_sheaf(codomain(inc_X))\nCoherent sheaf of modules\n  on normal toric variety\nwith restrictions\n  1: submodule with 2 generators\n    1: dx_1_1\n    2: dx_2_1\n  represented as subquotient with no relations\n  2: submodule with 2 generators\n    1: dx_1_2\n    2: dx_2_2\n  represented as subquotient with no relations\n  3: submodule with 2 generators\n    1: dx_1_3\n    2: dx_2_3\n  represented as subquotient with no relations\n\njulia> inc_F = Oscar.PullbackSheaf(inc_X, F)\nCoherent sheaf of modules\n  on scheme over QQ covered with 3 patches\n    1: [x_1_1, x_2_1]   scheme(x_1_1^3 - x_2_1)\n    2: [x_1_2, x_2_2]   scheme(x_1_2^2*x_2_2 - 1)\n    3: [x_1_3, x_2_3]   scheme(x_1_3^3 - x_2_3^2)\nwith restrictions\n  1: submodule with 2 generators\n    1: dx_1_1\n    2: dx_2_1\n  represented as subquotient with no relations\n  2: submodule with 2 generators\n    1: dx_1_2\n    2: dx_2_2\n  represented as subquotient with no relations\n  3: submodule with 2 generators\n    1: dx_1_3\n    2: dx_2_3\n  represented as subquotient with no relations\n\njulia> typeof(inc_F)\nPullbackSheaf{CoveredScheme{QQField}, AbsAffineScheme, ModuleFP, Map}\n\n\n\n\n\n\n","category":"type"},{"location":"AlgebraicGeometry/Schemes/Sheaves/#DirectSumSheaf","page":"Sheaves on covered schemes","title":"DirectSumSheaf","text":"DirectSumSheaf\n\nGiven two or more AbsCoherentSheafs F and G on an AbsCoveredScheme X,  this holds the sheaf associated to the direct sum of F and G\n\nExamples\n\njulia> IP1 = projective_space(GF(7), [:x, :y])\nProjective space of dimension 1\n  over prime field of characteristic 7\nwith homogeneous coordinates [x, y]\n\njulia> Y = covered_scheme(IP1);\n\njulia> Omega = cotangent_sheaf(Y)\nCoherent sheaf of modules\n  on scheme over GF(7) covered with 2 patches\n    1: [(y//x)]   affine 1-space\n    2: [(x//y)]   affine 1-space\nwith restrictions\n  1: free module of rank 1 over multivariate polynomial ring in 1 variable over GF(7)\n  2: free module of rank 1 over multivariate polynomial ring in 1 variable over GF(7)\n\njulia> F = free_module(OO(Y), 1)\nCoherent sheaf of modules\n  on scheme over GF(7) covered with 2 patches\n    1: [(y//x)]   affine 1-space\n    2: [(x//y)]   affine 1-space\nwith restrictions\n  1: free module of rank 1 over multivariate polynomial ring in 1 variable over GF(7)\n  2: free module of rank 1 over multivariate polynomial ring in 1 variable over GF(7)\n\njulia> W = Oscar.DirectSumSheaf(Y, [Omega, F])\nCoherent sheaf of modules\n  on scheme over GF(7) covered with 2 patches\n    1: [(y//x)]   affine 1-space\n    2: [(x//y)]   affine 1-space\nwith restrictions\n  1: direct sum of (Multivariate polynomial ring in 1 variable over GF(7)^1, Multivariate polynomial ring in 1 variable over GF(7)^1)\n  2: direct sum of (Multivariate polynomial ring in 1 variable over GF(7)^1, Multivariate polynomial ring in 1 variable over GF(7)^1)\n\njulia> typeof(W)\nDirectSumSheaf{CoveredScheme{FqField}, AbsAffineScheme, ModuleFP, Map}\n\n\n\n\n\n\n","category":"type"},{"location":"AlgebraicGeometry/Schemes/Sheaves/","page":"Sheaves on covered schemes","title":"Sheaves on covered schemes","text":"We provide some common constructors.","category":"page"},{"location":"AlgebraicGeometry/Schemes/Sheaves/","page":"Sheaves on covered schemes","title":"Sheaves on covered schemes","text":"twisting_sheaf(IP::AbsProjectiveScheme{<:Field}, d::Int)\ntautological_bundle(IP::AbsProjectiveScheme{<:Field})\ncotangent_sheaf(X::AbsCoveredScheme)\nfree_module(R::StructureSheafOfRings, n::Int)\ndual(M::SheafOfModules)\ntangent_sheaf(X::AbsCoveredScheme)","category":"page"},{"location":"AlgebraicGeometry/Schemes/Sheaves/#twisting_sheaf-Tuple{AbsProjectiveScheme{<:Field}, Int64}","page":"Sheaves on covered schemes","title":"twisting_sheaf","text":"twisting_sheaf(IP::AbsProjectiveScheme{<:Field}, d::Int)\n\nFor a ProjectiveScheme ℙ return the d-th twisting sheaf 𝒪(d) as a CoherentSheaf on ℙ.\n\nExamples\n\njulia> P = projective_space(QQ,3)\nProjective space of dimension 3\n  over rational field\nwith homogeneous coordinates [s0, s1, s2, s3]\n\njulia> twisting_sheaf(P, 4)\nCoherent sheaf of modules\n  on scheme over QQ covered with 4 patches\n    1: [(s1//s0), (s2//s0), (s3//s0)]   affine 3-space\n    2: [(s0//s1), (s2//s1), (s3//s1)]   affine 3-space\n    3: [(s0//s2), (s1//s2), (s3//s2)]   affine 3-space\n    4: [(s0//s3), (s1//s3), (s2//s3)]   affine 3-space\nwith restrictions\n  1: free module of rank 1 over multivariate polynomial ring in 3 variables over QQ\n  2: free module of rank 1 over multivariate polynomial ring in 3 variables over QQ\n  3: free module of rank 1 over multivariate polynomial ring in 3 variables over QQ\n  4: free module of rank 1 over multivariate polynomial ring in 3 variables over QQ\n\n\n\n\n\n","category":"method"},{"location":"AlgebraicGeometry/Schemes/Sheaves/#tautological_bundle-Tuple{AbsProjectiveScheme{<:Field}}","page":"Sheaves on covered schemes","title":"tautological_bundle","text":"tautological_bundle(IP::AbsProjectiveScheme{<:Field})\n\nFor a ProjectiveScheme ℙ return the sheaf 𝒪(-1) as a CoherentSheaf on ℙ.\n\nExamples\n\njulia> P = projective_space(QQ,3)\nProjective space of dimension 3\n  over rational field\nwith homogeneous coordinates [s0, s1, s2, s3]\n\njulia> tautological_bundle(P)\nCoherent sheaf of modules\n  on scheme over QQ covered with 4 patches\n    1: [(s1//s0), (s2//s0), (s3//s0)]   affine 3-space\n    2: [(s0//s1), (s2//s1), (s3//s1)]   affine 3-space\n    3: [(s0//s2), (s1//s2), (s3//s2)]   affine 3-space\n    4: [(s0//s3), (s1//s3), (s2//s3)]   affine 3-space\nwith restrictions\n  1: free module of rank 1 over multivariate polynomial ring in 3 variables over QQ\n  2: free module of rank 1 over multivariate polynomial ring in 3 variables over QQ\n  3: free module of rank 1 over multivariate polynomial ring in 3 variables over QQ\n  4: free module of rank 1 over multivariate polynomial ring in 3 variables over QQ\n\n\n\n\n\n","category":"method"},{"location":"AlgebraicGeometry/Schemes/Sheaves/#cotangent_sheaf-Tuple{AbsCoveredScheme}","page":"Sheaves on covered schemes","title":"cotangent_sheaf","text":"cotangent_sheaf(X::AbsCoveredScheme)\n\nFor an AbsCoveredScheme X, return the sheaf Ω¹(X) of Kaehler-differentials on X as a CoherentSheaf.\n\nExamples\n\njulia> IP1 = projective_space(QQ, 1);\n\njulia> X = covered_scheme(IP1)\nScheme\n  over rational field\nwith default covering\n  described by patches\n    1: affine 1-space\n    2: affine 1-space\n  in the coordinate(s)\n    1: [(s1//s0)]\n    2: [(s0//s1)]\n\njulia> Omega = cotangent_sheaf(X);\n\njulia> U, V = affine_charts(X);\n\njulia> UV, VU = gluing_domains(default_covering(X)[U, V]);\n\njulia> dx = Omega(U)[1]\nd(s1//s0)\n\njulia> Omega(V)\nFree module of rank 1 over multivariate polynomial ring in 1 variable over QQ\n\njulia> Omega(U, VU)(dx)\n-1/(s0//s1)^2*d(s0//s1)\n\n\n\n\n\n\n","category":"method"},{"location":"AlgebraicGeometry/Schemes/Sheaves/#free_module-Tuple{StructureSheafOfRings, Int64}","page":"Sheaves on covered schemes","title":"free_module","text":"free_module(R::StructureSheafOfRings, n::Int)\n\nReturn the sheaf of free 𝒪-modules 𝒪ⁿ for a structure sheaf of rings 𝒪 = R.\n\n\n\n\n\n","category":"method"},{"location":"AlgebraicGeometry/Schemes/Sheaves/#dual-Tuple{Oscar.SheafOfModules}","page":"Sheaves on covered schemes","title":"dual","text":"dual(M::SheafOfModules)\n\nFor a SheafOfModules ℳ on an AbsCoveredScheme X, return the 𝒪_X-dual ℋ om_𝒪_X(ℳ  𝒪_X) of ℳ.\n\n\n\n\n\n","category":"method"},{"location":"AlgebraicGeometry/Schemes/Sheaves/#tangent_sheaf-Tuple{AbsCoveredScheme}","page":"Sheaves on covered schemes","title":"tangent_sheaf","text":"tangent_sheaf(X::AbsCoveredScheme)\n\nReturn the tangent sheaf T_X of X, constructed as ℋ om_𝒪_X(Ω¹_X 𝒪_X).\n\n\n\n\n\n","category":"method"},{"location":"AlgebraicGeometry/Schemes/Sheaves/","page":"Sheaves on covered schemes","title":"Sheaves on covered schemes","text":"projectivization(E::AbsCoherentSheaf; var_names::Vector{String}=Vector{String}(), check::Bool=true)","category":"page"},{"location":"AlgebraicGeometry/Schemes/Sheaves/#projectivization-Tuple{Oscar.AbsCoherentSheaf}","page":"Sheaves on covered schemes","title":"projectivization","text":"projectivization(E::AbsCoherentSheaf;\n    var_names::Vector{String}=Vector{String}(),\n    check::Bool=true\n  )\n\nFor a locally free sheaf E on an AbsCoveredScheme X this produces the associated projectivization ℙ (E)  X as a CoveredProjectiveScheme.\n\nA list of names for the variables of the relative homogeneous coordinate rings can be provided with var_names.\n\n!!! note: The sheaf E needs to be locally free so that a trivializing_covering can be computed. The check for this can be turned off by setting check=false.\n\n\n\n\n\n","category":"method"},{"location":"Groups/intro/","page":"Introduction","title":"Introduction","text":"CurrentModule = Oscar\nDocTestSetup = Oscar.doctestsetup()","category":"page"},{"location":"Groups/intro/#Introduction","page":"Introduction","title":"Introduction","text":"","category":"section"},{"location":"Groups/intro/","page":"Introduction","title":"Introduction","text":"The groups part of OSCAR provides functionality for handling","category":"page"},{"location":"Groups/intro/","page":"Introduction","title":"Introduction","text":"Permutation groups\nMatrix groups\nFinitely presented groups\nPolycyclic groups\nProducts of groups\nGroups of automorphisms","category":"page"},{"location":"Groups/intro/","page":"Introduction","title":"Introduction","text":"General textbooks offering details on theory and algorithms include:","category":"page"},{"location":"Groups/intro/","page":"Introduction","title":"Introduction","text":"[Hup67]\n[HEO05]","category":"page"},{"location":"Groups/intro/#Contact","page":"Introduction","title":"Contact","text":"","category":"section"},{"location":"Groups/intro/","page":"Introduction","title":"Introduction","text":"Please direct questions about this part of OSCAR to the following people:","category":"page"},{"location":"Groups/intro/","page":"Introduction","title":"Introduction","text":"Thomas Breuer,\nMax Horn.","category":"page"},{"location":"Groups/intro/","page":"Introduction","title":"Introduction","text":"You can ask questions in the OSCAR Slack.","category":"page"},{"location":"Groups/intro/","page":"Introduction","title":"Introduction","text":"Alternatively, you can raise an issue on github.","category":"page"},{"location":"TropicalGeometry/hypersurface/","page":"Tropical hypersurfaces","title":"Tropical hypersurfaces","text":"CurrentModule = Oscar\nDocTestSetup = Oscar.doctestsetup()","category":"page"},{"location":"TropicalGeometry/hypersurface/#Tropical-hypersurfaces","page":"Tropical hypersurfaces","title":"Tropical hypersurfaces","text":"","category":"section"},{"location":"TropicalGeometry/hypersurface/#Introduction","page":"Tropical hypersurfaces","title":"Introduction","text":"","category":"section"},{"location":"TropicalGeometry/hypersurface/","page":"Tropical hypersurfaces","title":"Tropical hypersurfaces","text":"A tropical hypersurface is a balanced polyhedral complex of codimension one.  It is dual to a regular subdivision of a Newton polytope. For more on tropical hypersurfaces, see","category":"page"},{"location":"TropicalGeometry/hypersurface/","page":"Tropical hypersurfaces","title":"Tropical hypersurfaces","text":"Chapter 3.1 in [MS15]\nChapter 1 in [Jos21]","category":"page"},{"location":"TropicalGeometry/hypersurface/#Note:","page":"Tropical hypersurfaces","title":"Note:","text":"","category":"section"},{"location":"TropicalGeometry/hypersurface/","page":"Tropical hypersurfaces","title":"Tropical hypersurfaces","text":"Objects of type TropicalHypersurface need to be embedded, abstract tropical hypersurfaces are currently not supported.\nThe type TropicalHypersurface can be thought of as subtype of TropicalVariety in the sense that it should have all properties and features of the latter.","category":"page"},{"location":"TropicalGeometry/hypersurface/#Constructors","page":"Tropical hypersurfaces","title":"Constructors","text":"","category":"section"},{"location":"TropicalGeometry/hypersurface/","page":"Tropical hypersurfaces","title":"Tropical hypersurfaces","text":"In addition to converting from TropicalVariety, objects of type TropicalHypersurface can be constructed from:","category":"page"},{"location":"TropicalGeometry/hypersurface/","page":"Tropical hypersurfaces","title":"Tropical hypersurfaces","text":"polynomials over a tropical semiring,\npolynomials over a field and a tropical semiring map,\nsubdivision of points and a choice of min- or max-convention.","category":"page"},{"location":"TropicalGeometry/hypersurface/","page":"Tropical hypersurfaces","title":"Tropical hypersurfaces","text":"tropical_hypersurface","category":"page"},{"location":"TropicalGeometry/hypersurface/#tropical_hypersurface","page":"Tropical hypersurfaces","title":"tropical_hypersurface","text":"tropical_hypersurface(f::MPolyRingElem{<:TropicalSemiringElem}, weighted_polyhedral_complex_only::Bool=false)\n\nReturn the tropical hypersurface of the tropical polynomial f.  If weighted_polyhedral_complex==true, will not cache any extra information.\n\nExamples\n\njulia> T = tropical_semiring()\nMin tropical semiring\n\njulia> R,(x,y) = T[:x, :y];\n\njulia> f = x+y+1\nx + y + (1)\n\njulia> tropical_hypersurface(f)\nMin tropical hypersurface\n\n\n\n\n\n\ntropical_hypersurface(f::MPolyRingElem, val::TropicalSemiringMap; weighted_polyhedral_complex_only::Bool=false)\n\nReturn the tropical hypersurface of the tropical polynomial that is the image of f under coefficient-wise val.  If weighted_polyhedral_complex==true, will not cache any extra information.\n\nExamples\n\njulia> R,(x,y) = QQ[:x, :y];\n\njulia> val = tropical_semiring_map(QQ,2)\nMap into Min tropical semiring encoding the 2-adic valuation on Rational field\n\njulia> f = x+y+2\nx + y + 2\n\njulia> tropical_hypersurface(f,val)\nMin tropical hypersurface\n\n\n\n\n\n\ntropical_hypersurface(Delta::SubdivisionOfPoints, minOrMax::Union{typeof(min),typeof(max)}=min; weighted_polyhedral_complex_only::Bool=false)\n\nConstruct the tropical hypersurface dual to a regular subdivision Delta in convention minOrMax. To be precise, the tropical hypersurface of the tropical polynomial with exponent vectors points(Delta) and coefficients min_weight(Delta) (min-convention) or -min_weight(Delta) (max-convention).  If weighted_polyhedral_complex==true, will not cache any extra information.\n\nExamples\n\njulia> Delta = subdivision_of_points([0 0; 1 0; 0 1; 2 0],[0,0,0,1])\nSubdivision of points in ambient dimension 2\n\njulia> tropical_hypersurface(Delta)\nMin tropical hypersurface\n\n\n\n\n\n","category":"function"},{"location":"TropicalGeometry/hypersurface/#Properties","page":"Tropical hypersurfaces","title":"Properties","text":"","category":"section"},{"location":"TropicalGeometry/hypersurface/","page":"Tropical hypersurfaces","title":"Tropical hypersurfaces","text":"In addition to the properties inherited from TropicalVariety, objects of type TropicalHypersurface have the following exclusive properties:","category":"page"},{"location":"TropicalGeometry/hypersurface/","page":"Tropical hypersurfaces","title":"Tropical hypersurfaces","text":"algebraic_polynomial(TropH::TropicalHypersurface)\ntropical_polynomial(TropH::TropicalHypersurface)\ndual_subdivision(TropH::TropicalHypersurface)","category":"page"},{"location":"TropicalGeometry/hypersurface/#algebraic_polynomial-Tuple{TropicalHypersurface}","page":"Tropical hypersurfaces","title":"algebraic_polynomial","text":"algebraic_polynomial(TropH::TropicalHypersurface)\n\nReturn the polynomial over a valued field used to construct TropH.  Raises an error if it is not cached.\n\n\n\n\n\n","category":"method"},{"location":"TropicalGeometry/hypersurface/#tropical_polynomial-Tuple{TropicalHypersurface}","page":"Tropical hypersurfaces","title":"tropical_polynomial","text":"tropical_polynomial(TropH::TropicalHypersurface)\n\nReturn the tropical polynomial used to construct TropH.  Raises an error if it is not cached.\n\n\n\n\n\n","category":"method"},{"location":"TropicalGeometry/hypersurface/#dual_subdivision-Tuple{TropicalHypersurface}","page":"Tropical hypersurfaces","title":"dual_subdivision","text":"dual_subdivision(TropH::TropicalHypersurface)\n\nReturn the dual subdivision used to construct TropH.  Raises an error if it is not cached.\n\nExamples\n\njulia> Delta = subdivision_of_points([0 0; 1 0; 0 1; 2 0],[0,0,0,1])\nSubdivision of points in ambient dimension 2\n\njulia> th = tropical_hypersurface(Delta)\nMin tropical hypersurface\n\njulia> sop = dual_subdivision(th)\nSubdivision of points in ambient dimension 2\n\njulia> points(sop)\n4-element SubObjectIterator{PointVector{QQFieldElem}}:\n [0, 0]\n [1, 0]\n [0, 1]\n [2, 0]\n\njulia> maximal_cells(sop)\n2-element SubObjectIterator{Vector{Int64}}:\n [1, 2, 3]\n [2, 3, 4]\n\n\n\n\n\n","category":"method"},{"location":"TropicalGeometry/hypersurface/#Example","page":"Tropical hypersurfaces","title":"Example","text":"","category":"section"},{"location":"TropicalGeometry/hypersurface/","page":"Tropical hypersurfaces","title":"Tropical hypersurfaces","text":"The following code sets up an example and prints the vertices and rays of the tropical hypersurface (in no particular order).","category":"page"},{"location":"TropicalGeometry/hypersurface/","page":"Tropical hypersurfaces","title":"Tropical hypersurfaces","text":"julia> T = tropical_semiring();\n\njulia> Tx,(x1,x2) = polynomial_ring(T, 2);\n\njulia> g = 1 + 2*x1^2 + 2*x2^2 + 1*x1*x2;\n\njulia> TropH = tropical_hypersurface(g);\n\njulia> vertRays = vertices_and_rays(TropH)\n5-element SubObjectIterator{Union{PointVector{QQFieldElem}, RayVector{QQFieldElem}}}:\n [-1, -1]\n [1, 0]\n [0, 1]\n [-1//2, 1//2]\n [1//2, -1//2]","category":"page"},{"location":"TropicalGeometry/hypersurface/","page":"Tropical hypersurfaces","title":"Tropical hypersurfaces","text":"By broadcasting the typeof() command, we can see, which are vertices, and which are rays.","category":"page"},{"location":"TropicalGeometry/hypersurface/","page":"Tropical hypersurfaces","title":"Tropical hypersurfaces","text":"julia> typeof.(vertRays)\n5-element Vector{DataType}:\n RayVector{QQFieldElem}\n RayVector{QQFieldElem}\n RayVector{QQFieldElem}\n PointVector{QQFieldElem}\n PointVector{QQFieldElem}","category":"page"},{"location":"TropicalGeometry/hypersurface/","page":"Tropical hypersurfaces","title":"Tropical hypersurfaces","text":"The maximal polyhedra of our tropical hypersurface is simply the edges (both bounded and unbounded). The command maximal_polyhedra() gives us a list of these edges (in no particular order).","category":"page"},{"location":"TropicalGeometry/hypersurface/","page":"Tropical hypersurfaces","title":"Tropical hypersurfaces","text":"julia> maxPol = maximal_polyhedra(TropH)\n5-element SubObjectIterator{Polyhedron{QQFieldElem}}:\n Polyhedron in ambient dimension 2\n Polyhedron in ambient dimension 2\n Polyhedron in ambient dimension 2\n Polytope in ambient dimension 2\n Polyhedron in ambient dimension 2","category":"page"},{"location":"TropicalGeometry/hypersurface/","page":"Tropical hypersurfaces","title":"Tropical hypersurfaces","text":"The polyhedrons are the unbounded edges, and the polytopes are the bounded edges.","category":"page"},{"location":"TropicalGeometry/hypersurface/","page":"Tropical hypersurfaces","title":"Tropical hypersurfaces","text":"The incidence matrix of the maximal polyhedra is a list of the relations between the elements of vertices_and_rays(TropH).  From these relations, we can draw the hypersurface. However, one should be careful, as there is no distinction between vertices and rays in the incidence matrix.","category":"page"},{"location":"TropicalGeometry/hypersurface/","page":"Tropical hypersurfaces","title":"Tropical hypersurfaces","text":"julia> IncidenceMatrix(maxPol)\n5×5 IncidenceMatrix\n[1, 4]\n[1, 5]\n[3, 4]\n[4, 5]\n[2, 5]","category":"page"},{"location":"TropicalGeometry/hypersurface/","page":"Tropical hypersurfaces","title":"Tropical hypersurfaces","text":"This is made clearer if we ask for the vertices of each of the maximal polyhedra (the bounded edges have a vertex at each end, while the unbounded only have one vertex).","category":"page"},{"location":"TropicalGeometry/hypersurface/","page":"Tropical hypersurfaces","title":"Tropical hypersurfaces","text":"julia> vertices.(maxPol)\n5-element Vector{SubObjectIterator{PointVector{QQFieldElem}}}:\n [[-1//2, 1//2]]\n [[1//2, -1//2]]\n [[-1//2, 1//2]]\n [[-1//2, 1//2], [1//2, -1//2]]\n [[1//2, -1//2]]","category":"page"},{"location":"TropicalGeometry/hypersurface/","page":"Tropical hypersurfaces","title":"Tropical hypersurfaces","text":"Instead of being between two vertices, the unbounded edges are defined by a vertex and a ray. These rays can be seen in the following way.","category":"page"},{"location":"TropicalGeometry/hypersurface/","page":"Tropical hypersurfaces","title":"Tropical hypersurfaces","text":"julia> rays.(maxPol)\n5-element Vector{SubObjectIterator{RayVector{QQFieldElem}}}:\n [[-1, -1]]\n [[-1, -1]]\n [[0, 1]]\n 0-element SubObjectIterator{RayVector{QQFieldElem}}\n [[1, 0]]","category":"page"},{"location":"General/complex/#Complex-Algorithms-in-OSCAR","page":"Complex Algorithms in OSCAR","title":"Complex Algorithms in OSCAR","text":"","category":"section"},{"location":"General/complex/","page":"Complex Algorithms in OSCAR","title":"Complex Algorithms in OSCAR","text":"On this page we will list some of the more involved algorithmic problems of OSCAR which you may encounter in the background. For larger examples these may not terminate, due to lack of memory or time. We will not go into the details of the respective complexity, as there is sufficient literature.","category":"page"},{"location":"General/complex/","page":"Complex Algorithms in OSCAR","title":"Complex Algorithms in OSCAR","text":"Often there are several algorithms in OSCAR solving a particular problem, and trying different alternatives may be worthwhile, as some algorithms may not terminate, while others finish in an instant.","category":"page"},{"location":"General/complex/#Groebner-and-Standard-Bases","page":"Complex Algorithms in OSCAR","title":"Groebner and Standard Bases","text":"","category":"section"},{"location":"General/complex/","page":"Complex Algorithms in OSCAR","title":"Complex Algorithms in OSCAR","text":"A standard basis of an ideal is a generating with special properties. A standard basis is necessary for many (mathematical) low level operations from commutative algebra.","category":"page"},{"location":"General/complex/","page":"Complex Algorithms in OSCAR","title":"Complex Algorithms in OSCAR","text":"Ideal membership\nRadical of an ideal\nKernel of a ring homomorphism\nKrull dimension of an ideal","category":"page"},{"location":"General/complex/#Double-Description","page":"Complex Algorithms in OSCAR","title":"Double Description","text":"","category":"section"},{"location":"General/complex/","page":"Complex Algorithms in OSCAR","title":"Complex Algorithms in OSCAR","text":"A polyhedron may be described as the convex hull of a finite set of points or as the intersection of finitely many halfspaces. We omit the more complex cases of unbounded or non-fulldimensional polyhedra here. Computing one description from the other is done via double description algorithms. Many simple algorithms on polyhedra need a double description.","category":"page"},{"location":"General/complex/","page":"Complex Algorithms in OSCAR","title":"Complex Algorithms in OSCAR","text":"Equality of polyhedra\nFace lattice\nLattice points\nHilbert basis","category":"page"},{"location":"General/complex/#Omitted-input-sanity-checks","page":"Complex Algorithms in OSCAR","title":"Omitted input sanity checks","text":"","category":"section"},{"location":"General/complex/","page":"Complex Algorithms in OSCAR","title":"Complex Algorithms in OSCAR","text":"Some input sanity checks are omitted on purpose, since they would be too expensive to verify performance wise. We will continue to add to the following list.","category":"page"},{"location":"General/complex/","page":"Complex Algorithms in OSCAR","title":"Complex Algorithms in OSCAR","text":"Checking that the input for subdivision_of_points actually defines a proper polyhedral complex covering the convex hull of the given points.","category":"page"},{"location":"AbstractAlgebra/field/#Field-functionality","page":"Field functionality","title":"Field functionality","text":"","category":"section"},{"location":"AbstractAlgebra/field/#Abstract-types-for-rings","page":"Field functionality","title":"Abstract types for rings","text":"","category":"section"},{"location":"AbstractAlgebra/field/","page":"Field functionality","title":"Field functionality","text":"All field types in AbstractAlgebra belong to the Field abstract type and field elements belong to the FieldElem abstract type.","category":"page"},{"location":"AbstractAlgebra/field/","page":"Field functionality","title":"Field functionality","text":"As Julia types cannot belong to our FieldElem type hierarchy, we also provide the union type FieldElement which includes FieldElem in union with the Julia types Rational and AbstractFloat.","category":"page"},{"location":"AbstractAlgebra/field/","page":"Field functionality","title":"Field functionality","text":"Note that","category":"page"},{"location":"AbstractAlgebra/field/","page":"Field functionality","title":"Field functionality","text":"Field <: Ring\nFieldElem <: RingElem\nFieldElement <: RingElement","category":"page"},{"location":"AbstractAlgebra/field/","page":"Field functionality","title":"Field functionality","text":"Of course all Ring functionality is available for AbstractAlgebra fields and their elements.","category":"page"},{"location":"AbstractAlgebra/field/#Functions-for-types-and-parents-of-fields","page":"Field functionality","title":"Functions for types and parents of fields","text":"","category":"section"},{"location":"AbstractAlgebra/field/","page":"Field functionality","title":"Field functionality","text":"characteristic(R::MyParent)","category":"page"},{"location":"AbstractAlgebra/field/","page":"Field functionality","title":"Field functionality","text":"Return the characteristic of the field. If the characteristic is not known, an exception is raised.","category":"page"},{"location":"AbstractAlgebra/field/#Basic-functions","page":"Field functionality","title":"Basic functions","text":"","category":"section"},{"location":"AbstractAlgebra/field/","page":"Field functionality","title":"Field functionality","text":"is_unit(f::MyElem)","category":"page"},{"location":"AbstractAlgebra/field/","page":"Field functionality","title":"Field functionality","text":"Return true if the given element is invertible, i.e. nonzero in the field.","category":"page"},{"location":"AlgebraicGeometry/Schemes/CoveredSchemeMorphisms/","page":"Morphisms of covered schemes","title":"Morphisms of covered schemes","text":"CurrentModule = Oscar","category":"page"},{"location":"AlgebraicGeometry/Schemes/CoveredSchemeMorphisms/#Morphisms-of-covered-schemes","page":"Morphisms of covered schemes","title":"Morphisms of covered schemes","text":"","category":"section"},{"location":"AlgebraicGeometry/Schemes/CoveredSchemeMorphisms/","page":"Morphisms of covered schemes","title":"Morphisms of covered schemes","text":"Suppose f  X to Y is a morphism of AbsCoveredSchemes. Theoretically, and hence  also technically, the required information behind f is a list of morphisms  of affine schemes f_i  U_i to V_F(i) for some pair of Coverings leftU_iright_i in I of X and leftV_jright_j in J of Y and a map of indices F  I to J This information is held by a CoveringMorphism:","category":"page"},{"location":"AlgebraicGeometry/Schemes/CoveredSchemeMorphisms/","page":"Morphisms of covered schemes","title":"Morphisms of covered schemes","text":"    CoveringMorphism","category":"page"},{"location":"AlgebraicGeometry/Schemes/CoveredSchemeMorphisms/#CoveringMorphism","page":"Morphisms of covered schemes","title":"CoveringMorphism","text":"CoveringMorphism\n\nA morphism f  C  D of two coverings. For every patch U of C this provides a map f[U'] of type AffineSchemeMorType from U  U to some patch codomain(f[U]) in D for some affine patches U covering U.\n\nNote: For two affine patches U₁ U₂  U the codomains of f[U₁] and f[U₂] do not need to coincide! However, given the gluings in C and D, all affine maps have to coincide on their overlaps.\n\n\n\n\n\n","category":"type"},{"location":"AlgebraicGeometry/Schemes/CoveredSchemeMorphisms/","page":"Morphisms of covered schemes","title":"Morphisms of covered schemes","text":"The basic functionality of CoveringMorphisms comprises domain and codomain which  both return a Covering, together with ","category":"page"},{"location":"AlgebraicGeometry/Schemes/CoveredSchemeMorphisms/","page":"Morphisms of covered schemes","title":"Morphisms of covered schemes","text":"getindex(f::CoveringMorphism, U::AbsAffineScheme)","category":"page"},{"location":"AlgebraicGeometry/Schemes/CoveredSchemeMorphisms/","page":"Morphisms of covered schemes","title":"Morphisms of covered schemes","text":"which for U = U_i returns the AbsAffineSchemeMor f_i  U_i to V_F(i).","category":"page"},{"location":"AlgebraicGeometry/Schemes/CoveredSchemeMorphisms/","page":"Morphisms of covered schemes","title":"Morphisms of covered schemes","text":"Note that, in general, neither the domain nor the codomain of the covering_morphism of  f : X \\to Y need to coincide with the default_covering of X, respectively Y.  In fact, one will usually need to restrict to a refinement of the default_covering of X in order to realize the covering morphism in the first place. ","category":"page"},{"location":"AlgebraicGeometry/Schemes/CoveredSchemeMorphisms/#The-interface-for-morphisms-of-covered-schemes","page":"Morphisms of covered schemes","title":"The interface for morphisms of covered schemes","text":"","category":"section"},{"location":"AlgebraicGeometry/Schemes/CoveredSchemeMorphisms/","page":"Morphisms of covered schemes","title":"Morphisms of covered schemes","text":"Every AbsCoveredSchemeMorphism f  X to Y is required to implement the following minimal  interface.","category":"page"},{"location":"AlgebraicGeometry/Schemes/CoveredSchemeMorphisms/","page":"Morphisms of covered schemes","title":"Morphisms of covered schemes","text":"domain(f::AbsCoveredSchemeMorphism)                 # returns X\ncodomain(f::AbsCoveredSchemeMorphism)               # returns Y\ncovering_morphism(f::AbsCoveredSchemeMorphism)      # returns the underlying covering morphism {f_i}","category":"page"},{"location":"AlgebraicGeometry/Schemes/CoveredSchemeMorphisms/","page":"Morphisms of covered schemes","title":"Morphisms of covered schemes","text":"For the user's convenience, also the domain and codomain  of the underlying covering_morphism are forwarded as domain_covering and  codomain_covering, respectively, together with getindex(phi::CoveringMorphism, U::AbsAffineScheme)  as getindex(f::AbsCoveredSchemeMorphism, U::AbsAffineScheme).","category":"page"},{"location":"AlgebraicGeometry/Schemes/CoveredSchemeMorphisms/","page":"Morphisms of covered schemes","title":"Morphisms of covered schemes","text":"The minimal concrete type of an AbsCoveredSchemeMorphism which  implements this interface, is CoveredSchemeMorphism.","category":"page"},{"location":"AlgebraicGeometry/Schemes/CoveredSchemeMorphisms/#Special-types-of-morphisms-of-covered-schemes","page":"Morphisms of covered schemes","title":"Special types of morphisms of covered schemes","text":"","category":"section"},{"location":"AlgebraicGeometry/Schemes/CoveredSchemeMorphisms/#Closed-embeddings","page":"Morphisms of covered schemes","title":"Closed embeddings","text":"","category":"section"},{"location":"AlgebraicGeometry/Schemes/CoveredSchemeMorphisms/","page":"Morphisms of covered schemes","title":"Morphisms of covered schemes","text":"CoveredClosedEmbedding\nimage_ideal(phi::CoveredClosedEmbedding)","category":"page"},{"location":"AlgebraicGeometry/Schemes/CoveredSchemeMorphisms/#CoveredClosedEmbedding","page":"Morphisms of covered schemes","title":"CoveredClosedEmbedding","text":"CoveredClosedEmbedding <: AbsCoveredSchemeMorphism\n\nType for closed embeddings of covered schemes.\n\nIn addition to the closed embedding it stores  the sheaf of ideals defining the image.\n\n\n\n\n\n","category":"type"},{"location":"AlgebraicGeometry/Schemes/CoveredSchemeMorphisms/#image_ideal-Tuple{Oscar.CoveredClosedEmbedding}","page":"Morphisms of covered schemes","title":"image_ideal","text":"image_ideal(phi::CoveredClosedEmbedding)\n\nFor a closed embedding phi colon X to Y return the sheaf of ideals on Y defining the image of phi.\n\n\n\n\n\n","category":"method"},{"location":"AlgebraicGeometry/Schemes/CoveredSchemeMorphisms/#Composite-morphisms","page":"Morphisms of covered schemes","title":"Composite morphisms","text":"","category":"section"},{"location":"AlgebraicGeometry/Schemes/CoveredSchemeMorphisms/","page":"Morphisms of covered schemes","title":"Morphisms of covered schemes","text":"CompositeCoveredSchemeMorphism","category":"page"},{"location":"AlgebraicGeometry/Schemes/CoveredSchemeMorphisms/#CompositeCoveredSchemeMorphism","page":"Morphisms of covered schemes","title":"CompositeCoveredSchemeMorphism","text":"CompositeCoveredSchemeMorphism{\n    DomainType<:AbsCoveredScheme,\n    CodomainType<:AbsCoveredScheme,\n    BaseMorphismType\n   } <: AbsCoveredSchemeMorphism{\n                             DomainType,\n                             CodomainType,\n                             BaseMorphismType,\n                             CoveredSchemeMorphism\n                            }\n\nA special concrete type of an AbsCoveredSchemeMorphism of the form f = hᵣ  hᵣ₁    h₁ X  Y for arbitrary AbsCoveredSchemeMorphisms h₁  X  Z₁, h₂  Z₁  Z₂, ..., hᵣ  Zᵣ₁  Y.\n\nSince every such morphism hⱼ will in general have an underlying CoveringMorphism with domain and codomain covering actual composition of such a sequence of morphisms will lead to an exponential increase in complexity of these coverings because of the necessary refinements. Nevertheless, the pullback or pushforward of various objects on either X or Y through such a chain of maps is possible stepwise. This type allows one to have one concrete morphism rather than a list of morphisms and to reroute such calculations to iteration over the various maps.\n\nIn addition to the usual functionality of the AbsCoveredSchemeMorphism interface, this concrete type has the getters\n\nmaps(f::CompositeCoveredSchemeMorphism)\n\nto obtain a list of the hⱼ and map(f, j) to obtain the j-th map directly.\n\n\n\n\n\n","category":"type"},{"location":"AlgebraicGeometry/Schemes/CoveredSchemeMorphisms/#Morphisms-from-rational-functions","page":"Morphisms of covered schemes","title":"Morphisms from rational functions","text":"","category":"section"},{"location":"AlgebraicGeometry/Schemes/CoveredSchemeMorphisms/","page":"Morphisms of covered schemes","title":"Morphisms of covered schemes","text":"Suppose X and Y are two irreducible and reduced varieties. Then a morphism  f  X to Y might be given by means of the following data. Let V subset Y be  some dense affine patch with coordinates x_1dotsx_n (i.e. the gens of OO(V)). ","category":"page"},{"location":"AlgebraicGeometry/Schemes/CoveredSchemeMorphisms/","page":"Morphisms of covered schemes","title":"Morphisms of covered schemes","text":"These x_i extend to rational functions v_i on Y and these pull back to rational functions  f^* v_i = u_i on X. On every affine patch U subset X there now exists  some maximal Zariski-open subset W subset U (which need not be affine), such that  all the f^* v_i extend to regular functions on W. Hence, one can realize the  morphisms of affine schemes f_j  W_j to V for some open covering of W. ","category":"page"},{"location":"AlgebraicGeometry/Schemes/CoveredSchemeMorphisms/","page":"Morphisms of covered schemes","title":"Morphisms of covered schemes","text":"Similarly, for every other non-empty patch V_2 of Y the pullback of gens(OO(V_2)) can  be computed from the f^* v_i and extended maximally to some W subset U for every patch  U of X. Altogether, this allows to compute a full CoveringMorphism and  – at least in theory – an instance of CoveredSchemeMorphism. In practice,  however, this computation is usually much too expensive to really be carried out, while  the data necessary to compute various pullbacks and/or pushforwards of objects defined  on X and Y can be extracted from the f^* v_i more directly. ","category":"page"},{"location":"AlgebraicGeometry/Schemes/CoveredSchemeMorphisms/","page":"Morphisms of covered schemes","title":"Morphisms of covered schemes","text":"A lazy concrete data structure to house this kind of morphism is ","category":"page"},{"location":"AlgebraicGeometry/Schemes/CoveredSchemeMorphisms/","page":"Morphisms of covered schemes","title":"Morphisms of covered schemes","text":"MorphismFromRationalFunctions","category":"page"},{"location":"AlgebraicGeometry/Schemes/CoveredSchemeMorphisms/#MorphismFromRationalFunctions","page":"Morphisms of covered schemes","title":"MorphismFromRationalFunctions","text":"MorphismFromRationalFunctions{DomainType<:AbsCoveredScheme, CodomainType<:AbsCoveredScheme}\n\nA lazy type for a dominant morphism φ  X  Y of AbsCoveredSchemes which is given  by a set of rational functions a₁aₙ in the fraction field of the base_ring of 𝒪(U) for one of the dense open affine_charts U of X.  The aᵢ represent the pullbacks of the coordinates (gens) of some  affine_chart V of the codomain Y under this map. \n\njulia> IP1 = covered_scheme(projective_space(QQ, [:s, :t]))\nScheme\n  over rational field\nwith default covering\n  described by patches\n    1: affine 1-space\n    2: affine 1-space\n  in the coordinate(s)\n    1: [(t//s)]\n    2: [(s//t)]\n\njulia> IP2 = projective_space(QQ, [:x, :y, :z]);\n\njulia> S = homogeneous_coordinate_ring(IP2);\n\njulia> x, y, z = gens(S);\n\njulia> IPC, inc_IPC = sub(IP2, ideal(S, [x^2 - y*z]));\n\njulia> C = covered_scheme(IPC);\n\njulia> U = first(affine_charts(IP1))\nSpectrum\n  of multivariate polynomial ring in 1 variable (t//s)\n    over rational field\n\njulia> V = first(affine_charts(C))\nSpectrum\n  of quotient\n    of multivariate polynomial ring in 2 variables (y//x), (z//x)\n      over rational field\n    by ideal (-(y//x)*(z//x) + 1)\n\njulia> t = first(gens(OO(U)))\n(t//s)\n\njulia> Phi = MorphismFromRationalFunctions(IP1, C, U, V, [t//one(t), 1//t]);\n\njulia> realizations = Oscar.realize_on_patch(Phi, U);\n\njulia> realizations[3]\nAffine scheme morphism\n  from [(t//s)]          AA^1\n  to   [(x//z), (y//z)]  scheme((x//z)^2 - (y//z))\ngiven by the pullback function\n  (x//z) -> (t//s)\n  (y//z) -> (t//s)^2\n\n\n\n\n\n\n","category":"type"},{"location":"AlgebraicGeometry/Schemes/CoveredSchemeMorphisms/","page":"Morphisms of covered schemes","title":"Morphisms of covered schemes","text":"Note that the key idea of this data type is to not use the underlying_morphism  together with its covering_morphism, but to find cheaper ways to do computations!  The computation of the underlying_morphism is triggered by any call to functions  which have not been overwritten with a special method for f::MorphismFromRationalFunctions.  However, this computation should be considered as way too expensive besides some small examples. ","category":"page"},{"location":"AlgebraicGeometry/Schemes/CoveredSchemeMorphisms/","page":"Morphisms of covered schemes","title":"Morphisms of covered schemes","text":"For instance, if one wants to pull back a prime ideal sheaf mathcal I on Y along  some isomorphism f  X to Y, then one only needs to find one realization  f_j  U_j to V_F(j) of f on affine patches U_j of X and V_F(j)  of Y such that mathcal I(V_F(j))neq 0 and f_j^* mathcal I(V_F(j)) neq 0.  Then f^* mathcal I can be extended uniquely to all of X from U_j and  there is no need to realize the full covering_morphism of f. In order to facilitate such computations as lazy as possible, there are various fine-grained  entry points and caching mechanisms to realize f on open subsets:","category":"page"},{"location":"AlgebraicGeometry/Schemes/CoveredSchemeMorphisms/","page":"Morphisms of covered schemes","title":"Morphisms of covered schemes","text":"realize_on_patch(Phi::MorphismFromRationalFunctions, U::AbsAffineScheme)\nrealize_on_open_subset(Phi::MorphismFromRationalFunctions, U::AbsAffineScheme, V::AbsAffineScheme)\nrealization_preview(Phi::MorphismFromRationalFunctions, U::AbsAffineScheme, V::AbsAffineScheme)\nrandom_realization(Phi::MorphismFromRationalFunctions, U::AbsAffineScheme, V::AbsAffineScheme)\ncheap_realization(Phi::MorphismFromRationalFunctions, U::AbsAffineScheme, V::AbsAffineScheme)\nrealize_maximally_on_open_subset(Phi::MorphismFromRationalFunctions, U::AbsAffineScheme, V::AbsAffineScheme)\nrealize(Phi::MorphismFromRationalFunctions)","category":"page"},{"location":"AlgebraicGeometry/Schemes/CoveredSchemeMorphisms/#realize_on_patch-Tuple{MorphismFromRationalFunctions, AbsAffineScheme}","page":"Morphisms of covered schemes","title":"realize_on_patch","text":"realize_on_patch(Phi::MorphismFromRationalFunctions, U::AbsAffineScheme)\n\nFor U in the domain_covering of Phi construct a list of morphisms  fₖ  Uₖ  Vₖ from PrincipalOpenSubsets Uₖ of U to patches  Vₖ in the codomain_covering so that altogether the fₖ can be assembled  to a CoveringMorphism which realizes Phi.\n\n\n\n\n\n","category":"method"},{"location":"AlgebraicGeometry/Schemes/CoveredSchemeMorphisms/#realize_on_open_subset-Tuple{MorphismFromRationalFunctions, AbsAffineScheme, AbsAffineScheme}","page":"Morphisms of covered schemes","title":"realize_on_open_subset","text":"realize_on_open_subset(Phi::MorphismFromRationalFunctions, U::AbsAffineScheme, V::AbsAffineScheme)\n\nReturn a morphism f : U' → V from some PrincipalOpenSubset of U to V such that the restriction of Phi to U' is f. Note that U' need not be maximal  with this property!\n\n\n\n\n\n","category":"method"},{"location":"AlgebraicGeometry/Schemes/CoveredSchemeMorphisms/#realization_preview-Tuple{MorphismFromRationalFunctions, AbsAffineScheme, AbsAffineScheme}","page":"Morphisms of covered schemes","title":"realization_preview","text":"realization_preview(Phi::MorphismFromRationalFunctions, U::AbsAffineScheme, V::AbsAffineScheme)\n\nFor a pair (U, V) of patches in the domain_covering and the codomain_covering  of Phi, respectively, this returns a list of elements in the fraction field of the  ambient_coordinate_ring of U which represent the pullbacks of gens(OO(V)) under  Phi to U.\n\n\n\n\n\n","category":"method"},{"location":"AlgebraicGeometry/Schemes/CoveredSchemeMorphisms/#random_realization-Tuple{MorphismFromRationalFunctions, AbsAffineScheme, AbsAffineScheme}","page":"Morphisms of covered schemes","title":"random_realization","text":"random_realization(Phi::MorphismFromRationalFunctions, U::AbsAffineScheme, V::AbsAffineScheme)\n\nFor a pair (U, V) of patches in the domain_covering and the codomain_covering  of Phi, respectively, this creates a random PrincipalOpenSubset U' on which  the restriction f : U' → V of Phi can be realized and returns that restriction. Note that U' need not (and usually will not) be maximal with this property.\n\n\n\n\n\n","category":"method"},{"location":"AlgebraicGeometry/Schemes/CoveredSchemeMorphisms/#cheap_realization-Tuple{MorphismFromRationalFunctions, AbsAffineScheme, AbsAffineScheme}","page":"Morphisms of covered schemes","title":"cheap_realization","text":"cheap_realization(Phi::MorphismFromRationalFunctions, U::AbsAffineScheme, V::AbsAffineScheme)\n\nFor a pair (U, V) of patches in the domain_covering and the codomain_covering  of Phi, respectively, this creates a random PrincipalOpenSubset U' on which  the restriction f : U' → V of Phi can be realized and returns that restriction. Note that U' need not (and usually will not) be maximal with this property.\n\nThis method is cheap in the sense that it simply inverts all representatives of  the denominators occurring in the realization_preview(Phi, U, V).\n\n\n\n\n\n","category":"method"},{"location":"AlgebraicGeometry/Schemes/CoveredSchemeMorphisms/#realize_maximally_on_open_subset-Tuple{MorphismFromRationalFunctions, AbsAffineScheme, AbsAffineScheme}","page":"Morphisms of covered schemes","title":"realize_maximally_on_open_subset","text":"realize_maximally_on_open_subset(Phi::MorphismFromRationalFunctions, U::AbsAffineScheme, V::AbsAffineScheme)\n\nFor a pair (U, V) of patches in the domain_covering and the codomain_covering  of Phi, respectively, this returns a list of morphisms fₖ : U'ₖ → V such that the  restriction of Phi to U'ₖ and V is fₖ and altogether the U'ₖ cover the maximal  open subset U'⊂ U on which the restriction U' → V of Phi can be realized.\n\n\n\n\n\n","category":"method"},{"location":"AlgebraicGeometry/Schemes/CoveredSchemeMorphisms/#realize-Tuple{MorphismFromRationalFunctions}","page":"Morphisms of covered schemes","title":"realize","text":"realize(Phi::MorphismFromRationalFunctions)\n\nComputes a full realization of Phi as a CoveredSchemeMorphism. Note  that this computation is very expensive and usage of this method should  be avoided.\n\n\n\n\n\n","category":"method"},{"location":"AlgebraicGeometry/ToricVarieties/NormalToricVarieties/","page":"Normal Toric Varieties","title":"Normal Toric Varieties","text":"CurrentModule = Oscar","category":"page"},{"location":"AlgebraicGeometry/ToricVarieties/NormalToricVarieties/#Normal-Toric-Varieties","page":"Normal Toric Varieties","title":"Normal Toric Varieties","text":"","category":"section"},{"location":"AlgebraicGeometry/ToricVarieties/NormalToricVarieties/#Introduction","page":"Normal Toric Varieties","title":"Introduction","text":"","category":"section"},{"location":"AlgebraicGeometry/ToricVarieties/NormalToricVarieties/","page":"Normal Toric Varieties","title":"Normal Toric Varieties","text":"We introduce two main types of normal toric varieties, distinguishing between the affine and non-affine case:","category":"page"},{"location":"AlgebraicGeometry/ToricVarieties/NormalToricVarieties/","page":"Normal Toric Varieties","title":"Normal Toric Varieties","text":"AffineNormalToricVariety is the type for toric varieties associated to a cone sigma, denoted by U_sigma in [CLS11]\nNormalToricVariety is the type for toric varieties associated to a polyhedral fan Sigma, denoted by X_Sigma in [CLS11]","category":"page"},{"location":"AlgebraicGeometry/ToricVarieties/NormalToricVarieties/","page":"Normal Toric Varieties","title":"Normal Toric Varieties","text":"warning: Warning\nThe lattice is always assumed to be the standard lattice mathbbZ^n. Transformations for non-standard lattices will have to be done by the user.","category":"page"},{"location":"AlgebraicGeometry/ToricVarieties/NormalToricVarieties/#Equality-of-Normal-Toric-Varieties","page":"Normal Toric Varieties","title":"Equality of Normal Toric Varieties","text":"","category":"section"},{"location":"AlgebraicGeometry/ToricVarieties/NormalToricVarieties/","page":"Normal Toric Varieties","title":"Normal Toric Varieties","text":"warning: Warning\nEquality of normal toric varieties is computationally very demanding. We have therefore made special design decisions for the == method.","category":"page"},{"location":"AlgebraicGeometry/ToricVarieties/NormalToricVarieties/","page":"Normal Toric Varieties","title":"Normal Toric Varieties","text":"In OSCAR, the == operator is reserved to check if two normal toric varieties are identical, meaning their underlying polyhedral fans are the same. However, this check is computationally challenging due to several reasons:","category":"page"},{"location":"AlgebraicGeometry/ToricVarieties/NormalToricVarieties/","page":"Normal Toric Varieties","title":"Normal Toric Varieties","text":"The ray generators might be scaled.\nThe ray generators might be stored in different orders.\nThe maximal (polyhedral) cones of the polyhedral fan might be stored in different orders.\nIf we fall back on polyhedral fan equality, lineality of the cones must also be considered.","category":"page"},{"location":"AlgebraicGeometry/ToricVarieties/NormalToricVarieties/","page":"Normal Toric Varieties","title":"Normal Toric Varieties","text":"To avoid this computational bottleneck, we have specially designed the == method. It checks if the memory locations of the two objects in question are identical. If  so, our == method returns true. Otherwise, it raise an error.","category":"page"},{"location":"AlgebraicGeometry/ToricVarieties/NormalToricVarieties/","page":"Normal Toric Varieties","title":"Normal Toric Varieties","text":"Note that triple equality === (i.e. the check of equal the memory locations) is always supported for normal toric varieties. We recommend using it.","category":"page"},{"location":"AlgebraicGeometry/ToricVarieties/NormalToricVarieties/","page":"Normal Toric Varieties","title":"Normal Toric Varieties","text":"However, if you truly need to check for two normal toric varieties to be mathematically identical, then you will need to add a custom method. This method could look as follows:","category":"page"},{"location":"AlgebraicGeometry/ToricVarieties/NormalToricVarieties/","page":"Normal Toric Varieties","title":"Normal Toric Varieties","text":"function slow_equal(tv1::NormalToricVariety, tv2::NormalToricVariety)\n  tv1 === tv2 && return true\n  ambient_dim(tv1) == ambient_dim(tv2) || return false\n  f_vector(tv1) == f_vector(tv2) || return false\n  return Set(maximal_cones(tv1)) == Set(maximal_cones(tv2))\nend","category":"page"},{"location":"AlgebraicGeometry/ToricVarieties/NormalToricVarieties/","page":"Normal Toric Varieties","title":"Normal Toric Varieties","text":"Please note that this method slow_equal is not performant, that we currently (summer 2024) have no intentions in adding this function to OSCAR nor to make improvements to its performance. Rather, expect this method to be slow, potentially painfully so.","category":"page"},{"location":"AlgebraicGeometry/ToricVarieties/NormalToricVarieties/#Constructors","page":"Normal Toric Varieties","title":"Constructors","text":"","category":"section"},{"location":"AlgebraicGeometry/ToricVarieties/NormalToricVarieties/#Affine-Toric-Varieties","page":"Normal Toric Varieties","title":"Affine Toric Varieties","text":"","category":"section"},{"location":"AlgebraicGeometry/ToricVarieties/NormalToricVarieties/","page":"Normal Toric Varieties","title":"Normal Toric Varieties","text":"affine_normal_toric_variety(C::Cone)\nnormal_toric_variety(C::Cone)\naffine_normal_toric_variety(v::NormalToricVariety)","category":"page"},{"location":"AlgebraicGeometry/ToricVarieties/NormalToricVarieties/#affine_normal_toric_variety-Tuple{Cone}","page":"Normal Toric Varieties","title":"affine_normal_toric_variety","text":"affine_normal_toric_variety(C::Cone)\n\nConstruct the affine normal toric variety U_C corresponding to a polyhedral cone C.\n\nExamples\n\nSet C to be the positive orthant in two dimensions.\n\njulia> C = positive_hull([1 0; 0 1])\nPolyhedral cone in ambient dimension 2\n\njulia> antv = affine_normal_toric_variety(C)\nNormal toric variety\n\n\n\n\n\n","category":"method"},{"location":"AlgebraicGeometry/ToricVarieties/NormalToricVarieties/#normal_toric_variety-Tuple{Cone}","page":"Normal Toric Varieties","title":"normal_toric_variety","text":"normal_toric_variety(C::Cone)\n\nConstruct the (affine) normal toric variety X_Sigma corresponding to a polyhedral fan Sigma = C consisting only of the cone C.\n\nExamples\n\nSet C to be the positive orthant in two dimensions.\n\njulia> C = positive_hull([1 0; 0 1])\nPolyhedral cone in ambient dimension 2\n\njulia> ntv = normal_toric_variety(C)\nNormal toric variety\n\n\n\n\n\n","category":"method"},{"location":"AlgebraicGeometry/ToricVarieties/NormalToricVarieties/#affine_normal_toric_variety-Tuple{NormalToricVariety}","page":"Normal Toric Varieties","title":"affine_normal_toric_variety","text":"affine_normal_toric_variety(v::NormalToricVariety)\n\nFor internal design, we make a strict distinction between normal toric varieties and affine toric varieties. Given an affine, normal toric variety v, this method turns it into an affine toric variety.\n\nExamples\n\njulia> v = normal_toric_variety(positive_hull([1 0; 0 1]))\nNormal toric variety\n\njulia> affineVariety = affine_normal_toric_variety(v)\nNormal toric variety\n\n\n\n\n\n","category":"method"},{"location":"AlgebraicGeometry/ToricVarieties/NormalToricVarieties/#Normal-Toric-Varieties-2","page":"Normal Toric Varieties","title":"Normal Toric Varieties","text":"","category":"section"},{"location":"AlgebraicGeometry/ToricVarieties/NormalToricVarieties/","page":"Normal Toric Varieties","title":"Normal Toric Varieties","text":"normal_toric_variety","category":"page"},{"location":"AlgebraicGeometry/ToricVarieties/NormalToricVarieties/#normal_toric_variety","page":"Normal Toric Varieties","title":"normal_toric_variety","text":"normal_toric_variety(C::Cone)\n\nConstruct the (affine) normal toric variety X_Sigma corresponding to a polyhedral fan Sigma = C consisting only of the cone C.\n\nExamples\n\nSet C to be the positive orthant in two dimensions.\n\njulia> C = positive_hull([1 0; 0 1])\nPolyhedral cone in ambient dimension 2\n\njulia> ntv = normal_toric_variety(C)\nNormal toric variety\n\n\n\n\n\nnormal_toric_variety(max_cones::IncidenceMatrix, rays::AbstractCollection[RayVector]; non_redundant::Bool = false)\n\nConstruct a normal toric variety X by providing the rays and maximal cones as vector of vectors. By default, this method allows redundancies in the input, e.g. duplicate rays and non-maximal cones. If the user is certain that no redundancy exists in the entered information, one can pass non_redundant = true as third argument. This will bypass these consistency checks. In addition, this will ensure that the order of the rays is not altered by the constructor.\n\nExamples\n\njulia> ray_generators = [[1,0], [0, 1], [-1, 5], [0, -1]]\n4-element Vector{Vector{Int64}}:\n [1, 0]\n [0, 1]\n [-1, 5]\n [0, -1]\n\njulia> max_cones = incidence_matrix([[1, 2], [2, 3], [3, 4], [4, 1]])\n4×4 IncidenceMatrix\n[1, 2]\n[2, 3]\n[3, 4]\n[1, 4]\n\njulia> normal_toric_variety(max_cones, ray_generators)\nNormal toric variety\n\njulia> normal_toric_variety(max_cones, ray_generators; non_redundant = true)\nNormal toric variety\n\n\n\n\n\nnormal_toric_variety(PF::PolyhedralFan)\n\nConstruct the normal toric variety X_PF corresponding to a polyhedral fan PF.\n\nExamples\n\nTake PF to be the normal fan of the square.\n\njulia> square = cube(2)\nPolytope in ambient dimension 2\n\njulia> nf = normal_fan(square)\nPolyhedral fan in ambient dimension 2\n\njulia> ntv = normal_toric_variety(nf)\nNormal toric variety\n\n\n\n\n\nnormal_toric_variety(P::Polyhedron)\n\nConstruct the normal toric variety X_Sigma_P corresponding to the normal fan Sigma_P of the given polyhedron P.\n\nNote that this only coincides with the projective variety associated to P from the affine relations of the lattice points in P, if P is very ample.\n\nExamples\n\nSet P to be a square.\n\njulia> square = cube(2)\nPolytope in ambient dimension 2\n\njulia> ntv = normal_toric_variety(square)\nNormal toric variety\n\n\n\n\n\n","category":"function"},{"location":"AlgebraicGeometry/ToricVarieties/NormalToricVarieties/#Famous-Toric-Varieties","page":"Normal Toric Varieties","title":"Famous Toric Varieties","text":"","category":"section"},{"location":"AlgebraicGeometry/ToricVarieties/NormalToricVarieties/","page":"Normal Toric Varieties","title":"Normal Toric Varieties","text":"The constructors of del_pezzo_surface, hirzebruch_surface, projective_space and weighted_projective_space always make a default/standard choice for the grading of the Cox ring.","category":"page"},{"location":"AlgebraicGeometry/ToricVarieties/NormalToricVarieties/","page":"Normal Toric Varieties","title":"Normal Toric Varieties","text":"affine_space(::Type{NormalToricVariety}, d::Int)\ndel_pezzo_surface(::Type{NormalToricVariety}, b::Int)\nhirzebruch_surface(::Type{NormalToricVariety}, r::Int)\nprojective_space(::Type{NormalToricVariety}, d::Int)\nweighted_projective_space(::Type{NormalToricVariety}, w::Vector{T}) where {T <: IntegerUnion}","category":"page"},{"location":"AlgebraicGeometry/ToricVarieties/NormalToricVarieties/#affine_space-Tuple{Type{NormalToricVariety}, Int64}","page":"Normal Toric Varieties","title":"affine_space","text":"affine_space(::Type{NormalToricVariety}, d::Int)\n\nConstruct the (toric) affine space of dimension d.\n\nExamples\n\njulia> affine_space(NormalToricVariety, 2)\nNormal toric variety\n\n\n\n\n\n","category":"method"},{"location":"AlgebraicGeometry/ToricVarieties/NormalToricVarieties/#del_pezzo_surface-Tuple{Type{NormalToricVariety}, Int64}","page":"Normal Toric Varieties","title":"del_pezzo_surface","text":"del_pezzo_surface(::Type{NormalToricVariety}, b::Int)\n\nConstructs the del Pezzo surface with b blowups for b at most 3.\n\nExamples\n\njulia> del_pezzo_surface(NormalToricVariety, 3)\nNormal toric variety\n\n\n\n\n\n","category":"method"},{"location":"AlgebraicGeometry/ToricVarieties/NormalToricVarieties/#hirzebruch_surface-Tuple{Type{NormalToricVariety}, Int64}","page":"Normal Toric Varieties","title":"hirzebruch_surface","text":"hirzebruch_surface(::Type{NormalToricVariety}, r::Int)\n\nConstruct the r-th Hirzebruch surface.\n\nExamples\n\njulia> hirzebruch_surface(NormalToricVariety, 5)\nNormal toric variety\n\n\n\n\n\n","category":"method"},{"location":"AlgebraicGeometry/ToricVarieties/NormalToricVarieties/#projective_space-Tuple{Type{NormalToricVariety}, Int64}","page":"Normal Toric Varieties","title":"projective_space","text":"projective_space(::Type{NormalToricVariety}, d::Int)\n\nConstruct the projective space of dimension d.\n\nExamples\n\njulia> projective_space(NormalToricVariety, 2)\nNormal toric variety\n\n\n\n\n\n","category":"method"},{"location":"AlgebraicGeometry/ToricVarieties/NormalToricVarieties/#weighted_projective_space-Union{Tuple{T}, Tuple{Type{NormalToricVariety}, Vector{T}}} where T<:Union{Integer, ZZRingElem}","page":"Normal Toric Varieties","title":"weighted_projective_space","text":"weighted_projective_space(::Type{NormalToricVariety}, w::Vector{T}) where {T <: IntegerUnion}\n\nConstruct the weighted projective space corresponding to the weights w.\n\nExamples\n\njulia> weighted_projective_space(NormalToricVariety, [2, 3, 1])\nNormal toric variety\n\n\n\n\n\n","category":"method"},{"location":"AlgebraicGeometry/ToricVarieties/NormalToricVarieties/#Constructions-based-on-triangulations","page":"Normal Toric Varieties","title":"Constructions based on triangulations","text":"","category":"section"},{"location":"AlgebraicGeometry/ToricVarieties/NormalToricVarieties/","page":"Normal Toric Varieties","title":"Normal Toric Varieties","text":"It is possible to associate toric varieties to star triangulations of the lattice points of polyhedrons. Specifically, we can associate to any full star triangulation of the lattice points of the polyhedron in question a toric variety. For this task, we provide the following constructors.","category":"page"},{"location":"AlgebraicGeometry/ToricVarieties/NormalToricVarieties/","page":"Normal Toric Varieties","title":"Normal Toric Varieties","text":"normal_toric_variety_from_star_triangulation(P::Polyhedron)\nnormal_toric_varieties_from_star_triangulations(P::Polyhedron)","category":"page"},{"location":"AlgebraicGeometry/ToricVarieties/NormalToricVarieties/#normal_toric_variety_from_star_triangulation-Tuple{Polyhedron}","page":"Normal Toric Varieties","title":"normal_toric_variety_from_star_triangulation","text":"normal_toric_variety_from_star_triangulation(P::Polyhedron)\n\nReturn a toric variety that was obtained from a fine regular star triangulation of the lattice points of the polyhedron P. This is particularly useful when the lattice points of the polyhedron in question admit many triangulations.\n\nExamples\n\njulia> P = convex_hull([0 0 0; 0 0 1; 1 0 1; 1 1 1; 0 1 1])\nPolyhedron in ambient dimension 3\n\njulia> v = normal_toric_variety_from_star_triangulation(P)\nNormal toric variety\n\n\n\n\n\n","category":"method"},{"location":"AlgebraicGeometry/ToricVarieties/NormalToricVarieties/#normal_toric_varieties_from_star_triangulations-Tuple{Polyhedron}","page":"Normal Toric Varieties","title":"normal_toric_varieties_from_star_triangulations","text":"normal_toric_varieties_from_star_triangulations(P::Polyhedron)\n\nReturn the list of toric varieties obtained from fine regular star triangulations of the polyhedron P. With this we can compute the two phases of the famous conifold transition.\n\nExamples\n\njulia> P = convex_hull([0 0 0; 0 0 1; 1 0 1; 1 1 1; 0 1 1])\nPolyhedron in ambient dimension 3\n\njulia> (v1, v2) = normal_toric_varieties_from_star_triangulations(P)\n2-element Vector{NormalToricVariety}:\n Normal toric variety\n Normal toric variety\n\njulia> stanley_reisner_ideal(v1)\nIdeal generated by\n  x1*x4\n\njulia> stanley_reisner_ideal(v2)\nIdeal generated by\n  x2*x3\n\n\n\n\n\n","category":"method"},{"location":"AlgebraicGeometry/ToricVarieties/NormalToricVarieties/","page":"Normal Toric Varieties","title":"Normal Toric Varieties","text":"An application of this functionality exists in the physics. Witten's Generalized-Sigma models (GLSM) [Wit88] originally sparked interest in the physics community in toric varieties. On a mathematical level, this establishes a construction of toric varieties for which a Z^n grading of the Cox ring is provided. See for example [FJR17], which describes this as GIT construction [CLS11].","category":"page"},{"location":"AlgebraicGeometry/ToricVarieties/NormalToricVarieties/","page":"Normal Toric Varieties","title":"Normal Toric Varieties","text":"Explicitly, given the grading of the Cox ring, the map from the group of torus invariant Weil divisors to the class group is known. Under the assumption that the variety in question has no torus factor, we can then identify the map from the lattice to the group of torus invariant Weil divisors as the kernel of the map from the torus invariant Weil divisor to the class group. The latter is a map between free Abelian groups, i.e. is provided by an integer valued matrix. The rows of this matrix are nothing but the ray generators of the fan of the toric variety. It then remains to triangulate these rays, hence in general for a GLSM the toric variety is only unique up to fine regular star triangulations. We provide the following two constructors:","category":"page"},{"location":"AlgebraicGeometry/ToricVarieties/NormalToricVarieties/","page":"Normal Toric Varieties","title":"Normal Toric Varieties","text":"normal_toric_variety_from_glsm(charges::ZZMatrix)\nnormal_toric_varieties_from_glsm(charges::ZZMatrix)","category":"page"},{"location":"AlgebraicGeometry/ToricVarieties/NormalToricVarieties/#normal_toric_variety_from_glsm-Tuple{ZZMatrix}","page":"Normal Toric Varieties","title":"normal_toric_variety_from_glsm","text":"normal_toric_variety_from_glsm(charges::ZZMatrix)\n\nReturn one toric variety with the desired GLSM charges. This can be particularly useful provided that there are many such toric varieties.\n\nExamples\n\njulia> charges = [[1, 1, 1]]\n1-element Vector{Vector{Int64}}:\n [1, 1, 1]\n\njulia> normal_toric_variety_from_glsm(charges)\nNormal toric variety\n\nFor convenience, we also support:\n\nnormal_toric_variety_from_glsm(charges::Vector{Vector{Int}})\nnormal_toric_variety_from_glsm(charges::Vector{Vector{ZZRingElem}})\n\n\n\n\n\n","category":"method"},{"location":"AlgebraicGeometry/ToricVarieties/NormalToricVarieties/#normal_toric_varieties_from_glsm-Tuple{ZZMatrix}","page":"Normal Toric Varieties","title":"normal_toric_varieties_from_glsm","text":"normal_toric_varieties_from_glsm(charges::ZZMatrix)\n\nReturn all toric variety with the desired GLSM charges. This computation may take a long time if there are many such toric varieties.\n\nExamples\n\njulia> charges = [[1, 1, 1]]\n1-element Vector{Vector{Int64}}:\n [1, 1, 1]\n\njulia> normal_toric_varieties_from_glsm(charges)\n1-element Vector{NormalToricVariety}:\n Normal toric variety\n\njulia> varieties = normal_toric_varieties_from_glsm(matrix(ZZ, [1 2 3 4 6 0; -1 -1 -2 -2 -3 1]))\n1-element Vector{NormalToricVariety}:\n Normal toric variety\n\njulia> cox_ring(varieties[1])\nMultivariate polynomial ring in 6 variables over QQ graded by\n  x1 -> [1 -1]\n  x2 -> [2 -1]\n  x3 -> [3 -2]\n  x4 -> [4 -2]\n  x5 -> [6 -3]\n  x6 -> [0 1]\n\nFor convenience, we also support:\n\nnormal_toric_varieties_from_glsm(charges::Vector{Vector{Int}})\nnormal_toric_varieties_from_glsm(charges::Vector{Vector{ZZRingElem}})\n\n\n\n\n\n","category":"method"},{"location":"AlgebraicGeometry/ToricVarieties/NormalToricVarieties/#Further-Constructions","page":"Normal Toric Varieties","title":"Further Constructions","text":"","category":"section"},{"location":"AlgebraicGeometry/ToricVarieties/NormalToricVarieties/","page":"Normal Toric Varieties","title":"Normal Toric Varieties","text":"Base.:*(v::NormalToricVarietyType, w::NormalToricVarietyType)\nprojectivization(E::ToricLineBundle...)\ntotal_space(E::ToricLineBundle...)","category":"page"},{"location":"AlgebraicGeometry/ToricVarieties/NormalToricVarieties/#*-Tuple{Union{AffineNormalToricVariety, CyclicQuotientSingularity, NormalToricVariety}, Union{AffineNormalToricVariety, CyclicQuotientSingularity, NormalToricVariety}}","page":"Normal Toric Varieties","title":"*","text":"Base.:*(v::NormalToricVarietyType, w::NormalToricVarietyType)\n\nReturn the Cartesian/direct product of two normal toric varieties v and w.\n\nBy default, we prepend an \"x\" to all homogeneous coordinate names of the first factor v and a \"y\" to all homogeneous coordinate names of the second factor w. This default can be overwritten by invoking set_coordinate_names after creating the variety (cf. set_coordinate_names(v::NormalToricVarietyType, coordinate_names::Vector{String})).\n\nImportant: Recall that the coordinate names can only be changed as long as the toric variety in question is not finalized (cf. is_finalized(v::NormalToricVarietyType)).\n\nCrucially, the order of the homogeneous coordinates is not shuffled. To be more specific, assume that v has n_1 and w has n_2 homogeneous coordinates. Then v * w has n_1 + n_2 homogeneous coordinates. The first n_1 of these coordinates are those of v and appear in the very same order as they do for v. The remaining n_2 homogeneous coordinates are those of w and appear in the very same order as they do for w.\n\nExamples\n\njulia> P2 = projective_space(NormalToricVariety, 2)\nNormal toric variety\n\njulia> v1 = P2 * P2\nNormal toric variety\n\njulia> cox_ring(v1)\nMultivariate polynomial ring in 6 variables over QQ graded by\n  xx1 -> [1 0]\n  xx2 -> [1 0]\n  xx3 -> [1 0]\n  yx1 -> [0 1]\n  yx2 -> [0 1]\n  yx3 -> [0 1]\n\njulia> v2 = P2 * P2\nNormal toric variety\n\njulia> set_coordinate_names(v2, [\"x1\", \"x2\", \"x3\", \"y1\", \"y2\", \"y3\"])\n\n\njulia> cox_ring(v2)\nMultivariate polynomial ring in 6 variables over QQ graded by\n  x1 -> [1 0]\n  x2 -> [1 0]\n  x3 -> [1 0]\n  y1 -> [0 1]\n  y2 -> [0 1]\n  y3 -> [0 1]\n\n\n\n\n\n","category":"method"},{"location":"AlgebraicGeometry/ToricVarieties/NormalToricVarieties/#projectivization-Tuple{Vararg{ToricLineBundle}}","page":"Normal Toric Varieties","title":"projectivization","text":"projectivization(E::ToricLineBundle...)\n\nThis function computes the projectivization of a direct sum of line bundles or divisors. Please see [OM78] for more background information.\n\nExamples\n\nLet us construct the projective bundles X=mathbbP(mathcalO_mathbbP^1oplusmathcalO_mathbbP^1(1)) and Y=mathbbP(mathcalO_mathbbP^1oplusmathcalO_mathbbP^1(2)).\n\njulia> P1 = projective_space(NormalToricVariety, 1);\n\njulia> D0 = toric_divisor(P1, [0,0]);\n\njulia> D1 = toric_divisor(P1, [1,0]);\n\njulia> X = projectivization(D0, D1)\nNormal toric variety\n\njulia> L0 = toric_line_bundle(P1, [0]);\n\njulia> L1 = toric_line_bundle(P1, [2]);\n\njulia> Y = projectivization(L0, L1)\nNormal toric variety\n\n\n\n\n\n","category":"method"},{"location":"AlgebraicGeometry/ToricVarieties/NormalToricVarieties/#total_space-Tuple{Vararg{ToricLineBundle}}","page":"Normal Toric Varieties","title":"total_space","text":"total_space(E::ToricLineBundle...)\n\nThis function computes the total space of a direct sum of line bundles or divisors. Please see [OM78] for more background information.\n\nExamples\n\nLet us construct the toric Calabi-Yau varieties given by the total space of mathcalO_mathbbP^1(2)oplusmathcalO_mathbbP^1(-4) and omega_mathbbP^2.\n\njulia> P1 = projective_space(NormalToricVariety, 1);\n\njulia> L1 = toric_line_bundle(P1, [2]);\n\njulia> L2 = toric_line_bundle(P1, [-4]);\n\njulia> X = total_space(L1, L2)\nNormal toric variety\n\njulia> degree(canonical_bundle(X))\n0\n\njulia> P2 = projective_space(NormalToricVariety, 2);\n\njulia> D = canonical_divisor(P2);\n\njulia> Y = total_space(D)\nNormal toric variety\n\njulia> degree(canonical_bundle(Y))\n0\n\n\n\n\n\n","category":"method"},{"location":"AlgebraicGeometry/ToricVarieties/NormalToricVarieties/#Properties-of-Toric-Varieties","page":"Normal Toric Varieties","title":"Properties of Toric Varieties","text":"","category":"section"},{"location":"AlgebraicGeometry/ToricVarieties/NormalToricVarieties/","page":"Normal Toric Varieties","title":"Normal Toric Varieties","text":"has_torusfactor(v::NormalToricVarietyType)\nis_affine(v::NormalToricVarietyType)\nis_complete(v::NormalToricVarietyType)\nis_fano(v::NormalToricVarietyType)\nis_gorenstein(v::NormalToricVarietyType)\nis_simplicial(v::NormalToricVarietyType)\nis_smooth(v::NormalToricVarietyType)\nis_normal(v::NormalToricVarietyType)\nis_orbifold(v::NormalToricVarietyType)\nis_projective(v::NormalToricVarietyType)\nis_projective_space(v::NormalToricVarietyType)\nis_q_gorenstein(v::NormalToricVarietyType)","category":"page"},{"location":"AlgebraicGeometry/ToricVarieties/NormalToricVarieties/#has_torusfactor-Tuple{Union{AffineNormalToricVariety, CyclicQuotientSingularity, NormalToricVariety}}","page":"Normal Toric Varieties","title":"has_torusfactor","text":"has_torusfactor(v::NormalToricVarietyType)\n\nChecks if the normal toric variety v has a torus factor.\n\nExamples\n\njulia> has_torusfactor(projective_space(NormalToricVariety, 2))\nfalse\n\n\n\n\n\n","category":"method"},{"location":"AlgebraicGeometry/ToricVarieties/NormalToricVarieties/#is_affine-Tuple{Union{AffineNormalToricVariety, CyclicQuotientSingularity, NormalToricVariety}}","page":"Normal Toric Varieties","title":"is_affine","text":"is_affine(v::NormalToricVarietyType)\n\nChecks if the normal toric variety v is affine.\n\nExamples\n\njulia> is_affine(projective_space(NormalToricVariety, 2))\nfalse\n\n\n\n\n\n","category":"method"},{"location":"AlgebraicGeometry/ToricVarieties/NormalToricVarieties/#is_complete-Tuple{Union{AffineNormalToricVariety, CyclicQuotientSingularity, NormalToricVariety}}","page":"Normal Toric Varieties","title":"is_complete","text":"is_complete(v::NormalToricVarietyType)\n\nChecks if the normal toric variety v is complete.\n\nExamples\n\njulia> is_complete(projective_space(NormalToricVariety, 2))\ntrue\n\n\n\n\n\n","category":"method"},{"location":"AlgebraicGeometry/ToricVarieties/NormalToricVarieties/#is_fano-Tuple{Union{AffineNormalToricVariety, CyclicQuotientSingularity, NormalToricVariety}}","page":"Normal Toric Varieties","title":"is_fano","text":"is_fano(v::NormalToricVarietyType)\n\nChecks if the normal toric variety v is fano.\n\nExamples\n\njulia> is_fano(projective_space(NormalToricVariety, 2))\ntrue\n\n\n\n\n\n","category":"method"},{"location":"AlgebraicGeometry/ToricVarieties/NormalToricVarieties/#is_gorenstein-Tuple{Union{AffineNormalToricVariety, CyclicQuotientSingularity, NormalToricVariety}}","page":"Normal Toric Varieties","title":"is_gorenstein","text":"is_gorenstein(v::NormalToricVarietyType)\n\nChecks if the normal toric variety v is Gorenstein.\n\nExamples\n\njulia> is_gorenstein(projective_space(NormalToricVariety, 2))\ntrue\n\n\n\n\n\n","category":"method"},{"location":"AlgebraicGeometry/ToricVarieties/NormalToricVarieties/#is_simplicial-Tuple{Union{AffineNormalToricVariety, CyclicQuotientSingularity, NormalToricVariety}}","page":"Normal Toric Varieties","title":"is_simplicial","text":"is_simplicial(v::NormalToricVarietyType)\n\nChecks if the normal toric variety v is simplicial. Hence, this function works just as is_orbifold. It is implemented for user convenience.\n\nExamples\n\njulia> is_simplicial(projective_space(NormalToricVariety, 2))\ntrue\n\n\n\n\n\n","category":"method"},{"location":"AlgebraicGeometry/ToricVarieties/NormalToricVarieties/#is_smooth-Tuple{Union{AffineNormalToricVariety, CyclicQuotientSingularity, NormalToricVariety}}","page":"Normal Toric Varieties","title":"is_smooth","text":"is_smooth(v::NormalToricVarietyType)\n\nChecks if the normal toric variety v is smooth.\n\nExamples\n\njulia> is_smooth(projective_space(NormalToricVariety, 2))\ntrue\n\n\n\n\n\n","category":"method"},{"location":"AlgebraicGeometry/ToricVarieties/NormalToricVarieties/#is_normal-Tuple{Union{AffineNormalToricVariety, CyclicQuotientSingularity, NormalToricVariety}}","page":"Normal Toric Varieties","title":"is_normal","text":"is_normal(v::NormalToricVarietyType)\n\nChecks if the normal toric variety v is normal. (This function is somewhat tautological at this point.)\n\nExamples\n\njulia> is_normal(projective_space(NormalToricVariety, 2))\ntrue\n\n\n\n\n\n","category":"method"},{"location":"AlgebraicGeometry/ToricVarieties/NormalToricVarieties/#is_orbifold-Tuple{Union{AffineNormalToricVariety, CyclicQuotientSingularity, NormalToricVariety}}","page":"Normal Toric Varieties","title":"is_orbifold","text":"is_orbifold(v::NormalToricVarietyType)\n\nChecks if the normal toric variety v is an orbifold.\n\nExamples\n\njulia> is_orbifold(projective_space(NormalToricVariety, 2))\ntrue\n\n\n\n\n\n","category":"method"},{"location":"AlgebraicGeometry/ToricVarieties/NormalToricVarieties/#is_projective-Tuple{Union{AffineNormalToricVariety, CyclicQuotientSingularity, NormalToricVariety}}","page":"Normal Toric Varieties","title":"is_projective","text":"is_projective(v::NormalToricVarietyType)\n\nChecks if the normal toric variety v is projective, i.e. if the fan of v is the the normal fan of a polytope.\n\nExamples\n\njulia> is_projective(projective_space(NormalToricVariety, 2))\ntrue\n\n\n\n\n\n","category":"method"},{"location":"AlgebraicGeometry/ToricVarieties/NormalToricVarieties/#is_projective_space-Tuple{Union{AffineNormalToricVariety, CyclicQuotientSingularity, NormalToricVariety}}","page":"Normal Toric Varieties","title":"is_projective_space","text":"is_projective_space(v::NormalToricVarietyType)\n\nDecides if the normal toric varieties v is a projective space.\n\nExamples\n\njulia> F5 = hirzebruch_surface(NormalToricVariety, 5)\nNormal toric variety\n\njulia> is_projective_space(F5)\nfalse\n\njulia> is_projective_space(projective_space(NormalToricVariety, 2))\ntrue\n\n\n\n\n\n","category":"method"},{"location":"AlgebraicGeometry/ToricVarieties/NormalToricVarieties/#is_q_gorenstein-Tuple{Union{AffineNormalToricVariety, CyclicQuotientSingularity, NormalToricVariety}}","page":"Normal Toric Varieties","title":"is_q_gorenstein","text":"is_q_gorenstein(v::NormalToricVarietyType)\n\nChecks if the normal toric variety v is Q-Gorenstein.\n\nExamples\n\njulia> is_q_gorenstein(projective_space(NormalToricVariety, 2))\ntrue\n\n\n\n\n\n","category":"method"},{"location":"AlgebraicGeometry/ToricVarieties/NormalToricVarieties/#Operations-for-Toric-Varieties","page":"Normal Toric Varieties","title":"Operations for Toric Varieties","text":"","category":"section"},{"location":"AlgebraicGeometry/ToricVarieties/NormalToricVarieties/#Affine-Open-Covering","page":"Normal Toric Varieties","title":"Affine Open Covering","text":"","category":"section"},{"location":"AlgebraicGeometry/ToricVarieties/NormalToricVarieties/","page":"Normal Toric Varieties","title":"Normal Toric Varieties","text":"affine_open_covering( v::NormalToricVarietyType )","category":"page"},{"location":"AlgebraicGeometry/ToricVarieties/NormalToricVarieties/#affine_open_covering-Tuple{Union{AffineNormalToricVariety, CyclicQuotientSingularity, NormalToricVariety}}","page":"Normal Toric Varieties","title":"affine_open_covering","text":"affine_open_covering(v::NormalToricVarietyType)\n\nCompute an affine open cover of the normal toric variety v, i.e. returns a list of affine toric varieties.\n\nExamples\n\njulia> p2 = projective_space(NormalToricVariety, 2)\nNormal toric variety\n\njulia> affine_open_covering(p2)\n3-element Vector{AffineNormalToricVariety}:\n Normal toric variety\n Normal toric variety\n Normal toric variety\n\n\n\n\n\n","category":"method"},{"location":"AlgebraicGeometry/ToricVarieties/NormalToricVarieties/#Characters,-Weil-Divisors,-Cartier-Divisors,-Class-Group-and-Picard-Group","page":"Normal Toric Varieties","title":"Characters, Weil Divisors, Cartier Divisors, Class Group and Picard Group","text":"","category":"section"},{"location":"AlgebraicGeometry/ToricVarieties/NormalToricVarieties/","page":"Normal Toric Varieties","title":"Normal Toric Varieties","text":"torusinvariant_cartier_divisor_group(v::NormalToricVarietyType)\ncharacter_lattice(v::NormalToricVarietyType)\nclass_group(v::NormalToricVarietyType)\nmap_from_torusinvariant_cartier_divisor_group_to_torusinvariant_weil_divisor_group(v::NormalToricVarietyType)\nmap_from_torusinvariant_cartier_divisor_group_to_picard_group(v::NormalToricVarietyType)\nmap_from_character_lattice_to_torusinvariant_weil_divisor_group(v::NormalToricVarietyType)\nmap_from_torusinvariant_weil_divisor_group_to_class_group(v::NormalToricVarietyType)\npicard_group(v::NormalToricVarietyType)\ntorusinvariant_weil_divisor_group(v::NormalToricVarietyType)\ntorusinvariant_prime_divisors(v::NormalToricVarietyType)","category":"page"},{"location":"AlgebraicGeometry/ToricVarieties/NormalToricVarieties/#torusinvariant_cartier_divisor_group-Tuple{Union{AffineNormalToricVariety, CyclicQuotientSingularity, NormalToricVariety}}","page":"Normal Toric Varieties","title":"torusinvariant_cartier_divisor_group","text":"torusinvariant_cartier_divisor_group(v::NormalToricVarietyType)\n\nReturn the Cartier divisor group of an abstract normal toric variety v.\n\nExamples\n\njulia> p2 = projective_space(NormalToricVariety, 2)\nNormal toric variety\n\njulia> torusinvariant_cartier_divisor_group(p2)\nZ^3\n\n\n\n\n\n","category":"method"},{"location":"AlgebraicGeometry/ToricVarieties/NormalToricVarieties/#character_lattice-Tuple{Union{AffineNormalToricVariety, CyclicQuotientSingularity, NormalToricVariety}}","page":"Normal Toric Varieties","title":"character_lattice","text":"character_lattice(v::NormalToricVarietyType)\n\nReturn the character lattice of a normal toric variety v.\n\nExamples\n\njulia> p2 = projective_space(NormalToricVariety, 2);\n\njulia> character_lattice(p2)\nZ^2\n\n\n\n\n\n","category":"method"},{"location":"AlgebraicGeometry/ToricVarieties/NormalToricVarieties/#class_group-Tuple{Union{AffineNormalToricVariety, CyclicQuotientSingularity, NormalToricVariety}}","page":"Normal Toric Varieties","title":"class_group","text":"class_group(v::NormalToricVarietyType)\n\nReturn the class group of the normal toric variety v.\n\nExamples\n\njulia> p2 = projective_space(NormalToricVariety, 2);\n\njulia> class_group(p2)\nZ\n\n\n\n\n\n","category":"method"},{"location":"AlgebraicGeometry/ToricVarieties/NormalToricVarieties/#map_from_torusinvariant_cartier_divisor_group_to_torusinvariant_weil_divisor_group-Tuple{Union{AffineNormalToricVariety, CyclicQuotientSingularity, NormalToricVariety}}","page":"Normal Toric Varieties","title":"map_from_torusinvariant_cartier_divisor_group_to_torusinvariant_weil_divisor_group","text":"map_from_torusinvariant_cartier_divisor_group_to_torusinvariant_weil_divisor_group(v::NormalToricVarietyType)\n\nReturn the embedding of the group of Cartier divisors into the group of torus-invariant Weil divisors of an abstract normal toric variety v.\n\nExamples\n\njulia> p2 = projective_space(NormalToricVariety, 2)\nNormal toric variety\n\njulia> map_from_torusinvariant_cartier_divisor_group_to_torusinvariant_weil_divisor_group(p2)\nMap\n  from Z^3\n  to Z^3\n\n\n\n\n\n","category":"method"},{"location":"AlgebraicGeometry/ToricVarieties/NormalToricVarieties/#map_from_torusinvariant_cartier_divisor_group_to_picard_group-Tuple{Union{AffineNormalToricVariety, CyclicQuotientSingularity, NormalToricVariety}}","page":"Normal Toric Varieties","title":"map_from_torusinvariant_cartier_divisor_group_to_picard_group","text":"map_from_torusinvariant_cartier_divisor_group_to_picard_group(v::NormalToricVarietyType)\n\nReturn the map from the Cartier divisors to the Picard group of an abstract normal toric variety v.\n\nExamples\n\njulia> p2 = projective_space(NormalToricVariety, 2)\nNormal toric variety\n\njulia> map_from_torusinvariant_cartier_divisor_group_to_picard_group(p2)\nMap\n  from Z^3\n  to Z\n\n\n\n\n\n","category":"method"},{"location":"AlgebraicGeometry/ToricVarieties/NormalToricVarieties/#map_from_character_lattice_to_torusinvariant_weil_divisor_group-Tuple{Union{AffineNormalToricVariety, CyclicQuotientSingularity, NormalToricVariety}}","page":"Normal Toric Varieties","title":"map_from_character_lattice_to_torusinvariant_weil_divisor_group","text":"map_from_character_lattice_to_torusinvariant_weil_divisor_group(v::NormalToricVarietyType)\n\nReturn the map from the character lattice to the group of principal divisors of a normal toric variety v.\n\nExamples\n\njulia> p2 = projective_space(NormalToricVariety, 2);\n\njulia> map_from_character_lattice_to_torusinvariant_weil_divisor_group(p2)\nMap\n  from Z^2\n  to Z^3\n\n\n\n\n\n","category":"method"},{"location":"AlgebraicGeometry/ToricVarieties/NormalToricVarieties/#map_from_torusinvariant_weil_divisor_group_to_class_group-Tuple{Union{AffineNormalToricVariety, CyclicQuotientSingularity, NormalToricVariety}}","page":"Normal Toric Varieties","title":"map_from_torusinvariant_weil_divisor_group_to_class_group","text":"map_from_torusinvariant_weil_divisor_group_to_class_group(v::NormalToricVarietyType)\n\nReturn the map from the group of Weil divisors to the class of group of a normal toric variety v.\n\nExamples\n\njulia> p2 = projective_space(NormalToricVariety, 2);\n\njulia> map_from_torusinvariant_weil_divisor_group_to_class_group(p2)\nMap\n  from Z^3\n  to Z\n\n\n\n\n\n","category":"method"},{"location":"AlgebraicGeometry/ToricVarieties/NormalToricVarieties/#picard_group-Tuple{Union{AffineNormalToricVariety, CyclicQuotientSingularity, NormalToricVariety}}","page":"Normal Toric Varieties","title":"picard_group","text":"picard_group(v::NormalToricVarietyType)\n\nReturn the Picard group of an abstract normal toric variety v.\n\nExamples\n\njulia> p2 = projective_space(NormalToricVariety, 2)\nNormal toric variety\n\njulia> picard_group(p2)\nZ\n\n\n\n\n\n","category":"method"},{"location":"AlgebraicGeometry/ToricVarieties/NormalToricVarieties/#torusinvariant_weil_divisor_group-Tuple{Union{AffineNormalToricVariety, CyclicQuotientSingularity, NormalToricVariety}}","page":"Normal Toric Varieties","title":"torusinvariant_weil_divisor_group","text":"torusinvariant_weil_divisor_group(v::NormalToricVarietyType)\n\nReturn the torusinvariant divisor group of a normal toric variety v.\n\nExamples\n\njulia> p2 = projective_space(NormalToricVariety, 2);\n\njulia> torusinvariant_weil_divisor_group(p2)\nZ^3\n\n\n\n\n\n","category":"method"},{"location":"AlgebraicGeometry/ToricVarieties/NormalToricVarieties/#torusinvariant_prime_divisors-Tuple{Union{AffineNormalToricVariety, CyclicQuotientSingularity, NormalToricVariety}}","page":"Normal Toric Varieties","title":"torusinvariant_prime_divisors","text":"torusinvariant_prime_divisors(v::NormalToricVarietyType)\n\nReturn the list of all torus invariant prime divisors in a normal toric variety v.\n\nExamples\n\njulia> p2 = projective_space(NormalToricVariety, 2);\n\njulia> torusinvariant_prime_divisors(p2)\n3-element Vector{ToricDivisor}:\n Torus-invariant, prime divisor on a normal toric variety\n Torus-invariant, prime divisor on a normal toric variety\n Torus-invariant, prime divisor on a normal toric variety\n\n\n\n\n\n","category":"method"},{"location":"AlgebraicGeometry/ToricVarieties/NormalToricVarieties/#Gorenstein-and-Picard-index","page":"Normal Toric Varieties","title":"Gorenstein and Picard index","text":"","category":"section"},{"location":"AlgebraicGeometry/ToricVarieties/NormalToricVarieties/","page":"Normal Toric Varieties","title":"Normal Toric Varieties","text":"gorenstein_index(v::NormalToricVarietyType)\npicard_index(v::NormalToricVarietyType)","category":"page"},{"location":"AlgebraicGeometry/ToricVarieties/NormalToricVarieties/#gorenstein_index-Tuple{Union{AffineNormalToricVariety, CyclicQuotientSingularity, NormalToricVariety}}","page":"Normal Toric Varieties","title":"gorenstein_index","text":"gorenstein_index(v::NormalToricVarietyType)\n\nReturn the Gorenstein index of a mathbbQ-Gorenstein normal toric variety v.  This is the smallest positive integer l such that -l K is Cartier, where K is a canonical divisor on v. See exercise 8.3.10 and 8.3.11 in [CLS11] for more details.\n\nExamples\n\njulia> gorenstein_index(weighted_projective_space(NormalToricVariety, [2,3,5]))\n3\n\n\n\n\n\n","category":"method"},{"location":"AlgebraicGeometry/ToricVarieties/NormalToricVarieties/#picard_index-Tuple{Union{AffineNormalToricVariety, CyclicQuotientSingularity, NormalToricVariety}}","page":"Normal Toric Varieties","title":"picard_index","text":"picard_index(v::NormalToricVarietyType)\n\nReturn the index of the Picard group in the class group of a simplicial normal  toric variety v. Here, the Picard group embeds as the group of Cartier divisor classes into the class group via map_from_picard_group_to_class_group. See  [HHS11] for more details.\n\nExamples\n\njulia> picard_index(weighted_projective_space(NormalToricVariety, [2,3,5]))\n30\n\n\n\n\n\n","category":"method"},{"location":"AlgebraicGeometry/ToricVarieties/NormalToricVarieties/#Cones-and-Fans","page":"Normal Toric Varieties","title":"Cones and Fans","text":"","category":"section"},{"location":"AlgebraicGeometry/ToricVarieties/NormalToricVarieties/","page":"Normal Toric Varieties","title":"Normal Toric Varieties","text":"polyhedral_fan(v::NormalToricVarietyType)\ncone(v::AffineNormalToricVariety)\nweight_cone(v::AffineNormalToricVariety)\nhilbert_basis(v::AffineNormalToricVariety)\nmori_cone(v::NormalToricVariety)\nnef_cone(v::NormalToricVariety)","category":"page"},{"location":"AlgebraicGeometry/ToricVarieties/NormalToricVarieties/#polyhedral_fan-Tuple{Union{AffineNormalToricVariety, CyclicQuotientSingularity, NormalToricVariety}}","page":"Normal Toric Varieties","title":"polyhedral_fan","text":"polyhedral_fan(v::NormalToricVarietyType)\n\nReturn the fan of an abstract normal toric variety v.\n\nExamples\n\njulia> p2 = projective_space(NormalToricVariety, 2)\nNormal toric variety\n\njulia> polyhedral_fan(p2)\nPolyhedral fan in ambient dimension 2\n\n\n\n\n\n","category":"method"},{"location":"AlgebraicGeometry/ToricVarieties/NormalToricVarieties/#cone-Tuple{AffineNormalToricVariety}","page":"Normal Toric Varieties","title":"cone","text":"cone(v::AffineNormalToricVariety)\n\nReturn the cone of the affine normal toric variety v.\n\nExamples\n\njulia> cone(affine_normal_toric_variety(Oscar.positive_hull([1 1; -1 1])))\nPolyhedral cone in ambient dimension 2\n\n\n\n\n\n","category":"method"},{"location":"AlgebraicGeometry/ToricVarieties/NormalToricVarieties/#weight_cone-Tuple{AffineNormalToricVariety}","page":"Normal Toric Varieties","title":"weight_cone","text":"weight_cone(v::AffineNormalToricVariety)\n\nReturn the dual cone of the affine normal toric variety v.\n\nExamples\n\njulia> C = positive_hull([1 0; 0 1])\nPolyhedral cone in ambient dimension 2\n\njulia> antv = affine_normal_toric_variety(C)\nNormal toric variety\n\njulia> weight_cone(antv)\nPolyhedral cone in ambient dimension 2\n\njulia> polarize(cone(antv)) == weight_cone(antv)\ntrue\n\n\n\n\n\n","category":"method"},{"location":"AlgebraicGeometry/ToricVarieties/NormalToricVarieties/#hilbert_basis-Tuple{AffineNormalToricVariety}","page":"Normal Toric Varieties","title":"hilbert_basis","text":"hilbert_basis(v::AffineNormalToricVariety)\n\nFor an affine toric variety v, this returns the Hilbert basis of the cone dual to the cone of v.\n\nExamples\n\njulia> C = positive_hull([-1 1; 1 1])\nPolyhedral cone in ambient dimension 2\n\njulia> antv = affine_normal_toric_variety(C)\nNormal toric variety\n\njulia> hilbert_basis(antv)\n[-1   1]\n[ 1   1]\n[ 0   1]\n\n\n\n\n\n","category":"method"},{"location":"AlgebraicGeometry/ToricVarieties/NormalToricVarieties/#mori_cone-Tuple{NormalToricVariety}","page":"Normal Toric Varieties","title":"mori_cone","text":"mori_cone(v::NormalToricVariety)\n\nReturn the mori cone of the normal toric variety v.\n\nExamples\n\njulia> p2 = projective_space(NormalToricVariety, 2)\nNormal toric variety\n\njulia> mori = mori_cone(p2)\nPolyhedral cone in ambient dimension 1\n\njulia> dim(mori)\n1\n\n\n\n\n\n","category":"method"},{"location":"AlgebraicGeometry/ToricVarieties/NormalToricVarieties/#nef_cone-Tuple{NormalToricVariety}","page":"Normal Toric Varieties","title":"nef_cone","text":"nef_cone(v::NormalToricVariety)\n\nReturn the nef cone of the normal toric variety v.\n\nExamples\n\njulia> p2 = projective_space(NormalToricVariety, 2)\nNormal toric variety\n\njulia> nef = nef_cone(p2)\nPolyhedral cone in ambient dimension 1\n\njulia> dim(nef)\n1\n\n\n\n\n\n","category":"method"},{"location":"AlgebraicGeometry/ToricVarieties/NormalToricVarieties/#Dimensions","page":"Normal Toric Varieties","title":"Dimensions","text":"","category":"section"},{"location":"AlgebraicGeometry/ToricVarieties/NormalToricVarieties/","page":"Normal Toric Varieties","title":"Normal Toric Varieties","text":"dim(v::NormalToricVarietyType)\ndim_of_torusfactor(v::NormalToricVarietyType)\neuler_characteristic(v::NormalToricVarietyType)\nbetti_number(v::NormalToricVarietyType, i::Int)","category":"page"},{"location":"AlgebraicGeometry/ToricVarieties/NormalToricVarieties/#dim-Tuple{Union{AffineNormalToricVariety, CyclicQuotientSingularity, NormalToricVariety}}","page":"Normal Toric Varieties","title":"dim","text":"dim(v::NormalToricVarietyType)\n\nReturn the dimension of the normal toric variety v.\n\nExamples\n\njulia> C = Oscar.positive_hull([1 0]);\n\njulia> antv = affine_normal_toric_variety(C);\n\njulia> dim(antv)\n1\n\n\n\n\n\n","category":"method"},{"location":"AlgebraicGeometry/ToricVarieties/NormalToricVarieties/#dim_of_torusfactor-Tuple{Union{AffineNormalToricVariety, CyclicQuotientSingularity, NormalToricVariety}}","page":"Normal Toric Varieties","title":"dim_of_torusfactor","text":"dim_of_torusfactor(v::NormalToricVarietyType)\n\nReturn the dimension of the torus factor of the normal toric variety v.\n\nExamples\n\njulia> C = Oscar.positive_hull([1 0]);\n\njulia> antv = affine_normal_toric_variety(C);\n\njulia> dim_of_torusfactor(antv)\n1\n\n\n\n\n\n","category":"method"},{"location":"AlgebraicGeometry/ToricVarieties/NormalToricVarieties/#euler_characteristic-Tuple{Union{AffineNormalToricVariety, CyclicQuotientSingularity, NormalToricVariety}}","page":"Normal Toric Varieties","title":"euler_characteristic","text":"euler_characteristic(v::NormalToricVarietyType)\n\nReturn the Euler characteristic of the normal toric variety v.\n\nExamples\n\njulia> C = Oscar.positive_hull([1 0]);\n\njulia> antv = affine_normal_toric_variety(C);\n\njulia> euler_characteristic(antv)\n1\n\n\n\n\n\n","category":"method"},{"location":"AlgebraicGeometry/ToricVarieties/NormalToricVarieties/#betti_number-Tuple{Union{AffineNormalToricVariety, CyclicQuotientSingularity, NormalToricVariety}, Int64}","page":"Normal Toric Varieties","title":"betti_number","text":"betti_number(v::NormalToricVarietyType, i::Int)\n\nCompute the i-th Betti number of the normal toric variety v.  Specifically, this method returns the dimension of the i-th  simplicial homology group (with rational coefficients) of v.  The employed algorithm is derived from theorem 12.3.12 in  [CLS11]. Note that this theorem requires that the normal  toric variety v is both complete and simplicial.\n\nExamples\n\njulia> P3 = projective_space(NormalToricVariety, 3)\nNormal toric variety\n\njulia> betti_number(P3,0)\n1\n\njulia> betti_number(P3, 1)\n0\n\n\n\n\n\n","category":"method"},{"location":"AlgebraicGeometry/ToricVarieties/NormalToricVarieties/#Rings-and-ideals","page":"Normal Toric Varieties","title":"Rings and ideals","text":"","category":"section"},{"location":"AlgebraicGeometry/ToricVarieties/NormalToricVarieties/","page":"Normal Toric Varieties","title":"Normal Toric Varieties","text":"We support the following rings and ideals for toric varieties:","category":"page"},{"location":"AlgebraicGeometry/ToricVarieties/NormalToricVarieties/","page":"Normal Toric Varieties","title":"Normal Toric Varieties","text":"Cox ring (also termed the \"total coordinate ring\" in [CLS11]),\ncoordinate ring of torus,\ncohomology_ring,\nChow ring,\nirrelevant ideal,\nStanley-Reisner ideal,\nideal of linear relations,\ntoric ideal.","category":"page"},{"location":"AlgebraicGeometry/ToricVarieties/NormalToricVarieties/","page":"Normal Toric Varieties","title":"Normal Toric Varieties","text":"Of course, for any of these coordinate names and the coefficient ring have to be chosen. The coefficient ring is fixed to Q. Therefore, the method coefficient_ring(v::NormalToricVarietyType) always return the field of rational numbers. For the coordinate names, we provide the following setter functions:","category":"page"},{"location":"AlgebraicGeometry/ToricVarieties/NormalToricVarieties/","page":"Normal Toric Varieties","title":"Normal Toric Varieties","text":"set_coordinate_names(v::NormalToricVarietyType, coordinate_names::AbstractVector{<:VarName})\nset_coordinate_names_of_torus(v::NormalToricVarietyType, coordinate_names::AbstractVector{<:VarName})","category":"page"},{"location":"AlgebraicGeometry/ToricVarieties/NormalToricVarieties/#set_coordinate_names-Tuple{Union{AffineNormalToricVariety, CyclicQuotientSingularity, NormalToricVariety}, AbstractVector{<:Union{Char, AbstractString, Symbol}}}","page":"Normal Toric Varieties","title":"set_coordinate_names","text":"set_coordinate_names(v::NormalToricVarietyType, coordinate_names::AbstractVector{<:VarName})\n\nAllows to set the names of the homogeneous coordinates as long as the toric variety in question is not yet finalized (cf. is_finalized(v::NormalToricVarietyType)).\n\nExamples\n\njulia> C = Oscar.positive_hull([1 0]);\n\njulia> antv = affine_normal_toric_variety(C);\n\njulia> set_coordinate_names(antv, [:u])\n\njulia> coordinate_names(antv)\n1-element Vector{String}:\n \"u\"\n\njulia> set_coordinate_names(antv, [\"v\"])\n\njulia> coordinate_names(antv)\n1-element Vector{String}:\n \"v\"\n\njulia> set_coordinate_names(antv, ['w'])\n\njulia> coordinate_names(antv)\n1-element Vector{String}:\n \"w\"\n\n\n\n\n\n","category":"method"},{"location":"AlgebraicGeometry/ToricVarieties/NormalToricVarieties/#set_coordinate_names_of_torus-Tuple{Union{AffineNormalToricVariety, CyclicQuotientSingularity, NormalToricVariety}, AbstractVector{<:Union{Char, AbstractString, Symbol}}}","page":"Normal Toric Varieties","title":"set_coordinate_names_of_torus","text":"set_coordinate_names_of_torus(v::NormalToricVarietyType, coordinate_names::AbstractVector{<:VarName})\n\nAllows to set the names of the coordinates of the torus.\n\nExamples\n\njulia> F3 = hirzebruch_surface(NormalToricVariety, 3);\n\njulia> set_coordinate_names_of_torus(F3, [\"u\", \"v\"])\n\njulia> coordinate_names_of_torus(F3)\n2-element Vector{String}:\n \"u\"\n \"v\"\n\n\n\n\n\n","category":"method"},{"location":"AlgebraicGeometry/ToricVarieties/NormalToricVarieties/","page":"Normal Toric Varieties","title":"Normal Toric Varieties","text":"The following methods allow to extract the chosen coordinates:","category":"page"},{"location":"AlgebraicGeometry/ToricVarieties/NormalToricVarieties/","page":"Normal Toric Varieties","title":"Normal Toric Varieties","text":"coordinate_names(v::NormalToricVarietyType)\ncoordinate_names_of_torus(v::NormalToricVarietyType)","category":"page"},{"location":"AlgebraicGeometry/ToricVarieties/NormalToricVarieties/#coordinate_names-Tuple{Union{AffineNormalToricVariety, CyclicQuotientSingularity, NormalToricVariety}}","page":"Normal Toric Varieties","title":"coordinate_names","text":"coordinate_names(v::NormalToricVarietyType)\n\nReturn the names of the homogeneous coordinates of the normal toric variety v. The default is x1, ..., xn.\n\nExamples\n\njulia> C = Oscar.positive_hull([1 0]);\n\njulia> antv = affine_normal_toric_variety(C);\n\njulia> coordinate_names(antv)\n1-element Vector{String}:\n \"x1\"\n\n\n\n\n\n","category":"method"},{"location":"AlgebraicGeometry/ToricVarieties/NormalToricVarieties/#coordinate_names_of_torus-Tuple{Union{AffineNormalToricVariety, CyclicQuotientSingularity, NormalToricVariety}}","page":"Normal Toric Varieties","title":"coordinate_names_of_torus","text":"coordinate_names_of_torus(v::NormalToricVarietyType)\n\nReturn the names of the coordinates of the torus of the normal toric variety v. The default is x1, ..., xn.\n\n\n\n\n\n","category":"method"},{"location":"AlgebraicGeometry/ToricVarieties/NormalToricVarieties/","page":"Normal Toric Varieties","title":"Normal Toric Varieties","text":"In order to efficiently construct algebraic cycles (elements of the Cox ring), cohomology classes (elements of the cohomology ring), or in order to compare ideals, it is imperative to fix choices of the coordinate names. The default value for coordinate names is [x1, x2, ... ]. The choice of coordinate names is fixed, once one of the above-mentioned rings is computed via one the following methods:","category":"page"},{"location":"AlgebraicGeometry/ToricVarieties/NormalToricVarieties/","page":"Normal Toric Varieties","title":"Normal Toric Varieties","text":"cox_ring(v::NormalToricVarietyType)\nirrelevant_ideal(v::NormalToricVarietyType)\nideal_of_linear_relations(v::NormalToricVarietyType)\nstanley_reisner_ideal(v::NormalToricVarietyType)\ntoric_ideal(antv::AffineNormalToricVariety)\ncoordinate_ring_of_torus(v::NormalToricVarietyType)","category":"page"},{"location":"AlgebraicGeometry/ToricVarieties/NormalToricVarieties/#cox_ring-Tuple{Union{AffineNormalToricVariety, CyclicQuotientSingularity, NormalToricVariety}}","page":"Normal Toric Varieties","title":"cox_ring","text":"cox_ring(v::NormalToricVarietyType)\n\nComputes the Cox ring of the normal toric variety v. Note that [CLS11] refers to this ring as the \"total coordinate ring\". For uniformity with schemes, we also support the function coordinate_ring to refer to the Cox ring.\n\nExamples\n\njulia> p2 = projective_space(NormalToricVariety, 2);\n\njulia> set_coordinate_names(p2, [\"y1\", \"y2\", \"y3\"])\n\njulia> cox_ring(p2)\nMultivariate polynomial ring in 3 variables over QQ graded by\n  y1 -> [1]\n  y2 -> [1]\n  y3 -> [1]\n\njulia> cox_ring(p2) == coordinate_ring(p2)\ntrue\n\n\n\n\n\n","category":"method"},{"location":"AlgebraicGeometry/ToricVarieties/NormalToricVarieties/#irrelevant_ideal-Tuple{Union{AffineNormalToricVariety, CyclicQuotientSingularity, NormalToricVariety}}","page":"Normal Toric Varieties","title":"irrelevant_ideal","text":"irrelevant_ideal(v::NormalToricVarietyType)\n\nReturn the irrelevant ideal of a normal toric variety v.\n\nExamples\n\njulia> p2 = projective_space(NormalToricVariety, 2);\n\njulia> length(gens(irrelevant_ideal(p2)))\n3\n\n\n\n\n\n","category":"method"},{"location":"AlgebraicGeometry/ToricVarieties/NormalToricVarieties/#ideal_of_linear_relations-Tuple{Union{AffineNormalToricVariety, CyclicQuotientSingularity, NormalToricVariety}}","page":"Normal Toric Varieties","title":"ideal_of_linear_relations","text":"ideal_of_linear_relations(v::NormalToricVarietyType)\n\nReturn the ideal of linear relations of the simplicial and complete toric variety v.\n\nExamples\n\njulia> p2 = projective_space(NormalToricVariety, 2);\n\njulia> ngens(ideal_of_linear_relations(p2))\n2\n\n\n\n\n\n","category":"method"},{"location":"AlgebraicGeometry/ToricVarieties/NormalToricVarieties/#stanley_reisner_ideal-Tuple{Union{AffineNormalToricVariety, CyclicQuotientSingularity, NormalToricVariety}}","page":"Normal Toric Varieties","title":"stanley_reisner_ideal","text":"stanley_reisner_ideal(v::NormalToricVarietyType)\n\nReturn the Stanley-Reisner ideal of a normal toric variety v.\n\nExamples\n\njulia> p2 = projective_space(NormalToricVariety, 2);\n\njulia> ngens(stanley_reisner_ideal(p2))\n1\n\n\n\n\n\n","category":"method"},{"location":"AlgebraicGeometry/ToricVarieties/NormalToricVarieties/#toric_ideal-Tuple{AffineNormalToricVariety}","page":"Normal Toric Varieties","title":"toric_ideal","text":"toric_ideal(antv::AffineNormalToricVariety)\n\nReturn the toric ideal defining the affine normal toric variety.\n\nExamples\n\nTake the cone over the square at height one. The resulting toric variety has one defining equation. In projective space this corresponds to mathbbP^1timesmathbbP^1. Note that this cone is self-dual, the toric ideal comes from the dual cone.\n\njulia> C = positive_hull([1 0 0; 1 1 0; 1 0 1; 1 1 1])\nPolyhedral cone in ambient dimension 3\n\njulia> antv = affine_normal_toric_variety(C)\nNormal toric variety\n\njulia> toric_ideal(antv)\nIdeal generated by\n  -x1*x2 + x3*x4\n\n\n\n\n\n","category":"method"},{"location":"AlgebraicGeometry/ToricVarieties/NormalToricVarieties/#coordinate_ring_of_torus-Tuple{Union{AffineNormalToricVariety, CyclicQuotientSingularity, NormalToricVariety}}","page":"Normal Toric Varieties","title":"coordinate_ring_of_torus","text":"coordinate_ring_of_torus(v::NormalToricVarietyType)\n\nComputes the coordinate ring of the torus of the normal toric variety v.\n\nExamples\n\njulia> p2 = projective_space(NormalToricVariety, 2);\n\njulia> set_coordinate_names_of_torus(p2, [\"y1\", \"y2\"])\n\njulia> coordinate_ring_of_torus(p2)\nQuotient\n  of multivariate polynomial ring in 4 variables y1, y2, y1_, y2_\n    over rational field\n  by ideal (y1*y1_ - 1, y2*y2_ - 1)\n\n\n\n\n\n","category":"method"},{"location":"AlgebraicGeometry/ToricVarieties/NormalToricVarieties/","page":"Normal Toric Varieties","title":"Normal Toric Varieties","text":"One can check the status as follows:","category":"page"},{"location":"AlgebraicGeometry/ToricVarieties/NormalToricVarieties/","page":"Normal Toric Varieties","title":"Normal Toric Varieties","text":"is_finalized(v::NormalToricVarietyType)","category":"page"},{"location":"AlgebraicGeometry/ToricVarieties/NormalToricVarieties/#is_finalized-Tuple{Union{AffineNormalToricVariety, CyclicQuotientSingularity, NormalToricVariety}}","page":"Normal Toric Varieties","title":"is_finalized","text":"is_finalized(v::NormalToricVarietyType)\n\nChecks if the Cox ring, the coordinate ring of the torus, the cohomology_ring, the Chow ring, the Stanley-Reisner ideal, the irrelevant ideal, the ideal of linear relations or the toric ideal has been cached. If any of these has been cached, then this function returns true and otherwise false.\n\nExamples\n\njulia> is_finalized(del_pezzo_surface(NormalToricVariety, 3))\nfalse\n\n\n\n\n\n","category":"method"},{"location":"AlgebraicGeometry/ToricVarieties/NormalToricVarieties/","page":"Normal Toric Varieties","title":"Normal Toric Varieties","text":"After the variety finalized, one can enforce to obtain the above ideals in different rings. Also, one can opt to compute the above rings with a different choice of coordinate names and different coefficient ring. To this end, one provides a custom ring (which reflects the desired choice of coordinate names and coefficient ring) as first argument. However, note that the cached ideals and rings are not altered.","category":"page"},{"location":"AlgebraicGeometry/ToricVarieties/NormalToricVarieties/","page":"Normal Toric Varieties","title":"Normal Toric Varieties","text":"cox_ring(R::MPolyRing, v::NormalToricVarietyType)\nirrelevant_ideal(R::MPolyRing, v::NormalToricVarietyType)\nideal_of_linear_relations(R::MPolyRing, v::NormalToricVarietyType)\nstanley_reisner_ideal(R::MPolyRing, v::NormalToricVarietyType)\ntoric_ideal(R::MPolyRing, antv::AffineNormalToricVariety)\ncoordinate_ring_of_torus(R::MPolyRing, v::NormalToricVarietyType)","category":"page"},{"location":"AlgebraicGeometry/ToricVarieties/NormalToricVarieties/#cox_ring-Tuple{MPolyRing, Union{AffineNormalToricVariety, CyclicQuotientSingularity, NormalToricVariety}}","page":"Normal Toric Varieties","title":"cox_ring","text":"cox_ring(R::MPolyRing, v::NormalToricVarietyType)\n\nComputes the Cox ring of the normal toric variety v, in this case by adding the Cox grading to the given ring R. Note that [CLS11] refers to this ring as the \"total coordinate ring\".\n\nExamples\n\njulia> p2 = projective_space(NormalToricVariety, 2);\n\njulia> R, _ = polynomial_ring(QQ, 3);\n\njulia> cox_ring(R, p2)\nMultivariate polynomial ring in 3 variables over QQ graded by\n  x1 -> [1]\n  x2 -> [1]\n  x3 -> [1]\n\n\n\n\n\n","category":"method"},{"location":"AlgebraicGeometry/ToricVarieties/NormalToricVarieties/#irrelevant_ideal-Tuple{MPolyRing, Union{AffineNormalToricVariety, CyclicQuotientSingularity, NormalToricVariety}}","page":"Normal Toric Varieties","title":"irrelevant_ideal","text":"irrelevant_ideal(R::MPolyRing, v::NormalToricVarietyType)\n\nReturn the irrelevant ideal of a normal toric variety v as an ideal in R.\n\nExamples\n\njulia> p2 = projective_space(NormalToricVariety, 2);\n\njulia> R, _ = polynomial_ring(QQ, 3);\n\njulia> length(gens(irrelevant_ideal(R, p2)))\n3\n\n\n\n\n\n","category":"method"},{"location":"AlgebraicGeometry/ToricVarieties/NormalToricVarieties/#ideal_of_linear_relations-Tuple{MPolyRing, Union{AffineNormalToricVariety, CyclicQuotientSingularity, NormalToricVariety}}","page":"Normal Toric Varieties","title":"ideal_of_linear_relations","text":"ideal_of_linear_relations(R::MPolyRing, v::NormalToricVarietyType)\n\nReturn the ideal of linear relations of the simplicial and complete toric variety v in the ring R.\n\nExamples\n\njulia> p2 = projective_space(NormalToricVariety, 2);\n\njulia> R, _ = polynomial_ring(QQ, 3);\n\njulia> ngens(ideal_of_linear_relations(R, p2))\n2\n\n\n\n\n\n","category":"method"},{"location":"AlgebraicGeometry/ToricVarieties/NormalToricVarieties/#stanley_reisner_ideal-Tuple{MPolyRing, Union{AffineNormalToricVariety, CyclicQuotientSingularity, NormalToricVariety}}","page":"Normal Toric Varieties","title":"stanley_reisner_ideal","text":"stanley_reisner_ideal(R::MPolyRing, v::NormalToricVarietyType)\n\nReturn the Stanley-Reisner ideal of a normal toric variety v as an ideal of R.\n\nExamples\n\njulia> p2 = projective_space(NormalToricVariety, 2);\n\njulia> R, _ = polynomial_ring(QQ, 3);\n\njulia> ngens(stanley_reisner_ideal(R, p2))\n1\n\n\n\n\n\n","category":"method"},{"location":"AlgebraicGeometry/ToricVarieties/NormalToricVarieties/#toric_ideal-Tuple{MPolyRing, AffineNormalToricVariety}","page":"Normal Toric Varieties","title":"toric_ideal","text":"toric_ideal(R::MPolyRing, antv::AffineNormalToricVariety)\n\nReturn the toric ideal defining the affine normal toric variety as an ideal in R.\n\nExamples\n\nTake the cone over the square at height one. The resulting toric variety has one defining equation. In projective space this corresponds to mathbbP^1timesmathbbP^1. Note that this cone is self-dual, the toric ideal comes from the dual cone.\n\njulia> C = positive_hull([1 0 0; 1 1 0; 1 0 1; 1 1 1])\nPolyhedral cone in ambient dimension 3\n\njulia> antv = affine_normal_toric_variety(C)\nNormal toric variety\n\njulia> R, _ = polynomial_ring(QQ, 4);\n\njulia> toric_ideal(R, antv)\nIdeal generated by\n  -x1*x2 + x3*x4\n\n\n\n\n\n","category":"method"},{"location":"AlgebraicGeometry/ToricVarieties/NormalToricVarieties/#coordinate_ring_of_torus-Tuple{MPolyRing, Union{AffineNormalToricVariety, CyclicQuotientSingularity, NormalToricVariety}}","page":"Normal Toric Varieties","title":"coordinate_ring_of_torus","text":"coordinate_ring_of_torus(R::MPolyRing, v::NormalToricVarietyType)\n\nComputes the coordinate ring of the torus of the normal toric variety v in the given polynomial ring R.\n\n\n\n\n\n","category":"method"},{"location":"AlgebraicGeometry/ToricVarieties/NormalToricVarieties/","page":"Normal Toric Varieties","title":"Normal Toric Varieties","text":"Along the same lines, characters can be turned into rational functions:","category":"page"},{"location":"AlgebraicGeometry/ToricVarieties/NormalToricVarieties/","page":"Normal Toric Varieties","title":"Normal Toric Varieties","text":"character_to_rational_function(v::NormalToricVarietyType, character::Vector{ZZRingElem})\ncharacter_to_rational_function(R::MPolyRing, v::NormalToricVarietyType, character::Vector{ZZRingElem})","category":"page"},{"location":"AlgebraicGeometry/ToricVarieties/NormalToricVarieties/#character_to_rational_function-Tuple{Union{AffineNormalToricVariety, CyclicQuotientSingularity, NormalToricVariety}, Vector{ZZRingElem}}","page":"Normal Toric Varieties","title":"character_to_rational_function","text":"character_to_rational_function(v::NormalToricVarietyType, character::Vector{ZZRingElem})\n\nComputes the rational function corresponding to a character of the normal toric variety v.\n\nExamples\n\njulia> p2 = projective_space(NormalToricVariety, 2);\n\njulia> character_to_rational_function(p2, [-1, 2])\nx2^2*x1_\n\n\n\n\n\n","category":"method"},{"location":"AlgebraicGeometry/ToricVarieties/NormalToricVarieties/#character_to_rational_function-Tuple{MPolyRing, Union{AffineNormalToricVariety, CyclicQuotientSingularity, NormalToricVariety}, Vector{ZZRingElem}}","page":"Normal Toric Varieties","title":"character_to_rational_function","text":"character_to_rational_function(R::MPolyRing, v::NormalToricVarietyType, character::Vector{ZZRingElem})\n\nComputes the rational function corresponding to a character of the normal toric variety v.\n\nExamples\n\njulia> p2 = projective_space(NormalToricVariety, 2);\n\njulia> R, _ = polynomial_ring(QQ, 4);\n\njulia> character_to_rational_function(R, p2, [-1, 2])\nx2^2*x3\n\n\n\n\n\n","category":"method"},{"location":"AlgebraicGeometry/ToricVarieties/NormalToricVarieties/#Auxiliary-Methods","page":"Normal Toric Varieties","title":"Auxiliary Methods","text":"","category":"section"},{"location":"AlgebraicGeometry/ToricVarieties/NormalToricVarieties/","page":"Normal Toric Varieties","title":"Normal Toric Varieties","text":"binomial_exponents_to_ideal(binoms::Union{AbstractMatrix, ZZMatrix})\ntoric_ideal(pts::ZZMatrix)","category":"page"},{"location":"AlgebraicGeometry/ToricVarieties/NormalToricVarieties/#binomial_exponents_to_ideal-Tuple{Union{ZZMatrix, AbstractMatrix}}","page":"Normal Toric Varieties","title":"binomial_exponents_to_ideal","text":"binomial_exponents_to_ideal(binoms::Union{AbstractMatrix, ZZMatrix})\n\nThis function converts the rows of a matrix to binomials. Each row r is written as r=u-v with u vge 0 by splitting into positive and negative entries. Then the row r corresponds to x^u-x^v.  The resulting ideal is returned.\n\nExamples\n\njulia> A = [-1 -1 0 2; 2 3 -2 -1]\n2×4 Matrix{Int64}:\n -1  -1   0   2\n  2   3  -2  -1\n\njulia> binomial_exponents_to_ideal(A)\nIdeal generated by\n  -x1*x2 + x4^2\n  x1^2*x2^3 - x3^2*x4\n\n\n\n\n\n","category":"method"},{"location":"AlgebraicGeometry/ToricVarieties/NormalToricVarieties/#toric_ideal-Tuple{ZZMatrix}","page":"Normal Toric Varieties","title":"toric_ideal","text":"toric_ideal(pts::ZZMatrix)\n\nReturn the toric ideal generated from the linear relations between the points pts. This is the ideal generated by the set of binomials x^u-x^v  u vinmathbbZ^n_ge 0 (pts)^Tcdot(u-v) = 0\n\nExamples\n\njulia> C = positive_hull([-2 5; 1 0]);\n\njulia> H = hilbert_basis(C);\n\njulia> toric_ideal(H)\nIdeal generated by\n  x2*x3 - x4^2\n  -x1*x3 + x2^2*x4\n  -x1*x4 + x2^3\n  -x1*x3^2 + x2*x4^3\n  -x1*x3^3 + x4^5\n\n\n\n\n\n","category":"method"},{"location":"Nemo/padic/","page":"Padics","title":"Padics","text":"CurrentModule = Nemo\nDocTestSetup = quote\n    using Nemo\nend","category":"page"},{"location":"Nemo/padic/#Padics","page":"Padics","title":"Padics","text":"","category":"section"},{"location":"Nemo/padic/","page":"Padics","title":"Padics","text":"P-adic fields are provided in Nemo by Flint. This allows construction of p-adic fields for any prime p.","category":"page"},{"location":"Nemo/padic/","page":"Padics","title":"Padics","text":"P-adic fields are constructed using the padic_field function.","category":"page"},{"location":"Nemo/padic/","page":"Padics","title":"Padics","text":"The types of p-adic fields in Nemo are given in the following table, along with the libraries that provide them and the associated types of the parent objects.","category":"page"},{"location":"Nemo/padic/","page":"Padics","title":"Padics","text":"Library Field Element type Parent type\nFlint mathbbQ_p PadicFieldElem PadicField","category":"page"},{"location":"Nemo/padic/","page":"Padics","title":"Padics","text":"All the p-adic field types belong to the Field abstract type and the p-adic field element types belong to the FieldElem abstract type.","category":"page"},{"location":"Nemo/padic/#P-adic-functionality","page":"Padics","title":"P-adic functionality","text":"","category":"section"},{"location":"Nemo/padic/","page":"Padics","title":"Padics","text":"P-adic fields in Nemo implement all the AbstractAlgebra field functionality:.","category":"page"},{"location":"Nemo/padic/","page":"Padics","title":"Padics","text":"https://nemocas.github.io/AbstractAlgebra.jl/stable/field","category":"page"},{"location":"Nemo/padic/","page":"Padics","title":"Padics","text":"Below, we document all the additional function that is provide by Nemo for p-adic fields.","category":"page"},{"location":"Nemo/padic/#Constructors","page":"Padics","title":"Constructors","text":"","category":"section"},{"location":"Nemo/padic/","page":"Padics","title":"Padics","text":"In order to construct p-adic field elements in Nemo, one must first construct the p-adic field itself. This is accomplished with one of the following constructors.","category":"page"},{"location":"Nemo/padic/","page":"Padics","title":"Padics","text":"padic_field","category":"page"},{"location":"Nemo/padic/#padic_field","page":"Padics","title":"padic_field","text":"padic_field(p::Integer; precision::Int=64, cached::Bool=true, check::Bool=true)\npadic_field(p::ZZRingElem; precision::Int=64, cached::Bool=true, check::Bool=true)\n\nReturn the p-adic field for the given prime p. The default absolute precision of elements of the field may be set with precision.\n\n\n\n\n\n","category":"function"},{"location":"Nemo/padic/","page":"Padics","title":"Padics","text":"Here are some examples of creating p-adic fields and making use of the resulting parent objects to coerce various elements into those fields.","category":"page"},{"location":"Nemo/padic/","page":"Padics","title":"Padics","text":"Examples","category":"page"},{"location":"Nemo/padic/","page":"Padics","title":"Padics","text":"julia> R = padic_field(7, precision = 30)\nField of 7-adic numbers\n\njulia> S = padic_field(ZZ(65537), precision = 30)\nField of 65537-adic numbers\n\njulia> a = R()\nO(7^30)\n\njulia> b = S(1)\n65537^0 + O(65537^30)\n\njulia> c = S(ZZ(123))\n123*65537^0 + O(65537^30)\n\njulia> d = R(ZZ(1)//7^2)\n7^-2 + O(7^28)","category":"page"},{"location":"Nemo/padic/#Big-oh-notation","page":"Padics","title":"Big-oh notation","text":"","category":"section"},{"location":"Nemo/padic/","page":"Padics","title":"Padics","text":"Elements of p-adic fields can  be constructed using the big-oh notation. For this purpose we define the following functions.","category":"page"},{"location":"Nemo/padic/","page":"Padics","title":"Padics","text":"O(::PadicField, ::Integer)\nO(::PadicField, ::ZZRingElem)\nO(::PadicField, ::QQFieldElem)","category":"page"},{"location":"Nemo/padic/#O-Tuple{PadicField, Integer}","page":"Padics","title":"O","text":"O(R::PadicField, m::Integer)\n\nConstruct the value 0 + O(p^n) given m = p^n. An exception results if m is not found to be a power of p = prime(R).\n\n\n\n\n\n","category":"method"},{"location":"Nemo/padic/#O-Tuple{PadicField, ZZRingElem}","page":"Padics","title":"O","text":"O(R::PadicField, m::ZZRingElem)\n\nConstruct the value 0 + O(p^n) given m = p^n. An exception results if m is not found to be a power of p = prime(R).\n\n\n\n\n\n","category":"method"},{"location":"Nemo/padic/#O-Tuple{PadicField, QQFieldElem}","page":"Padics","title":"O","text":"O(R::PadicField, m::QQFieldElem)\n\nConstruct the value 0 + O(p^n) given m = p^n. An exception results if m is not found to be a power of p = prime(R).\n\n\n\n\n\n","category":"method"},{"location":"Nemo/padic/","page":"Padics","title":"Padics","text":"The O(p^n) construction can be used to construct p-adic values of precision n by adding it to integer values representing the p-adic value modulo p^n as in the examples.","category":"page"},{"location":"Nemo/padic/","page":"Padics","title":"Padics","text":"Examples","category":"page"},{"location":"Nemo/padic/","page":"Padics","title":"Padics","text":"julia> R = padic_field(7, precision = 30)\nField of 7-adic numbers\n\njulia> S = padic_field(ZZ(65537), precision = 30)\nField of 65537-adic numbers\n\njulia> c = 1 + 2*7 + 4*7^2 + O(R, 7^3)\n7^0 + 2*7^1 + 4*7^2 + O(7^3)\n\njulia> d = 13 + 357*ZZ(65537) + O(S, ZZ(65537)^12)\n13*65537^0 + 357*65537^1 + O(65537^12)\n\njulia> f = ZZ(1)//7^2 + ZZ(2)//7 + 3 + 4*7 + O(R, 7^2)\n7^-2 + 2*7^-1 + 3*7^0 + 4*7^1 + O(7^2)","category":"page"},{"location":"Nemo/padic/","page":"Padics","title":"Padics","text":"Beware that the expression 1 + 2*p + 3*p^2 + O(R, p^n) is actually computed as a normal Julia expression. Therefore if Int values are used instead of ZZRingElems or Julia BigInts, overflow may result in evaluating the value.","category":"page"},{"location":"Nemo/padic/#Basic-manipulation","page":"Padics","title":"Basic manipulation","text":"","category":"section"},{"location":"Nemo/padic/","page":"Padics","title":"Padics","text":"prime(::PadicField)","category":"page"},{"location":"Nemo/padic/#prime-Tuple{PadicField}","page":"Padics","title":"prime","text":"prime(R::PadicField)\n\nReturn the prime p for the given p-adic field.\n\n\n\n\n\n","category":"method"},{"location":"Nemo/padic/","page":"Padics","title":"Padics","text":"precision(::PadicFieldElem)","category":"page"},{"location":"Nemo/padic/#precision-Tuple{PadicFieldElem}","page":"Padics","title":"precision","text":"precision(a::PadicFieldElem)\n\nReturn the precision of the given p-adic field element, i.e. if the element is known to O(p^n) this function will return n.\n\n\n\n\n\n","category":"method"},{"location":"Nemo/padic/","page":"Padics","title":"Padics","text":"valuation(::PadicFieldElem)","category":"page"},{"location":"Nemo/padic/#valuation-Tuple{PadicFieldElem}","page":"Padics","title":"valuation","text":"valuation(a::PadicFieldElem)\n\nReturn the valuation of the given p-adic field element, i.e. if the given element is divisible by p^n but not a higher power of p then the function will return n.\n\n\n\n\n\n","category":"method"},{"location":"Nemo/padic/","page":"Padics","title":"Padics","text":"lift(::ZZRing, ::PadicFieldElem)\nlift(::QQField, ::PadicFieldElem)","category":"page"},{"location":"Nemo/padic/#lift-Tuple{ZZRing, PadicFieldElem}","page":"Padics","title":"lift","text":"lift(R::ZZRing, a::PadicFieldElem)\n\nReturn a lift of the given p-adic field element to mathbbZ.\n\n\n\n\n\n","category":"method"},{"location":"Nemo/padic/#lift-Tuple{QQField, PadicFieldElem}","page":"Padics","title":"lift","text":"lift(R::QQField, a::PadicFieldElem)\n\nReturn a lift of the given p-adic field element to mathbbQ.\n\n\n\n\n\n","category":"method"},{"location":"Nemo/padic/","page":"Padics","title":"Padics","text":"Examples","category":"page"},{"location":"Nemo/padic/","page":"Padics","title":"Padics","text":"julia> R = padic_field(7, precision = 30)\nField of 7-adic numbers\n\njulia> a = 1 + 2*7 + 4*7^2 + O(R, 7^3)\n7^0 + 2*7^1 + 4*7^2 + O(7^3)\n\njulia> b = 7^2 + 3*7^3 + O(R, 7^5)\n7^2 + 3*7^3 + O(7^5)\n\njulia> c = R(2)\n2*7^0 + O(7^30)\n\njulia> k = precision(a)\n3\n\njulia> m = prime(R)\n7\n\njulia> n = valuation(b)\n2\n\njulia> p = lift(ZZ, a)\n211\n\njulia> q = lift(QQ, divexact(a, b))\n337//49","category":"page"},{"location":"Nemo/padic/#Square-root","page":"Padics","title":"Square root","text":"","category":"section"},{"location":"Nemo/padic/","page":"Padics","title":"Padics","text":"Base.sqrt(::PadicFieldElem)","category":"page"},{"location":"Nemo/padic/#sqrt-Tuple{PadicFieldElem}","page":"Padics","title":"sqrt","text":"Base.sqrt(f::PolyRingElem{T}; check::Bool=true) where T <: RingElement\n\nReturn the square root of f. By default the function checks the input is square and raises an exception if not. If check=false this check is omitted.\n\n\n\n\n\nBase.sqrt(a::FracElem{T}; check::Bool=true) where T <: RingElem\n\nReturn the square root of a. By default the function will throw an exception if the input is not square. If check=false this test is omitted.\n\n\n\n\n\nsqrt(a::FieldElem)\n\nReturn the square root of the element a. By default the function will throw an exception if the input is not square. If check=false this test is omitted.\n\n\n\n\n\nsqrt(a::Generic.PuiseuxSeriesElem{T}; check::Bool=true) where T <: RingElement\n\nReturn the square root of the given Puiseux series a. By default the function will throw an exception if the input is not square. If check=false this test is omitted.\n\n\n\n\n\n","category":"method"},{"location":"Nemo/padic/","page":"Padics","title":"Padics","text":"Examples","category":"page"},{"location":"Nemo/padic/","page":"Padics","title":"Padics","text":"julia> R = padic_field(7, precision = 30)\nField of 7-adic numbers\n\njulia> a = 1 + 7 + 2*7^2 + O(R, 7^3)\n7^0 + 7^1 + 2*7^2 + O(7^3)\n\njulia> b = 2 + 3*7 + O(R, 7^5)\n2*7^0 + 3*7^1 + O(7^5)\n\njulia> c = 7^2 + 2*7^3 + O(R, 7^4)\n7^2 + 2*7^3 + O(7^4)\n\njulia> d = sqrt(a)\n7^0 + 4*7^1 + 3*7^2 + O(7^3)\n\njulia> f = sqrt(b)\n3*7^0 + 5*7^1 + 7^2 + 7^3 + O(7^5)\n\njulia> f = sqrt(c)\n7^1 + 7^2 + O(7^3)\n\njulia> g = sqrt(R(121))\n3*7^0 + 5*7^1 + 6*7^2 + 6*7^3 + 6*7^4 + 6*7^5 + 6*7^6 + 6*7^7 + 6*7^8 + 6*7^9 + 6*7^10 + 6*7^11 + 6*7^12 + 6*7^13 + 6*7^14 + 6*7^15 + 6*7^16 + 6*7^17 + 6*7^18 + 6*7^19 + 6*7^20 + 6*7^21 + 6*7^22 + 6*7^23 + 6*7^24 + 6*7^25 + 6*7^26 + 6*7^27 + 6*7^28 + 6*7^29 + O(7^30)\n\njulia> g^2 == R(121)\ntrue","category":"page"},{"location":"Nemo/padic/#Special-functions","page":"Padics","title":"Special functions","text":"","category":"section"},{"location":"Nemo/padic/","page":"Padics","title":"Padics","text":"Base.exp(::PadicFieldElem)","category":"page"},{"location":"Nemo/padic/#exp-Tuple{PadicFieldElem}","page":"Padics","title":"exp","text":"exp(a::PadicFieldElem)\n\nReturn the p-adic exponential of a, assuming the p-adic exponential function converges at a.\n\n\n\n\n\n","category":"method"},{"location":"Nemo/padic/","page":"Padics","title":"Padics","text":"log(::PadicFieldElem)","category":"page"},{"location":"Nemo/padic/#log-Tuple{PadicFieldElem}","page":"Padics","title":"log","text":"log(a::PadicFieldElem)\n\nReturn the p-adic logarithm of a, assuming the p-adic logarithm converges at a.\n\n\n\n\n\n","category":"method"},{"location":"Nemo/padic/","page":"Padics","title":"Padics","text":"teichmuller(::PadicFieldElem)","category":"page"},{"location":"Nemo/padic/#teichmuller-Tuple{PadicFieldElem}","page":"Padics","title":"teichmuller","text":"teichmuller(a::PadicFieldElem)\n\nReturn the Teichmuller lift of the p-adic value a. We require the valuation of a to be non-negative. The precision of the output will be the same as the precision of the input. For convenience, if a is congruent to zero modulo p we return zero. If the input is not valid an exception is thrown.\n\n\n\n\n\n","category":"method"},{"location":"Nemo/padic/","page":"Padics","title":"Padics","text":"Examples","category":"page"},{"location":"Nemo/padic/","page":"Padics","title":"Padics","text":"julia> R = padic_field(7, precision = 30)\nField of 7-adic numbers\n\njulia> a = 1 + 7 + 2*7^2 + O(R, 7^3)\n7^0 + 7^1 + 2*7^2 + O(7^3)\n\njulia> b = 2 + 5*7 + 3*7^2 + O(R, 7^3)\n2*7^0 + 5*7^1 + 3*7^2 + O(7^3)\n\njulia> c = 3*7 + 2*7^2 + O(R, 7^5)\n3*7^1 + 2*7^2 + O(7^5)\n\njulia> c = exp(c)\n7^0 + 3*7^1 + 3*7^2 + 4*7^3 + 4*7^4 + O(7^5)\n\njulia> d = log(a)\n7^1 + 5*7^2 + O(7^3)\n\njulia> c = exp(R(0))\n7^0 + O(7^30)\n\njulia> d = log(R(1))\nO(7^30)\n\njulia> f = teichmuller(b)\n2*7^0 + 4*7^1 + 6*7^2 + O(7^3)","category":"page"},{"location":"DeveloperDocumentation/caching/","page":"Caching parent objects in OSCAR","title":"Caching parent objects in OSCAR","text":"CurrentModule = Oscar\nDocTestSetup = Oscar.doctestsetup()","category":"page"},{"location":"DeveloperDocumentation/caching/#Caching-parent-objects-in-OSCAR","page":"Caching parent objects in OSCAR","title":"Caching parent objects in OSCAR","text":"","category":"section"},{"location":"DeveloperDocumentation/caching/","page":"Caching parent objects in OSCAR","title":"Caching parent objects in OSCAR","text":"Many functions in OSCAR that construct parent objects (such as rings, modules, groups, etc.) have an optional keyword argument cached::Bool. If set to true then the object is put into a cache, and when the construction function is later called again with identical inputs, then the cached object is returned instead of creating a new object. In contrast when cached is set to false then each time a new object is returned.","category":"page"},{"location":"DeveloperDocumentation/caching/","page":"Caching parent objects in OSCAR","title":"Caching parent objects in OSCAR","text":"Example:","category":"page"},{"location":"DeveloperDocumentation/caching/","page":"Caching parent objects in OSCAR","title":"Caching parent objects in OSCAR","text":"julia> R1, = polynomial_ring(QQ, :x; cached = true);\n\njulia> R2, = polynomial_ring(QQ, :x; cached = true);\n\njulia> R1 === R2  # identical as both were created with `cached = true`\ntrue\n\njulia> R3, = polynomial_ring(QQ, :x; cached = false);\n\njulia> R1 === R3  # not identical as R3 was created with `cached = false`\nfalse\n\njulia> R4, = polynomial_ring(QQ, :y; cached = true);\n\njulia> R1 === R4  # not identical despite `cached = true` due to differing variable names\nfalse","category":"page"},{"location":"DeveloperDocumentation/caching/#Why-cache-parent-objects?","page":"Caching parent objects in OSCAR","title":"Why cache parent objects?","text":"","category":"section"},{"location":"DeveloperDocumentation/caching/","page":"Caching parent objects in OSCAR","title":"Caching parent objects in OSCAR","text":"The main reason for supporting caching of parent objects is user convenience: experience shows that most mathematicians (espescially those who are not also programmers; but it really affects all) are surprised if, say, QQ[:x] == Q[:x] produces false.","category":"page"},{"location":"DeveloperDocumentation/caching/","page":"Caching parent objects in OSCAR","title":"Caching parent objects in OSCAR","text":"For interactive use, it is often simply convenient: e.g. in the following example, we use map_coefficients to map polynomials over the integers to polynomials over a finite field, and the results can be added – this is only possible because the new polynomials have the same parent, thanks to caching.","category":"page"},{"location":"DeveloperDocumentation/caching/","page":"Caching parent objects in OSCAR","title":"Caching parent objects in OSCAR","text":"julia> Zx, x = ZZ[:x]\n(Univariate polynomial ring in x over ZZ, x)\n\njulia> F = GF(2);\n\njulia> map_coefficients(F, x^2) + map_coefficients(F, x)\nx^2 + x","category":"page"},{"location":"DeveloperDocumentation/caching/","page":"Caching parent objects in OSCAR","title":"Caching parent objects in OSCAR","text":"Caching parents also has downsides. E.g. all those cached objects take up memory which in some cases can add up to significant amounts.","category":"page"},{"location":"DeveloperDocumentation/caching/#Rules-for-implementations","page":"Caching parent objects in OSCAR","title":"Rules for implementations","text":"","category":"section"},{"location":"DeveloperDocumentation/caching/","page":"Caching parent objects in OSCAR","title":"Caching parent objects in OSCAR","text":"In the following we describe some rules related to caching for people implementing parent constructor functions","category":"page"},{"location":"DeveloperDocumentation/caching/","page":"Caching parent objects in OSCAR","title":"Caching parent objects in OSCAR","text":"Don't use caching in code inside OSCAR (caching is for end users!)\ni.e., code inside OSCAR by default should always construct rings with cached = false.\nIn other words: internal code should not rely on caching being active. Usually the need for using cached parents can be overcome by allowing callers to pass in a parent object as an additional function argument. One may still provide a default value for that as a user convenience, but these default parents then should be created with cached=false.\nRationale: this avoids clogging the system with cached objects the user never asked for. It also eliminates sources of bugs: a cached ring may have attributes assigned that modify its behavior in a way that it is completely unexpected in code dealing with \"newly created\" ring\nAll end-user facing constructors should have a cached::Bool keyword argument with a default value, regardless of whether caching is actually supported or not.\nif caching is supported, then cached should default to true\nif caching is not supported, then cached should default to false\nRationale: this allows us to comply pro-actively with the first rule: when creating a parent object, you always pass in cached = false. If not all constructors support this, we can't comply with it. Even if a constructor does not support caching right now: this might change in the future. So by allowing the cached argument in all cases, we can write future-proof code.\nCaches must not overflow\nthe simplest solution to achieve this is to use an AbstractAlgebra.CacheDictType instances (which really is an alias for WeakValueDict) together with get_cached! which automatically removes objects from caches if nothing outside the cache references it anymore\nAlternatively one may offer a manual way for users to \"flush\" caches, but beware the problems this can cause when code relies on parents being cached – yet another reason for rule 1.","category":"page"},{"location":"DeveloperDocumentation/caching/","page":"Caching parent objects in OSCAR","title":"Caching parent objects in OSCAR","text":"For convenience, Hecke also defines these \"standard rings\" for use in functions like cyclotomic_polynomial","category":"page"},{"location":"DeveloperDocumentation/caching/","page":"Caching parent objects in OSCAR","title":"Caching parent objects in OSCAR","text":"module Globals\n  using Hecke\n  const Qx, _ = polynomial_ring(QQ, :x, cached = false)\n  const Zx, _ = polynomial_ring(ZZ, :x, cached = false)\n  const Zxy, _ = polynomial_ring(ZZ, [:x, :y], cached = false)\nend","category":"page"},{"location":"DeveloperDocumentation/caching/","page":"Caching parent objects in OSCAR","title":"Caching parent objects in OSCAR","text":"You can use these in your own code as well, or imitate this pattern if convenient.","category":"page"},{"location":"DeveloperDocumentation/caching/","page":"Caching parent objects in OSCAR","title":"Caching parent objects in OSCAR","text":"As always, if in doubt what to do, please ask.","category":"page"},{"location":"Groups/matgroup/","page":"Matrix groups","title":"Matrix groups","text":"CurrentModule = Oscar\nDocTestSetup = Oscar.doctestsetup()","category":"page"},{"location":"Groups/matgroup/#Matrix-groups","page":"Matrix groups","title":"Matrix groups","text":"","category":"section"},{"location":"Groups/matgroup/","page":"Matrix groups","title":"Matrix groups","text":"matrix_group(R::Ring, m::Int, V::AbstractVector{T}; check::Bool=true) where T<:Union{MatElem,MatrixGroupElem}\nMatrixGroup{RE<:RingElem, T<:MatElem{RE}}\nMatrixGroupElem{RE<:RingElem, T<:MatElem{RE}}\nbase_ring(G::MatrixGroup{RE}) where RE <: RingElem\ndegree(G::MatrixGroup)\ncentralizer(G::MatrixGroup{T}, x::MatrixGroupElem{T}) where T <: FinFieldElem\nmap_entries(f, G::MatrixGroup)","category":"page"},{"location":"Groups/matgroup/#matrix_group-Union{Tuple{T}, Tuple{Ring, Int64, AbstractVector{T}}} where T<:Union{MatElem, MatrixGroupElem}","page":"Matrix groups","title":"matrix_group","text":"matrix_group(R::Ring, m::Int, V::T...) where T<:Union{MatElem,MatrixGroupElem}\nmatrix_group(R::Ring, m::Int, V::AbstractVector{T}) where T<:Union{MatElem,MatrixGroupElem}\nmatrix_group(V::T...) where T<:Union{MatElem,MatrixGroupElem}\nmatrix_group(V::AbstractVector{T}) where T<:Union{MatElem,MatrixGroupElem}\n\nReturn the matrix group generated by matrices in V. If the degree m and coefficient ring R are not given, then V must be non-empty\n\n\n\n\n\n","category":"method"},{"location":"Groups/matgroup/#MatrixGroup","page":"Matrix groups","title":"MatrixGroup","text":"MatrixGroup{RE<:RingElem, T<:MatElem{RE}} <: GAPGroup\n\nType of groups G of n x n matrices over the ring R, where n = degree(G) and R = base_ring(G).\n\n\n\n\n\n","category":"type"},{"location":"Groups/matgroup/#MatrixGroupElem","page":"Matrix groups","title":"MatrixGroupElem","text":"MatrixGroupElem{RE<:RingElem, T<:MatElem{RE}} <: AbstractMatrixGroupElem\n\nElements of a group of type MatrixGroup{RE<:RingElem, T<:MatElem{RE}}\n\n\n\n\n\n","category":"type"},{"location":"Groups/matgroup/#base_ring-Union{Tuple{MatrixGroup{RE, T} where T<:MatElem{RE}}, Tuple{RE}} where RE<:RingElem","page":"Matrix groups","title":"base_ring","text":"base_ring(G::MatrixGroup)\n\nReturn the base ring of the matrix group G.\n\n\n\n\n\n","category":"method"},{"location":"Groups/matgroup/#degree-Tuple{MatrixGroup}","page":"Matrix groups","title":"degree","text":"degree(G::MatrixGroup)\n\nReturn the degree of the matrix group G, i.e. the number of rows of its matrices.\n\n\n\n\n\n","category":"method"},{"location":"Groups/matgroup/#centralizer-Union{Tuple{T}, Tuple{MatrixGroup{T, T1} where T1<:MatElem{T}, MatrixGroupElem{T, T1} where T1<:MatElem{T}}} where T<:FinFieldElem","page":"Matrix groups","title":"centralizer","text":"centralizer(G::MatrixGroup{T}, x::MatrixGroupElem{T})\n\nReturn (C,f), where C is the centralizer of x in C and f is the embedding of C into G. If G = GL(n,F) or SL(n,F), then f = nothing. In this case, to get the embedding homomorphism of C into G, use\n\nis_subgroup(C, G)[2]\n\n\n\n\n\n","category":"method"},{"location":"Groups/matgroup/#map_entries-Tuple{Any, MatrixGroup}","page":"Matrix groups","title":"map_entries","text":"map_entries(f, G::MatrixGroup)\n\nReturn the matrix group obtained by applying f element-wise to each generator of G.\n\nf can be a ring or a field, a suitable map, or a Julia function.\n\nExamples\n\njulia> mat = matrix(ZZ, 2, 2, [1, 1, 0, 1]);\n\njulia> G = matrix_group(mat);\n\njulia> G2 = map_entries(x -> -x, G)\nMatrix group of degree 2\n  over integer ring\n\njulia> is_finite(G2)\nfalse\n\njulia> order(map_entries(GF(3), G))\n3\n\n\n\n\n\n","category":"method"},{"location":"Groups/matgroup/#Elements-of-matrix-groups","page":"Matrix groups","title":"Elements of matrix groups","text":"","category":"section"},{"location":"Groups/matgroup/","page":"Matrix groups","title":"Matrix groups","text":"matrix(x::MatrixGroupElem)\nbase_ring(x::MatrixGroupElem)\nnrows(x::MatrixGroupElem)\ndet(x::MatrixGroupElem)\ntr(x::MatrixGroupElem)\nmultiplicative_jordan_decomposition(x::MatrixGroupElem)\nis_semisimple(x::MatrixGroupElem{T}) where T <: FinFieldElem\nis_unipotent(x::MatrixGroupElem{T}) where T <: FinFieldElem","category":"page"},{"location":"Groups/matgroup/#matrix-Tuple{MatrixGroupElem}","page":"Matrix groups","title":"matrix","text":"matrix(x::MatrixGroupElem)\n\nReturn the underlying matrix of x.\n\n\n\n\n\n","category":"method"},{"location":"Groups/matgroup/#base_ring-Tuple{MatrixGroupElem}","page":"Matrix groups","title":"base_ring","text":"base_ring(x::MatrixGroupElem)\n\nReturn the base ring of the underlying matrix of x.\n\n\n\n\n\n","category":"method"},{"location":"Groups/matgroup/#nrows-Tuple{MatrixGroupElem}","page":"Matrix groups","title":"nrows","text":"number_of_rows(x::MatrixGroupElem)\n\nReturn the number of rows of the underlying matrix of x.\n\n\n\n\n\n","category":"method"},{"location":"Groups/matgroup/#det-Tuple{MatrixGroupElem}","page":"Matrix groups","title":"det","text":"det(x::MatrixGroupElem)\n\nReturn the determinant of the underlying matrix of x.\n\n\n\n\n\n","category":"method"},{"location":"Groups/matgroup/#tr-Tuple{MatrixGroupElem}","page":"Matrix groups","title":"tr","text":"tr(x::MatrixGroupElem)\n\nReturn the trace of the underlying matrix of x.\n\n\n\n\n\n","category":"method"},{"location":"Groups/matgroup/#multiplicative_jordan_decomposition-Tuple{MatrixGroupElem}","page":"Matrix groups","title":"multiplicative_jordan_decomposition","text":"multiplicative_jordan_decomposition(M::MatrixGroupElem)\n\nReturn S and U in the group G = parent(M) such that S is semisimple, U is unipotent and  M = SU = US.\n\nwarning: WARNING:\nthis is NOT, in general, the same output returned when M has type MatElem.\n\n\n\n\n\n","category":"method"},{"location":"Groups/matgroup/#is_semisimple-Union{Tuple{MatrixGroupElem{T, T1} where T1<:MatElem{T}}, Tuple{T}} where T<:FinFieldElem","page":"Matrix groups","title":"is_semisimple","text":"is_semisimple(x::MatrixGroupElem{T}) where T <: FinFieldElem\n\nReturn whether x is semisimple, i.e. has order coprime with the characteristic of its base ring.\n\n\n\n\n\n","category":"method"},{"location":"Groups/matgroup/#is_unipotent-Union{Tuple{MatrixGroupElem{T, T1} where T1<:MatElem{T}}, Tuple{T}} where T<:FinFieldElem","page":"Matrix groups","title":"is_unipotent","text":"is_unipotent(x::MatrixGroupElem{T}) where T <: FinFieldElem\n\nReturn whether x is unipotent, i.e. its order is a power of the characteristic of its base ring.\n\n\n\n\n\n","category":"method"},{"location":"Groups/matgroup/#Sesquilinear-forms","page":"Matrix groups","title":"Sesquilinear forms","text":"","category":"section"},{"location":"Groups/matgroup/","page":"Matrix groups","title":"Matrix groups","text":"SesquilinearForm{T<:RingElem}\nis_alternating(f::SesquilinearForm)\nis_hermitian(f::SesquilinearForm)\nis_quadratic(f::SesquilinearForm)\nis_symmetric(f::SesquilinearForm)\nalternating_form(B::MatElem{T}) where T <: FieldElem\nsymmetric_form(B::MatElem{T}) where T <: FieldElem\nhermitian_form(B::MatElem{T}) where T <: FieldElem\nquadratic_form(B::MatElem{T}) where T <: FieldElem\nquadratic_form(f::MPolyRingElem{T}) where T <: FieldElem\ncorresponding_bilinear_form(B::SesquilinearForm)\ncorresponding_quadratic_form(B::SesquilinearForm)\ngram_matrix(f::SesquilinearForm)\ndefining_polynomial(f::SesquilinearForm)\nradical(f::SesquilinearForm{T}) where T\nwitt_index(f::SesquilinearForm{T}) where T\nis_degenerate(f::SesquilinearForm{T}) where T\nis_singular(f::SesquilinearForm{T}) where T\nis_congruent(f::SesquilinearForm{T}, g::SesquilinearForm{T}) where T <: RingElem","category":"page"},{"location":"Groups/matgroup/#SesquilinearForm","page":"Matrix groups","title":"SesquilinearForm","text":"SesquilinearForm{T<:RingElem}\n\nType of groups G of n x n matrices over the ring R, where n = degree(G) and R = base_ring(G). At the moment, only rings of type fqPolyRepField are supported.\n\n\n\n\n\n","category":"type"},{"location":"Groups/matgroup/#is_alternating-Tuple{SesquilinearForm}","page":"Matrix groups","title":"is_alternating","text":"is_alternating(f::SesquilinearForm)\n\nReturn whether the form f is an alternating form.\n\n\n\n\n\n","category":"method"},{"location":"Groups/matgroup/#is_hermitian-Tuple{SesquilinearForm}","page":"Matrix groups","title":"is_hermitian","text":"is_hermitian(f::SesquilinearForm)\n\nReturn whether the form f is a hermitian form.\n\n\n\n\n\n","category":"method"},{"location":"Groups/matgroup/#is_quadratic-Tuple{SesquilinearForm}","page":"Matrix groups","title":"is_quadratic","text":"is_quadratic(f::SesquilinearForm)\n\nReturn whether the form f is a quadratic form.\n\n\n\n\n\n","category":"method"},{"location":"Groups/matgroup/#is_symmetric-Tuple{SesquilinearForm}","page":"Matrix groups","title":"is_symmetric","text":"is_symmetric(f::SesquilinearForm)\n\nReturn whether the form f is a symmetric form.\n\n\n\n\n\n","category":"method"},{"location":"Groups/matgroup/#alternating_form-Union{Tuple{MatElem{T}}, Tuple{T}} where T<:FieldElem","page":"Matrix groups","title":"alternating_form","text":"alternating_form(B::MatElem{T})\n\nReturn the alternating form with Gram matrix B.\n\n\n\n\n\n","category":"method"},{"location":"Groups/matgroup/#symmetric_form-Union{Tuple{MatElem{T}}, Tuple{T}} where T<:FieldElem","page":"Matrix groups","title":"symmetric_form","text":"symmetric_form(B::MatElem{T})\n\nReturn the symmetric form with Gram matrix B.\n\n\n\n\n\n","category":"method"},{"location":"Groups/matgroup/#hermitian_form-Union{Tuple{MatElem{T}}, Tuple{T}} where T<:FieldElem","page":"Matrix groups","title":"hermitian_form","text":"hermitian_form(B::MatElem{T})\n\nReturn the hermitian form with Gram matrix B.\n\n\n\n\n\n","category":"method"},{"location":"Groups/matgroup/#quadratic_form-Union{Tuple{MatElem{T}}, Tuple{T}} where T<:FieldElem","page":"Matrix groups","title":"quadratic_form","text":"quadratic_form(B::MatElem{T})\n\nReturn the quadratic form with Gram matrix B.\n\n\n\n\n\n","category":"method"},{"location":"Groups/matgroup/#quadratic_form-Union{Tuple{MPolyRingElem{T}}, Tuple{T}} where T<:FieldElem","page":"Matrix groups","title":"quadratic_form","text":"quadratic_form(f::MPolyRingElem{T}; check=true)\n\nReturn the quadratic form described by the polynomial f. Here, f must be a homogeneous polynomial of degree 2. If check is set as false, it does not check whether the polynomial is homogeneous of degree 2. To define quadratic forms of dimension 1, f can also have type PolyRingElem{T}.\n\n\n\n\n\n","category":"method"},{"location":"Groups/matgroup/#corresponding_bilinear_form-Tuple{SesquilinearForm}","page":"Matrix groups","title":"corresponding_bilinear_form","text":"corresponding_bilinear_form(Q::SesquilinearForm)\n\nGiven a quadratic form Q, return the bilinear form B defined by B(u,v) = Q(u+v)-Q(u)-Q(v).\n\n\n\n\n\n","category":"method"},{"location":"Groups/matgroup/#corresponding_quadratic_form-Tuple{SesquilinearForm}","page":"Matrix groups","title":"corresponding_quadratic_form","text":"corresponding_quadratic_form(Q::SesquilinearForm)\n\nGiven a symmetric form f, returns the quadratic form Q defined by Q(v) = f(v,v)/2. It is defined only in odd characteristic.\n\n\n\n\n\n","category":"method"},{"location":"Groups/matgroup/#gram_matrix-Tuple{SesquilinearForm}","page":"Matrix groups","title":"gram_matrix","text":"gram_matrix(B::SesquilinearForm)\n\nReturn the Gram matrix of a sesquilinear or quadratic form B.\n\n\n\n\n\n","category":"method"},{"location":"Groups/matgroup/#defining_polynomial-Tuple{SesquilinearForm}","page":"Matrix groups","title":"defining_polynomial","text":"defining_polynomial(f::SesquilinearForm)\n\nReturn the polynomial that defines the quadratic form f.\n\n\n\n\n\n","category":"method"},{"location":"Groups/matgroup/#radical-Union{Tuple{SesquilinearForm{T}}, Tuple{T}} where T","page":"Matrix groups","title":"radical","text":"radical(f::SesquilinearForm{T})\n\nReturn the radical of the sesquilinear form f, i.e. the subspace of all v such that f(u,v)=0 for all u. The radical of a quadratic form Q is the set of vectors v such that Q(v)=0  and v lies in the radical of the corresponding bilinear form.\n\n\n\n\n\n","category":"method"},{"location":"Groups/matgroup/#witt_index-Union{Tuple{SesquilinearForm{T}}, Tuple{T}} where T","page":"Matrix groups","title":"witt_index","text":"witt_index(f::SesquilinearForm{T})\n\nReturn the Witt index of the form induced by f on V/Rad(f). The Witt Index is the dimension of a maximal totally isotropic (singular for quadratic forms) subspace.\n\n\n\n\n\n","category":"method"},{"location":"Groups/matgroup/#is_degenerate-Union{Tuple{SesquilinearForm{T}}, Tuple{T}} where T","page":"Matrix groups","title":"is_degenerate","text":"is_degenerate(f::SesquilinearForm{T})\n\nReturn whether f is degenerate, i.e. f has nonzero radical. A quadratic form is degenerate if the corresponding bilinear form is.\n\n\n\n\n\n","category":"method"},{"location":"Groups/matgroup/#is_singular-Union{Tuple{SesquilinearForm{T}}, Tuple{T}} where T","page":"Matrix groups","title":"is_singular","text":"is_singular(Q::SesquilinearForm{T})\n\nFor a quadratic form Q, return whether Q is singular, i.e. Q has nonzero radical.\n\n\n\n\n\n","category":"method"},{"location":"Groups/matgroup/#is_congruent-Union{Tuple{T}, Tuple{SesquilinearForm{T}, SesquilinearForm{T}}} where T<:RingElem","page":"Matrix groups","title":"is_congruent","text":"is_congruent(f::SesquilinearForm{T}, g::SesquilinearForm{T}) where T <: RingElem\n\nIf f and g are sesquilinear forms, return (true, C) if there exists a matrix C such that f^C = g, or equivalently, CBC* = A, where A and B are the Gram matrices of f and g respectively, and C* is the transpose-conjugate matrix of C. If such C does not exist, then return (false, nothing).\n\nIf f and g are quadratic forms, return (true, C) if there exists a matrix C such that f^A = ag for some scalar a. If such C does not exist, then return (false, nothing).\n\n\n\n\n\n","category":"method"},{"location":"Groups/matgroup/#Invariant-forms","page":"Matrix groups","title":"Invariant forms","text":"","category":"section"},{"location":"Groups/matgroup/","page":"Matrix groups","title":"Matrix groups","text":"invariant_bilinear_forms(G::MatrixGroup{S,T}) where {S,T}\ninvariant_sesquilinear_forms(G::MatrixGroup{S,T}) where {S,T}\ninvariant_quadratic_forms(G::MatrixGroup{S,T}) where {S,T}\ninvariant_symmetric_forms(G::MatrixGroup{S,T}) where {S,T}\ninvariant_alternating_forms(G::MatrixGroup{S,T}) where {S,T}\ninvariant_hermitian_forms(G::MatrixGroup{S,T}) where {S,T}\ninvariant_bilinear_form(G::MatrixGroup)\ninvariant_sesquilinear_form(G::MatrixGroup)\ninvariant_quadratic_form(G::MatrixGroup)\npreserved_quadratic_forms(G::MatrixGroup{S,T}) where {S,T}\npreserved_sesquilinear_forms(G::MatrixGroup{S,T}) where {S,T}\nisometry_group(f::SesquilinearForm{T}) where T\northogonal_sign(G::MatrixGroup)","category":"page"},{"location":"Groups/matgroup/#invariant_bilinear_forms-Union{Tuple{MatrixGroup{S, T}}, Tuple{T}, Tuple{S}} where {S, T}","page":"Matrix groups","title":"invariant_bilinear_forms","text":"invariant_bilinear_forms(G::MatrixGroup)\n\nReturn a generating set for the vector spaces of bilinear forms preserved by the group G.\n\nwarning: Note:\nAt the moment, elements of the generating set are returned of type mat_elem_type(G).\n\n\n\n\n\n","category":"method"},{"location":"Groups/matgroup/#invariant_sesquilinear_forms-Union{Tuple{MatrixGroup{S, T}}, Tuple{T}, Tuple{S}} where {S, T}","page":"Matrix groups","title":"invariant_sesquilinear_forms","text":"invariant_sesquilinear_forms(G::MatrixGroup)\n\nReturn a generating set for the vector spaces of sesquilinear non-bilinear forms preserved by the group G. An exception is thrown if base_ring(G) is not a finite field with even degree over its prime subfield.\n\nwarning: Note:\nAt the moment, elements of the generating set are returned of type mat_elem_type(G).\n\n\n\n\n\n","category":"method"},{"location":"Groups/matgroup/#invariant_quadratic_forms-Union{Tuple{MatrixGroup{S, T}}, Tuple{T}, Tuple{S}} where {S, T}","page":"Matrix groups","title":"invariant_quadratic_forms","text":"invariant_quadratic_forms(G::MatrixGroup)\n\nReturn a generating set for the vector spaces of quadratic forms preserved by the group G.\n\nwarning: Note:\nAt the moment, elements of the generating set are returned of type mat_elem_type(G).\n\n\n\n\n\n","category":"method"},{"location":"Groups/matgroup/#invariant_symmetric_forms-Union{Tuple{MatrixGroup{S, T}}, Tuple{T}, Tuple{S}} where {S, T}","page":"Matrix groups","title":"invariant_symmetric_forms","text":"invariant_symmetric_forms(G::MatrixGroup)\n\nReturn a generating set for the vector spaces of symmetric forms preserved by the group G.\n\nwarning: Note:\nAt the moment, elements of the generating set are returned of type mat_elem_type(G).\n\nwarning: Note:\nWork properly only in odd characteristic. In even characteristic, only alternating forms are found.\n\n\n\n\n\n","category":"method"},{"location":"Groups/matgroup/#invariant_alternating_forms-Union{Tuple{MatrixGroup{S, T}}, Tuple{T}, Tuple{S}} where {S, T}","page":"Matrix groups","title":"invariant_alternating_forms","text":"invariant_alternating_forms(G::MatrixGroup)\n\nReturn a generating set for the vector spaces of alternating forms preserved by the group G.\n\nwarning: Note:\nAt the moment, elements of the generating set are returned of type mat_elem_type(G).\n\n\n\n\n\n","category":"method"},{"location":"Groups/matgroup/#invariant_hermitian_forms-Union{Tuple{MatrixGroup{S, T}}, Tuple{T}, Tuple{S}} where {S, T}","page":"Matrix groups","title":"invariant_hermitian_forms","text":"invariant_hermitian_forms(G::MatrixGroup)\n\nReturn a generating set for the vector spaces of hermitian forms preserved by the group G. An exception is thrown if base_ring(G) is not a finite field with even degree over its prime subfield.\n\nwarning: Note:\nAt the moment, elements of the generating set are returned of type mat_elem_type(G).\n\n\n\n\n\n","category":"method"},{"location":"Groups/matgroup/#invariant_bilinear_form-Tuple{MatrixGroup}","page":"Matrix groups","title":"invariant_bilinear_form","text":"invariant_bilinear_form(G::MatrixGroup)\n\nReturn an invariant bilinear form for the group G. An exception is thrown if the module induced by the action of G is not absolutely irreducible.\n\nwarning: Note:\nAt the moment, the output is returned of type mat_elem_type(G).\n\n\n\n\n\n","category":"method"},{"location":"Groups/matgroup/#invariant_sesquilinear_form-Tuple{MatrixGroup}","page":"Matrix groups","title":"invariant_sesquilinear_form","text":"invariant_sesquilinear_form(G::MatrixGroup)\n\nReturn an invariant sesquilinear (non bilinear) form for the group G. An exception is thrown if the module induced by the action of G is not absolutely irreducible or if the group is defined over a finite field of odd degree over the prime field.\n\nwarning: Note:\nAt the moment, the output is returned of type mat_elem_type(G).\n\n\n\n\n\n","category":"method"},{"location":"Groups/matgroup/#invariant_quadratic_form-Tuple{MatrixGroup}","page":"Matrix groups","title":"invariant_quadratic_form","text":"invariant_quadratic_form(G::MatrixGroup)\n\nReturn an invariant quadratic form for the group G. An exception is thrown if the module induced by the action of G is not absolutely irreducible.\n\nwarning: Note:\nAt the moment, the output is returned of type mat_elem_type(G).\n\n\n\n\n\n","category":"method"},{"location":"Groups/matgroup/#preserved_quadratic_forms-Union{Tuple{MatrixGroup{S, T}}, Tuple{T}, Tuple{S}} where {S, T}","page":"Matrix groups","title":"preserved_quadratic_forms","text":"preserved_quadratic_forms(G::MatrixGroup)\n\nUses random methods to find all of the quadratic forms preserved by G up to a scalar (i.e. such that G is a group of similarities for the forms).  Since the procedure relies on a pseudo-random generator,  the user may need to execute the operation more than once to find all invariant quadratic forms.\n\n\n\n\n\n","category":"method"},{"location":"Groups/matgroup/#preserved_sesquilinear_forms-Union{Tuple{MatrixGroup{S, T}}, Tuple{T}, Tuple{S}} where {S, T}","page":"Matrix groups","title":"preserved_sesquilinear_forms","text":"preserved_sesquilinear_forms(G::MatrixGroup)\n\nUses random methods to find all of the sesquilinear forms preserved by G up to a scalar (i.e. such that G is a group of similarities for the forms). Since the procedure relies on a pseudo-random generator, the user may need to execute the operation more than once to find all invariant sesquilinear forms.\n\n\n\n\n\n","category":"method"},{"location":"Groups/matgroup/#isometry_group-Union{Tuple{SesquilinearForm{T}}, Tuple{T}} where T","page":"Matrix groups","title":"isometry_group","text":"isometry_group(f::SesquilinearForm{T})\n\nReturn the group of isometries for the sesquilinear form f.\n\n\n\n\n\n","category":"method"},{"location":"Groups/matgroup/#orthogonal_sign-Tuple{MatrixGroup}","page":"Matrix groups","title":"orthogonal_sign","text":"orthogonal_sign(G::MatrixGroup)\n\nFor absolutely irreducible G of degree n and such that base_ring(G) is a finite field, return\n\nnothing if G does not preserve a nonzero quadratic form,\n0 if n is odd and G preserves a nonzero quadratic form,\n1 if n is even and G preserves a nonzero quadratic form of + type,\n-1 if n is even and G preserves a nonzero quadratic form of - type.\n\n\n\n\n\n","category":"method"},{"location":"Groups/matgroup/#Utilities-for-matrices","page":"Matrix groups","title":"Utilities for matrices","text":"","category":"section"},{"location":"Groups/matgroup/","page":"Matrix groups","title":"Matrix groups","text":"pol_elementary_divisors(A::MatElem{T}) where T\ngeneralized_jordan_block(f::T, n::Int) where T<:PolyRingElem\ngeneralized_jordan_form(A::MatElem{T}; with_pol=false) where T\nmatrix(A::Vector{AbstractAlgebra.Generic.FreeModuleElem{T}}) where T <: RingElem\nupper_triangular_matrix(L::AbstractVector{T}) where {T <: NCRingElement}\nlower_triangular_matrix(L::AbstractVector{T}) where {T <: NCRingElement}\nconjugate_transpose(x::MatElem{T}) where T <: FinFieldElem\ncomplement(V::AbstractAlgebra.Generic.FreeModule{T}, W::AbstractAlgebra.Generic.Submodule{T}) where T <: FieldElem\npermutation_matrix(F::Ring, Q::AbstractVector{<:IntegerUnion})\nis_alternating(B::MatElem)\nis_hermitian(B::MatElem{T}) where T <: FinFieldElem","category":"page"},{"location":"Groups/matgroup/#pol_elementary_divisors-Union{Tuple{MatElem{T}}, Tuple{T}} where T","page":"Matrix groups","title":"pol_elementary_divisors","text":"pol_elementary_divisors(x::MatElem)\npol_elementary_divisors(x::MatrixGroupElem)\n\nReturn a list of pairs (f_i,m_i), for irreducible polynomials f_i and positive integers m_i, where the f_i^m_i are the elementary divisors of x.\n\n\n\n\n\n","category":"method"},{"location":"Groups/matgroup/#generalized_jordan_block-Union{Tuple{T}, Tuple{T, Int64}} where T<:PolyRingElem","page":"Matrix groups","title":"generalized_jordan_block","text":"generalized_jordan_block(f::T, n::Int) where T<:PolyRingElem\n\nReturn the Jordan block of dimension n corresponding to the polynomial f.\n\n\n\n\n\n","category":"method"},{"location":"Groups/matgroup/#generalized_jordan_form-Union{Tuple{MatElem{T}}, Tuple{T}} where T","page":"Matrix groups","title":"generalized_jordan_form","text":"generalized_jordan_form(A::MatElem{T}; with_pol::Bool=false) where T\n\nReturn (J,Z), where Z^-1*J*Z = A and J is a diagonal join of Jordan blocks (corresponding to irreducible polynomials).\n\n\n\n\n\n","category":"method"},{"location":"Groups/matgroup/#matrix-Union{Tuple{Array{AbstractAlgebra.Generic.FreeModuleElem{T}, 1}}, Tuple{T}} where T<:RingElem","page":"Matrix groups","title":"matrix","text":"matrix(A::Vector{AbstractAlgebra.Generic.FreeModuleElem})\n\nReturn the matrix whose rows are the vectors in A. All vectors in A must have the same length and the same base ring.\n\n\n\n\n\n","category":"method"},{"location":"Groups/matgroup/#upper_triangular_matrix-Union{Tuple{AbstractVector{T}}, Tuple{T}} where T<:NCRingElement","page":"Matrix groups","title":"upper_triangular_matrix","text":"upper_triangular_matrix(L::AbstractVector{T}) where {T <: NCRingElement}\n\nReturn the n by n matrix whose entries on and above the main diagonal are the elements of L, and which has zeroes elsewhere. The value of n is determined by the condition that L has length n(n+1)2.\n\nAn exception is thrown if there is no integer n with this property.\n\nExamples\n\njulia> upper_triangular_matrix([1, 2, 3])\n[1   2]\n[0   3]\n\n\n\n\n\n","category":"method"},{"location":"Groups/matgroup/#lower_triangular_matrix-Union{Tuple{AbstractVector{T}}, Tuple{T}} where T<:NCRingElement","page":"Matrix groups","title":"lower_triangular_matrix","text":"lower_triangular_matrix(L::AbstractVector{T}) where {T <: NCRingElement}\n\nReturn the n by n matrix whose entries on and below the main diagonal are the elements of L, and which has zeroes elsewhere. The value of n is determined by the condition that L has length n(n+1)2.\n\nAn exception is thrown if there is no integer n with this property.\n\nExamples\n\njulia> lower_triangular_matrix([1, 2, 3])\n[1   0]\n[2   3]\n\n\n\n\n\n","category":"method"},{"location":"Groups/matgroup/#conjugate_transpose-Union{Tuple{MatElem{T}}, Tuple{T}} where T<:FinFieldElem","page":"Matrix groups","title":"conjugate_transpose","text":"conjugate_transpose(x::MatElem{T}) where T <: FinFieldElem\n\nIf the base ring of x is GF(q^2), return the matrix transpose( map ( y -> y^q, x) ). An exception is thrown if the base ring does not have even degree.\n\n\n\n\n\n","category":"method"},{"location":"Groups/matgroup/#complement-Union{Tuple{T}, Tuple{AbstractAlgebra.Generic.FreeModule{T}, AbstractAlgebra.Generic.Submodule{T}}} where T<:FieldElem","page":"Matrix groups","title":"complement","text":"complement(V::AbstractAlgebra.Generic.FreeModule{T}, W::AbstractAlgebra.Generic.Submodule{T}) where T <: FieldElem\n\nReturn a complement for W in V, i.e. a subspace U of V such that V is direct sum of U and W.\n\n\n\n\n\n","category":"method"},{"location":"Groups/matgroup/#permutation_matrix-Tuple{Ring, AbstractVector{<:Union{Integer, ZZRingElem}}}","page":"Matrix groups","title":"permutation_matrix","text":"permutation_matrix(F::Ring, Q::AbstractVector{T}) where T <: Int\npermutation_matrix(F::Ring, p::PermGroupElem)\n\nReturn the permutation matrix over the ring R corresponding to the sequence Q or to the permutation p. If Q is a sequence, then Q must contain exactly once every integer from 1 to some n.\n\nExamples\n\njulia> s = perm([3,1,2])\n(1,3,2)\n\njulia> permutation_matrix(QQ,s)\n[0   0   1]\n[1   0   0]\n[0   1   0]\n\n\n\n\n\n\n","category":"method"},{"location":"Groups/matgroup/#is_alternating-Tuple{MatElem}","page":"Matrix groups","title":"is_alternating","text":"is_alternating(B::MatElem)\n\nReturn whether the form corresponding to the matrix B is alternating, i.e. B = -transpose(B) and B has zeros on the diagonal. Return false if B is not a square matrix.\n\n\n\n\n\n","category":"method"},{"location":"Groups/matgroup/#is_hermitian-Union{Tuple{MatElem{T}}, Tuple{T}} where T<:FinFieldElem","page":"Matrix groups","title":"is_hermitian","text":"is_hermitian(B::MatElem{T}) where T <: FinFieldElem\n\nReturn whether the matrix B is hermitian, i.e. B = conjugate_transpose(B). Return false if B is not a square matrix, or the field has not even degree.\n\n\n\n\n\n","category":"method"},{"location":"Groups/matgroup/#Classical-groups","page":"Matrix groups","title":"Classical groups","text":"","category":"section"},{"location":"Groups/matgroup/","page":"Matrix groups","title":"Matrix groups","text":"general_linear_group(n::Int, F::Ring)\nspecial_linear_group(n::Int, F::Ring)\nsymplectic_group(n::Int, F::Ring)\northogonal_group(e::Int, n::Int, F::Ring)\nspecial_orthogonal_group(e::Int, n::Int, F::Ring)\nomega_group(e::Int, n::Int, F::Ring)\nunitary_group(n::Int, q::Int)\nspecial_unitary_group(n::Int, q::Int)","category":"page"},{"location":"Groups/matgroup/#general_linear_group-Tuple{Int64, Ring}","page":"Matrix groups","title":"general_linear_group","text":"general_linear_group(n::Int, q::Int)\ngeneral_linear_group(n::Int, R::Ring)\nGL = general_linear_group\n\nReturn the general linear group of dimension n over the ring R respectively the field GF(q).\n\nCurrently R must be either a finite field or a residue ring or ZZ.\n\nExamples\n\njulia> F = GF(7)\nPrime field of characteristic 7\n\njulia> H = general_linear_group(2, F)\nGL(2,7)\n\njulia> gens(H)\n2-element Vector{MatrixGroupElem{FqFieldElem, FqMatrix}}:\n [3 0; 0 1]\n [6 1; 6 0]\n\njulia> order(general_linear_group(2, residue_ring(ZZ, 6)[1]))\n288\n\n\n\n\n\n","category":"method"},{"location":"Groups/matgroup/#special_linear_group-Tuple{Int64, Ring}","page":"Matrix groups","title":"special_linear_group","text":"special_linear_group(n::Int, q::Int)\nspecial_linear_group(n::Int, R::Ring)\nSL = special_linear_group\n\nReturn the special linear group of dimension n over the ring R respectively the field GF(q).\n\nCurrently R must be either a finite field or a residue ring or ZZ.\n\nExamples\n\njulia> F = GF(7)\nPrime field of characteristic 7\n\njulia> H = special_linear_group(2, F)\nSL(2,7)\n\njulia> gens(H)\n2-element Vector{MatrixGroupElem{FqFieldElem, FqMatrix}}:\n [3 0; 0 5]\n [6 1; 6 0]\n\njulia> order(special_linear_group(2, residue_ring(ZZ, 6)[1]))\n144\n\n\n\n\n\n","category":"method"},{"location":"Groups/matgroup/#symplectic_group-Tuple{Int64, Ring}","page":"Matrix groups","title":"symplectic_group","text":"symplectic_group(n::Int, q::Int)\nsymplectic_group(n::Int, R::Ring)\nSp = symplectic_group\n\nReturn the symplectic group of dimension n over the ring R respectively the field GF(q). The dimension n must be even.\n\nCurrently R must be either a finite field or a residue ring of prime power order.\n\nExamples\n\njulia> F = GF(7)\nPrime field of characteristic 7\n\njulia> H = symplectic_group(2, F)\nSp(2,7)\n\njulia> gens(H)\n2-element Vector{MatrixGroupElem{FqFieldElem, FqMatrix}}:\n [3 0; 0 5]\n [6 1; 6 0]\n\njulia> order(symplectic_group(2, residue_ring(ZZ, 4)[1]))\n48\n\n\n\n\n\n","category":"method"},{"location":"Groups/matgroup/#orthogonal_group-Tuple{Int64, Int64, Ring}","page":"Matrix groups","title":"orthogonal_group","text":"orthogonal_group(e::Int, n::Int, R::Ring)\northogonal_group(e::Int, n::Int, q::Int)\nGO = orthogonal_group\n\nReturn the orthogonal group of dimension n over the ring R respectively the field GF(q), and of type e, where e in {+1,-1} for n even and e=0 for n odd. If n is odd, e can be omitted.\n\nCurrently R must be either a finite field or a residue ring of odd prime power order.\n\nExamples\n\njulia> F = GF(7)\nPrime field of characteristic 7\n\njulia> H = orthogonal_group(1, 2, F)\nGO+(2,7)\n\njulia> gens(H)\n2-element Vector{MatrixGroupElem{FqFieldElem, FqMatrix}}:\n [3 0; 0 5]\n [0 1; 1 0]\n\njulia> order(orthogonal_group(-1, 2, residue_ring(ZZ, 9)[1]))\n24\n\n\n\n\n\n","category":"method"},{"location":"Groups/matgroup/#special_orthogonal_group-Tuple{Int64, Int64, Ring}","page":"Matrix groups","title":"special_orthogonal_group","text":"special_orthogonal_group(e::Int, n::Int, R::Ring)\nspecial_orthogonal_group(e::Int, n::Int, q::Int)\nSO = special_orthogonal_group\n\nReturn the special orthogonal group of dimension n over the ring R respectively the field GF(q), and of type e, where e in {+1,-1} for n even and e=0 for n odd. If n is odd, e can be omitted.\n\nCurrently R must be either a finite field or a residue ring of odd prime power order.\n\nExamples\n\njulia> F = GF(7)\nPrime field of characteristic 7\n\njulia> H = special_orthogonal_group(1, 2, F)\nSO+(2,7)\n\njulia> gens(H)\n3-element Vector{MatrixGroupElem{FqFieldElem, FqMatrix}}:\n [3 0; 0 5]\n [5 0; 0 3]\n [1 0; 0 1]\n\njulia> order(special_orthogonal_group(-1, 2, residue_ring(ZZ, 9)[1]))\n12\n\n\n\n\n\n","category":"method"},{"location":"Groups/matgroup/#omega_group-Tuple{Int64, Int64, Ring}","page":"Matrix groups","title":"omega_group","text":"omega_group(e::Int, n::Int, R::Ring)\nomega_group(e::Int, n::Int, q::Int)\n\nReturn the Omega group of dimension n over the field GF(q) of type e, where e in {+1,-1} for n even and e=0 for n odd. If n is odd, e can be omitted.\n\nCurrently R must be either a finite field or a residue ring of odd prime power order.\n\nExamples\n\njulia> F = GF(7)\nPrime field of characteristic 7\n\njulia> H = omega_group(1, 2, F)\nOmega+(2,7)\n\njulia> gens(H)\n1-element Vector{MatrixGroupElem{FqFieldElem, FqMatrix}}:\n [2 0; 0 4]\n\njulia> order(omega_group(0, 3, residue_ring(ZZ, 9)[1]))\n324\n\n\n\n\n\n","category":"method"},{"location":"Groups/matgroup/#unitary_group-Tuple{Int64, Int64}","page":"Matrix groups","title":"unitary_group","text":"unitary_group(n::Int, q::Int)\nGU = unitary_group\n\nReturn the unitary group of dimension n over the field GF(q^2).\n\nExamples\n\njulia> H = unitary_group(2,3)\nGU(2,3)\n\njulia> gens(H)\n2-element Vector{MatrixGroupElem{FqFieldElem, FqMatrix}}:\n [o 0; 0 2*o]\n [2 2*o+2; 2*o+2 0]\n\n\n\n\n\n","category":"method"},{"location":"Groups/matgroup/#special_unitary_group-Tuple{Int64, Int64}","page":"Matrix groups","title":"special_unitary_group","text":"special_unitary_group(n::Int, q::Int)\nSU = special_unitary_group\n\nReturn the special unitary group of dimension n over the field with q^2 elements.\n\nExamples\n\njulia> H = special_unitary_group(2,3)\nSU(2,3)\n\njulia> gens(H)\n2-element Vector{MatrixGroupElem{FqFieldElem, FqMatrix}}:\n [1 2*o+2; 0 1]\n [0 2*o+2; 2*o+2 0]\n\n\n\n\n\n","category":"method"},{"location":"TropicalGeometry/semiring/#Tropical-semirings,-matrices,-and-polynomials","page":"Tropical semirings, matrices, and polynomials","title":"Tropical semirings, matrices, and polynomials","text":"","category":"section"},{"location":"TropicalGeometry/semiring/#Introduction","page":"Tropical semirings, matrices, and polynomials","title":"Introduction","text":"","category":"section"},{"location":"TropicalGeometry/semiring/","page":"Tropical semirings, matrices, and polynomials","title":"Tropical semirings, matrices, and polynomials","text":"In OSCAR, the tropical semiring is either","category":"page"},{"location":"TropicalGeometry/semiring/","page":"Tropical semirings, matrices, and polynomials","title":"Tropical semirings, matrices, and polynomials","text":"the min-plus semiring (mathbbQcup+inftyoplusodot) with aoplus b=min(ab) and aodot b=a+b,\nthe max-plus semiring (mathbbQcup-inftyoplusodot) with aoplus b=max(ab) and aodot b=a+b.","category":"page"},{"location":"TropicalGeometry/semiring/","page":"Tropical semirings, matrices, and polynomials","title":"Tropical semirings, matrices, and polynomials","text":"Whereas tropical semirings in [MS15] and [Jos21] are extensions of the real numbers, tropical semirings in OSCAR are an extension of the rational numbers to avoid precision issues.","category":"page"},{"location":"TropicalGeometry/semiring/#Constructor","page":"Tropical semirings, matrices, and polynomials","title":"Constructor","text":"","category":"section"},{"location":"TropicalGeometry/semiring/","page":"Tropical semirings, matrices, and polynomials","title":"Tropical semirings, matrices, and polynomials","text":"Objects of type TropicalSemiring, as well as matrices and polynomials thereover, can be constructed as follows:","category":"page"},{"location":"TropicalGeometry/semiring/","page":"Tropical semirings, matrices, and polynomials","title":"Tropical semirings, matrices, and polynomials","text":"tropical_semiring()","category":"page"},{"location":"TropicalGeometry/semiring/#tropical_semiring-Tuple{}","page":"Tropical semirings, matrices, and polynomials","title":"tropical_semiring","text":"tropical_semiring(M::Union{typeof(min),typeof(max)}=min)\n\nReturn the min-plus (default) or max-plus semiring.\n\nwarning: Warning\n+, *, /, and ^ are used for tropical addition, tropical multipliciation, tropical division, and tropical exponentiation, respectively.\nThere is no additive inverse or subtraction in the tropical semiring. Negating a tropical number or subtracting two tropical numbers will raise an error.\nZeroes of tropical semirings are printed as infty or -infty instead of their proper unicode characters.  To enabled unicode in the current and future sessions, run allow_unicode(true).\n\nExamples (basic arithmetic)\n\njulia> T = tropical_semiring() # = tropical_semiring(min)\nMin tropical semiring\n\njulia> T = tropical_semiring(max)\nMax tropical semiring\n\njulia> 0*T(3) + 1*T(1)^2 + zero(T) # = max(0+3,1+2*1,-∞)\n(3)\n\njulia> T(0) == 0    # checks whether the tropical number is 0\ntrue\n\njulia> iszero(T(0)) # checks whether the tropical number is neutral element of addition\nfalse\n\nExamples (polynomials)\n\njulia> T = tropical_semiring()\nMin tropical semiring\n\njulia> Tx,(x1,x2) = polynomial_ring(T,2)\n(Multivariate polynomial ring in 2 variables over min tropical semiring, AbstractAlgebra.Generic.MPoly{TropicalSemiringElem{typeof(min)}}[x1, x2])\n\njulia> f = x1 + -1*x2 + 0\nx1 + (-1)*x2 + (0)\n\njulia> evaluate(f,T.([-1//2,1//2])) # warning: omitting T() gives an error\n(-1//2)\n\nExamples (matrices)\n\njulia> T = tropical_semiring()\nMin tropical semiring\n\njulia> A = identity_matrix(T, 2) # = tropical identity matrix\n[  (0)   infty]\n[infty     (0)]\n\njulia> 2*A\n[  (2)   infty]\n[infty     (2)]\n\njulia> A*A\n[  (0)   infty]\n[infty     (0)]\n\njulia> det(A)\n(0)\n\njulia> minors(A,1)\n4-element Vector{TropicalSemiringElem{typeof(min)}}:\n (0)\n infty\n infty\n (0)\n\n\n\n\n\n","category":"method"},{"location":"TropicalGeometry/semiring/#Properties","page":"Tropical semirings, matrices, and polynomials","title":"Properties","text":"","category":"section"},{"location":"TropicalGeometry/semiring/","page":"Tropical semirings, matrices, and polynomials","title":"Tropical semirings, matrices, and polynomials","text":"Objects of type TropicalSemiring have the following properties:","category":"page"},{"location":"TropicalGeometry/semiring/","page":"Tropical semirings, matrices, and polynomials","title":"Tropical semirings, matrices, and polynomials","text":"convention(T::TropicalSemiring{typeof(min)})","category":"page"},{"location":"TropicalGeometry/semiring/#convention-Tuple{TropicalSemiring{typeof(min)}}","page":"Tropical semirings, matrices, and polynomials","title":"convention","text":"convention(T::TropicalSemiring)\n\nReturn min if T is the min tropical semiring, return max if T is the max tropical semiring. Works similarly for tropical numbers, tropical vectors and matrices, and tropical polynomials.\n\nExamples\n\njulia> T = tropical_semiring(min)\nMin tropical semiring\n\njulia> convention(T)\nmin (generic function with 27 methods)\n\njulia> T = tropical_semiring(max)\nMax tropical semiring\n\njulia> convention(T)\nmax (generic function with 27 methods)\n\n\n\n\n\n","category":"method"},{"location":"TropicalGeometry/semiring/#Related-functions","page":"Tropical semirings, matrices, and polynomials","title":"Related functions","text":"","category":"section"},{"location":"TropicalGeometry/semiring/","page":"Tropical semirings, matrices, and polynomials","title":"Tropical semirings, matrices, and polynomials","text":"Other functions related to TropicalSemiring, matrices, and polynomials thereover include:","category":"page"},{"location":"TropicalGeometry/semiring/","page":"Tropical semirings, matrices, and polynomials","title":"Tropical semirings, matrices, and polynomials","text":"det(A::AbstractAlgebra.Generic.MatSpaceElem{<: Oscar.TropicalSemiringElem})\ntropical_polynomial(f::MPolyRingElem, nu::TropicalSemiringMap)","category":"page"},{"location":"TropicalGeometry/semiring/#det-Tuple{AbstractAlgebra.Generic.MatSpaceElem{<:TropicalSemiringElem}}","page":"Tropical semirings, matrices, and polynomials","title":"det","text":"det(M::MatrixElem{T}) where {T <: RingElement}\n\nReturn the determinant of the matrix M. We assume M is square.\n\nExamples\n\njulia> R, x = polynomial_ring(QQ, :x)\n(Univariate polynomial ring in x over rationals, x)\n\njulia> A = R[x 1; 1 x^2];\n\njulia> d = det(A)\nx^3 - 1\n\n\n\n\n\ndet(A::MatrixElem{<: TropicalSemiringElem})\n\nReturn the tropical determinant of A.  That is, this function evaluates the tropicalization of the ordinary determinant considered as a multivariate polynomial at A.\n\nThat computation is equivalent to solving a linear assignment problem from combinatorial optimization.  The implementation employs the Hungarian method, which is polynomial time.  See Chapter 3 in [Jos21].\n\nnote: Note\nThis function effectively overwrites the det command for tropical matrices.  This means that functions like minors will use the tropical determinant when used on a tropical matrix.\n\nExamples\n\njulia> A = matrix(tropical_semiring(),[1 2; 3 4])\n[(1)   (2)]\n[(3)   (4)]\n\njulia> det(A)\n(5)\n\n\n\n\n\n","category":"method"},{"location":"TropicalGeometry/semiring/#tropical_polynomial-Tuple{MPolyRingElem, TropicalSemiringMap}","page":"Tropical semirings, matrices, and polynomials","title":"tropical_polynomial","text":"tropical_polynomial(f::Union{<:MPolyRingElem,<:PolyRingElem},nu::TropicalSemiringMap)\n\nGiven a polynomial f and a tropical semiring map nu, return the tropicalization of f as a polynomial over the tropical semiring.\n\nExamples\n\njulia> R, (x,y) = polynomial_ring(QQ,[:x, :y])\n(Multivariate polynomial ring in 2 variables over QQ, QQMPolyRingElem[x, y])\n\njulia> nu = tropical_semiring_map(QQ,7)\nMap into Min tropical semiring encoding the 7-adic valuation on Rational field\n\njulia> f = 7*x+y+49\n7*x + y + 49\n\njulia> tropical_polynomial(f,nu)\n(1)*x + y + (2)\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/elliptic_curves/finite_fields/#Elliptic-curves-over-finite-fields","page":"Elliptic curves over finite fields","title":"Elliptic curves over finite fields","text":"","category":"section"},{"location":"Hecke/manual/elliptic_curves/finite_fields/","page":"Elliptic curves over finite fields","title":"Elliptic curves over finite fields","text":"CurrentModule = Hecke\nDocTestSetup = quote\n    using Hecke\nend","category":"page"},{"location":"Hecke/manual/elliptic_curves/finite_fields/#Random-points","page":"Elliptic curves over finite fields","title":"Random points","text":"","category":"section"},{"location":"Hecke/manual/elliptic_curves/finite_fields/","page":"Elliptic curves over finite fields","title":"Elliptic curves over finite fields","text":"  rand(E::EllipticCurve{<: FinFieldElem})","category":"page"},{"location":"Hecke/manual/elliptic_curves/finite_fields/","page":"Elliptic curves over finite fields","title":"Elliptic curves over finite fields","text":"Return a random point on the elliptic curve E defined over a finite field.","category":"page"},{"location":"Hecke/manual/elliptic_curves/finite_fields/","page":"Elliptic curves over finite fields","title":"Elliptic curves over finite fields","text":"julia> E = elliptic_curve(GF(3), [1, 2]);\n\njulia> rand(E)\nPoint  (2 : 0 : 1)  of Elliptic curve with equation\ny^2 = x^3 + x + 2","category":"page"},{"location":"Hecke/manual/elliptic_curves/finite_fields/#Cardinality-and-orders","page":"Elliptic curves over finite fields","title":"Cardinality and orders","text":"","category":"section"},{"location":"Hecke/manual/elliptic_curves/finite_fields/","page":"Elliptic curves over finite fields","title":"Elliptic curves over finite fields","text":"order(::EllipticCurve{<:FinFieldElem})\norder(::EllipticCurvePoint{<:FinFieldElem})","category":"page"},{"location":"Hecke/manual/elliptic_curves/finite_fields/#order-Tuple{EllipticCurve{<:FinFieldElem}}","page":"Elliptic curves over finite fields","title":"order","text":"order(::Type{T} = BigInt, G::Group) where T\n\nReturn the order of G as an instance of T. If G is of infinite order, an InfiniteOrderError exception will be thrown. Use is_finite(G) to avoid this kind of exception. If the order does not fit into type T, an InexactError exception will be thrown.\n\n\n\n\n\norder(::Type{T} = BigInt, g::GroupElem) where T\n\nReturn the order of g as an instance of T. If g is of infinite order, an InfiniteOrderError exception will be thrown. Use is_finite_order(G) to avoid this kind of exception. If the order does not fit into type T, an InexactError exception will be thrown.\n\n\n\n\n\norder(E::EllipticCurve{<: FinFieldElem}) -> ZZRingElem\n\nGiven an elliptic curve E over a finite field mathbf F, compute E(mathbf F).\n\nExamples\n\njulia> E = elliptic_curve(GF(101), [1, 2]);\n\njulia> order(E)\n100\n\n\n\n\n\norder(::Type{T} = ZZRingElem, c::CycleType) where T <: IntegerUnion\n\nReturn the order of the permutations with cycle structure c.\n\nExamples\n\njulia> g = symmetric_group(3);\n\njulia> all(x -> order(cycle_structure(x)) == order(x), gens(g))\ntrue\n\n\n\n\n\norder(W::WeylGroup) -> ZZRingELem\norder(::Type{T}, W::WeylGroup) where {T} -> T\n\nReturn the order of W.\n\nIf W is infinite, an InfiniteOrderError exception will be thrown.\n\nwarning: Experimental\nThis function is part of the experimental code in Oscar. Please read here for more details.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/elliptic_curves/finite_fields/#order-Tuple{EllipticCurvePoint{<:FinFieldElem}}","page":"Elliptic curves over finite fields","title":"order","text":"order(::Type{T} = BigInt, G::Group) where T\n\nReturn the order of G as an instance of T. If G is of infinite order, an InfiniteOrderError exception will be thrown. Use is_finite(G) to avoid this kind of exception. If the order does not fit into type T, an InexactError exception will be thrown.\n\n\n\n\n\norder(::Type{T} = BigInt, g::GroupElem) where T\n\nReturn the order of g as an instance of T. If g is of infinite order, an InfiniteOrderError exception will be thrown. Use is_finite_order(G) to avoid this kind of exception. If the order does not fit into type T, an InexactError exception will be thrown.\n\n\n\n\n\norder(P::EllipticCurvePoint, [fac::Fac{ZZRingElem}]) -> ZZRingElem\n\nGiven a point P on an elliptic curve E over a finite field, return the order of this point.\n\nOptionally, one can supply the factorization of a multiple of the point order, for example the order of E.\n\nExamples\n\njulia> E = elliptic_curve(GF(101), [1, 2]);\n\njulia> P = E([17, 65]);\n\njulia> order(P)\n100\n\njulia> fac = factor(order(E))\n1 * 5^2 * 2^2\n\njulia> order(P, fac)\n100\n\n\n\n\n\norder(::Type{T} = ZZRingElem, c::CycleType) where T <: IntegerUnion\n\nReturn the order of the permutations with cycle structure c.\n\nExamples\n\njulia> g = symmetric_group(3);\n\njulia> all(x -> order(cycle_structure(x)) == order(x), gens(g))\ntrue\n\n\n\n\n\norder(W::WeylGroup) -> ZZRingELem\norder(::Type{T}, W::WeylGroup) where {T} -> T\n\nReturn the order of W.\n\nIf W is infinite, an InfiniteOrderError exception will be thrown.\n\nwarning: Experimental\nThis function is part of the experimental code in Oscar. Please read here for more details.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/elliptic_curves/finite_fields/#Frobenius","page":"Elliptic curves over finite fields","title":"Frobenius","text":"","category":"section"},{"location":"Hecke/manual/elliptic_curves/finite_fields/","page":"Elliptic curves over finite fields","title":"Elliptic curves over finite fields","text":"trace_of_frobenius(::EllipticCurve{<:FinFieldElem})\ntrace_of_frobenius(::EllipticCurve{<:FinFieldElem}, ::Int)","category":"page"},{"location":"Hecke/manual/elliptic_curves/finite_fields/#trace_of_frobenius-Tuple{EllipticCurve{<:FinFieldElem}}","page":"Elliptic curves over finite fields","title":"trace_of_frobenius","text":"trace_of_frobenius(E::EllipticCurve{FinFieldElem}) -> Int\n\nReturn the trace of the Frobenius endomorphism on the elliptic curve E over mathbfF_q. This is equal to q + 1 - n where n is the number of points on E over mathbfF_q.\n\nExamples\n\njulia> E = elliptic_curve(GF(101), [1, 2]);\n\njulia> trace_of_frobenius(E) == 101 + 1 - order(E)\ntrue\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/elliptic_curves/finite_fields/#trace_of_frobenius-Tuple{EllipticCurve{<:FinFieldElem}, Int64}","page":"Elliptic curves over finite fields","title":"trace_of_frobenius","text":"trace_of_frobenius(E::EllipticCurve{<: FinFieldElem}, r::Int) -> ZZRingElem\n\nReturn the trace of the r-th power of the Frobenius endomorphism on the elliptic curve E.\n\njulia> E = elliptic_curve(GF(101, 2), [1, 2]);\n\njulia> trace_of_frobenius(E, 2)\n18802\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/elliptic_curves/finite_fields/#Group-structure-of-rational-points","page":"Elliptic curves over finite fields","title":"Group structure of rational points","text":"","category":"section"},{"location":"Hecke/manual/elliptic_curves/finite_fields/","page":"Elliptic curves over finite fields","title":"Elliptic curves over finite fields","text":"gens(::EllipticCurve{T}) where {T <: FinFieldElem}\nabelian_group(::EllipticCurve{<:FinFieldElem})","category":"page"},{"location":"Hecke/manual/elliptic_curves/finite_fields/#gens-Union{Tuple{EllipticCurve{T}}, Tuple{T}} where T<:FinFieldElem","page":"Elliptic curves over finite fields","title":"gens","text":"gens(E::EllipticCurve{<:FinFieldElem}) -> Vector{EllipticCurvePoint}\n\nReturn a list of generators of the group of rational points on E.\n\nExamples\n\njulia> E = elliptic_curve(GF(101, 2), [1, 2]);\n\njulia> gens(E)\n2-element Vector{EllipticCurvePoint{FqFieldElem}}:\n Point  (16*o + 42 : 88*o + 97 : 1)  of Elliptic curve with equation\ny^2 = x^3 + x + 2\n Point  (88*o + 23 : 94*o + 22 : 1)  of Elliptic curve with equation\ny^2 = x^3 + x + 2\n\njulia> E = elliptic_curve(GF(101), [1, 2]);\n\njulia> gens(E)\n1-element Vector{EllipticCurvePoint{FqFieldElem}}:\n Point  (85 : 58 : 1)  of Elliptic curve with equation\ny^2 = x^3 + x + 2\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/elliptic_curves/finite_fields/#abelian_group-Tuple{EllipticCurve{<:FinFieldElem}}","page":"Elliptic curves over finite fields","title":"abelian_group","text":"abelian_group(E::EllipticCurve{<:FinFieldElem}) -> FinGenAbGroup, Map\n\nReturn an abelian group A isomorphic to the group of rational points of E and a map E to A.\n\nwarning: Warning\nThe map is not implemented yet.\n\njulia> E = elliptic_curve(GF(101, 2), [1, 2]);\n\njulia> A, _ = abelian_group(E);\n\njulia> A\nZ/2 x Z/5200\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/elliptic_curves/finite_fields/#Discrete-logarithm","page":"Elliptic curves over finite fields","title":"Discrete logarithm","text":"","category":"section"},{"location":"Hecke/manual/elliptic_curves/finite_fields/","page":"Elliptic curves over finite fields","title":"Elliptic curves over finite fields","text":"disc_log(::EllipticCurvePoint, ::EllipticCurvePoint)","category":"page"},{"location":"Hecke/manual/elliptic_curves/finite_fields/#disc_log-Tuple{EllipticCurvePoint, EllipticCurvePoint}","page":"Elliptic curves over finite fields","title":"disc_log","text":"disc_log(P::EllipticCurvePoint, Q::EllipticCurvePoint, [n::IntegerUnion]) -> ZZRingElem\n\nReturn the discrete logarithm m of Q with respect to the base P, that is, mP = Q.\n\nIf a multiple n of the order of P is known, this can be supplied as an optional argument.\n\njulia> E = elliptic_curve(GF(101), [1, 2]);\n\njulia> P = E([6, 74])\nPoint  (6 : 74 : 1)  of Elliptic curve with equation\ny^2 = x^3 + x + 2\n\njulia> Q = E([85, 43])\nPoint  (85 : 43 : 1)  of Elliptic curve with equation\ny^2 = x^3 + x + 2\n\njulia> disc_log(P, Q)\n13\n\n\n\n\n\n","category":"method"},{"location":"Groups/recog/","page":"Group recognition","title":"Group recognition","text":"CurrentModule = Oscar\nDocTestSetup = Oscar.doctestsetup()","category":"page"},{"location":"Groups/recog/#Group-recognition","page":"Group recognition","title":"Group recognition","text":"","category":"section"},{"location":"Groups/recog/","page":"Group recognition","title":"Group recognition","text":"The idea of constructive group recognition is to compute a recognition tree for a given (permutation or matrix) group, which describes the structure of this group in a recursive way: Each non-leaf node of the tree describes an epimorphism such that the kernel and the image belong to the two subtrees of the node. Each leaf node describes a group for which efficient methods are available that allow one to decide whether a group element is an element of this group, and if yes to write the element as a word in terms of suitable generators.","category":"page"},{"location":"Groups/recog/","page":"Group recognition","title":"Group recognition","text":"The recognition tree has enough information to decide whether a group element is an element of the given group, and if yes to write the element as a word in terms of suitable generators of the given group.","category":"page"},{"location":"Groups/recog/","page":"Group recognition","title":"Group recognition","text":"recognize\nis_ready\nnice_gens\nstraight_line_program(tree::GroupRecognitionTree, g::GAPGroupElem)","category":"page"},{"location":"Groups/recog/#recognize","page":"Group recognition","title":"recognize","text":"recognize(G::Union{PermGroup, MatrixGroup})\n\nReturn a GroupRecognitionTree object that describes the structure of G in a recursive way. If the recognition was successful (see is_ready) then the result provides a membership test that is usually more efficient than the membership test without the recognition information.\n\nExamples\n\njulia> recognize(symmetric_group(5))\nRecognition tree: MovesOnlySmallPoints Size=120\n\njulia> g = general_linear_group(4, 9);\n\njulia> s = sub(g, [rand(g), rand(g)])[1];\n\njulia> rec = recognize(s);  is_ready(rec)\ntrue\n\njulia> rand(s) in rec\ntrue\n\n\n\n\n\n","category":"function"},{"location":"Groups/recog/#is_ready","page":"Group recognition","title":"is_ready","text":"is_ready(tree::GroupRecognitionTree)\n\nReturn true if the recognition procedure for the group of tree was successful, and false otherwise.\n\nExamples\n\njulia> rec = recognize(GL(4, 2));  is_ready(rec)\ntrue\n\n\n\n\n\n","category":"function"},{"location":"Groups/recog/#nice_gens","page":"Group recognition","title":"nice_gens","text":"nice_gens(tree::GroupRecognitionTree)\n\nReturn the vector of generators of the group of tree w.r.t. which the straight line programs for group elements computed by straight_line_program are written.\n\nExamples\n\njulia> rec = recognize(GL(4, 2));  is_ready(rec)\ntrue\n\njulia> x = rand(group(rec));\n\njulia> slp = straight_line_program(rec, x);\n\njulia> evaluate(slp, nice_gens(rec)) == x\ntrue\n\n\n\n\n\n","category":"function"},{"location":"Groups/recog/#straight_line_program-Tuple{Oscar.GroupRecognitionTree, GAPGroupElem}","page":"Group recognition","title":"straight_line_program","text":"straight_line_program(tree::GroupRecognitionTree, g::GAPGroupElem)\n\nReturn a straight line program for the element g of the group of tree. The inputs of this program correspond to nice_gens(tree), see nice_gens for an example.\n\n\n\n\n\n","category":"method"},{"location":"AlgebraicGeometry/ToricVarieties/ToricSchemes/","page":"Toric Schemes","title":"Toric Schemes","text":"CurrentModule = Oscar","category":"page"},{"location":"AlgebraicGeometry/ToricVarieties/ToricSchemes/#Toric-Schemes","page":"Toric Schemes","title":"Toric Schemes","text":"","category":"section"},{"location":"AlgebraicGeometry/ToricVarieties/ToricSchemes/","page":"Toric Schemes","title":"Toric Schemes","text":"Toric varieties are special instances of schemes. As such, all scheme functionality is available to toric varieties.","category":"page"},{"location":"AlgebraicGeometry/ToricVarieties/ToricSchemes/#Content","page":"Toric Schemes","title":"Content","text":"","category":"section"},{"location":"AlgebraicGeometry/ToricVarieties/ToricSchemes/","page":"Toric Schemes","title":"Toric Schemes","text":"We aim for a seamless transition among toric varieties and covered schemes.","category":"page"},{"location":"AlgebraicGeometry/ToricVarieties/ToricSchemes/","page":"Toric Schemes","title":"Toric Schemes","text":"One advantage is that we can hope for improved performance of scheme functionality by using toric backends when applicable. In addition, one can apply powerful scheme computations to toric settings, thus extending the available toolkit significantly.","category":"page"},{"location":"AlgebraicGeometry/ToricVarieties/ToricSchemes/","page":"Toric Schemes","title":"Toric Schemes","text":"The user can extract the scheme corresponding to a toric variety as follows:","category":"page"},{"location":"AlgebraicGeometry/ToricVarieties/ToricSchemes/","page":"Toric Schemes","title":"Toric Schemes","text":"underlying_scheme(X::AffineNormalToricVariety)\nunderlying_scheme(X::NormalToricVariety)","category":"page"},{"location":"AlgebraicGeometry/ToricVarieties/ToricSchemes/#underlying_scheme-Tuple{AffineNormalToricVariety}","page":"Toric Schemes","title":"underlying_scheme","text":"underlying_scheme(X::AffineNormalToricVariety)\n\nFor an affine toric scheme X, this returns the underlying scheme. In other words, by applying this method, you obtain a scheme that has forgotten its toric origin.\n\nExamples\n\njulia> C = positive_hull([1 0; 0 1])\nPolyhedral cone in ambient dimension 2\n\njulia> antv = affine_normal_toric_variety(C)\nNormal toric variety\n\njulia> Oscar.underlying_scheme(antv)\nSpectrum\n  of quotient\n    of multivariate polynomial ring in 2 variables x1, x2\n      over rational field\n    by ideal (0)\n\n\n\n\n\n","category":"method"},{"location":"AlgebraicGeometry/ToricVarieties/ToricSchemes/#underlying_scheme-Tuple{NormalToricVariety}","page":"Toric Schemes","title":"underlying_scheme","text":"underlying_scheme(X::NormalToricVariety)\n\nFor a toric covered scheme X, this returns the underlying scheme. In other words, by applying this method, you obtain a scheme that has forgotten its toric origin.\n\nExamples\n\njulia> P2 = projective_space(NormalToricVariety, 2)\nNormal toric variety\n\njulia> Oscar.underlying_scheme(P2)\nScheme\n  over rational field\nwith default covering\n  described by patches\n    1: normal toric variety\n    2: normal toric variety\n    3: normal toric variety\n  in the coordinate(s)\n    1: [x_1_1, x_2_1]\n    2: [x_1_2, x_2_2]\n    3: [x_1_3, x_2_3]\n\n\n\n\n\n","category":"method"},{"location":"AlgebraicGeometry/ToricVarieties/ToricSchemes/","page":"Toric Schemes","title":"Toric Schemes","text":"We also provide functionality to forget the toric structure completely. In this sense, the following methods return the underlying covered scheme, but this scheme does not remember being a toric variety.","category":"page"},{"location":"AlgebraicGeometry/ToricVarieties/ToricSchemes/","page":"Toric Schemes","title":"Toric Schemes","text":"forget_toric_structure(X::AffineNormalToricVariety)\nforget_toric_structure(X::NormalToricVariety)","category":"page"},{"location":"AlgebraicGeometry/ToricVarieties/ToricSchemes/#forget_toric_structure-Tuple{AffineNormalToricVariety}","page":"Toric Schemes","title":"forget_toric_structure","text":"forget_toric_structure(X::AffineNormalToricVariety)\n\nReturn a pair (Y, iso) where Y is a scheme without toric structure, together with an isomorphism iso : Y → X.\n\nExamples\n\njulia> C = positive_hull([1 0; 0 1])\nPolyhedral cone in ambient dimension 2\n\njulia> antv = affine_normal_toric_variety(C)\nNormal toric variety\n\njulia> forget_toric_structure(antv)\n(scheme(0), Hom: scheme(0) -> normal toric variety)\n\n\n\n\n\n","category":"method"},{"location":"AlgebraicGeometry/ToricVarieties/ToricSchemes/#forget_toric_structure-Tuple{NormalToricVariety}","page":"Toric Schemes","title":"forget_toric_structure","text":"forget_toric_structure(X::NormalToricVariety)\n\nReturn a pair (Y, iso) where Y is a scheme without toric structure, together with an isomorphism iso : Y → X.\n\nExamples\n\njulia> P2 = projective_space(NormalToricVariety, 2)\nNormal toric variety\n\njulia> forget_toric_structure(P2)\n(Scheme over QQ covered with 3 patches, Hom: scheme over QQ covered with 3 patches -> normal toric variety)\n\n\n\n\n\n","category":"method"},{"location":"AlgebraicGeometry/ToricVarieties/ToricSchemes/#Contact","page":"Toric Schemes","title":"Contact","text":"","category":"section"},{"location":"AlgebraicGeometry/ToricVarieties/ToricSchemes/","page":"Toric Schemes","title":"Toric Schemes","text":"Please direct questions about this part of OSCAR to the following people:","category":"page"},{"location":"AlgebraicGeometry/ToricVarieties/ToricSchemes/","page":"Toric Schemes","title":"Toric Schemes","text":"Martin Bies,\nMatthias Zach.","category":"page"},{"location":"AlgebraicGeometry/ToricVarieties/ToricSchemes/","page":"Toric Schemes","title":"Toric Schemes","text":"You can ask questions in the OSCAR Slack.","category":"page"},{"location":"AlgebraicGeometry/ToricVarieties/ToricSchemes/","page":"Toric Schemes","title":"Toric Schemes","text":"Alternatively, you can raise an issue on github.","category":"page"},{"location":"AlgebraicGeometry/Schemes/GeneralSchemes/","page":"General schemes","title":"General schemes","text":"CurrentModule = Oscar","category":"page"},{"location":"AlgebraicGeometry/Schemes/GeneralSchemes/#General-schemes","page":"General schemes","title":"General schemes","text":"","category":"section"},{"location":"AlgebraicGeometry/Schemes/GeneralSchemes/","page":"General schemes","title":"General schemes","text":"Arbitrary schemes over a commutative base ring mathbb k with unit  are instances of the abstract type","category":"page"},{"location":"AlgebraicGeometry/Schemes/GeneralSchemes/","page":"General schemes","title":"General schemes","text":"Scheme{BaseRingType<:Ring}","category":"page"},{"location":"AlgebraicGeometry/Schemes/GeneralSchemes/#Scheme","page":"General schemes","title":"Scheme","text":"Scheme{BaseRingType<:Ring}\n\nA scheme over a ring 𝕜 of type BaseRingType.\n\n\n\n\n\n","category":"type"},{"location":"AlgebraicGeometry/Schemes/GeneralSchemes/","page":"General schemes","title":"General schemes","text":"Morphisms of schemes shall be derived from the abstract type","category":"page"},{"location":"AlgebraicGeometry/Schemes/GeneralSchemes/","page":"General schemes","title":"General schemes","text":"SchemeMor{DomainType, CodomainType, MorphismType, BaseMorType}","category":"page"},{"location":"AlgebraicGeometry/Schemes/GeneralSchemes/#SchemeMor","page":"General schemes","title":"SchemeMor","text":"SchemeMor{DomainType, CodomainType, MorphismType, BaseMorType}\n\nA morphism of schemes f  X  Y of type MorphismType with X of type DomainType and Y of type CodomainType.\n\nWhen X and Y are defined over schemes BX and BY other than Spec(𝕜), BaseMorType is the type of the underlying morphism BX  BY; otherwise, it can be set to Nothing.\n\n\n\n\n\n","category":"type"},{"location":"AlgebraicGeometry/Schemes/GeneralSchemes/#Change-of-base","page":"General schemes","title":"Change of base","text":"","category":"section"},{"location":"AlgebraicGeometry/Schemes/GeneralSchemes/","page":"General schemes","title":"General schemes","text":"base_change(phi::Any, X::Scheme)\nbase_change(phi::Any, f::SchemeMor;\n    domain_map::AbsSchemeMor, codomain_map::AbsSchemeMor\n    )","category":"page"},{"location":"AlgebraicGeometry/Schemes/GeneralSchemes/#base_change-Tuple{Any, Scheme}","page":"General schemes","title":"base_change","text":"base_change(phi::Any, X::Scheme)\n\nFor a Scheme X over a base_ring 𝕜 and a map φ  𝕜  R  we compute X = X ₖ Spec(R) and return a pair (X', f) where  f  X  X is the canonical morphism.\n\nnote: Note\nWe do not restrict phi to be of type Map so that one can also use coercion, anonymous functions, etc. \n\n\n\n\n\n","category":"method"},{"location":"AlgebraicGeometry/Schemes/GeneralSchemes/#base_change-Tuple{Any, SchemeMor}","page":"General schemes","title":"base_change","text":"base_change(phi::Any, f::SchemeMor;\n    domain_map::SchemeMor, codomain_map::SchemeMor\n  )\n\nFor a morphism f  X  Y with both X and Y defined over a  base_ring 𝕜 and a map φ  𝕜  R return a triple (a, F, b)  where a  X  X is the morphism from base_change(phi, X),  b  Y  Y the one for Y, and F  X  Y the induced  morphism on those fiber products.\n\nnote: Note\nWe do not restrict phi to be of type Map so that one can also use coercion, anonymous functions, etc. \n\nnote: Note\nThe morphisms a and b can be passed as the optional arguments domain_map and codomain_map, respectively. \n\n\n\n\n\n","category":"method"},{"location":"Nemo/series/","page":"Power series and Laurent series","title":"Power series and Laurent series","text":"CurrentModule = Nemo\nDocTestSetup = quote\n    using Nemo\nend","category":"page"},{"location":"Nemo/series/#Power-series-and-Laurent-series","page":"Power series and Laurent series","title":"Power series and Laurent series","text":"","category":"section"},{"location":"Nemo/series/","page":"Power series and Laurent series","title":"Power series and Laurent series","text":"Nemo allows the creation of capped relative and absolute power series over any computable ring R. Capped relative power series are power series of the form a_jx^j + a_j+1x^j+1 + cdots + a_k-1x^k-1 + O(x^k) where j geq 0, a_j in R and the relative precision k - j is at most equal to some specified precision n. On the other hand capped absolute power series are power series of the form a_jx^j + a_j+1x^j+1 + cdots + a_n-1x^n-1 + O(x^n) where j geq 0, a_j in R and the precision n is fixed.","category":"page"},{"location":"Nemo/series/","page":"Power series and Laurent series","title":"Power series and Laurent series","text":"There are two different kinds of implementation: a generic one for the case where no specific implementation exists (provided by AbstractAlgebra.jl), and efficient implementations of power series over numerous specific rings, usually provided by C/C++ libraries.","category":"page"},{"location":"Nemo/series/","page":"Power series and Laurent series","title":"Power series and Laurent series","text":"The following table shows each of the relative power series types available in Nemo, the base ring R, and the Julia/Nemo types for that kind of series (the type information is mainly of concern to developers).","category":"page"},{"location":"Nemo/series/","page":"Power series and Laurent series","title":"Power series and Laurent series","text":"Base ring Library Element type Parent type\nGeneric ring R AbstractAlgebra.jl `Generic.RelSeries{T} Generic.RelPowerSeriesRing{T}\nmathbbZ Flint ZZRelPowerSeriesRingElem ZZRelPowerSeriesRing\nmathbbZnmathbbZ (small n) Flint zzModRelPowerSeriesRingElem zzModRelPowerSeriesRing\nmathbbZnmathbbZ (large n) Flint ZZModRelPowerSeriesRingElem ZZModRelPowerSeriesRing\nmathbbQ Flint QQRelPowerSeriesRingElem QQRelPowerSeriesRing\nmathbbF_p (small n) Flint fpRelPowerSeriesRingElem fpRelPowerSeriesRing\nmathbbF_p (large n) Flint FpRelPowerSeriesRingElem FpRelPowerSeriesRing\nmathbbF_p^n (small p) Flint fqPolyRepRelPowerSeriesRingElem fqPolyRepRelPowerSeriesRing\nmathbbF_p^n (large p) Flint FqPolyRepRelPowerSeriesRingElem FqPolyRepRelPowerSeriesRing","category":"page"},{"location":"Nemo/series/","page":"Power series and Laurent series","title":"Power series and Laurent series","text":"All relative power series elements belong to the abstract type RelPowerSeriesRingElem and all of the relative power series ring types belong to the abstract type RelPowerSeriesRing.","category":"page"},{"location":"Nemo/series/","page":"Power series and Laurent series","title":"Power series and Laurent series","text":"The maximum relative precision, the string representation of the variable and the base ring R of a generic power series are stored in its parent object. ","category":"page"},{"location":"Nemo/series/","page":"Power series and Laurent series","title":"Power series and Laurent series","text":"Here is the corresponding table for the absolute power series types.","category":"page"},{"location":"Nemo/series/","page":"Power series and Laurent series","title":"Power series and Laurent series","text":"Base ring Library Element type Parent type\nGeneric ring R AbstractAlgebra.jl Generic.AbsSeries{T} Generic.AbsPowerSeriesRing{T}\nmathbbZ Flint ZZAbsPowerSeriesRingElem ZZAbsPowerSeriesRing\nmathbbZnmathbbZ (small n) Flint zzModAbsPowerSeriesRingElem zzModAbsPowerSeriesRing\nmathbbZnmathbbZ (large n) Flint ZZModAbsPowerSeriesRingElem ZZModAbsPowerSeriesRing\nmathbbQ Flint QQAbsPowerSeriesRingElem QQAbsPowerSeriesRing\nmathbbF_p (small n) Flint fpAbsPowerSeriesRingElem fpAbsPowerSeriesRing\nmathbbF_p (large n) Flint FpAbsPowerSeriesRingElem FpAbsPowerSeriesRing\nmathbbF_p^n (small n) Flint fqPolyRepAbsPowerSeriesRingElem fqPolyRepAbsPowerSeriesRing\nmathbbF_p^n (large n) Flint FqPolyRepAbsPowerSeriesRingElem FqPolyRepAbsPowerSeriesRing","category":"page"},{"location":"Nemo/series/","page":"Power series and Laurent series","title":"Power series and Laurent series","text":"All absolute power series elements belong to the abstract type AbsPowerSeriesRingElem and all of the absolute power series ring types belong to the abstract type AbsPowerSeriesRing.","category":"page"},{"location":"Nemo/series/","page":"Power series and Laurent series","title":"Power series and Laurent series","text":"The absolute precision, the string representation of the variable and the base ring R of a generic power series are stored in its parent object. ","category":"page"},{"location":"Nemo/series/","page":"Power series and Laurent series","title":"Power series and Laurent series","text":"All power series element types belong to the abstract type SeriesElem and all of the power series ring types belong to the abstract type SeriesRing. This enables one to write generic functions that can accept any Nemo power series type.","category":"page"},{"location":"Nemo/series/","page":"Power series and Laurent series","title":"Power series and Laurent series","text":"AbstractAlgebra.jl also provides Nemo with a generic implementation of Laurent series over a given ring R. For completeness, we list it here.","category":"page"},{"location":"Nemo/series/","page":"Power series and Laurent series","title":"Power series and Laurent series","text":"Base ring Library Element type Parent type\nGeneric ring R AbstractAlgebra.jl Generic.LaurentSeriesRingElem{T} Generic.LaurentSeriesRing{T}\nGeneric field K AbstractAlgebra.jl Generic.LaurentSeriesFieldElem{T} Generic.LaurentSeriesField{T}","category":"page"},{"location":"Nemo/series/#Capped-relative-power-series","page":"Power series and Laurent series","title":"Capped relative power series","text":"","category":"section"},{"location":"Nemo/series/","page":"Power series and Laurent series","title":"Power series and Laurent series","text":"Capped relative power series have their maximum relative precision capped at some value prec_max. This means that if the leading term of a nonzero power series element is c_ax^a and the precision is b then the power series is of the form  c_ax^a + c_a+1x^a+1 + ldots + O(x^a + b).","category":"page"},{"location":"Nemo/series/","page":"Power series and Laurent series","title":"Power series and Laurent series","text":"The zero power series is simply taken to be 0 + O(x^b).","category":"page"},{"location":"Nemo/series/","page":"Power series and Laurent series","title":"Power series and Laurent series","text":"The capped relative model has the advantage that power series are stable multiplicatively. In other words, for nonzero power series f and g we have that divexact(f*g), g) == f.","category":"page"},{"location":"Nemo/series/","page":"Power series and Laurent series","title":"Power series and Laurent series","text":"However, capped relative power series are not additively stable, i.e. we do not always have (f + g) - g = f.","category":"page"},{"location":"Nemo/series/","page":"Power series and Laurent series","title":"Power series and Laurent series","text":"In the capped relative model we say that two power series are equal if they agree up to the minimum absolute precision of the two power series. Thus, for example, x^5 + O(x^10) == 0 + O(x^5), since the minimum absolute precision is 5.","category":"page"},{"location":"Nemo/series/","page":"Power series and Laurent series","title":"Power series and Laurent series","text":"During computations, it is possible for power series to lose relative precision due to cancellation. For example if f = x^3 + x^5 + O(x^8) and g = x^3 + x^6 + O(x^8) then f - g = x^5 - x^6 + O(x^8) which now has relative precision 3 instead of relative precision 5.","category":"page"},{"location":"Nemo/series/","page":"Power series and Laurent series","title":"Power series and Laurent series","text":"Amongst other things, this means that equality is not transitive. For example x^6 + O(x^11) == 0 + O(x^5) and x^7 + O(x^12) == 0 + O(x^5) but x^6 + O(x^11) neq x^7 + O(x^12).","category":"page"},{"location":"Nemo/series/","page":"Power series and Laurent series","title":"Power series and Laurent series","text":"Sometimes it is necessary to compare power series not just for arithmetic equality, as above, but to see if they have precisely the same precision and terms. For this purpose we introduce the isequal function.","category":"page"},{"location":"Nemo/series/","page":"Power series and Laurent series","title":"Power series and Laurent series","text":"For example, if f = x^2 + O(x^7) and g = x^2 + O(x^8) and h = 0 + O(x^2) then f == g, f == h and g == h, but isequal(f, g), isequal(f, h) and isequal(g, h) would all return false. However, if k = x^2 + O(x^7) then isequal(f, k) would return true.","category":"page"},{"location":"Nemo/series/","page":"Power series and Laurent series","title":"Power series and Laurent series","text":"There are further difficulties if we construct polynomial over power series. For example, consider the polynomial in y over the power series ring in x over the rationals. Normalisation of such polynomials is problematic. For instance, what is the leading coefficient of (0 + O(x^10))y + (1 + O(x^10))?","category":"page"},{"location":"Nemo/series/","page":"Power series and Laurent series","title":"Power series and Laurent series","text":"If one takes it to be (0 + O(x^10)) then some functions may not terminate due to the fact that algorithms may require the degree of polynomials to decrease with each iteration. Instead, the degree may remain constant and simply accumulate leading terms which are arithmetically zero but not identically zero.","category":"page"},{"location":"Nemo/series/","page":"Power series and Laurent series","title":"Power series and Laurent series","text":"On the other hand, when constructing power series over other power series, if we simply throw away terms which are arithmetically equal to zero, our computations may have different output depending on the order in which the power series are added!","category":"page"},{"location":"Nemo/series/","page":"Power series and Laurent series","title":"Power series and Laurent series","text":"One should be aware of these difficulties when working with power series. Power series, as represented on a computer, simply don't satisfy the axioms of a ring. They must be used with care in order to approximate operations in a mathematical power series ring.","category":"page"},{"location":"Nemo/series/","page":"Power series and Laurent series","title":"Power series and Laurent series","text":"Simply increasing the precision will not necessarily give a \"more correct\" answer and some computations may not even terminate due to the presence of arithmetic zeroes!","category":"page"},{"location":"Nemo/series/#Capped-absolute-power-series","page":"Power series and Laurent series","title":"Capped absolute power series","text":"","category":"section"},{"location":"Nemo/series/","page":"Power series and Laurent series","title":"Power series and Laurent series","text":"An absolute power series ring over a ring R with precision p behaves  very much like the quotient Rx(x^p) of the polynomial ring over R.","category":"page"},{"location":"Nemo/series/#Power-series-functionality","page":"Power series and Laurent series","title":"Power series functionality","text":"","category":"section"},{"location":"Nemo/series/","page":"Power series and Laurent series","title":"Power series and Laurent series","text":"Power series rings in Nemo provide all the functionality described for power series in AbstractAlgebra:","category":"page"},{"location":"Nemo/series/","page":"Power series and Laurent series","title":"Power series and Laurent series","text":"https://nemocas.github.io/AbstractAlgebra.jl/stable/series","category":"page"},{"location":"Nemo/series/","page":"Power series and Laurent series","title":"Power series and Laurent series","text":"In addition, generic power series and Laurent series are provided by AbstractAlgebra.","category":"page"},{"location":"Nemo/series/","page":"Power series and Laurent series","title":"Power series and Laurent series","text":"We list below only the functionality that is Nemo specific for power series rings.","category":"page"},{"location":"Nemo/series/#Special-functions","page":"Power series and Laurent series","title":"Special functions","text":"","category":"section"},{"location":"Nemo/series/","page":"Power series and Laurent series","title":"Power series and Laurent series","text":"Examples","category":"page"},{"location":"Nemo/series/","page":"Power series and Laurent series","title":"Power series and Laurent series","text":"julia> T, z = power_series_ring(QQ, 30, \"z\")\n(Univariate power series ring over QQ, z + O(z^31))\n\njulia> a = 1 + z + 3z^2 + O(z^5)\n1 + z + 3*z^2 + O(z^5)\n\njulia> b = z + 2z^2 + 5z^3 + O(z^5)\nz + 2*z^2 + 5*z^3 + O(z^5)\n\njulia> d = divexact(z, exp(z + O(z^40)) - 1)\n1 - 1//2*z + 1//12*z^2 - 1//720*z^4 + 1//30240*z^6 - 1//1209600*z^8 + 1//47900160*z^10 - 691//1307674368000*z^12 + 1//74724249600*z^14 - 3617//10670622842880000*z^16 + 43867//5109094217170944000*z^18 - 174611//802857662698291200000*z^20 + 77683//14101100039391805440000*z^22 - 236364091//1693824136731743669452800000*z^24 + 657931//186134520519971831808000000*z^26 - 3392780147//37893265687455865519472640000000*z^28 + O(z^29)\n\njulia> f = exp(b)\n1 + z + 5//2*z^2 + 43//6*z^3 + 193//24*z^4 + O(z^5)\n\njulia> g = log(a)\nz + 5//2*z^2 - 8//3*z^3 - 7//4*z^4 + O(z^5)\n\njulia> h = sqrt(a)\n1 + 1//2*z + 11//8*z^2 - 11//16*z^3 - 77//128*z^4 + O(z^5)\n\njulia> k = sin(b)\nz + 2*z^2 + 29//6*z^3 - z^4 + O(z^5)\n\njulia> m = atanh(b)\nz + 2*z^2 + 16//3*z^3 + 2*z^4 + O(z^5)","category":"page"},{"location":"Hecke/manual/quad_forms/genusherm/#Genera-for-hermitian-lattices","page":"Genera for hermitian lattices","title":"Genera for hermitian lattices","text":"","category":"section"},{"location":"Hecke/manual/quad_forms/genusherm/","page":"Genera for hermitian lattices","title":"Genera for hermitian lattices","text":"CurrentModule = Hecke\nDocTestSetup = quote\n    using Hecke\n  end","category":"page"},{"location":"Hecke/manual/quad_forms/genusherm/#Local-genus-symbols","page":"Genera for hermitian lattices","title":"Local genus symbols","text":"","category":"section"},{"location":"Hecke/manual/quad_forms/genusherm/","page":"Genera for hermitian lattices","title":"Genera for hermitian lattices","text":"Definition 8.3.1 ([Kir16]) Let L be a hermitian lattice over EK and let mathfrak p be a prime ideal of mathcal O_K. Let mathfrak P be the largest ideal of mathcal O_E over mathfrak p being invariant under the involution of E. We suppose that we are given a Jordan decomposition","category":"page"},{"location":"Hecke/manual/quad_forms/genusherm/","page":"Genera for hermitian lattices","title":"Genera for hermitian lattices","text":"   L_mathfrak p = perp_i=1^tL_i","category":"page"},{"location":"Hecke/manual/quad_forms/genusherm/","page":"Genera for hermitian lattices","title":"Genera for hermitian lattices","text":"where the Jordan block L_i is mathfrak P^s_i-modular for 1 leq i leq t, for a strictly increasing sequence of integers s_1  ldots  s_t. In particular, mathfrak s(L_i) = mathfrak P^s_i. Then, the local genus symbol g(L mathfrak p) of L_mathfrak p is defined to be:","category":"page"},{"location":"Hecke/manual/quad_forms/genusherm/","page":"Genera for hermitian lattices","title":"Genera for hermitian lattices","text":"if mathfrak p is good, i.e. non ramified and non dyadic,","category":"page"},{"location":"Hecke/manual/quad_forms/genusherm/","page":"Genera for hermitian lattices","title":"Genera for hermitian lattices","text":"   g(L mathfrak p) = (s_1 r_1 d_1) ldots (s_t r_t d_t)","category":"page"},{"location":"Hecke/manual/quad_forms/genusherm/","page":"Genera for hermitian lattices","title":"Genera for hermitian lattices","text":"where d_i = 1 if the determinant (resp. discriminant) of L_i is a norm   in K_mathfrak p^times, and d_i = -1 otherwise, and   r_i = textrank(L_i) for all i;","category":"page"},{"location":"Hecke/manual/quad_forms/genusherm/","page":"Genera for hermitian lattices","title":"Genera for hermitian lattices","text":"if mathfrak p is bad,","category":"page"},{"location":"Hecke/manual/quad_forms/genusherm/","page":"Genera for hermitian lattices","title":"Genera for hermitian lattices","text":"   g(L mathfrak p) = (s_1 r_1 d_1 n_1) ldots (s_t r_t d_t n_t)","category":"page"},{"location":"Hecke/manual/quad_forms/genusherm/","page":"Genera for hermitian lattices","title":"Genera for hermitian lattices","text":"where for all i, n_i = textord_mathfrak p(mathfrak n(L_i))","category":"page"},{"location":"Hecke/manual/quad_forms/genusherm/","page":"Genera for hermitian lattices","title":"Genera for hermitian lattices","text":"Note that we define the scale and the norm of the lattice L_i (1 leq i leq n) defined over the extension of local fields E_mathfrak PK_mathfrak p similarly to the ones of L, by extending by continuity the sesquilinear form of the ambient space of L to the completion. Regarding the determinant (resp. discriminant), it is defined as the determinant of the Gram matrix associated to a basis of L_i relatively to the extension of the sesquilinear form (resp. (-1)^(m(m-1)2 times the determinant, where m is the rank of L_i).","category":"page"},{"location":"Hecke/manual/quad_forms/genusherm/","page":"Genera for hermitian lattices","title":"Genera for hermitian lattices","text":"We call any tuple in g = g(L mathfrak p) = g_1 ldots g_t a Jordan block of g since it corresponds to invariants of a Jordan block of the completion of the lattice L at mathfrak p. For any such block g_i, we call respectively s_i r_i d_i n_i the scale, the rank, the determinant class (resp. discriminant class) and the norm of g_i. Note that the norm is necessary only when the prime ideal is bad.","category":"page"},{"location":"Hecke/manual/quad_forms/genusherm/","page":"Genera for hermitian lattices","title":"Genera for hermitian lattices","text":"We say that two hermitian lattices L and L over EK are in the same local genus at mathfrak p if g(L mathfrak p) = g(L mathfrak p).","category":"page"},{"location":"Hecke/manual/quad_forms/genusherm/#Creation-of-local-genus-symbols","page":"Genera for hermitian lattices","title":"Creation of local genus symbols","text":"","category":"section"},{"location":"Hecke/manual/quad_forms/genusherm/","page":"Genera for hermitian lattices","title":"Genera for hermitian lattices","text":"There are two ways of creating a local genus symbol for hermitian lattices:","category":"page"},{"location":"Hecke/manual/quad_forms/genusherm/","page":"Genera for hermitian lattices","title":"Genera for hermitian lattices","text":"either abstractly, by choosing the extension EK, the prime ideal mathfrak p of mathcal O_K, the Jordan blocks data and the type of the d_i's (either determinant class :det or discriminant class :disc);","category":"page"},{"location":"Hecke/manual/quad_forms/genusherm/","page":"Genera for hermitian lattices","title":"Genera for hermitian lattices","text":"   genus(HermLat, E::NumField, p::AbsNumFieldOrderIdeal{AbsSimpleNumField, AbsSimpleNumFieldElem}, data::Vector; type::Symbol = :det,\n                                                          check::Bool = false)\n                                                             -> HermLocalGenus","category":"page"},{"location":"Hecke/manual/quad_forms/genusherm/","page":"Genera for hermitian lattices","title":"Genera for hermitian lattices","text":"or by constructing the local genus symbol of the completion of a hermitian lattice L over EK at a prime ideal mathfrak p of mathcal O_K.","category":"page"},{"location":"Hecke/manual/quad_forms/genusherm/","page":"Genera for hermitian lattices","title":"Genera for hermitian lattices","text":"   genus(L::HermLat, p::AbsNumFieldOrderIdeal{AbsSimpleNumField, AbsSimpleNumFieldElem}) -> HermLocalGenus","category":"page"},{"location":"Hecke/manual/quad_forms/genusherm/#Examples","page":"Genera for hermitian lattices","title":"Examples","text":"","category":"section"},{"location":"Hecke/manual/quad_forms/genusherm/","page":"Genera for hermitian lattices","title":"Genera for hermitian lattices","text":"We will construct two examples for the rest of this section. Note that the prime chosen here is bad.","category":"page"},{"location":"Hecke/manual/quad_forms/genusherm/","page":"Genera for hermitian lattices","title":"Genera for hermitian lattices","text":"using Hecke # hide\nQx, x = QQ[\"x\"];\nK, a = number_field(x^2 - 2, \"a\");\nKt, t  = K[\"t\"];\nE, b = number_field(t^2 - a, \"b\");\nOK = maximal_order(K);\np = prime_decomposition(OK, 2)[1][1];\ng1 = genus(HermLat, E, p, [(0, 1, 1, 0), (2, 2, -1, 1)], type = :det)\nD = matrix(E, 3, 3, [5//2*a - 4, 0, 0, 0, a, a, 0, a, -4*a + 8]);\ngens = Vector{Hecke.RelSimpleNumFieldElem{AbsSimpleNumFieldElem}}[map(E, [1, 0, 0]), map(E, [a, 0, 0]), map(E, [b, 0, 0]), map(E, [a*b, 0, 0]), map(E, [0, 1, 0]), map(E, [0, a, 0]), map(E, [0, b, 0]), map(E, [0, a*b, 0]), map(E, [0, 0, 1]), map(E, [0, 0, a]), map(E, [0, 0, b]), map(E, [0, 0, a*b])];\nL = hermitian_lattice(E, gens, gram = D);\ng2 = genus(L, p)","category":"page"},{"location":"Hecke/manual/quad_forms/genusherm/","page":"Genera for hermitian lattices","title":"Genera for hermitian lattices","text":"","category":"page"},{"location":"Hecke/manual/quad_forms/genusherm/#Attributes","page":"Genera for hermitian lattices","title":"Attributes","text":"","category":"section"},{"location":"Hecke/manual/quad_forms/genusherm/","page":"Genera for hermitian lattices","title":"Genera for hermitian lattices","text":"length(::HermLocalGenus)\nbase_field(::HermLocalGenus)\nprime(::HermLocalGenus)","category":"page"},{"location":"Hecke/manual/quad_forms/genusherm/#length-Tuple{HermLocalGenus}","page":"Genera for hermitian lattices","title":"length","text":"length(g::HermLocalGenus) -> Int\n\nGiven a local genus symbol g for hermitian lattices, return the number of Jordan blocks of g.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/quad_forms/genusherm/#base_field-Tuple{HermLocalGenus}","page":"Genera for hermitian lattices","title":"base_field","text":"base_field(g::HermLocalGenus) -> NumField\n\nGiven a local genus symbol g for hermitian lattices over EK, return E.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/quad_forms/genusherm/#prime-Tuple{HermLocalGenus}","page":"Genera for hermitian lattices","title":"prime","text":"prime(g::HermLocalGenus) -> AbsNumFieldOrderIdeal{AbsSimpleNumField, AbsSimpleNumFieldElem}\n\nGiven a local genus symbol g for hermitian lattices over EK at a prime ideal mathfrak p of mathcal O_K, return mathfrak p.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/quad_forms/genusherm/#Examples-2","page":"Genera for hermitian lattices","title":"Examples","text":"","category":"section"},{"location":"Hecke/manual/quad_forms/genusherm/","page":"Genera for hermitian lattices","title":"Genera for hermitian lattices","text":"using Hecke # hide\nQx, x = QQ[\"x\"];\nK, a = number_field(x^2 - 2, \"a\");\nKt, t  = K[\"t\"];\nE, b = number_field(t^2 - a, \"b\");\nOK = maximal_order(K);\np = prime_decomposition(OK, 2)[1][1];\ng1 = genus(HermLat, E, p, [(0, 1, 1, 0), (2, 2, -1, 1)], type = :det);\nlength(g1)\nbase_field(g1)\nprime(g1)","category":"page"},{"location":"Hecke/manual/quad_forms/genusherm/","page":"Genera for hermitian lattices","title":"Genera for hermitian lattices","text":"","category":"page"},{"location":"Hecke/manual/quad_forms/genusherm/#Invariants","page":"Genera for hermitian lattices","title":"Invariants","text":"","category":"section"},{"location":"Hecke/manual/quad_forms/genusherm/","page":"Genera for hermitian lattices","title":"Genera for hermitian lattices","text":"scale(::HermLocalGenus, ::Int)\nscale(::HermLocalGenus)\nscales(::HermLocalGenus)\nrank(::HermLocalGenus, ::Int)\nrank(::HermLocalGenus)\nranks(::HermLocalGenus)\ndet(::HermLocalGenus, ::Int)\ndet(::HermLocalGenus)\ndets(::HermLocalGenus)\ndiscriminant(::HermLocalGenus, ::Int)\ndiscriminant(::HermLocalGenus)\nnorm(::HermLocalGenus, ::Int)\nnorm(::HermLocalGenus)\nnorms(::HermLocalGenus)","category":"page"},{"location":"Hecke/manual/quad_forms/genusherm/#scale-Tuple{HermLocalGenus, Int64}","page":"Genera for hermitian lattices","title":"scale","text":"scale(g::HermLocalGenus, i::Int) -> Int\n\nGiven a local genus symbol g for hermitian lattices over EK at a prime mathfrak p of mathcal O_K, return the mathfrak P-valuation of the scale of the ith Jordan block of g, where mathfrak P is a prime ideal of mathcal O_E lying over mathfrak p.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/quad_forms/genusherm/#scale-Tuple{HermLocalGenus}","page":"Genera for hermitian lattices","title":"scale","text":"scale(g::HermLocalGenus) -> AbsSimpleNumFieldOrderFractionalIdeal\n\nGiven a local genus symbol g for hermitian lattices over EK at a prime mathfrak p of mathcal O_K, return the scale of the Jordan block of minimum mathfrak P-valuation, where mathfrakP is a prime ideal of mathcal O_E lying over mathfrak p.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/quad_forms/genusherm/#scales-Tuple{HermLocalGenus}","page":"Genera for hermitian lattices","title":"scales","text":"scales(g::HermLocalGenus) -> Vector{Int}\n\nGiven a local genus symbol g for hermitian lattices over EK at a prime mathfrak p of mathcal O_K, return the mathfrak P-valuation of the scales of the Jordan blocks of g, where mathfrak P is a prime ideal of mathcal O_E lying over mathfrak p.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/quad_forms/genusherm/#rank-Tuple{HermLocalGenus, Int64}","page":"Genera for hermitian lattices","title":"rank","text":"rank(g::HermLocalGenus, i::Int) -> Int\n\nGiven a local genus symbol g for hermitian lattices, return the rank of the ith Jordan block of g.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/quad_forms/genusherm/#rank-Tuple{HermLocalGenus}","page":"Genera for hermitian lattices","title":"rank","text":"rank(g::HermLocalGenus) -> Int\n\nGiven a local genus symbol g for hermitian lattices over EK at a prime ideal mathfrak p of mathcal O_K, return the rank of any hermitian lattice whose mathfrak p-adic completion has local genus symbol g.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/quad_forms/genusherm/#ranks-Tuple{HermLocalGenus}","page":"Genera for hermitian lattices","title":"ranks","text":"ranks(g::HermLocalGenus) -> Vector{Int}\n\nGiven a local genus symbol g for hermitian lattices, return the ranks of the Jordan blocks of g.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/quad_forms/genusherm/#det-Tuple{HermLocalGenus, Int64}","page":"Genera for hermitian lattices","title":"det","text":"det(g::HermLocalGenus, i::Int) -> Int\n\nGiven a local genus symbol g for hermitian lattices over EK, return the determinant of the ith Jordan block of g.\n\nThe returned value is 1 or -1 depending on whether the determinant is a local norm in K.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/quad_forms/genusherm/#det-Tuple{HermLocalGenus}","page":"Genera for hermitian lattices","title":"det","text":"det(g::HermLocalGenus) -> Int\n\nGiven a local genus symbol g for hermitian lattices over EK at a prime ideal mathfrak p of mathcal O_K, return the determinant of a hermitian lattice whose mathfrak p-adic completion has local genus symbol g.\n\nThe returned value is 1 or -1 depending on whether the determinant is a local norm in K.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/quad_forms/genusherm/#dets-Tuple{HermLocalGenus}","page":"Genera for hermitian lattices","title":"dets","text":"dets(g::HermLocalGenus) -> Vector{Int}\n\nGiven a local genus symbol g for hermitian lattices over EK, return the determinants of the Jordan blocks of g.\n\nThe returned values are 1 or -1 depending on whether the respective determinants are are local norms in K.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/quad_forms/genusherm/#discriminant-Tuple{HermLocalGenus, Int64}","page":"Genera for hermitian lattices","title":"discriminant","text":"discriminant(g::HermLocalGenus, i::Int) -> Int\n\nGiven a local genus symbol g for hermitian lattices over EK, return the discriminant of the ith Jordan block of g.\n\nThe returned value is 1 or -1 depending on whether the discriminant is a local norm in K.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/quad_forms/genusherm/#discriminant-Tuple{HermLocalGenus}","page":"Genera for hermitian lattices","title":"discriminant","text":"discriminant(g::HermLocalGenus) -> Int\n\nGiven a local genus symbol g for hermitian lattices over EK at a prime ideal mathfrak p of mathcal O_K, return the discriminant of a hermitian lattice whose mathfrak p-adic completion has local genus symbol g.\n\nThe returned value is 1 or -1 depending on whether the discriminant is a local norm in K.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/quad_forms/genusherm/#norm-Tuple{HermLocalGenus, Int64}","page":"Genera for hermitian lattices","title":"norm","text":"norm(g::HermLocalGenus, i::Int) -> Int\n\nGiven a local genus symbol g for hermitian lattices over EK at a prime ideal mathfrak p of mathcal O_K, return the mathfrak p-valuation of the norm of the ith Jordan block of g.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/quad_forms/genusherm/#norm-Tuple{HermLocalGenus}","page":"Genera for hermitian lattices","title":"norm","text":"norm(g::HermLocalGenus) -> AbsSimpleNumFieldOrderFractionalIdeal\n\nReturn the norm of g, i.e. the norm of any of its representatives.\n\nGiven a local genus symbol g of hermitian lattices over EK at a prime ideal mathfrak p of mathcal O_K, it norm is computed as the norm of the Jordan block of minimum mathfrak p-valuation.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/quad_forms/genusherm/#norms-Tuple{HermLocalGenus}","page":"Genera for hermitian lattices","title":"norms","text":"norms(g::HermLocalGenus) -> Vector{Int}\n\nGiven a local genus symbol g for hermitian lattices over EK at a prime ideal mathfrak p of mathcal O_K, return the mathfrak p-valuations of the norms of the Jordan blocks of g.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/quad_forms/genusherm/#Examples-3","page":"Genera for hermitian lattices","title":"Examples","text":"","category":"section"},{"location":"Hecke/manual/quad_forms/genusherm/","page":"Genera for hermitian lattices","title":"Genera for hermitian lattices","text":"using Hecke # hide\nQx, x = QQ[\"x\"];\nK, a = number_field(x^2 - 2, \"a\");\nKt, t  = K[\"t\"];\nE, b = number_field(t^2 - a, \"b\");\nOK = maximal_order(K);\np = prime_decomposition(OK, 2)[1][1];\nD = matrix(E, 3, 3, [5//2*a - 4, 0, 0, 0, a, a, 0, a, -4*a + 8]);\ngens = Vector{Hecke.RelSimpleNumFieldElem{AbsSimpleNumFieldElem}}[map(E, [1, 0, 0]), map(E, [a, 0, 0]), map(E, [b, 0, 0]), map(E, [a*b, 0, 0]), map(E, [0, 1, 0]), map(E, [0, a, 0]), map(E, [0, b, 0]), map(E, [0, a*b, 0]), map(E, [0, 0, 1]), map(E, [0, 0, a]), map(E, [0, 0, b]), map(E, [0, 0, a*b])];\nL = hermitian_lattice(E, gens, gram = D);\ng2 = genus(L, p);\nscales(g2)\nranks(g2)\ndets(g2)\nnorms(g2)\nrank(g2), det(g2), discriminant(g2)","category":"page"},{"location":"Hecke/manual/quad_forms/genusherm/","page":"Genera for hermitian lattices","title":"Genera for hermitian lattices","text":"","category":"page"},{"location":"Hecke/manual/quad_forms/genusherm/#Predicates","page":"Genera for hermitian lattices","title":"Predicates","text":"","category":"section"},{"location":"Hecke/manual/quad_forms/genusherm/","page":"Genera for hermitian lattices","title":"Genera for hermitian lattices","text":"is_ramified(::HermLocalGenus)\nis_split(::HermLocalGenus)\nis_inert(::HermLocalGenus)\nis_dyadic(::HermLocalGenus)","category":"page"},{"location":"Hecke/manual/quad_forms/genusherm/#is_ramified-Tuple{HermLocalGenus}","page":"Genera for hermitian lattices","title":"is_ramified","text":"is_ramified(g::HermLocalGenus) -> Bool\n\nGiven a local genus symbol g for hermitian lattices over EK at a prime ideal mathfrak p of mathcal O_K, return whether mathfrak p is ramified in mathcal O_E.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/quad_forms/genusherm/#is_split-Tuple{HermLocalGenus}","page":"Genera for hermitian lattices","title":"is_split","text":"is_split(g::HermLocalGenus) -> Bool\n\nGiven a local genus symbol g for hermitian lattices over EK at a prime ideal mathfrak p of mathcal O_K, return whether mathfrak p is split in mathcal O_E.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/quad_forms/genusherm/#is_inert-Tuple{HermLocalGenus}","page":"Genera for hermitian lattices","title":"is_inert","text":"is_inert(g::HermLocalGenus) -> Bool\n\nGiven a local genus symbol g for hermitian lattices over EK at a prime ideal mathfrak p of mathcal O_K, return whether mathfrak p is inert in mathcal O_E.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/quad_forms/genusherm/#is_dyadic-Tuple{HermLocalGenus}","page":"Genera for hermitian lattices","title":"is_dyadic","text":"is_dyadic(g::HermLocalGenus) -> Bool\n\nGiven a local genus symbol g for hermitian lattices over EK at a prime ideal mathfrak p of mathcal O_K, return whether mathfrak p is dyadic.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/quad_forms/genusherm/#Examples-4","page":"Genera for hermitian lattices","title":"Examples","text":"","category":"section"},{"location":"Hecke/manual/quad_forms/genusherm/","page":"Genera for hermitian lattices","title":"Genera for hermitian lattices","text":"using Hecke # hide\nQx, x = QQ[\"x\"];\nK, a = number_field(x^2 - 2, \"a\");\nKt, t  = K[\"t\"];\nE, b = number_field(t^2 - a, \"b\");\nOK = maximal_order(K);\np = prime_decomposition(OK, 2)[1][1];\ng1 = genus(HermLat, E, p, [(0, 1, 1, 0), (2, 2, -1, 1)], type = :det);\nis_ramified(g1), is_split(g1), is_inert(g1), is_dyadic(g1)","category":"page"},{"location":"Hecke/manual/quad_forms/genusherm/","page":"Genera for hermitian lattices","title":"Genera for hermitian lattices","text":"","category":"page"},{"location":"Hecke/manual/quad_forms/genusherm/#Local-uniformizer","page":"Genera for hermitian lattices","title":"Local uniformizer","text":"","category":"section"},{"location":"Hecke/manual/quad_forms/genusherm/","page":"Genera for hermitian lattices","title":"Genera for hermitian lattices","text":"uniformizer(::HermLocalGenus)","category":"page"},{"location":"Hecke/manual/quad_forms/genusherm/#uniformizer-Tuple{HermLocalGenus}","page":"Genera for hermitian lattices","title":"uniformizer","text":"uniformizer(g::HermLocalGenus) -> NumFieldElem\n\nGiven a local genus symbol g for hermitian lattices over EK at a prime ideal mathfrak p of mathcal O_K, return a generator for the largest ideal of mathcal O_E containing mathfrak p and invariant under the action of the non-trivial involution of E.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/quad_forms/genusherm/#Example","page":"Genera for hermitian lattices","title":"Example","text":"","category":"section"},{"location":"Hecke/manual/quad_forms/genusherm/","page":"Genera for hermitian lattices","title":"Genera for hermitian lattices","text":"using Hecke # hide\nQx, x = QQ[\"x\"];\nK, a = number_field(x^2 - 2, \"a\");\nKt, t  = K[\"t\"];\nE, b = number_field(t^2 - a, \"b\");\nOK = maximal_order(K);\np = prime_decomposition(OK, 2)[1][1];\ng1 = genus(HermLat, E, p, [(0, 1, 1, 0), (2, 2, -1, 1)], type = :det);\nuniformizer(g1)","category":"page"},{"location":"Hecke/manual/quad_forms/genusherm/","page":"Genera for hermitian lattices","title":"Genera for hermitian lattices","text":"","category":"page"},{"location":"Hecke/manual/quad_forms/genusherm/#Determinant-representatives","page":"Genera for hermitian lattices","title":"Determinant representatives","text":"","category":"section"},{"location":"Hecke/manual/quad_forms/genusherm/","page":"Genera for hermitian lattices","title":"Genera for hermitian lattices","text":"Let g be a local genus symbol for hermitian lattices. Its determinant class, or the determinant class of its Jordan blocks, are given by pm 1, depending on whether the determinants are local norms or not. It is possible to get a representative of this determinant class in terms of powers of the uniformizer of g.","category":"page"},{"location":"Hecke/manual/quad_forms/genusherm/","page":"Genera for hermitian lattices","title":"Genera for hermitian lattices","text":"det_representative(::HermLocalGenus, ::Int)\ndet_representative(::HermLocalGenus)","category":"page"},{"location":"Hecke/manual/quad_forms/genusherm/#det_representative-Tuple{HermLocalGenus, Int64}","page":"Genera for hermitian lattices","title":"det_representative","text":"det_representative(g::HermLocalGenus, i::Int) -> NumFieldElem\n\nGiven a local genus symbol g for hermitian lattices over EK, return a representative of the norm class of the determinant of the ith Jordan block of g in K^times.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/quad_forms/genusherm/#det_representative-Tuple{HermLocalGenus}","page":"Genera for hermitian lattices","title":"det_representative","text":"det_representative(g::HermLocalGenus) -> NumFieldElem\n\nGiven a local genus symbol g for hermitian lattices over EK, return a representative of the norm class of the determinant of g in K^times.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/quad_forms/genusherm/#Examples-5","page":"Genera for hermitian lattices","title":"Examples","text":"","category":"section"},{"location":"Hecke/manual/quad_forms/genusherm/","page":"Genera for hermitian lattices","title":"Genera for hermitian lattices","text":"using Hecke # hide\nQx, x = QQ[\"x\"];\nK, a = number_field(x^2 - 2, \"a\");\nKt, t  = K[\"t\"];\nE, b = number_field(t^2 - a, \"b\");\nOK = maximal_order(K);\np = prime_decomposition(OK, 2)[1][1];\ng1 = genus(HermLat, E, p, [(0, 1, 1, 0), (2, 2, -1, 1)], type = :det);\ndet_representative(g1)\ndet_representative(g1,2)","category":"page"},{"location":"Hecke/manual/quad_forms/genusherm/","page":"Genera for hermitian lattices","title":"Genera for hermitian lattices","text":"","category":"page"},{"location":"Hecke/manual/quad_forms/genusherm/#Gram-matrices","page":"Genera for hermitian lattices","title":"Gram matrices","text":"","category":"section"},{"location":"Hecke/manual/quad_forms/genusherm/","page":"Genera for hermitian lattices","title":"Genera for hermitian lattices","text":"gram_matrix(::HermLocalGenus, ::Int)\ngram_matrix(::HermLocalGenus)","category":"page"},{"location":"Hecke/manual/quad_forms/genusherm/#gram_matrix-Tuple{HermLocalGenus, Int64}","page":"Genera for hermitian lattices","title":"gram_matrix","text":"gram_matrix(g::HermLocalGenus, i::Int) -> MatElem\n\nGiven a local genus symbol g for hermitian lattices over EK at a prime ideal mathfrak p of mathcal O_K, return a Gram matrix M of the ith Jordan block of g, with coefficients in E. M is such that any hermitian lattice over EK with Gram matrix M satisfies that the local genus symbol of its completion at mathfrak p is equal to the ith Jordan block of g.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/quad_forms/genusherm/#gram_matrix-Tuple{HermLocalGenus}","page":"Genera for hermitian lattices","title":"gram_matrix","text":"gram_matrix(g::HermLocalGenus) -> MatElem\n\nGiven a local genus symbol g for hermitian lattices over EK at a prime ideal mathfrak p of mathcal O_K, return a Gram matrix M of g, with coefficients in E.M is such that any hermitian lattice over EK with Gram matrix M satisfies that the local genus symbol of its completion at mathfrak p is g.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/quad_forms/genusherm/#Examples-6","page":"Genera for hermitian lattices","title":"Examples","text":"","category":"section"},{"location":"Hecke/manual/quad_forms/genusherm/","page":"Genera for hermitian lattices","title":"Genera for hermitian lattices","text":"using Hecke # hide\nQx, x = QQ[\"x\"];\nK, a = number_field(x^2 - 2, \"a\");\nKt, t  = K[\"t\"];\nE, b = number_field(t^2 - a, \"b\");\nOK = maximal_order(K);\np = prime_decomposition(OK, 2)[1][1];\nD = matrix(E, 3, 3, [5//2*a - 4, 0, 0, 0, a, a, 0, a, -4*a + 8]);\ngens = Vector{Hecke.RelSimpleNumFieldElem{AbsSimpleNumFieldElem}}[map(E, [1, 0, 0]), map(E, [a, 0, 0]), map(E, [b, 0, 0]), map(E, [a*b, 0, 0]), map(E, [0, 1, 0]), map(E, [0, a, 0]), map(E, [0, b, 0]), map(E, [0, a*b, 0]), map(E, [0, 0, 1]), map(E, [0, 0, a]), map(E, [0, 0, b]), map(E, [0, 0, a*b])];\nL = hermitian_lattice(E, gens, gram = D);\ng2 = genus(L, p);\ngram_matrix(g2)\ngram_matrix(g2,1)","category":"page"},{"location":"Hecke/manual/quad_forms/genusherm/","page":"Genera for hermitian lattices","title":"Genera for hermitian lattices","text":"","category":"page"},{"location":"Hecke/manual/quad_forms/genusherm/","page":"Genera for hermitian lattices","title":"Genera for hermitian lattices","text":"","category":"page"},{"location":"Hecke/manual/quad_forms/genusherm/#Global-genus-symbols","page":"Genera for hermitian lattices","title":"Global genus symbols","text":"","category":"section"},{"location":"Hecke/manual/quad_forms/genusherm/","page":"Genera for hermitian lattices","title":"Genera for hermitian lattices","text":"Let L be a hermitian lattice over EK. Let P(L) be the set of all prime ideals of mathcal O_K which are bad (ramified or dyadic), which are dividing the scale of L or which are dividing the volume of L. Let S(EK) be the set of real infinite places of K which split into complex places in E. We define the global genus symbol G(L) of L to be the datum consisting of the local genus symbols of L at each prime of P(L) and the signatures (i.e. the negative index of inertia) of the Gram matrix of the rational span of L at each place in S(EK).","category":"page"},{"location":"Hecke/manual/quad_forms/genusherm/","page":"Genera for hermitian lattices","title":"Genera for hermitian lattices","text":"Note that prime ideals in P(L) which don't ramify correspond to those for which the corresponding completions of L are not unimodular.","category":"page"},{"location":"Hecke/manual/quad_forms/genusherm/","page":"Genera for hermitian lattices","title":"Genera for hermitian lattices","text":"We say that two lattice L and L over EK are in the same genus, if G(L) = G(L).","category":"page"},{"location":"Hecke/manual/quad_forms/genusherm/#Creation-of-global-genus-symbols","page":"Genera for hermitian lattices","title":"Creation of global genus symbols","text":"","category":"section"},{"location":"Hecke/manual/quad_forms/genusherm/","page":"Genera for hermitian lattices","title":"Genera for hermitian lattices","text":"Similarly, there are two ways of constructing a global genus symbol for hermitian lattices:","category":"page"},{"location":"Hecke/manual/quad_forms/genusherm/","page":"Genera for hermitian lattices","title":"Genera for hermitian lattices","text":"either abstractly, by choosing the extension EK, the set of local genus symbols S and the signatures signatures at the places in S(EK). Note that this requires the given invariants to satisfy the product formula for Hilbert symbols.","category":"page"},{"location":"Hecke/manual/quad_forms/genusherm/","page":"Genera for hermitian lattices","title":"Genera for hermitian lattices","text":"   genus(S::Vector{HermLocalGenus}, signatures) -> HermGenus","category":"page"},{"location":"Hecke/manual/quad_forms/genusherm/","page":"Genera for hermitian lattices","title":"Genera for hermitian lattices","text":"Here signatures can be a dictionary with keys the infinite places and values   the corresponding signatures, or a collection of tuples of the type   (::InfPlc, ::Int);","category":"page"},{"location":"Hecke/manual/quad_forms/genusherm/","page":"Genera for hermitian lattices","title":"Genera for hermitian lattices","text":"or by constructing the global genus symbol of a given hermitian lattice L.","category":"page"},{"location":"Hecke/manual/quad_forms/genusherm/","page":"Genera for hermitian lattices","title":"Genera for hermitian lattices","text":"   genus(L::HermLat) -> HermGenus","category":"page"},{"location":"Hecke/manual/quad_forms/genusherm/#Examples-7","page":"Genera for hermitian lattices","title":"Examples","text":"","category":"section"},{"location":"Hecke/manual/quad_forms/genusherm/","page":"Genera for hermitian lattices","title":"Genera for hermitian lattices","text":"As before, we will construct two different global genus symbols for hermitian lattices, which we will use for the rest of this section.","category":"page"},{"location":"Hecke/manual/quad_forms/genusherm/","page":"Genera for hermitian lattices","title":"Genera for hermitian lattices","text":"using Hecke # hide\nQx, x = QQ[\"x\"];\nK, a = number_field(x^2 - 2, \"a\");\nKt, t  = K[\"t\"];\nE, b = number_field(t^2 - a, \"b\");\nOK = maximal_order(K);\np = prime_decomposition(OK, 2)[1][1];\ng1 = genus(HermLat, E, p, [(0, 1, 1, 0), (2, 2, -1, 1)], type = :det);\ninfp = infinite_places(E)\nSEK = unique([r.base_field_place for r in infp if isreal(r.base_field_place) && !isreal(r)]);\nlength(SEK)\nG1 = genus([g1], [(SEK[1], 1)])\nD = matrix(E, 3, 3, [5//2*a - 4, 0, 0, 0, a, a, 0, a, -4*a + 8]);\ngens = Vector{Hecke.RelSimpleNumFieldElem{AbsSimpleNumFieldElem}}[map(E, [1, 0, 0]), map(E, [a, 0, 0]), map(E, [b, 0, 0]), map(E, [a*b, 0, 0]), map(E, [0, 1, 0]), map(E, [0, a, 0]), map(E, [0, b, 0]), map(E, [0, a*b, 0]), map(E, [0, 0, 1]), map(E, [0, 0, a]), map(E, [0, 0, b]), map(E, [0, 0, a*b])];\nL = hermitian_lattice(E, gens, gram = D);\nG2 = genus(L)","category":"page"},{"location":"Hecke/manual/quad_forms/genusherm/","page":"Genera for hermitian lattices","title":"Genera for hermitian lattices","text":"","category":"page"},{"location":"Hecke/manual/quad_forms/genusherm/#Attributes-2","page":"Genera for hermitian lattices","title":"Attributes","text":"","category":"section"},{"location":"Hecke/manual/quad_forms/genusherm/","page":"Genera for hermitian lattices","title":"Genera for hermitian lattices","text":"base_field(::HermGenus)\nprimes(::HermGenus)\nsignatures(::HermGenus)\nrank(::HermGenus)\nis_integral(::HermGenus)\nlocal_symbols(::HermGenus)\nscale(::HermGenus)\nnorm(::HermGenus)","category":"page"},{"location":"Hecke/manual/quad_forms/genusherm/#base_field-Tuple{HermGenus}","page":"Genera for hermitian lattices","title":"base_field","text":"base_field(G::HermGenus) -> NumField\n\nGiven a global genus symbol G for hermitian lattices over EK, return E.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/quad_forms/genusherm/#primes-Tuple{HermGenus}","page":"Genera for hermitian lattices","title":"primes","text":"primes(G::HermGenus) -> Vector{AbsNumFieldOrderIdeal{AbsSimpleNumField, AbsSimpleNumFieldElem}}\n\nGiven a global genus symbol G for hermitian lattices over EK, return the list of prime ideals of mathcal O_K at which G has a local genus symbol.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/quad_forms/genusherm/#signatures-Tuple{HermGenus}","page":"Genera for hermitian lattices","title":"signatures","text":"signatures(G::HermGenus) -> Dict{InfPlc, Int}\n\nGiven a global genus symbol G for hermitian lattices over EK, return the signatures at the infinite places of K. For each real place, it is given by the negative index of inertia of the Gram matrix of the rational span of a hermitian lattice whose global genus symbol is G.\n\nThe output is given as a dictionary with keys the infinite places of K and value the corresponding signatures.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/quad_forms/genusherm/#rank-Tuple{HermGenus}","page":"Genera for hermitian lattices","title":"rank","text":"rank(G::HermGenus) -> Int\n\nReturn the rank of any hermitian lattice with global genus symbol G.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/quad_forms/genusherm/#is_integral-Tuple{HermGenus}","page":"Genera for hermitian lattices","title":"is_integral","text":"is_integral(G::HermGenus) -> Bool\n\nReturn whether G defines a genus of integral hermitian lattices.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/quad_forms/genusherm/#local_symbols-Tuple{HermGenus}","page":"Genera for hermitian lattices","title":"local_symbols","text":"local_symbols(G::HermGenus) -> Vector{HermLocalGenus}\n\nGiven a global genus symbol of hermitian lattices, return its associated local genus symbols.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/quad_forms/genusherm/#scale-Tuple{HermGenus}","page":"Genera for hermitian lattices","title":"scale","text":"scale(G::HermGenus) -> AbsSimpleNumFieldOrderFractionalIdeal\n\nReturn the scale ideal of any hermitian lattice with global genus symbol G.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/quad_forms/genusherm/#norm-Tuple{HermGenus}","page":"Genera for hermitian lattices","title":"norm","text":"norm(G::HermGenus) -> AbsSimpleNumFieldOrderFractionalIdeal\n\nReturn the norm ideal of any hermitian lattice with global genus symbol G.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/quad_forms/genusherm/#Examples-8","page":"Genera for hermitian lattices","title":"Examples","text":"","category":"section"},{"location":"Hecke/manual/quad_forms/genusherm/","page":"Genera for hermitian lattices","title":"Genera for hermitian lattices","text":"using Hecke # hide\nQx, x = QQ[\"x\"];\nK, a = number_field(x^2 - 2, \"a\");\nKt, t  = K[\"t\"];\nE, b = number_field(t^2 - a, \"b\");\nOK = maximal_order(K);\np = prime_decomposition(OK, 2)[1][1];\nD = matrix(E, 3, 3, [5//2*a - 4, 0, 0, 0, a, a, 0, a, -4*a + 8]);\ngens = Vector{Hecke.RelSimpleNumFieldElem{AbsSimpleNumFieldElem}}[map(E, [1, 0, 0]), map(E, [a, 0, 0]), map(E, [b, 0, 0]), map(E, [a*b, 0, 0]), map(E, [0, 1, 0]), map(E, [0, a, 0]), map(E, [0, b, 0]), map(E, [0, a*b, 0]), map(E, [0, 0, 1]), map(E, [0, 0, a]), map(E, [0, 0, b]), map(E, [0, 0, a*b])];\nL = hermitian_lattice(E, gens, gram = D);\nG2 = genus(L);\nbase_field(G2)\nprimes(G2)\nsignatures(G2)\nrank(G2)","category":"page"},{"location":"Hecke/manual/quad_forms/genusherm/","page":"Genera for hermitian lattices","title":"Genera for hermitian lattices","text":"","category":"page"},{"location":"Hecke/manual/quad_forms/genusherm/#Mass","page":"Genera for hermitian lattices","title":"Mass","text":"","category":"section"},{"location":"Hecke/manual/quad_forms/genusherm/","page":"Genera for hermitian lattices","title":"Genera for hermitian lattices","text":"Definition 4.2.1 [Kir16] Let L be a hermitian lattice over EK, and suppose that L is definite. In particular, the automorphism group of L is finite. Let L_1 ldots L_n be a set of representatives of isometry classes in the genus of L. This means that if L is a lattice over EK in the genus of L (i.e. they are in the same genus), then L is isometric to one of the L_i's, and these representatives are pairwise non-isometric. Then we define the mass of the genus G(L) of L to be","category":"page"},{"location":"Hecke/manual/quad_forms/genusherm/","page":"Genera for hermitian lattices","title":"Genera for hermitian lattices","text":"   textmass(G(L)) = sum_i=1^nfrac1textAut(L_i)","category":"page"},{"location":"Hecke/manual/quad_forms/genusherm/","page":"Genera for hermitian lattices","title":"Genera for hermitian lattices","text":"Note that since L is definite, any lattice in the genus of L is also definite, and the definition makes sense.","category":"page"},{"location":"Hecke/manual/quad_forms/genusherm/","page":"Genera for hermitian lattices","title":"Genera for hermitian lattices","text":"mass(::HermLat)","category":"page"},{"location":"Hecke/manual/quad_forms/genusherm/#mass-Tuple{HermLat}","page":"Genera for hermitian lattices","title":"mass","text":"mass(L::HermLat) -> QQFieldElem\n\nGiven a definite hermitian lattice L, return the mass of its genus.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/quad_forms/genusherm/#Example-2","page":"Genera for hermitian lattices","title":"Example","text":"","category":"section"},{"location":"Hecke/manual/quad_forms/genusherm/","page":"Genera for hermitian lattices","title":"Genera for hermitian lattices","text":"using Hecke # hide\nQx, x = polynomial_ring(QQ, \"x\");\nf = x^2 - 2;\nK, a = number_field(f, \"a\", cached = false);\nKt, t = polynomial_ring(K, \"t\");\ng = t^2 + 1;\nE, b = number_field(g, \"b\", cached = false);\nD = matrix(E, 3, 3, [1, 0, 0, 0, 1, 0, 0, 0, 1]);\ngens = Vector{Hecke.RelSimpleNumFieldElem{AbsSimpleNumFieldElem}}[map(E, [(-3*a + 7)*b + 3*a, (5//2*a - 1)*b - 3//2*a + 4, 0]), map(E, [(3004*a - 4197)*b - 3088*a + 4348, (-1047//2*a + 765)*b + 5313//2*a - 3780, (-a - 1)*b + 3*a - 1]), map(E, [(728381*a - 998259)*b + 3345554*a - 4653462, (-1507194*a + 2168244)*b - 1507194*a + 2168244, (-5917//2*a - 915)*b - 4331//2*a - 488])];\nL = hermitian_lattice(E, gens, gram = D);\nmass(L)","category":"page"},{"location":"Hecke/manual/quad_forms/genusherm/","page":"Genera for hermitian lattices","title":"Genera for hermitian lattices","text":"","category":"page"},{"location":"Hecke/manual/quad_forms/genusherm/","page":"Genera for hermitian lattices","title":"Genera for hermitian lattices","text":"","category":"page"},{"location":"Hecke/manual/quad_forms/genusherm/#Representatives-of-a-genus","page":"Genera for hermitian lattices","title":"Representatives of a genus","text":"","category":"section"},{"location":"Hecke/manual/quad_forms/genusherm/","page":"Genera for hermitian lattices","title":"Genera for hermitian lattices","text":"representative(::HermLocalGenus)\nBase.in(::HermLat, ::HermLocalGenus)\nrepresentative(::HermGenus)\nBase.in(::HermLat, ::HermGenus)\nrepresentatives(::HermGenus)\ngenus_representatives(::HermLat)","category":"page"},{"location":"Hecke/manual/quad_forms/genusherm/#representative-Tuple{HermLocalGenus}","page":"Genera for hermitian lattices","title":"representative","text":"representative(g::HermLocalGenus) -> HermLat\n\nGiven a local genus symbol g for hermitian lattices over EK at a prime ideal mathfrak p of mathcal O_K, return a hermitian lattice over EK whose completion at mathfrak p admits g as local genus symbol.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/quad_forms/genusherm/#in-Tuple{HermLat, HermLocalGenus}","page":"Genera for hermitian lattices","title":"in","text":"in(L::HermLat, g::HermLocalGenus) -> Bool\n\nReturn whether g and the local genus symbol of the completion of the hermitian lattice L at prime(g) agree. Note that L being in g requires both L and g to be defined over the same extension EK.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/quad_forms/genusherm/#representative-Tuple{HermGenus}","page":"Genera for hermitian lattices","title":"representative","text":"representative(G::HermGenus) -> HermLat\n\nGiven a global genus symbol G for hermitian lattices over EK, return a hermitian lattice over EK which admits G as global genus symbol.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/quad_forms/genusherm/#in-Tuple{HermLat, HermGenus}","page":"Genera for hermitian lattices","title":"in","text":"in(L::HermLat, G::HermGenus) -> Bool\n\nReturn whether G and the global genus symbol of the hermitian lattice L agree.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/quad_forms/genusherm/#representatives-Tuple{HermGenus}","page":"Genera for hermitian lattices","title":"representatives","text":"representatives(G::HermGenus) -> Vector{HermLat}\n\nGiven a global genus symbol G for hermitian lattices, return representatives for the isometry classes of hermitian lattices in G.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/quad_forms/genusherm/#genus_representatives-Tuple{HermLat}","page":"Genera for hermitian lattices","title":"genus_representatives","text":"genus_representatives(L::HermLat; max = inf, use_auto = true,\n                                             use_mass = false)\n                                                      -> Vector{HermLat}\n\nReturn representatives for the isometry classes in the genus of the hermitian lattice L. At most max representatives are returned.\n\nIf L is definite, the use of the automorphism group of L is enabled by default. It can be disabled by use_auto = false. In the case where L is indefinite, the entry use_auto has no effect. The computation of the mass can be enabled by use_mass = true.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/quad_forms/genusherm/#Examples-9","page":"Genera for hermitian lattices","title":"Examples","text":"","category":"section"},{"location":"Hecke/manual/quad_forms/genusherm/","page":"Genera for hermitian lattices","title":"Genera for hermitian lattices","text":"using Hecke # hide\nQx, x = QQ[\"x\"];\nK, a = number_field(x^2 - 2, \"a\");\nKt, t  = K[\"t\"];\nE, b = number_field(t^2 - a, \"b\");\nOK = maximal_order(K);\np = prime_decomposition(OK, 2)[1][1];\ng1 = genus(HermLat, E, p, [(0, 1, 1, 0), (2, 2, -1, 1)], type = :det);\nSEK = unique([restrict(r, K) for r in infinite_places(E) if isreal(restrict(r, K)) && !isreal(r)]);\nG1 = genus([g1], [(SEK[1], 1)]);\nL1 = representative(g1)\nL1 in g1\nL2 = representative(G1)\nL2 in G1, L2 in g1\nlength(genus_representatives(L1))\nlength(representatives(G1))","category":"page"},{"location":"Hecke/manual/quad_forms/genusherm/","page":"Genera for hermitian lattices","title":"Genera for hermitian lattices","text":"","category":"page"},{"location":"Hecke/manual/quad_forms/genusherm/#Sum-of-genera","page":"Genera for hermitian lattices","title":"Sum of genera","text":"","category":"section"},{"location":"Hecke/manual/quad_forms/genusherm/","page":"Genera for hermitian lattices","title":"Genera for hermitian lattices","text":"direct_sum(::HermLocalGenus, ::HermLocalGenus)\ndirect_sum(::HermGenus, ::HermGenus)","category":"page"},{"location":"Hecke/manual/quad_forms/genusherm/#direct_sum-Tuple{HermLocalGenus, HermLocalGenus}","page":"Genera for hermitian lattices","title":"direct_sum","text":"direct_sum(g1::HermLocalGenus, g2::HermLocalGenus) -> HermLocalGenus\n\nGiven two local genus symbols g1 and g2 for hermitian lattices over EK at the same prime ideal mathfrak p of mathcal O_K, return their direct sum. It corresponds to the local genus symbol of the mathfrak p-adic completion of the direct sum of respective representatives of g1 and g2.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/quad_forms/genusherm/#direct_sum-Tuple{HermGenus, HermGenus}","page":"Genera for hermitian lattices","title":"direct_sum","text":"direct_sum(G1::HermGenus, G2::HermGenus) -> HermGenus\n\nGiven two global genus symbols G1 and G2 for hermitian lattices over EK, return their direct sum. It corresponds to the global genus symbol of the direct sum of respective representatives of G1 and G2.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/quad_forms/genusherm/#Examples-10","page":"Genera for hermitian lattices","title":"Examples","text":"","category":"section"},{"location":"Hecke/manual/quad_forms/genusherm/","page":"Genera for hermitian lattices","title":"Genera for hermitian lattices","text":"using Hecke # hide\nQx, x = QQ[\"x\"];\nK, a = number_field(x^2 - 2, \"a\");\nKt, t  = K[\"t\"];\nE, b = number_field(t^2 - a, \"b\");\nOK = maximal_order(K);\np = prime_decomposition(OK, 2)[1][1];\ng1 = genus(HermLat, E, p, [(0, 1, 1, 0), (2, 2, -1, 1)], type = :det);\nSEK = unique([restrict(r, K) for r in infinite_places(E) if isreal(restrict(r, K)) && !isreal(r)]);\nG1 = genus([g1], [(SEK[1], 1)]);\nD = matrix(E, 3, 3, [5//2*a - 4, 0, 0, 0, a, a, 0, a, -4*a + 8]);\ngens = Vector{Hecke.RelSimpleNumFieldElem{AbsSimpleNumFieldElem}}[map(E, [1, 0, 0]), map(E, [a, 0, 0]), map(E, [b, 0, 0]), map(E, [a*b, 0, 0]), map(E, [0, 1, 0]), map(E, [0, a, 0]), map(E, [0, b, 0]), map(E, [0, a*b, 0]), map(E, [0, 0, 1]), map(E, [0, 0, a]), map(E, [0, 0, b]), map(E, [0, 0, a*b])];\nL = hermitian_lattice(E, gens, gram = D);\ng2 = genus(L, p);\nG2 = genus(L);\ndirect_sum(g1, g2)\ndirect_sum(G1, G2)","category":"page"},{"location":"Hecke/manual/quad_forms/genusherm/","page":"Genera for hermitian lattices","title":"Genera for hermitian lattices","text":"","category":"page"},{"location":"Hecke/manual/quad_forms/genusherm/#Enumeration-of-genera","page":"Genera for hermitian lattices","title":"Enumeration of genera","text":"","category":"section"},{"location":"Hecke/manual/quad_forms/genusherm/","page":"Genera for hermitian lattices","title":"Genera for hermitian lattices","text":"hermitian_local_genera(E, p, ::Int, ::Int, ::Int, ::Int)\nhermitian_genera(::Hecke.RelSimpleNumField, ::Int, ::Dict{InfPlc, Int}, ::Union{Hecke.RelNumFieldOrderIdeal, Hecke.RelNumFieldOrderFractionalIdeal})","category":"page"},{"location":"Hecke/manual/quad_forms/genusherm/#hermitian_local_genera-Tuple{Any, Any, Vararg{Int64, 4}}","page":"Genera for hermitian lattices","title":"hermitian_local_genera","text":"hermitian_local_genera(E::NumField, p::AbsNumFieldOrderIdeal{AbsSimpleNumField, AbsSimpleNumFieldElem}, rank::Int,\n                       det_val::Int, min_scale::Int, max_scale::Int)\n                                                  -> Vector{HermLocalGenus}\n\nReturn all local genus symbols for hermitian lattices over the algebra E, with base field K, at the prime idealp of mathcal O_K. Each of them has rank equal to rank, scale mathfrak P-valuations bounded between min_scale and max_scale and determinant p-valuations equal to det_val, where mathfrak P is a prime ideal of mathcal O_E lying above p.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/quad_forms/genusherm/#hermitian_genera-Tuple{Hecke.RelSimpleNumField, Int64, Dict{InfPlc, Int64}, Union{Hecke.RelNumFieldOrderFractionalIdeal, Hecke.RelNumFieldOrderIdeal}}","page":"Genera for hermitian lattices","title":"hermitian_genera","text":"hermitian_genera(E::NumField, rank::Int,\n                              signatures::Dict{InfPlc, Int},\n                              determinant::Union{Hecke.RelNumFieldOrderIdeal, Hecke.RelNumFieldOrderFractionalIdeal};\n                              min_scale::Union{Hecke.RelNumFieldOrderIdeal, Hecke.RelNumFieldOrderFractionalIdeal} = is_integral(determinant) ? inv(1*order(determinant)) : determinant,\n                              max_scale::Union{Hecke.RelNumFieldOrderIdeal, Hecke.RelNumFieldOrderFractionalIdeal} = is_integral(determinant) ? determinant : inv(1*order(determinant)))\n                                                                                                             -> Vector{HermGenus}\n\nReturn all global genus symbols for hermitian lattices over the algebraE with rank rank, signatures given by signatures, scale bounded by max_scale and determinant class equal to determinant.\n\nIf max_scale == nothing, it is set to be equal to determinant.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/quad_forms/genusherm/#Examples-11","page":"Genera for hermitian lattices","title":"Examples","text":"","category":"section"},{"location":"Hecke/manual/quad_forms/genusherm/","page":"Genera for hermitian lattices","title":"Genera for hermitian lattices","text":"using Hecke # hide\nK, a = cyclotomic_real_subfield(8, \"a\");\nKt, t = K[\"t\"];\nE, b = number_field(t^2 - a * t + 1);\np = prime_decomposition(maximal_order(K), 2)[1][1];\nhermitian_local_genera(E, p, 4, 2, 0, 4)\nSEK = unique([restrict(r, K) for r in infinite_places(E) if isreal(restrict(r, K)) && !isreal(r)]);\nhermitian_genera(E, 3, Dict(SEK[1] => 1, SEK[2] => 1), 30 * maximal_order(E))","category":"page"},{"location":"Hecke/manual/quad_forms/genusherm/#Rescaling","page":"Genera for hermitian lattices","title":"Rescaling","text":"","category":"section"},{"location":"Hecke/manual/quad_forms/genusherm/","page":"Genera for hermitian lattices","title":"Genera for hermitian lattices","text":"rescale(g::HermLocalGenus, a::Union{FieldElem, RationalUnion})\nrescale(G::HermGenus, a::Union{FieldElem, RationalUnion})","category":"page"},{"location":"Hecke/manual/quad_forms/genusherm/#rescale-Tuple{HermLocalGenus, Union{FieldElem, Integer, ZZRingElem, Rational}}","page":"Genera for hermitian lattices","title":"rescale","text":"rescale(g::HermLocalGenus, a::Union{FieldElem, RationalUnion})\n                                                          -> HermLocalGenus\n\nGiven a local genus symbol G of hermitian lattices and an element a lying in the base field E of g, return the local genus symbol at the prime ideal p associated to g of any representative of g rescaled by a.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/quad_forms/genusherm/#rescale-Tuple{HermGenus, Union{FieldElem, Integer, ZZRingElem, Rational}}","page":"Genera for hermitian lattices","title":"rescale","text":"rescale(G::HermGenus, a::Union{FieldElem, RationalUnion}) -> HermGenus\n\nGiven a global genus symbol G of hermitian lattices and an element a lying in the base field E of G, return the global genus symbol of any representative of G rescaled by a.\n\n\n\n\n\n","category":"method"},{"location":"AbstractAlgebra/module_homomorphism/","page":"Module Homomorphisms","title":"Module Homomorphisms","text":"CurrentModule = AbstractAlgebra\nDocTestSetup = AbstractAlgebra.doctestsetup()","category":"page"},{"location":"AbstractAlgebra/module_homomorphism/#Module-Homomorphisms","page":"Module Homomorphisms","title":"Module Homomorphisms","text":"","category":"section"},{"location":"AbstractAlgebra/module_homomorphism/","page":"Module Homomorphisms","title":"Module Homomorphisms","text":"Abstract Algebra provides homomorphisms of finitely presented modules.","category":"page"},{"location":"AbstractAlgebra/module_homomorphism/#Generic-module-homomorphism-types","page":"Module Homomorphisms","title":"Generic module homomorphism types","text":"","category":"section"},{"location":"AbstractAlgebra/module_homomorphism/","page":"Module Homomorphisms","title":"Module Homomorphisms","text":"AbstractAlgebra defines two module homomorphism types, namely Generic.ModuleHomomorphism and Generic.ModuleIsomorphism. Functionality for these is implemented in src/generic/ModuleHomomorphism.jl.","category":"page"},{"location":"AbstractAlgebra/module_homomorphism/#Abstract-types","page":"Module Homomorphisms","title":"Abstract types","text":"","category":"section"},{"location":"AbstractAlgebra/module_homomorphism/","page":"Module Homomorphisms","title":"Module Homomorphisms","text":"The Generic.ModuleHomomorphism and Generic.ModuleIsomorphism types inherit from Map(FPModuleHomomorphism).","category":"page"},{"location":"AbstractAlgebra/module_homomorphism/#Generic-functionality","page":"Module Homomorphisms","title":"Generic functionality","text":"","category":"section"},{"location":"AbstractAlgebra/module_homomorphism/","page":"Module Homomorphisms","title":"Module Homomorphisms","text":"The following generic functionality is provided for module homomorphisms.","category":"page"},{"location":"AbstractAlgebra/module_homomorphism/#Constructors","page":"Module Homomorphisms","title":"Constructors","text":"","category":"section"},{"location":"AbstractAlgebra/module_homomorphism/","page":"Module Homomorphisms","title":"Module Homomorphisms","text":"Homomorphisms of AbstractAlgebra modules, f  R^s to R^t, can be represented by stimes t matrices over R.","category":"page"},{"location":"AbstractAlgebra/module_homomorphism/","page":"Module Homomorphisms","title":"Module Homomorphisms","text":"ModuleHomomorphism(M1::FPModule{T}, M2::FPModule{T}, m::MatElem{T}) where T <: RingElement","category":"page"},{"location":"AbstractAlgebra/module_homomorphism/#ModuleHomomorphism-Union{Tuple{T}, Tuple{AbstractAlgebra.FPModule{T}, AbstractAlgebra.FPModule{T}, MatElem{T}}} where T<:RingElement","page":"Module Homomorphisms","title":"ModuleHomomorphism","text":"ModuleHomomorphism(M1::FPModule{T},\n                   M2::FPModule{T}, m::MatElem{T}) where T <: RingElement\n\nCreate the homomorphism f  M_1 to M_2 represented by the matrix m.\n\n\n\n\n\n","category":"method"},{"location":"AbstractAlgebra/module_homomorphism/","page":"Module Homomorphisms","title":"Module Homomorphisms","text":"ModuleIsomorphism(M1::FPModule{T}, M2::FPModule{T}, m::MatElem{T}) where T <: RingElement","category":"page"},{"location":"AbstractAlgebra/module_homomorphism/#ModuleIsomorphism-Union{Tuple{T}, Tuple{AbstractAlgebra.FPModule{T}, AbstractAlgebra.FPModule{T}, MatElem{T}}} where T<:RingElement","page":"Module Homomorphisms","title":"ModuleIsomorphism","text":"ModuleIsomorphism(M1::FPModule{T}, M2::FPModule{T}, M::MatElem{T},\n                  minv::MatElem{T}) where T <: RingElement\n\nCreate the isomorphism f  M_1 to M_2 represented by the matrix M. The inverse morphism is automatically computed.\n\n\n\n\n\n","category":"method"},{"location":"AbstractAlgebra/module_homomorphism/","page":"Module Homomorphisms","title":"Module Homomorphisms","text":"Examples","category":"page"},{"location":"AbstractAlgebra/module_homomorphism/","page":"Module Homomorphisms","title":"Module Homomorphisms","text":"julia> M = free_module(ZZ, 2)\nFree module of rank 2 over integers\n\njulia> f = ModuleHomomorphism(M, M, matrix(ZZ, 2, 2, [1, 2, 3, 4]))\nModule homomorphism\n  from free module of rank 2 over integers\n  to free module of rank 2 over integers\n\njulia> m = M([ZZ(1), ZZ(2)])\n(1, 2)\n\njulia> f(m)\n(7, 10)\n","category":"page"},{"location":"AbstractAlgebra/module_homomorphism/","page":"Module Homomorphisms","title":"Module Homomorphisms","text":"They can also be created by giving images (in the codomain) of the generators of the domain:","category":"page"},{"location":"AbstractAlgebra/module_homomorphism/","page":"Module Homomorphisms","title":"Module Homomorphisms","text":"ModuleHomomorphism(M1::FPModule{T}, M2::FPModule{T}, v::Vector{<:FPModuleElem{T}}) where T <: RingElement","category":"page"},{"location":"AbstractAlgebra/module_homomorphism/#Kernels","page":"Module Homomorphisms","title":"Kernels","text":"","category":"section"},{"location":"AbstractAlgebra/module_homomorphism/","page":"Module Homomorphisms","title":"Module Homomorphisms","text":"kernel(f::Map(FPModuleHomomorphism))","category":"page"},{"location":"AbstractAlgebra/module_homomorphism/#kernel-Tuple{Map{D, C, <:AbstractAlgebra.FPModuleHomomorphism, T} where {D, C, T}}","page":"Module Homomorphisms","title":"kernel","text":"kernel(f::ModuleHomomorphism{T}) where T <: RingElement\n\nReturn a pair K, g consisting of the kernel object K of the given module homomorphism f (as a submodule of its domain) and the canonical injection from the kernel into the domain of f.\n\n\n\n\n\n","category":"method"},{"location":"AbstractAlgebra/module_homomorphism/","page":"Module Homomorphisms","title":"Module Homomorphisms","text":"Examples","category":"page"},{"location":"AbstractAlgebra/module_homomorphism/","page":"Module Homomorphisms","title":"Module Homomorphisms","text":"julia> M = free_module(ZZ, 3)\nFree module of rank 3 over integers\n\njulia> m = M([ZZ(1), ZZ(2), ZZ(3)])\n(1, 2, 3)\n\njulia> S, f = sub(M, [m])\n(Submodule over integers with 1 generator and no relations, Hom: S -> M)\n\njulia> Q, g = quo(M, S)\n(Quotient module over integers with 2 generators and no relations, Hom: M -> Q)\n\njulia> kernel(g)\n(Submodule over integers with 1 generator and no relations, Hom: submodule over integers with 1 generator and no relations -> M)\n","category":"page"},{"location":"AbstractAlgebra/module_homomorphism/#Images","page":"Module Homomorphisms","title":"Images","text":"","category":"section"},{"location":"AbstractAlgebra/module_homomorphism/","page":"Module Homomorphisms","title":"Module Homomorphisms","text":"image(::Map(FPModuleHomomorphism))","category":"page"},{"location":"AbstractAlgebra/module_homomorphism/#image-Tuple{Map{D, C, <:AbstractAlgebra.FPModuleHomomorphism, T} where {D, C, T}}","page":"Module Homomorphisms","title":"image","text":"image(f::Map(FPModuleHomomorphism))\n\nReturn a pair I, g consisting of the image object I of the given module homomorphism f (as a submodule of its codomain) and the canonical injection from the image into the codomain of f\n\n\n\n\n\n","category":"method"},{"location":"AbstractAlgebra/module_homomorphism/","page":"Module Homomorphisms","title":"Module Homomorphisms","text":"M = free_module(ZZ, 3)\n\nm = M([ZZ(1), ZZ(2), ZZ(3)])\n\nS, f = sub(M, [m])\nQ, g = quo(M, S)\nK, k = kernel(g)\n\nimage(compose(k, g))","category":"page"},{"location":"AbstractAlgebra/module_homomorphism/#Preimages","page":"Module Homomorphisms","title":"Preimages","text":"","category":"section"},{"location":"AbstractAlgebra/module_homomorphism/","page":"Module Homomorphisms","title":"Module Homomorphisms","text":"preimage(::Map(FPModuleHomomorphism), ::FPModuleElem{T}) where T <: RingElement","category":"page"},{"location":"AbstractAlgebra/module_homomorphism/#preimage-Union{Tuple{T}, Tuple{Map{D, C, <:AbstractAlgebra.FPModuleHomomorphism, T} where {D, C, T}, AbstractAlgebra.FPModuleElem{T}}} where T<:RingElement","page":"Module Homomorphisms","title":"preimage","text":"preimage(f::Map(FPModuleHomomorphism),\n         v::FPModuleElem{T}) where T <: RingElement\n\nReturn a preimage of v under the homomorphism f, i.e. an element of the domain of f that maps to v under f. Note that this has no special mathematical properties. It is an element of the set theoretical preimage of the map f as a map of sets, if one exists. The preimage is neither unique nor chosen in a canonical way in general. When no such element exists, an exception is raised.\n\n\n\n\n\n","category":"method"},{"location":"AbstractAlgebra/module_homomorphism/","page":"Module Homomorphisms","title":"Module Homomorphisms","text":"M = free_module(ZZ, 3)\n\nm = M([ZZ(1), ZZ(2), ZZ(3)])\n\nS, f = sub(M, [m])\nQ, g = quo(M, S)\n\nm = rand(M, -10:10)\nn = g(m)\n\np = preimage(g, n)","category":"page"},{"location":"AbstractAlgebra/module_homomorphism/#Inverses","page":"Module Homomorphisms","title":"Inverses","text":"","category":"section"},{"location":"AbstractAlgebra/module_homomorphism/","page":"Module Homomorphisms","title":"Module Homomorphisms","text":"Module isomorphisms can be cheaply inverted.","category":"page"},{"location":"AbstractAlgebra/module_homomorphism/","page":"Module Homomorphisms","title":"Module Homomorphisms","text":"Base.inv(::Map(Generic.ModuleIsomorphism))","category":"page"},{"location":"AbstractAlgebra/module_homomorphism/#inv-Tuple{Map{AbstractAlgebra.FPModule{T}, AbstractAlgebra.FPModule{T}, AbstractAlgebra.FPModuleHomomorphism, AbstractAlgebra.Generic.ModuleIsomorphism} where T<:RingElement}","page":"Module Homomorphisms","title":"inv","text":"Base.inv(f::Map(ModuleIsomorphism))\n\nReturn the inverse map of the given module isomorphism. This is computed cheaply.\n\n\n\n\n\n","category":"method"},{"location":"AbstractAlgebra/module_homomorphism/","page":"Module Homomorphisms","title":"Module Homomorphisms","text":"M = free_module(ZZ, 2)\nN = matrix(ZZ, 2, 2, BigInt[1, 0, 0, 1])\nf = ModuleIsomorphism(M, M, N)\n\ng = inv(f)","category":"page"},{"location":"Groups/group_characters/","page":"Group characters","title":"Group characters","text":"CurrentModule = Oscar\nDocTestSetup = Oscar.doctestsetup()","category":"page"},{"location":"Groups/group_characters/#Group-characters","page":"Group characters","title":"Group characters","text":"","category":"section"},{"location":"Groups/group_characters/","page":"Group characters","title":"Group characters","text":"Let G be a finite group, and let rho G to GL(n R) be a group homomorphism, for some ring R. We call chi G to R, defined by chi(g) = Trace(rho(g)), the character afforded by rho.","category":"page"},{"location":"Groups/group_characters/","page":"Group characters","title":"Group characters","text":"Since chi is constant on conjugacy classes of G, it can be represented by an array l of values such that the value on the i-th conjugacy class of G (see conjugacy_classes) is stored at li. Note that this makes sense only if we assume that the ordering of conjugacy classes of G is fixed once the classes have been computed.","category":"page"},{"location":"Groups/group_characters/","page":"Group characters","title":"Group characters","text":"We deal only with the cases that either R can be embedded into some number field, or that R is a finite field.","category":"page"},{"location":"Groups/group_characters/","page":"Group characters","title":"Group characters","text":"In the former case, the eigenvalues of the matrix rho(g), for g in G, are k-th roots of unity, where k is the order of g, thus all values of chi can be represented by elements in the abelian closure of the field of rational numbers, see abelian_closure. The characters obtained this way are called ordinary characters.","category":"page"},{"location":"Groups/group_characters/","page":"Group characters","title":"Group characters","text":"In the latter case, the list of traces of rho(g) (the so-called Frobenius character of rho) is often not so interesting; instead, one considers the Brauer character of rho, which is defined on (conjugacy classes of) elements g whose order is coprime to the characteristic of R (the so-called p-regular elements resp. classes), by first lifting the eigenvalues of rho(g) to complex roots of unity and then summing up these roots; this way, one gets again a list of values in the abelian closure of the field of rationals.","category":"page"},{"location":"Groups/group_characters/","page":"Group characters","title":"Group characters","text":"The pointwise sum and product of two characters are again characters, they are afforded by the direct sum and the tensor product of the underlying representations. A character that is not the sum of two characters is called absolutely irreducible.","category":"page"},{"location":"Groups/group_characters/#Character-tables","page":"Group characters","title":"Character tables","text":"","category":"section"},{"location":"Groups/group_characters/","page":"Group characters","title":"Group characters","text":"Putting the values of the absolutely irreducible ordinary characters of a group G into an array such that the rows correspond to the characters and the columns correspond to the conjugacy classes yields the ordinary character table of G, which is in fact a square matrix. Analogously, the absolutely irreducible Brauer characters of G, for a given characteristic p, yield a square matrix, the p-modular Brauer character table.","category":"page"},{"location":"Groups/group_characters/","page":"Group characters","title":"Group characters","text":"Ordinary character tables can be computed with character_table from a given group. The computation of p-modular Brauer tables is currently restricted to the case of p-solvable groups.","category":"page"},{"location":"Groups/group_characters/","page":"Group characters","title":"Group characters","text":"Character tables contain a lot of information about their groups, many questions about a finite group can be answered by computations only with its characters. Thus it makes sense to deal also with character tables without an explicit labeling of the columns of the table by conjugacy classes of a group. For example, the character tables shown in the Atlas of Finite Groups [CCNPW85] and from the Atlas of Brauer Characters [JLPW95] are available in OSCAR. Such character tables can be fetched with character_table(id::String, p::Int = 0) from the database, via their names. Moreover, the library of character tables can be used similar to group libraries (see Group libraries) in the sense that all_character_table_names returns descriptions of all those available character tables that have certain properties.","category":"page"},{"location":"Groups/group_characters/","page":"Group characters","title":"Group characters","text":"In OSCAR, a character table t is identified with the array of absolutely irreducible characters of G, in the sense that t[i] yields the i-th irreducible character of G, and t[i, j] is the value of this character on the j-th conjugacy class of G (or the j-th conjugacy class of p-regular elements in the case of Brauer tables).","category":"page"},{"location":"Groups/group_characters/","page":"Group characters","title":"Group characters","text":"Ordinary and p-modular Brauer tables in OSCAR are distinguished by their characteristic(tbl::GAPGroupCharacterTable); its value is 0 for ordinary tables and p otherwise.","category":"page"},{"location":"Groups/group_characters/","page":"Group characters","title":"Group characters","text":"The character table to which a character chi belongs can be fetched as parent(chi).","category":"page"},{"location":"Groups/group_characters/","page":"Group characters","title":"Group characters","text":"GAPGroupCharacterTable\ncharacter_table(G::Union{GAPGroup, FinGenAbGroup}, p::T = 0) where T <: IntegerUnion\ncharacter_table(id::String, p::Int = 0)\ncharacter_table(series::Symbol, parameter::Union{Int, Vector{Int}})\nBase.show(io::IO, ::MIME\"text/plain\", tbl::GAPGroupCharacterTable)\ncharacteristic(tbl::GAPGroupCharacterTable)\nBase.mod(tbl::GAPGroupCharacterTable, p::Int)\nquo(tbl::GAPGroupCharacterTable, nclasses::Vector{Int})\nall_character_table_names\nis_character_table_name","category":"page"},{"location":"Groups/group_characters/#GAPGroupCharacterTable","page":"Group characters","title":"GAPGroupCharacterTable","text":"GAPGroupCharacterTable <: GroupCharacterTable\n\nThis is the type of (ordinary or Brauer) character tables that can delegate tasks to an underlying character table object in the GAP system (field GAPTable).\n\nThe value of the field characteristic determines whether the table is an ordinary one (value 0) or a p-modular one (value p).\n\nA group can (but need not) be stored in the field group. If it is available then also the field isomorphism is available, its value is a bijective map from the group value to a group in GAP.\n\nObjects of type GAPGroupCharacterTable support get_attribute, for example in order to store the already computed p-modular tables in an ordinary table, and to store the corresponding ordinary table in a p-modular table.\n\n\n\n\n\n","category":"type"},{"location":"Groups/group_characters/#character_table-Union{Tuple{Union{FinGenAbGroup, Oscar.GAPGroup}}, Tuple{T}, Tuple{Union{FinGenAbGroup, Oscar.GAPGroup}, T}} where T<:Union{Integer, ZZRingElem}","page":"Group characters","title":"character_table","text":"character_table(G::GAPGroup, p::T = 0) where T <: IntegerUnion\n\nReturn the ordinary (if p == 0) or p-modular character table of the finite group G. If the p-modular character table of G cannot be computed by GAP then nothing is returned.\n\nExamples\n\njulia> Oscar.with_unicode() do\n         show(stdout, MIME(\"text/plain\"), character_table(symmetric_group(3)))\n       end;\nCharacter table of Sym(3)\n\n 2  1  1  .\n 3  1  .  1\n\n   1a 2a 3a\n2P 1a 1a 3a\n3P 1a 2a 1a\n\nχ₁  1 -1  1\nχ₂  2  . -1\nχ₃  1  1  1\n\njulia> Oscar.with_unicode() do\n         show(stdout, MIME(\"text/plain\"), character_table(symmetric_group(3), 2))\n       end;\n2-modular Brauer table of Sym(3)\n\n 2  1  .\n 3  1  1\n\n   1a 3a\n2P 1a 3a\n3P 1a 1a\n\nχ₁  1  1\nχ₂  2 -1\n\n\n\n\n\n","category":"method"},{"location":"Groups/group_characters/#character_table","page":"Group characters","title":"character_table","text":"character_table(id::String, p::Int = 0)\n\nReturn the ordinary (if p == 0) or p-modular character table for which id is an admissible name in GAP's library of character tables. If no such table is available then nothing is returned.\n\nExamples\n\njulia> println(character_table(\"A5\"))\ncharacter table of A5\n\njulia> println(character_table(\"A5\", 2))\n2-modular Brauer table of A5\n\njulia> println(character_table(\"J5\"))\nnothing\n\nSeveral names can be admissible for the same character table from the library. For example, the alternating group on five points is isomorphic to the projective special linear groups in dimension 2 over the fields with four or five elements, and each of the strings \"A5\", \"L2(4)\", \"L2(5)\" is an admissible name for its library character table. The names are not case sensitive, thus also \"a5\" is admissible.\n\nUse all_character_table_names for creating a vector that contains one admissible name for each available character table, perhaps filtered by some conditions.\n\n\n\n\n\n","category":"function"},{"location":"Groups/group_characters/#character_table-Tuple{Symbol, Union{Int64, Vector{Int64}}}","page":"Group characters","title":"character_table","text":"character_table(series::Symbol, parameter::Any)\n\nReturn the ordinary character table of the group described by the series series and the parameter parameter.\n\nExamples\n\njulia> println(character_table(:Symmetric, 5))\ncharacter table of Sym(5)\n\njulia> println(character_table(:WeylB, 3))\ncharacter table of W(B3)\n\nCurrently the following series are supported.\n\nSeries Parameter\n:Cyclic pos. integer\n:Dihedral even pos. integer\n:Symmetric pos. integer\n:Alternating integer > 1\n:WeylB pos. integer\n:WeylD integer > 1\n:DoubleCoverSymmetric pos. integer\n:DoubleCoverAlternating pos. integer\n:GL2 prime power\n:SL2odd odd prime power\n:SL2even even prime power\n:PSL2odd odd prime power q s. t. (q-1)/2 is odd\n:PSL2even odd prime power q s. t. (q-1)/2 is even\n:Suzuki odd power of 2\n:GU3 prime power\n:SU3 prime power\nSymbol(\"P:Q\") vector [p, q] with prime p and q dividing p-1\n:ExtraspecialPlusOdd odd power of odd prime\n\n\n\n\n\n","category":"method"},{"location":"Groups/group_characters/#show-Tuple{IO, MIME{Symbol(\"text/plain\")}, Oscar.GAPGroupCharacterTable}","page":"Group characters","title":"show","text":"Base.show(io::IO, ::MIME\"text/plain\", tbl::GAPGroupCharacterTable)\n\nDisplay the irreducible characters of tbl and context information as a two-dimensional array.\n\nFirst a header is shown. If tbl stores a group then the header describes this group, otherwise it is equal to the identifier(tbl::GAPGroupCharacterTable) value of tbl.\nThen the irreducible characters of tbl are shown in column portions that fit on the screen, together with column labels above each portion and row labels on the left of each portion.\nThe column labels consist of the factored centralizer orders (see orders_centralizers, one row for each prime divisor of the group order), followed by one row showing the class names (see class_names), followed by the power maps (one row for each stored power map).\nThe row labels are X_1, X_2, ... (or χ with subscripts 1, 2, ... if unicode output is allowed). If io is an IOContext with key :indicator set to true then a second column of row labels shows the 2nd Frobenius-Schur indicator of the irreducibles (see indicator); analogously, setting the key :character_field to true yields a column showing the degrees of the character fields (see character_field), and setting the key :OD to true yields a column showing the known orthogonal discriminants of those irreducibles that have indicator + and even degree.\nDepending on the way how irrational character values are shown, a footer may be shown in the end. By default, irrationalities are shown as sums of roots of unity, where z_n (or ζ with subscript n if unicode output is allowed) denotes the primitive n-th root exp(2 pi in). If io is an IOContext with key :with_legend set to true then irrationalities are abbreviated as A, B, ..., and these names together with the corresponding expression as sums of roots of unity appear in the footer.\n\nOutput in LaTeX syntax can be created by calling show with second argument MIME(\"text/latex\").\n\nExamples\n\njulia> tbl = character_table(:Cyclic, 3);\n\njulia> Oscar.with_unicode() do\n         show(stdout, MIME(\"text/plain\"), tbl)\n       end;\nC3\n\n 3  1       1       1\n                     \n   1a      3a      3b\n3P 1a      1a      1a\n                     \nχ₁  1       1       1\nχ₂  1      ζ₃ -ζ₃ - 1\nχ₃  1 -ζ₃ - 1      ζ₃\n\njulia> Oscar.with_unicode() do\n         show(IOContext(stdout, :with_legend => true), MIME(\"text/plain\"), tbl)\n       end;\nC3\n\n 3  1  1  1\n           \n   1a 3a 3b\n3P 1a 1a 1a\n           \nχ₁  1  1  1\nχ₂  1  A  A̅\nχ₃  1  A̅  A\n\nA = ζ₃\nA̅ = -ζ₃ - 1\n\njulia> Oscar.with_unicode() do\n         show(IOContext(stdout, :indicator => true), MIME(\"text/plain\"), tbl)\n       end;\nC3\n\n    3  1       1       1\n                        \n      1a      3a      3b\n   3P 1a      1a      1a\n    2                   \nχ₁  +  1       1       1\nχ₂  o  1      ζ₃ -ζ₃ - 1\nχ₃  o  1 -ζ₃ - 1      ζ₃\n\njulia> Oscar.with_unicode() do\n         show(IOContext(stdout, :character_field => true), MIME(\"text/plain\"), tbl)\n       end;\nC3\n\n    3  1       1       1\n                        \n      1a      3a      3b\n   2P 1a      3b      3a\n   3P 1a      1a      1a\n    d                   \nχ₁  1  1       1       1\nχ₂  2  1      ζ₃ -ζ₃ - 1\nχ₃  2  1 -ζ₃ - 1      ζ₃\n\njulia> Oscar.with_unicode() do\n         show(IOContext(stdout, :with_legend => true), MIME(\"text/latex\"), tbl)\n       end;\nC3\n\n$\\begin{array}{rrrr}\n3 & 1 & 1 & 1 \\\\\n &  &  &  \\\\\n & 1a & 3a & 3b \\\\\n2P & 1a & 3b & 3a \\\\\n3P & 1a & 1a & 1a \\\\\n &  &  &  \\\\\n\\chi_{1} & 1 & 1 & 1 \\\\\n\\chi_{2} & 1 & A & \\overline{A} \\\\\n\\chi_{3} & 1 & \\overline{A} & A \\\\\n\\end{array}\n\n\\begin{array}{l}\nA = \\zeta_{3} \\\\\n\\overline{A} = -\\zeta_{3} - 1 \\\\\n\\end{array}\n$\n\n\n\n\n\n","category":"method"},{"location":"Groups/group_characters/#characteristic-Tuple{Oscar.GAPGroupCharacterTable}","page":"Group characters","title":"characteristic","text":"characteristic(::Type{T} = Int, tbl::GAPGroupCharacterTable) where T <: IntegerUnion\n\nReturn T(0) if tbl is an ordinary character table, and T(p) if tbl is a p-modular character table.\n\nExamples\n\njulia> tbl = character_table(\"A5\");\n\njulia> characteristic(tbl)\n0\n\njulia> characteristic(tbl % 2)\n2\n\n\n\n\n\n","category":"method"},{"location":"Groups/group_characters/#mod-Tuple{Oscar.GAPGroupCharacterTable, Int64}","page":"Group characters","title":"mod","text":"mod(tbl::GAPGroupCharacterTable, p::T) where T <: IntegerUnion\nrem(tbl::GAPGroupCharacterTable, p::T) where T <: IntegerUnion\n\nReturn the p-modular character table of tbl, or nothing if this table cannot be computed.\n\nThe syntax tbl % p is also supported.\n\nAn exception is thrown if tbl is not an ordinary character table.\n\nExamples\n\njulia> show(character_table(\"A5\") % 2)\n2-modular Brauer table of A5\n\n\n\n\n\n","category":"method"},{"location":"Groups/group_characters/#quo-Tuple{Oscar.GAPGroupCharacterTable, Vector{Int64}}","page":"Group characters","title":"quo","text":"quo(tbl::GAPGroupCharacterTable, nclasses::Vector{Int})\n\nReturn the pair (fact, proj) where fact is the character table of the factor of tbl modulo the normal subgroup that is the normal closure of the conjugacy classes whose positions are listed in nclasses, and proj is the class fusion from tbl to fact.\n\nExamples\n\njulia> t = character_table(\"2.A5\");\n\njulia> n = class_positions_of_center(t);  println(n)\n[1, 2]\n\njulia> fact, proj = quo(t, n);\n\njulia> order(fact)\n60\n\njulia> println(proj)\n[1, 1, 2, 3, 3, 4, 4, 5, 5]\n\n\n\n\n\n","category":"method"},{"location":"Groups/group_characters/#all_character_table_names","page":"Group characters","title":"all_character_table_names","text":"all_character_table_names(L...; ordered_by = nothing)\n\nReturn a vector of strings that contains an admissible name of each character table in the character table library that satisfies the conditions in the vector L.\n\nExamples\n\njulia> spor_names = all_character_table_names(is_sporadic_simple => true,\n         is_duplicate_table => false);\n\njulia> println(spor_names[1:5])\n[\"B\", \"Co1\", \"Co2\", \"Co3\", \"F3+\"]\n\njulia> spor_names = all_character_table_names(is_sporadic_simple,\n         !is_duplicate_table; ordered_by = order);\n\njulia> println(spor_names[1:5])\n[\"M11\", \"M12\", \"J1\", \"M22\", \"J2\"]\n\njulia> length(all_character_table_names(number_of_conjugacy_classes => 1))\n1\n\n\n\n\n\n","category":"function"},{"location":"Groups/group_characters/#is_character_table_name","page":"Group characters","title":"is_character_table_name","text":"is_character_table_name(name::String)\n\nReturn true if character_table(name) returns a character table, and false otherwise\n\nExamples\n\njulia> is_character_table_name(\"J1\")\ntrue\n\njulia> is_character_table_name(\"J5\")\nfalse\n\n\n\n\n\n","category":"function"},{"location":"Groups/group_characters/#Attributes-of-group-characters","page":"Group characters","title":"Attributes of group characters","text":"","category":"section"},{"location":"Groups/group_characters/","page":"Group characters","title":"Group characters","text":"character_field\nconductor(chi::GAPGroupClassFunction)\nconj(chi::GAPGroupClassFunction)\nNemo.degree(chi::GAPGroupClassFunction)\ngalois_orbit_sum\nindicator\nis_faithful(chi::GAPGroupClassFunction)\nis_rational(chi::GAPGroupClassFunction)\nis_irreducible(chi::GAPGroupClassFunction)\nschur_index(chi::GAPGroupClassFunction, recurse::Bool = true)\ndet(chi::GAPGroupClassFunction)\norder(chi::GAPGroupClassFunction)\norder_field_of_definition(chi::GAPGroupClassFunction)","category":"page"},{"location":"Groups/group_characters/#character_field","page":"Group characters","title":"character_field","text":"character_field(chi::GAPGroupClassFunction)\n\nIf chi is an ordinary character then return the pair (F, phi) where F is a number field that is generated by the character values of chi, and phi is the embedding of F into abelian_closure(QQ).\n\nIf chi is a Brauer character in characteristic p then return the pair (F, phi) where F is the finite field that is generated by the p-modular reductions of the values of chi, and phi is the identity map on F.\n\nExamples\n\njulia> t = character_table(\"A5\");\n\njulia> character_field(t[2])[1]\nNumber field with defining polynomial x^2 + x - 1\n  over rational field\n\njulia> flds_2 = map(character_field, mod(t, 2));\n\njulia> println([degree(x[1]) for x in flds_2])\n[1, 2, 2, 1]\n\n\n\n\n\n","category":"function"},{"location":"Groups/group_characters/#conductor-Tuple{Oscar.GAPGroupClassFunction}","page":"Group characters","title":"conductor","text":"conductor(::Type{T} = ZZRingElem, chi::GAPGroupClassFunction)\n          where T <: IntegerUnion\n\nReturn the minimal integer n, as an instance of T, such that all values of chi lie in the n-th cyclotomic field.\n\nExamples\n\njulia> tbl = character_table(\"A5\");\n\njulia> println([conductor(chi) for chi in tbl])\nZZRingElem[1, 5, 5, 1, 1]\n\n\n\n\n\n","category":"method"},{"location":"Groups/group_characters/#conj-Tuple{Oscar.GAPGroupClassFunction}","page":"Group characters","title":"conj","text":"conj(chi::GAPGroupClassFunction)\n\nReturn the class function whose values are the complex conjugates of the values of chi.\n\nExamples\n\njulia> tbl = character_table(alternating_group(4));\n\njulia> println([findfirst(==(conj(x)), tbl) for x in tbl])\n[1, 3, 2, 4]\n\n\n\n\n\n","category":"method"},{"location":"Groups/group_characters/#degree-Tuple{Oscar.GAPGroupClassFunction}","page":"Group characters","title":"degree","text":"degree(::Type{T} = QQFieldElem, chi::GAPGroupClassFunction)\n       where T <: Union{IntegerUnion, QQFieldElem, QQAbFieldElem}\n\nReturn chi[1], as an instance of T.\n\n\n\n\n\n","category":"method"},{"location":"Groups/group_characters/#galois_orbit_sum","page":"Group characters","title":"galois_orbit_sum","text":"galois_orbit_sum(chi::GAPGroupClassFunction)\n\nReturn a class function psi. If chi is an ordinary character then psi is the sum of all different Galois conjugates of chi; the values of psi are rationals. If chi is a Brauer character then psi is the sum of all different images of chi under powers of the Frobenius automorphism; thus psi is afforded by a representation over the prime field, but the values of psi need not be rationals.\n\nExamples\n\njulia> t = character_table(\"A5\");\n\njulia> println([degree(character_field(x)[1]) for x in t])\n[1, 2, 2, 1, 1]\n\njulia> println([degree(character_field(galois_orbit_sum(x))[1]) for x in t])\n[1, 1, 1, 1, 1]\n\n\n\n\n\n","category":"function"},{"location":"Groups/group_characters/#indicator","page":"Group characters","title":"indicator","text":"indicator(chi::GAPGroupClassFunction, n::Int = 2)\n\nReturn the n-th Frobenius-Schur indicator of chi, that is, the value (_g  G chi(g^n))G, where G is the group of chi.\n\nIf chi is irreducible then indicator(chi) is 0 if chi is not real-valued, 1 if chi is afforded by a real representation of G, and -1 if chi is real-valued but not afforded by a real representation of G.\n\nExamples\n\njulia> tbl = character_table(\"U3(3)\");\n\njulia> println([indicator(chi) for chi in tbl])\n[1, -1, 1, 0, 0, 1, 1, 0, 0, 1, 0, 0, 0, 0]\n\n\n\n\n\n","category":"function"},{"location":"Groups/group_characters/#is_faithful-Tuple{Oscar.GAPGroupClassFunction}","page":"Group characters","title":"is_faithful","text":"is_faithful(chi::GAPGroupClassFunction)\n\nReturn true if the value of chi at the identity element does not occur as value of chi at any other element, and false otherwise.\n\nIf chi is an ordinary character then true is returned if and only if the representations affording chi have trivial kernel.\n\nExamples\n\njulia> println(map(is_faithful, character_table(symmetric_group(3))))\nBool[0, 1, 0]\n\n\n\n\n\n","category":"method"},{"location":"Groups/group_characters/#is_rational-Tuple{Oscar.GAPGroupClassFunction}","page":"Group characters","title":"is_rational","text":"is_rational(chi::GAPGroupClassFunction)\n\nReturn true if all values of chi are rational, i.e., in QQ, and false otherwise.\n\nExamples\n\njulia> all(is_rational, character_table(symmetric_group(4)))\ntrue\n\njulia> all(is_rational, character_table(alternating_group(4)))\nfalse\n\n\n\n\n\n","category":"method"},{"location":"Groups/group_characters/#is_irreducible-Tuple{Oscar.GAPGroupClassFunction}","page":"Group characters","title":"is_irreducible","text":"is_irreducible(chi::GAPGroupClassFunction)\n\nReturn true if chi is an irreducible character, and false otherwise.\n\nA character is irreducible if it cannot be written as the sum of two characters. For ordinary characters this can be checked using the scalar product of class functions (see scalar_product. For Brauer characters there is no generic method for checking irreducibility.\n\nExamples\n\njulia> g = symmetric_group(4);\n\njulia> all(is_irreducible, character_table(g))\ntrue\n\njulia> is_irreducible(natural_character(g))\nfalse\n\n\n\n\n\n","category":"method"},{"location":"Groups/group_characters/#schur_index","page":"Group characters","title":"schur_index","text":"schur_index(chi::GAPGroupClassFunction) -> Int\n\nFor an ordinary irreducible character chi, return the minimal integer m such that the character m * chi is afforded by a representation over the character field of chi, or throw an exception if the currently used character theoretic criteria do not suffice for computing m.\n\nExamples\n\njulia> t = character_table(quaternion_group(8));\n\njulia> println(map(schur_index, t))\n[1, 1, 1, 1, 2]\n\n\n\n\n\n","category":"function"},{"location":"Groups/group_characters/#det-Tuple{Oscar.GAPGroupClassFunction}","page":"Group characters","title":"det","text":"det(chi::GAPGroupClassFunction)\n\nReturn the determinant character of the character chi. This is defined to be the character obtained by taking the determinant of representing matrices of any representation affording chi.\n\nExamples\n\njulia> t = character_table(symmetric_group(4));\n\njulia> all(chi -> det(chi) == exterior_power(chi, Int(degree(chi))), t)\ntrue\n\n\n\n\n\n","category":"method"},{"location":"Groups/group_characters/#order-Tuple{Oscar.GAPGroupClassFunction}","page":"Group characters","title":"order","text":"order(::Type{T} = ZZRingElem, chi::GAPGroupClassFunction)\n      where T <: IntegerUnion\n\nReturn the determinantal order of the character chi. This is defined to be the multiplicative order of det(chi).\n\nExamples\n\njulia> println([order(chi) for chi in character_table(symmetric_group(4))])\nZZRingElem[2, 1, 2, 2, 1]\n\n\n\n\n\n","category":"method"},{"location":"Groups/group_characters/#order_field_of_definition-Tuple{Oscar.GAPGroupClassFunction}","page":"Group characters","title":"order_field_of_definition","text":"order_field_of_definition(::Type{T} = ZZRingElem, chi::GAPGroupClassFunction) where T <: IntegerUnion\n\nReturn p^n, as an instance of T, if chi is a p-modular Brauer character such that the p-modular reductions of the values of chi span the field with p^n elements.\n\nNote that one need not compute the character_field value of chi in order to compute order_field_of_definition(chi).\n\nExamples\n\njulia> tbl = character_table(\"A5\", 2);\n\njulia> println([order_field_of_definition(chi) for chi in tbl])\nZZRingElem[2, 4, 4, 2]\n\n\n\n\n\n","category":"method"},{"location":"Groups/group_characters/#Attributes-of-character-tables","page":"Group characters","title":"Attributes of character tables","text":"","category":"section"},{"location":"Groups/group_characters/","page":"Group characters","title":"Group characters","text":"block_distribution\ncharacter_parameters\nclass_names(tbl::GAPGroupCharacterTable)\nclass_parameters\nconjugacy_classes(tbl::GAPGroupCharacterTable)\ndecomposition_matrix\nidentifier(tbl::GAPGroupCharacterTable)\ninduced_cyclic(tbl::GAPGroupCharacterTable)\nis_duplicate_table\nmaxes\nnames_of_fusion_sources\nclass_lengths(tbl::GAPGroupCharacterTable)\norders_centralizers\norders_class_representatives(tbl::GAPGroupCharacterTable)\nordinary_table(tbl::GAPGroupCharacterTable)\ntrivial_character(tbl::GAPGroupCharacterTable)\nregular_character(tbl::GAPGroupCharacterTable)\nlinear_characters(tbl::GAPGroupCharacterTable)","category":"page"},{"location":"Groups/group_characters/#block_distribution","page":"Group characters","title":"block_distribution","text":"block_distribution(tbl::GAPGroupCharacterTable, p::IntegerUnion)\n\nReturn a dictionary with the keys :defect (the vector containing at position i the defect of the i-th p-block of tbl) and :block (the vector containing at position i the number j such that tbl[i] belongs to the j-th p-block).\n\nAn exception is thrown if tbl is not an ordinary character table.\n\nExamples\n\njulia> block_distribution(character_table(\"A5\"), 2)\nDict{Symbol, Vector{Int64}} with 2 entries:\n  :block  => [1, 1, 1, 2, 1]\n  :defect => [2, 0]\n\n\n\n\n\n","category":"function"},{"location":"Groups/group_characters/#character_parameters","page":"Group characters","title":"character_parameters","text":"character_parameters(tbl::GAPGroupCharacterTable)\n\nReturn a vector of character parameters for the rows of tbl if such parameters are stored, and nothing otherwise.\n\nExamples\n\njulia> character_parameters(character_table(\"S5\"))\n7-element Vector{Vector{Int64}}:\n [5]\n [1, 1, 1, 1, 1]\n [3, 1, 1]\n [4, 1]\n [2, 1, 1, 1]\n [3, 2]\n [2, 2, 1]\n\njulia> character_parameters(character_table(\"M11\"))\n\n\n\n\n\n","category":"function"},{"location":"Groups/group_characters/#class_names-Tuple{Oscar.GAPGroupCharacterTable}","page":"Group characters","title":"class_names","text":"class_names(tbl::GAPGroupCharacterTable)\n\nReturn a vector of strings corresponding to the columns of tbl. The i-th entry consists of the element order for the i-th column, followed by at least one distinguishing letter. For example, the classes of elements of order two have class names `\"2a\", \"2b\", and so on.\n\nExamples\n\njulia> println(class_names(character_table(\"S5\")))\n[\"1a\", \"2a\", \"3a\", \"5a\", \"2b\", \"4a\", \"6a\"]\n\n\n\n\n\n","category":"method"},{"location":"Groups/group_characters/#class_parameters","page":"Group characters","title":"class_parameters","text":"class_parameters(tbl::GAPGroupCharacterTable)\n\nReturn a vector of class parameters for the columns of tbl if such parameters are stored, and nothing otherwise.\n\nExamples\n\njulia> class_parameters(character_table(\"S5\"))\n7-element Vector{Vector{Int64}}:\n [1, 1, 1, 1, 1]\n [2, 2, 1]\n [3, 1, 1]\n [5]\n [2, 1, 1, 1]\n [4, 1]\n [3, 2]\n\njulia> class_parameters(character_table(\"M11\"))\n\n\n\n\n\n","category":"function"},{"location":"Groups/group_characters/#conjugacy_classes-Tuple{Oscar.GAPGroupCharacterTable}","page":"Group characters","title":"conjugacy_classes","text":"conjugacy_classes(tbl::GAPGroupCharacterTable)\n\nReturn the vector of conjugacy classes of group(tbl), ordered such that they correspond to the columns of tbl.\n\nNote that the vectors conjugacy_classes(group(tbl)) and conjugacy_classes(tbl) are independent. They will usually have the same ordering, but it may happen that they are ordered differently.\n\nAn error is thrown if tbl does not store a group.\n\nExamples\n\njulia> g = symmetric_group(4);  tbl = character_table(g);\n\njulia> [length(c) for c in conjugacy_classes(tbl)] == class_lengths(tbl)\ntrue\n\n\n\n\n\n","category":"method"},{"location":"Groups/group_characters/#decomposition_matrix","page":"Group characters","title":"decomposition_matrix","text":"decomposition_matrix(modtbl::GAPGroupCharacterTable)\n\nReturn the decomposition matrix (of type ZZMatrix) of the Brauer character table modtbl. The rows and columns are indexed by the irreducible characters of the ordinary character table of modtbl and the irreducible characters of modtbl, respectively,\n\nExamples\n\njulia> t = character_table(\"A5\"); t2 = mod(t, 2);\n\njulia> decomposition_matrix(t2)\n[1   0   0   0]\n[1   0   1   0]\n[1   1   0   0]\n[0   0   0   1]\n[1   1   1   0]\n\n\n\n\n\n","category":"function"},{"location":"Groups/group_characters/#identifier-Tuple{Oscar.GAPGroupCharacterTable}","page":"Group characters","title":"identifier","text":"identifier(tbl::GAPGroupCharacterTable)\n\nReturn a string that identifies tbl. It is used mainly for library tables.\n\nExamples\n\njulia> identifier(character_table(\"A5\"))\n\"A5\"\n\n\n\n\n\n","category":"method"},{"location":"Groups/group_characters/#induced_cyclic-Tuple{Oscar.GAPGroupCharacterTable}","page":"Group characters","title":"induced_cyclic","text":"induced_cyclic(tbl::GAPGroupCharacterTable, classes::AbstractVector{Int} = 1:nrows(tbl))\n\nReturn the vector of permutation characters of tbl that are induced from cyclic subgroups. If classes is given then only the cyclic subgroups generated by elements in the classes at positions in this vector are returned.\n\nExamples\n\njulia> t = character_table(\"A5\");\n\njulia> ind = induced_cyclic(t);\n\njulia> all(x -> scalar_product(x, t[1]) == 1, ind)\ntrue\n\n\n\n\n\n","category":"method"},{"location":"Groups/group_characters/#is_duplicate_table","page":"Group characters","title":"is_duplicate_table","text":"is_duplicate_table(tbl::GAPGroupCharacterTable)\n\nReturn whether tbl is an ordinary table from the character table library that was constructed from another library character table by permuting rows and columns.\n\nOne application of this function is to restrict the search with all_character_table_names to only one library character table for each class of permutation equivalent tables.\n\nExamples\n\njulia> is_duplicate_table(character_table(\"A5\"))\nfalse\n\njulia> is_duplicate_table(character_table(\"A6M2\"))\ntrue\n\n\n\n\n\n","category":"function"},{"location":"Groups/group_characters/#maxes","page":"Group characters","title":"maxes","text":"maxes(tbl::GAPGroupCharacterTable)\n\nReturn either nothing (if the value is not known) or a vector of identifiers of the ordinary character tables of all maximal subgroups of tbl. There is no default method to compute this value from tbl.\n\nIf the maxes value of tbl is stored then it lists exactly one representative for each conjugacy class of maximal subgroups of the group of tbl, and the character tables of these maximal subgroups are available in the character table library, and compatible class fusions to tbl are stored on these tables.\n\nExamples\n\njulia> println(maxes(character_table(\"M11\")))\n[\"A6.2_3\", \"L2(11)\", \"3^2:Q8.2\", \"A5.2\", \"2.S4\"]\n\njulia> maxes(character_table(\"M\")) === nothing  # not (yet) known\ntrue\n\n\n\n\n\n","category":"function"},{"location":"Groups/group_characters/#names_of_fusion_sources","page":"Group characters","title":"names_of_fusion_sources","text":"names_of_fusion_sources(tbl::GAPGroupCharacterTable)\n\nReturn the vector of strings that are identifiers of those character tables which store a class fusion to tbl, which must be an ordinary character table.\n\nExamples\n\njulia> tbl = character_table(\"A5\");\n\njulia> println(maxes(tbl))\n[\"a4\", \"D10\", \"S3\"]\n\njulia> all(in(names_of_fusion_sources(tbl)), maxes(tbl))\ntrue\n\n\n\n\n\n","category":"function"},{"location":"Groups/group_characters/#class_lengths-Tuple{Oscar.GAPGroupCharacterTable}","page":"Group characters","title":"class_lengths","text":"class_lengths(tbl::GAPGroupCharacterTable)\n\nExamples\n\njulia> println(class_lengths(character_table(\"A5\")))\nZZRingElem[1, 15, 20, 12, 12]\n\n\n\n\n\n","category":"method"},{"location":"Groups/group_characters/#orders_centralizers","page":"Group characters","title":"orders_centralizers","text":"orders_centralizers(tbl::GAPGroupCharacterTable)\n\nReturn the vector of the orders of centralizers of conjugacy class representatives for tbl in the group of tbl, ordered according to the columns of tbl.\n\nExamples\n\njulia> println(orders_centralizers(character_table(\"A5\")))\nZZRingElem[60, 4, 3, 5, 5]\n\n\n\n\n\n","category":"function"},{"location":"Groups/group_characters/#orders_class_representatives-Tuple{Oscar.GAPGroupCharacterTable}","page":"Group characters","title":"orders_class_representatives","text":"orders_class_representatives(tbl::GAPGroupCharacterTable)\n\nReturn the vector of the orders of conjugacy class representatives for tbl, ordered according to the columns of tbl.\n\nExamples\n\njulia> println(orders_class_representatives(character_table(\"A5\")))\n[1, 2, 3, 5, 5]\n\n\n\n\n\n","category":"method"},{"location":"Groups/group_characters/#ordinary_table-Tuple{Oscar.GAPGroupCharacterTable}","page":"Group characters","title":"ordinary_table","text":"ordinary_table(tbl::GAPGroupCharacterTable)\n\nReturn the ordinary character table of tbl, provided that tbl is a Brauer character table.\n\nExamples\n\njulia> tbl = character_table(\"A5\");\n\njulia> ordinary_table(tbl % 2) === tbl\ntrue\n\n\n\n\n\n","category":"method"},{"location":"Groups/group_characters/#trivial_character-Tuple{Oscar.GAPGroupCharacterTable}","page":"Group characters","title":"trivial_character","text":"trivial_character(tbl::GAPGroupCharacterTable)\n\nReturn the character of tbl that has the value QQAbFieldElem(1) in each position.\n\nExamples\n\njulia> t = character_table(symmetric_group(4));\n\njulia> all(==(1), trivial_character(t))\ntrue\n\n\n\n\n\n","category":"method"},{"location":"Groups/group_characters/#regular_character-Tuple{Oscar.GAPGroupCharacterTable}","page":"Group characters","title":"regular_character","text":"regular_character(tbl::GAPGroupCharacterTable)\n\nReturn the regular character of tbl.\n\nExamples\n\njulia> tbl = character_table(symmetric_group(3));\n\njulia> values(regular_character(tbl))\n3-element Vector{QQAbFieldElem{AbsSimpleNumFieldElem}}:\n 6\n 0\n 0\n\n\n\n\n\n","category":"method"},{"location":"Groups/group_characters/#linear_characters-Tuple{Oscar.GAPGroupCharacterTable}","page":"Group characters","title":"linear_characters","text":"linear_characters(tbl::GAPGroupCharacterTable)\n\nReturn the array of linear characters of tbl, that is, the characters of degree 1.\n\nExamples\n\njulia> tbl = character_table(symmetric_group(3));\n\njulia> length(linear_characters(tbl))\n2\n\n\n\n\n\n","category":"method"},{"location":"Groups/group_characters/","page":"Group characters","title":"Group characters","text":"The following properties of a group can be read off from its character table. Therefore it is supported to call these functions with a character table.","category":"page"},{"location":"Groups/group_characters/","page":"Group characters","title":"Group characters","text":"is_abelian(tbl::GAPGroupCharacterTable)\nis_almost_simple(tbl::GAPGroupCharacterTable)\nis_cyclic(tbl::GAPGroupCharacterTable)\nis_elementary_abelian(tbl::GAPGroupCharacterTable)\nis_nilpotent(tbl::GAPGroupCharacterTable)\nis_perfect(tbl::GAPGroupCharacterTable)\nis_quasisimple(tbl::GAPGroupCharacterTable)\nis_simple(tbl::GAPGroupCharacterTable)\nis_solvable(tbl::GAPGroupCharacterTable)\nis_sporadic_simple(tbl::GAPGroupCharacterTable)\nis_supersolvable(tbl::GAPGroupCharacterTable)","category":"page"},{"location":"Groups/group_characters/#is_abelian-Tuple{Oscar.GAPGroupCharacterTable}","page":"Group characters","title":"is_abelian","text":"is_abelian(tbl::GAPGroupCharacterTable)\n\nReturn whether tbl is the ordinary character table of an abelian group, see is_abelian(G::GAPGroup).\n\nExamples\n\njulia> is_abelian(character_table(\"A5\"))\nfalse\n\njulia> is_abelian(character_table(\"C2\"))\ntrue\n\n\n\n\n\n","category":"method"},{"location":"Groups/group_characters/#is_almost_simple-Tuple{Oscar.GAPGroupCharacterTable}","page":"Group characters","title":"is_almost_simple","text":"is_almost_simple(tbl::GAPGroupCharacterTable)\n\nReturn whether tbl is the ordinary character table of an almost simple group, see is_almost_simple(G::GAPGroup).\n\nExamples\n\njulia> is_almost_simple(character_table(\"S5\"))\ntrue\n\njulia> is_almost_simple(character_table(\"S4\"))\nfalse\n\n\n\n\n\n","category":"method"},{"location":"Groups/group_characters/#is_cyclic-Tuple{Oscar.GAPGroupCharacterTable}","page":"Group characters","title":"is_cyclic","text":"is_cyclic(tbl::GAPGroupCharacterTable)\n\nReturn whether tbl is the ordinary character table of a cyclic group, see is_cyclic(G::GAPGroup).\n\nExamples\n\njulia> is_cyclic(character_table(\"C2\"))\ntrue\n\njulia> is_cyclic(character_table(\"S4\"))\nfalse\n\n\n\n\n\n","category":"method"},{"location":"Groups/group_characters/#is_elementary_abelian-Tuple{Oscar.GAPGroupCharacterTable}","page":"Group characters","title":"is_elementary_abelian","text":"is_elementary_abelian(tbl::GAPGroupCharacterTable)\n\nReturn whether tbl is the ordinary character table of an elementary abelian group, see is_elementary_abelian(G::GAPGroup).\n\nExamples\n\njulia> is_elementary_abelian(character_table(\"C2\"))\ntrue\n\njulia> is_elementary_abelian(character_table(\"S4\"))\nfalse\n\n\n\n\n\n","category":"method"},{"location":"Groups/group_characters/#is_nilpotent-Tuple{Oscar.GAPGroupCharacterTable}","page":"Group characters","title":"is_nilpotent","text":"is_nilpotent(tbl::GAPGroupCharacterTable)\n\nReturn whether tbl is the ordinary character table of a nilpotent group, see is_nilpotent(G::GAPGroup).\n\nExamples\n\njulia> is_nilpotent(character_table(\"C2\"))\ntrue\n\njulia> is_nilpotent(character_table(\"S4\"))\nfalse\n\n\n\n\n\n","category":"method"},{"location":"Groups/group_characters/#is_perfect-Tuple{Oscar.GAPGroupCharacterTable}","page":"Group characters","title":"is_perfect","text":"is_perfect(tbl::GAPGroupCharacterTable)\n\nReturn whether tbl is the ordinary character table of a perfect group, see is_perfect(G::GAPGroup).\n\nExamples\n\njulia> is_perfect(character_table(\"A5\"))\ntrue\n\njulia> is_perfect(character_table(\"S4\"))\nfalse\n\n\n\n\n\n","category":"method"},{"location":"Groups/group_characters/#is_quasisimple-Tuple{Oscar.GAPGroupCharacterTable}","page":"Group characters","title":"is_quasisimple","text":"is_quasisimple(tbl::GAPGroupCharacterTable)\n\nReturn whether tbl is the ordinary character table of a quasisimple group, see is_quasisimple(G::GAPGroup).\n\nExamples\n\njulia> is_quasisimple(character_table(\"A5\"))\ntrue\n\njulia> is_quasisimple(character_table(\"S4\"))\nfalse\n\n\n\n\n\n","category":"method"},{"location":"Groups/group_characters/#is_simple-Tuple{Oscar.GAPGroupCharacterTable}","page":"Group characters","title":"is_simple","text":"is_simple(tbl::GAPGroupCharacterTable)\n\nReturn whether tbl is the ordinary character table of a simple group, see is_simple(G::GAPGroup).\n\nExamples\n\njulia> is_simple(character_table(\"A5\"))\ntrue\n\njulia> is_simple(character_table(\"S4\"))\nfalse\n\n\n\n\n\n","category":"method"},{"location":"Groups/group_characters/#is_solvable-Tuple{Oscar.GAPGroupCharacterTable}","page":"Group characters","title":"is_solvable","text":"is_solvable(tbl::GAPGroupCharacterTable)\n\nReturn whether tbl is the ordinary character table of a solvable group, see is_solvable(G::GAPGroup).\n\nExamples\n\njulia> is_solvable(character_table(\"A5\"))\nfalse\n\njulia> is_solvable(character_table(\"S4\"))\ntrue\n\n\n\n\n\n","category":"method"},{"location":"Groups/group_characters/#is_sporadic_simple-Tuple{Oscar.GAPGroupCharacterTable}","page":"Group characters","title":"is_sporadic_simple","text":"is_sporadic_simple(tbl::GAPGroupCharacterTable)\n\nReturn whether tbl is the ordinary character table of a sporadic simple group, see is_sporadic_simple(G::GAPGroup).\n\nExamples\n\njulia> is_sporadic_simple(character_table(\"A5\"))\nfalse\n\njulia> is_sporadic_simple(character_table(\"M11\"))\ntrue\n\n\n\n\n\n","category":"method"},{"location":"Groups/group_characters/#is_supersolvable-Tuple{Oscar.GAPGroupCharacterTable}","page":"Group characters","title":"is_supersolvable","text":"is_supersolvable(tbl::GAPGroupCharacterTable)\n\nReturn whether tbl is the ordinary character table of a supersolvable group, see is_supersolvable(G::GAPGroup).\n\nExamples\n\njulia> is_supersolvable(character_table(\"A5\"))\nfalse\n\njulia> is_supersolvable(character_table(\"S3\"))\ntrue\n\n\n\n\n\n","category":"method"},{"location":"Groups/group_characters/#Construct-group-characters-from-groups","page":"Group characters","title":"Construct group characters from groups","text":"","category":"section"},{"location":"Groups/group_characters/","page":"Group characters","title":"Group characters","text":"linear_characters(G::GAPGroup)\nnatural_character(G::PermGroup)\nnatural_character(G::Union{MatrixGroup{QQFieldElem}, MatrixGroup{AbsSimpleNumFieldElem}})\nnatural_character(G::MatrixGroup{T, MT}) where T <: FinFieldElem where MT\nnatural_character(rho::GAPGroupHomomorphism)\ntrivial_character(G::GAPGroup)\nregular_character(G::GAPGroup)","category":"page"},{"location":"Groups/group_characters/#linear_characters-Tuple{Oscar.GAPGroup}","page":"Group characters","title":"linear_characters","text":"linear_characters(G::Union{GAPGroup, FinGenAbGroup})\n\nReturn the array of linear characters of G, that is, the characters of degree 1.\n\nExamples\n\njulia> G = symmetric_group(3);\n\njulia> length(linear_characters(G))\n2\n\n\n\n\n\n","category":"method"},{"location":"Groups/group_characters/#natural_character-Tuple{PermGroup}","page":"Group characters","title":"natural_character","text":"natural_character(G::PermGroup)\n\nReturn the permutation character of degree degree(G) that maps each element of G to the number of its fixed points.\n\nExamples\n\njulia> g = symmetric_group(4);\n\njulia> degree(natural_character(g))\n4\n\njulia> degree(natural_character(stabilizer(g, 4)[1]))\n4\n\n\n\n\n\n","category":"method"},{"location":"Groups/group_characters/#natural_character-Tuple{Union{MatrixGroup{AbsSimpleNumFieldElem, T} where T<:MatElem{AbsSimpleNumFieldElem}, MatrixGroup{QQFieldElem, T} where T<:MatElem{QQFieldElem}}}","page":"Group characters","title":"natural_character","text":"natural_character(G::Union{MatrixGroup{QQFieldElem}, MatrixGroup{AbsSimpleNumFieldElem}})\n\nReturn the character that maps each element of G to its trace. We assume that the entries of the elements of G are either of type QQFieldElem or contained in a cyclotomic field.\n\nExamples\n\njulia> g = matrix_group(matrix(ZZ, [0 1; 1 0]));\n\njulia> println(values(natural_character(g)))\nQQAbFieldElem{AbsSimpleNumFieldElem}[2, 0]\n\n\n\n\n\nnatural_character(G::MatrixGroup{FinFieldElem})\n\nReturn the character that maps each p-regular element of G, where p is the characteristic of the base field of G, to its Brauer character value.\n\nExamples\n\njulia> g = general_linear_group(2, 2);\n\njulia> println(values(natural_character(g)))\nQQAbFieldElem{AbsSimpleNumFieldElem}[2, -1]\n\n\n\n\n\n","category":"method"},{"location":"Groups/group_characters/#natural_character-Union{Tuple{MatrixGroup{T, MT}}, Tuple{T}, Tuple{MT}} where {MT, T<:FinFieldElem}","page":"Group characters","title":"natural_character","text":"natural_character(G::MatrixGroup{FinFieldElem})\n\nReturn the character that maps each p-regular element of G, where p is the characteristic of the base field of G, to its Brauer character value.\n\nExamples\n\njulia> g = general_linear_group(2, 2);\n\njulia> println(values(natural_character(g)))\nQQAbFieldElem{AbsSimpleNumFieldElem}[2, -1]\n\n\n\n\n\n","category":"method"},{"location":"Groups/group_characters/#natural_character-Tuple{GAPGroupHomomorphism}","page":"Group characters","title":"natural_character","text":"natural_character(rho::GAPGroupHomomorphism)\n\nReturn the character of domain(rho) that is afforded by the representation rho, where codomain(rho) must be a permutation group or a matrix group. In the latter case, an ordinary character is returned if the characteristic of the base field is zero, and a p-modular Brauer character is returned if the characteristic is p  0.\n\nExamples\n\njulia> g = symmetric_group(3);  h = general_linear_group(2, 2);\n\njulia> mp = hom(g, h, [g([2,1]), g([1, 3, 2])], gens(h));\n\njulia> println(values(natural_character(mp)))\nQQAbFieldElem{AbsSimpleNumFieldElem}[2, -1]\n\n\n\n\n\n","category":"method"},{"location":"Groups/group_characters/#trivial_character-Tuple{Oscar.GAPGroup}","page":"Group characters","title":"trivial_character","text":"trivial_character(G::GAPGroup)\n\nReturn the character of (the ordinary character table of) G that has the value QQAbFieldElem(1) in each position.\n\nExamples\n\njulia> g = symmetric_group(4);\n\njulia> all(==(1), trivial_character(g))\ntrue\n\n\n\n\n\n","category":"method"},{"location":"Groups/group_characters/#regular_character-Tuple{Oscar.GAPGroup}","page":"Group characters","title":"regular_character","text":"regular_character(G::GAPGroup)\n\nReturn the regular character of G.\n\nExamples\n\njulia> G = symmetric_group(3);\n\njulia> values(regular_character(G))\n3-element Vector{QQAbFieldElem{AbsSimpleNumFieldElem}}:\n 6\n 0\n 0\n\n\n\n\n\n","category":"method"},{"location":"Groups/group_characters/#Operations-for-group-characters","page":"Group characters","title":"Operations for group characters","text":"","category":"section"},{"location":"Groups/group_characters/","page":"Group characters","title":"Group characters","text":"length and iteration:","category":"page"},{"location":"Groups/group_characters/","page":"Group characters","title":"Group characters","text":"The length of a class function is the number of conjugacy classes of its group, iteration is defined w.r.t. the ordering of conjugacy classes.","category":"page"},{"location":"Groups/group_characters/","page":"Group characters","title":"Group characters","text":"arithmetic operations:","category":"page"},{"location":"Groups/group_characters/","page":"Group characters","title":"Group characters","text":"chi == psi: two class functions are equal if and only if they belong to the same character table and have the same values,\nchi + psi and chi - psi are the pointwise sum and difference, respectively, of the two class functions chi, psi,\nn*chi is the pointwise n-fold sum of chi, for an integer n,\nchi*psi is the pointwise (tensor) product of chi and psi,\nzero(chi) is the class function that is zero on all classes,\none(chi) is the trivial character of the character table of chi,\nchi^n is the n-th tensor power of chi, for positive integers n,\nchi(g) is the value of chi at the element g of the group of chi,\nchi^g is the conjugate character of chi under the action of a group element g that normalizes the group G of chi; we have chi^g(x) == chi(g*x*g^-1) for all x in G,\nchi^galaut is the Galois conjugate character of chi under the pointwise action of the field automorphism galaut (If galaut was created as QQAbAutomorphism(k) then the action raises each root of unity to its k-th power; this action defines a field automorphism of the n-th cyclotomic field whenever n and k are coprime.)\nchi^tbl is the character of the character table tbl that is induced from chi, where the group of chi is a subgroup of the group of tbl.","category":"page"},{"location":"Groups/group_characters/","page":"Group characters","title":"Group characters","text":"scalar_product(chi::GAPGroupClassFunction, psi::GAPGroupClassFunction)\ntensor_product(chi::GAPGroupClassFunction, psi::GAPGroupClassFunction)\ncoordinates(chi::GAPGroupClassFunction)\nmultiplicities_eigenvalues\ninduce(chi::GAPGroupClassFunction, tbl::GAPGroupCharacterTable)\nrestrict(chi::GAPGroupClassFunction, subtbl::GAPGroupCharacterTable)","category":"page"},{"location":"Groups/group_characters/#scalar_product-Tuple{Oscar.GAPGroupClassFunction, Oscar.GAPGroupClassFunction}","page":"Group characters","title":"scalar_product","text":"scalar_product(::Type{T} = QQFieldElem, chi::GAPGroupClassFunction, psi::GAPGroupClassFunction)\n               where T <: Union{IntegerUnion, ZZRingElem, QQFieldElem, QQAbFieldElem}\n\nReturn sum_g in G chi(g) conj(psi)(g) / G, where G is the group of both chi and psi. The result is an instance of T.\n\nNote that we do not support dot(chi, psi) and its infix notation because the documentation of dot states that the result is equal to the sum of dot results of corresponding entries, which does not hold for the scalar product of characters.\n\n\n\n\n\n","category":"method"},{"location":"Groups/group_characters/#tensor_product-Tuple{Oscar.GAPGroupClassFunction, Oscar.GAPGroupClassFunction}","page":"Group characters","title":"tensor_product","text":"tensor_product(chi::GAPGroupClassFunction, psi::GAPGroupClassFunction)\n\nReturn the pointwise product of chi and psi. The resulting character is afforded by the tensor product of representations corresponding to chi and psi, hence the name.\n\nAlias for chi * psi.\n\n\n\n\n\n","category":"method"},{"location":"Groups/group_characters/#coordinates-Tuple{Oscar.GAPGroupClassFunction}","page":"Group characters","title":"coordinates","text":"coordinates(::Type{T} = QQFieldElem, chi::GAPGroupClassFunction)\n               where T <: Union{IntegerUnion, ZZRingElem, QQFieldElem, QQAbFieldElem}\n\nReturn the vector a_1 a_2 ldots a_n of scalar products (see scalar_product) of chi with the irreducible characters t1 t2 ldots tn of the character table t of chi, that is, chi is equal to sum_i=1^n a_i ti. The result is an instance of Vector{T}.\n\nExamples\n\njulia> g = symmetric_group(4)\nSym(4)\n\njulia> chi = natural_character(g);\n\njulia> coordinates(Int, chi)\n5-element Vector{Int64}:\n 0\n 0\n 0\n 1\n 1\n\njulia> t = parent(chi);  t3 = mod(t, 3);  chi3 = restrict(chi, t3);\n\njulia> coordinates(Int, chi3)\n4-element Vector{Int64}:\n 0\n 1\n 0\n 1\n\n\n\n\n\n","category":"method"},{"location":"Groups/group_characters/#multiplicities_eigenvalues","page":"Group characters","title":"multiplicities_eigenvalues","text":"multiplicities_eigenvalues(::Type{T} = Int, chi::GAPGroupClassFunction, i::Int) where T <: IntegerUnion\n\nLet M be a representing matrix of an element in the i-th conjugacy class of the character table of chi, in a representation affording the character chi, and let n be the order of the elements in this conjugacy class.\n\nReturn the vector (m_1 m_2 ldots m_n) of integers of type T such that m_j is the multiplicity of zeta_n^j as an eigenvalue of M.\n\nExamples\n\njulia> t = character_table(\"A5\");  chi = t[4];\n\njulia> println(values(chi))\nQQAbFieldElem{AbsSimpleNumFieldElem}[4, 0, 1, -1, -1]\n\njulia> println(multiplicities_eigenvalues(chi, 5))\n[1, 1, 1, 1, 0]\n\n\n\n\n\n","category":"function"},{"location":"Groups/group_characters/#induce-Tuple{Oscar.GAPGroupClassFunction, Oscar.GAPGroupCharacterTable}","page":"Group characters","title":"induce","text":"induce(chi::GAPGroupClassFunction, G::Union{GAPGroup, FinGenAbGroup})\ninduce(chi::GAPGroupClassFunction, tbl::GAPGroupCharacterTable[, fusion::Vector{Int}])\n\nReturn the class function of G or tbl that is induced from chi, which is a class function of a subgroup of G or the group of tbl. The default for the class fusion fus is given either by the fusion of the conjugacy classes of the two character tables (if groups are stored in the tables) or by the class fusion given by known_class_fusion for the two tables.\n\nThe syntax chi^tbl and chi^G is also supported.\n\nExamples\n\njulia> s = character_table(\"A5\");  t = character_table(\"A6\");\n\njulia> maps = possible_class_fusions(s, t);  length(maps)\n4\n\njulia> chi = trivial_character(s);\n\njulia> ind = [induce(chi, t, x) for x in maps];\n\njulia> length(Set(ind))\n2\n\n\n\n\n\n","category":"method"},{"location":"Groups/group_characters/#restrict-Tuple{Oscar.GAPGroupClassFunction, Oscar.GAPGroupCharacterTable}","page":"Group characters","title":"restrict","text":"restrict(chi::GAPGroupClassFunction, H::Union{GAPGroup, FinGenAbGroup})\nrestrict(chi::GAPGroupClassFunction, subtbl::GAPGroupCharacterTable[, fusion::Vector{Int}])\n\nReturn the class function of H or subtbl that is the restriction of chi, which is a class function of a supergroup of H or the group of subtbl. The default for the class fusion fus is given either by the fusion of the conjugacy classes of the two character tables (if groups are stored in the tables) or by the class fusion given by known_class_fusion for the two tables.\n\nExamples\n\njulia> s = character_table(\"A5\");  t = character_table(\"A6\");\n\njulia> maps = possible_class_fusions(s, t);  length(maps)\n4\n\njulia> chi = t[2];  rest = [restrict(chi, s, x) for x in maps];\n\njulia> length(Set(rest))\n2\n\n\n\n\n\n","category":"method"},{"location":"Groups/group_characters/#Symmetrizations-of-group-characters","page":"Group characters","title":"Symmetrizations of group characters","text":"","category":"section"},{"location":"Groups/group_characters/","page":"Group characters","title":"Group characters","text":"symmetrizations(characters::Vector{GAPGroupClassFunction}, n::Int)\nsymmetric_parts(characters::Vector{GAPGroupClassFunction}, n::Int)\nanti_symmetric_parts(characters::Vector{GAPGroupClassFunction}, n::Int)\nexterior_power(chi::GAPGroupClassFunction, n::Int)\nsymmetric_power(chi::GAPGroupClassFunction, n::Int)\northogonal_components(characters::Vector{GAPGroupClassFunction}, n::Int)\nsymplectic_components(characters::Vector{GAPGroupClassFunction}, n::Int)","category":"page"},{"location":"Groups/group_characters/#symmetrizations-Tuple{Vector{Oscar.GAPGroupClassFunction}, Int64}","page":"Group characters","title":"symmetrizations","text":"symmetrizations(characters::Vector{GAPGroupClassFunction}, n::Int)\n\nReturn the vector of symmetrizations of characters with the ordinary irreducible characters of the symmetric group of degree n.\n\nThe symmetrization chi^lambda of the character chi with the character lambda of the symmetric group S_n of degree n is defined by\n\nchi^lambda(g) =\n(sum_rhoin S_n lambda(rho) prod_k=1^n chi(g^k)^a_k(rho) )  n\n\nwhere a_k(rho) is the number of cycles of length k in rho.\n\nNote that the returned list may contain zero class functions, and duplicates are not deleted.\n\nFor special kinds of symmetrizations, see symmetric_parts, anti_symmetric_parts, orthogonal_components, symplectic_components, exterior_power, symmetric_power.\n\n\n\n\n\n","category":"method"},{"location":"Groups/group_characters/#symmetric_parts-Tuple{Vector{Oscar.GAPGroupClassFunction}, Int64}","page":"Group characters","title":"symmetric_parts","text":"symmetric_parts(characters::Vector{GAPGroupClassFunction}, n::Int)\n\nReturn the vector of symmetrizations of characters with the trivial character of the symmetric group of degree n, see symmetrizations.\n\n\n\n\n\n","category":"method"},{"location":"Groups/group_characters/#anti_symmetric_parts-Tuple{Vector{Oscar.GAPGroupClassFunction}, Int64}","page":"Group characters","title":"anti_symmetric_parts","text":"anti_symmetric_parts(characters::Vector{GAPGroupClassFunction}, n::Int)\n\nReturn the vector of symmetrizations of characters with the sign character of the symmetric group of degree n, see symmetrizations.\n\n\n\n\n\n","category":"method"},{"location":"Groups/group_characters/#exterior_power-Tuple{Oscar.GAPGroupClassFunction, Int64}","page":"Group characters","title":"exterior_power","text":"exterior_power(chi::GAPGroupClassFunction, n::Int)\n\nReturn the class function of the n-th exterior power of the module that is afforded by chi.\n\nThis exterior power is the symmetrization of chi with the sign character of the symmetric group of degree n, see also symmetrizations and anti_symmetric_parts.\n\n\n\n\n\n","category":"method"},{"location":"Groups/group_characters/#symmetric_power-Tuple{Oscar.GAPGroupClassFunction, Int64}","page":"Group characters","title":"symmetric_power","text":"symmetric_power(chi::GAPGroupClassFunction, n::Int)\n\nReturn the class function of the n-th symmetric power of the module that is afforded by chi.\n\nThis symmetric power is the symmetrization of chi with the trivial character of the symmetric group of degree n, see also symmetrizations and symmetric_parts.\n\n\n\n\n\n","category":"method"},{"location":"Groups/group_characters/#orthogonal_components-Tuple{Vector{Oscar.GAPGroupClassFunction}, Int64}","page":"Group characters","title":"orthogonal_components","text":"orthogonal_components(characters::Vector{GAPGroupClassFunction}, n::Int)\n\nReturn the vector of the so-called Murnaghan components of the m-th tensor powers of the entries of characters, for m up to n, where n must be at least 2 and at most 6 and where we assume that the entries of characters are irreducible characters with Frobenius-Schur indicator +1, see indicator.\n\n\n\n\n\n","category":"method"},{"location":"Groups/group_characters/#symplectic_components-Tuple{Vector{Oscar.GAPGroupClassFunction}, Int64}","page":"Group characters","title":"symplectic_components","text":"symplectic_components(characters::Vector{GAPGroupClassFunction}, n::Int)\n\nReturn the vector of the Murnaghan components of the m-th tensor powers of the entries of characters, for m up to n, where n must be at least 2 and at most 6 and where we assume that the entries of characters are irreducible characters with Frobenius-Schur indicator -1, see indicator.\n\n\n\n\n\n","category":"method"},{"location":"Groups/group_characters/#Operations-for-character-tables","page":"Group characters","title":"Operations for character tables","text":"","category":"section"},{"location":"Groups/group_characters/","page":"Group characters","title":"Group characters","text":"class_multiplication_coefficient\nknown_class_fusion\nknown_class_fusions\norder(tbl::GAPGroupCharacterTable)\npossible_class_fusions\napproximate_class_fusion","category":"page"},{"location":"Groups/group_characters/#class_multiplication_coefficient","page":"Group characters","title":"class_multiplication_coefficient","text":"class_multiplication_coefficient(::Type{T} = ZZRingElem, tbl::GAPGroupCharacterTable, i::Int, j::Int, k::Int) where T <: IntegerUnion\n\nReturn the class multiplication coefficient of the classes i, j, and k of the group G with ordinary character table tbl, as an instance of T.\n\nThe class multiplication coefficient c_ijk of the classes i j k equals the  number of pairs (x y) of elements x y in G such that x lies in class i, y lies in class j, and their product xy is a fixed element of class k.\n\nIn the center of the group algebra of G, these numbers are found as coefficients of the decomposition of the product of two class sums K_i and K_j into class sums:\n\nK_i K_j = sum_k c_ijk K_k\n\nGiven the character table of a finite group G, whose classes are C_1 ldots C_r with representatives g_i in C_i, the class multiplication coefficient c_ijk can be computed with the following formula:\n\n    c_ijk = C_i C_j  G\n              sum_chi in Irr(G) chi(g_i) chi(g_j) chi(g_k^-1)\n               chi(1)\n\nOn the other hand the knowledge of the class multiplication coefficients admits the computation of the irreducible characters of G.\n\nExamples\n\njulia> class_multiplication_coefficient(character_table(\"A5\"), 2, 3, 4)\n5\n\njulia> class_multiplication_coefficient(character_table(\"A5\"), 2, 4, 4)\n0\n\n\n\n\n\n","category":"function"},{"location":"Groups/group_characters/#known_class_fusion","page":"Group characters","title":"known_class_fusion","text":"known_class_fusion(tbl1::GAPGroupCharacterTable, tbl2::GAPGroupCharacterTable)\n\nReturn (flag, fus) where flag == true if a class fusion to tbl2 is stored on tbl1, and flag == false otherwise.\n\nIn the former case, fus is the vector of integers, of length ncols(tbl1), such that the i-th conjugacy class of tbl1 corresponds to the fus[i]-th conjugacy class of tbl2, in the following sense.\n\nIf the group of tbl1 is a subgroup of the group of tbl2 then the i-th conjugacy class of tbl1 is contained in the fus[i]-th conjugacy class of tbl2. If the group of tbl2 is a factor group of the group of tbl1 then the image of the i-th conjugacy class tbl1 under the relevant epimorphism is the fus[i]-th conjugacy class of tbl2.\n\nExamples\n\njulia> t1 = character_table(\"A5\");  t2 = character_table(\"A6\");\n\njulia> known_class_fusion(t1, t2)\n(true, [1, 2, 3, 6, 7])\n\njulia> known_class_fusion(t2, t1)\n(false, Int64[])\n\n\n\n\n\n","category":"function"},{"location":"Groups/group_characters/#known_class_fusions","page":"Group characters","title":"known_class_fusions","text":"known_class_fusions(tbl::GAPGroupCharacterTable)\n\nReturn the vector of pairs (name, fus) where name is the identifier of a character table and fus is the stored class fusion from tbl to this table, see known_class_fusion.\n\n\n\n\n\n","category":"function"},{"location":"Groups/group_characters/#order-Tuple{Oscar.GAPGroupCharacterTable}","page":"Group characters","title":"order","text":"order(::Type{T} = ZZRingElem, tbl::GAPGroupCharacterTable) where T <: IntegerUnion\n\nReturn the order of the group for which tbl is the character table, as an instance of T.\n\nExamples\n\njulia> order(character_table(symmetric_group(4)))\n24\n\n\n\n\n\n","category":"method"},{"location":"Groups/group_characters/#possible_class_fusions","page":"Group characters","title":"possible_class_fusions","text":"possible_class_fusions(subtbl::GAPGroupCharacterTable,\n                       tbl::GAPGroupCharacterTable;\n                       decompose::Bool = true,\n                       fusionmap::Vector = [])\n\nReturn the vector of possible class fusions from subtbl to tbl. Each entry is an vector of positive integers, where the value at position i is the position of the conjugacy class in tbl that contains the i-th class of subtbl.\n\nIf decompose is set to true then the strategy is changed: The decomposability of restricted characters of tbl as integral linear combinations of characters of subtbl (with perhaps negative coefficients) is not checked; this does not change the result, but in certain situations it is faster to omit this step.\n\nIf fusionmap is set to a vector of integers and integer vectors then only those maps are returned that are compatible with the prescribed value.\n\nExamples\n\njulia> possible_class_fusions(character_table(\"A5\"), character_table(\"A6\"))\n4-element Vector{Vector{Int64}}:\n [1, 2, 3, 6, 7]\n [1, 2, 3, 7, 6]\n [1, 2, 4, 6, 7]\n [1, 2, 4, 7, 6]\n\n\n\n\n\n","category":"function"},{"location":"Groups/group_characters/#approximate_class_fusion","page":"Group characters","title":"approximate_class_fusion","text":"approximate_class_fusion(subtbl::GAPGroupCharacterTable,\n                         tbl::GAPGroupCharacterTable)\n\nCompute for each class of subtbl all those classes in tbl to which it can fuse under an embedding of the group of subtbl into the group of tbl, according to element orders and centralizer orders in the two tables.\n\nIf no embedding is possible then return an empty vector. Otherwise return a vector of length equal to the number of classes of subtbl, such that the entry at position i either an integer (if there is a unique possible image class) or the vector of the positions of possible image classes.\n\nExamples\n\njulia> subtbl = character_table(\"A5\"); tbl = character_table(\"A6\");\n\njulia> println(approximate_class_fusion(subtbl, tbl))\nUnion{Int64, Vector{Int64}}[1, 2, [3, 4], [6, 7], [6, 7]]\n\n\n\n\n\n","category":"function"},{"location":"Groups/group_characters/#Character-tables-and-normal-subgroups","page":"Group characters","title":"Character tables and normal subgroups","text":"","category":"section"},{"location":"Groups/group_characters/","page":"Group characters","title":"Group characters","text":"Normal subgroups of a group G are unions of conjugacy classes of elements of G. Thus one can often turn questions about a normal subgroup N of G into questions about the array of those positions in the list of conjugacy classes of G that contain the elements of N.","category":"page"},{"location":"Groups/group_characters/","page":"Group characters","title":"Group characters","text":"center(chi::GAPGroupClassFunction)\nclass_positions_of_center(chi::GAPGroupCharacterTable)\nclass_positions_of_center(chi::GAPGroupClassFunction)\nclass_positions_of_derived_subgroup\nkernel(chi::GAPGroupClassFunction)\nclass_positions_of_kernel\nclass_positions_of_normal_subgroups\npcore(tbl::GAPGroupCharacterTable, p::IntegerUnion)\nclass_positions_of_pcore\nclass_positions_of_solvable_residuum","category":"page"},{"location":"Groups/group_characters/#center-Tuple{Oscar.GAPGroupClassFunction}","page":"Group characters","title":"center","text":"center(chi::GAPGroupClassFunction)\n\nReturn C, f where C is the center of chi (i.e. the largest normal subgroup of the underlying group G of chi such that chi maps each element of C to chi[1] times a root of unity) and f is the embedding morphism of C into G.\n\nExamples\n\njulia> t = character_table(symmetric_group(4));\n\njulia> chi = t[3];  chi[1]\n2\n\njulia> C, f = center(chi);  order(C)\n4\n\n\n\n\n\n","category":"method"},{"location":"Groups/group_characters/#class_positions_of_center-Tuple{Oscar.GAPGroupCharacterTable}","page":"Group characters","title":"class_positions_of_center","text":"class_positions_of_center(tbl::GAPGroupCharacterTable)\n\nReturn the vector of integers i such that the i-th conjugacy class of tbl is contained in the center of the group G of tbl, i.e., the i-th class has length 1.\n\nExamples\n\njulia> tbl = character_table(dihedral_group(8));\n\njulia> println(class_positions_of_center(tbl))\n[1, 4]\n\n\n\n\n\n","category":"method"},{"location":"Groups/group_characters/#class_positions_of_center-Tuple{Oscar.GAPGroupClassFunction}","page":"Group characters","title":"class_positions_of_center","text":"class_positions_of_center(chi::GAPGroupClassFunction)\n\nReturn the vector of those integers i such that chi[i] is chi[1] times a root of unity.\n\nExamples\n\njulia> println(class_positions_of_center(character_table(\"2.A5\")[2]))\n[1, 2]\n\n\n\n\n\n","category":"method"},{"location":"Groups/group_characters/#class_positions_of_derived_subgroup","page":"Group characters","title":"class_positions_of_derived_subgroup","text":"class_positions_of_derived_subgroup(tbl::GAPGroupCharacterTable)\n\nReturn the vector of integers i such that the i-th conjugacy class of tbl is contained in the derived subgroup of the group G of tbl.\n\nExamples\n\njulia> tbl = character_table(dihedral_group(8));\n\njulia> println(class_positions_of_derived_subgroup(tbl))\n[1, 4]\n\n\n\n\n\n","category":"function"},{"location":"Groups/group_characters/#kernel-Tuple{Oscar.GAPGroupClassFunction}","page":"Group characters","title":"kernel","text":"kernel(chi::GAPGroupClassFunction)\n\nReturn C, f where C is the kernel of chi (i.e. the largest normal subgroup of the underlying group G of chi such that chi maps each element of C to chi[1]) and f is the embedding morphism of C into G.\n\nExamples\n\njulia> t = character_table(symmetric_group(4));\n\njulia> chi = t[3];  chi[1]\n2\n\njulia> C, f = kernel(chi);  order(C)\n4\n\n\n\n\n\n","category":"method"},{"location":"Groups/group_characters/#class_positions_of_kernel","page":"Group characters","title":"class_positions_of_kernel","text":"class_positions_of_kernel(chi::GAPGroupClassFunction)\n\nReturn the vector of those integers i such that chi[i] == chi[1] holds.\n\nExamples\n\njulia> println(class_positions_of_kernel(character_table(\"2.A5\")[2]))\n[1, 2]\n\n\n\n\n\n","category":"function"},{"location":"Groups/group_characters/#class_positions_of_normal_subgroups","page":"Group characters","title":"class_positions_of_normal_subgroups","text":"class_positions_of_normal_subgroups(tbl::GAPGroupCharacterTable)\n\nReturn a vector whose entries describe all normal subgroups of the group of tbl. Each entry is a vector of those class positions such that the union of these classes forms a normal subgroup.\n\nExamples\n\njulia> t = character_table(\"2.A5\");\n\njulia> class_positions_of_normal_subgroups(t)\n3-element Vector{Vector{Int64}}:\n [1]\n [1, 2]\n [1, 2, 3, 4, 5, 6, 7, 8, 9]\n\n\n\n\n\n","category":"function"},{"location":"Groups/group_characters/#pcore-Tuple{Oscar.GAPGroupCharacterTable, Union{Integer, ZZRingElem}}","page":"Group characters","title":"pcore","text":"pcore(tbl::GAPGroupCharacterTable, p::IntegerUnion)\n\nReturn the p-core of the group of tbl, see pcore(G::GAPGroup, p::IntegerUnion), but computed character-theoretically (see class_positions_of_pcore).\n\nExamples\n\njulia> order(pcore(character_table(symmetric_group(4)), 2)[1])\n4\n\n\n\n\n\n","category":"method"},{"location":"Groups/group_characters/#class_positions_of_pcore","page":"Group characters","title":"class_positions_of_pcore","text":"class_positions_of_pcore(tbl::GAPGroupCharacterTable, p::IntegerUnion)\n\nReturn the vector of integers i such that the i-th conjugacy class of tbl is contained in the p-core of the group of tbl, see pcore(G::GAPGroup, p::IntegerUnion).\n\nExamples\n\njulia> println(class_positions_of_pcore(character_table(\"2.A5\"), 2))\n[1, 2]\n\n\n\n\n\n","category":"function"},{"location":"Groups/group_characters/#class_positions_of_solvable_residuum","page":"Group characters","title":"class_positions_of_solvable_residuum","text":"class_positions_of_solvable_residuum(tbl::GAPGroupCharacterTable)\n\nReturn the vector of integers i such that the i-th conjugacy class of tbl is contained in the solvable residuum of the group G of tbl, i.e., the smallest normal subgroup N of G such that the factor group GN is solvable. This normal subgroup is equal to the last term of the derived series of G, see derived_series.\n\nExamples\n\njulia> tbl = character_table(symmetric_group(4));\n\njulia> println(class_positions_of_solvable_residuum(tbl))\n[1]\n\n\n\n\n\n","category":"function"},{"location":"InvariantTheory/tori/","page":"Invariants of Tori","title":"Invariants of Tori","text":"CurrentModule = Oscar","category":"page"},{"location":"InvariantTheory/tori/#Invariants-of-Tori","page":"Invariants of Tori","title":"Invariants of Tori","text":"","category":"section"},{"location":"InvariantTheory/tori/","page":"Invariants of Tori","title":"Invariants of Tori","text":"In this section, with notation as in the introduction to this chapter, T =(K^ast)^m will be a torus of rank m over a field K. To compute invariants of diagonal torus actions, OSCAR makes use of Algorithm 4.3.1  in [DK15] which, in particular, relies on algorithmic means from polyhedral geometry.","category":"page"},{"location":"InvariantTheory/tori/#Creating-Invariant-Rings","page":"Invariants of Tori","title":"Creating Invariant Rings","text":"","category":"section"},{"location":"InvariantTheory/tori/#How-Tori-and-Their-Representations-are-Given","page":"Invariants of Tori","title":"How Tori  and Their Representations are Given","text":"","category":"section"},{"location":"InvariantTheory/tori/","page":"Invariants of Tori","title":"Invariants of Tori","text":" torus_group(F::Field, n::Int)","category":"page"},{"location":"InvariantTheory/tori/#torus_group-Tuple{Field, Int64}","page":"Invariants of Tori","title":"torus_group","text":"torus_group(K::Field, m::Int)\n\nReturn the torus (K^ast)^m.\n\nnote: Note\nIn the context of computing invariant rings, there is no need to deal with the group structure of a torus: The torus (K^ast)^m is specified by just giving K and m.\n\nExamples\n\njulia> T = torus_group(QQ,2)\nTorus of rank 2\n  over QQ\n\nwarning: Experimental\nThis function is part of the experimental code in Oscar. Please read here for more details.\n\n\n\n\n\n","category":"method"},{"location":"InvariantTheory/tori/","page":"Invariants of Tori","title":"Invariants of Tori","text":"rank(T::TorusGroup)","category":"page"},{"location":"InvariantTheory/tori/#rank-Tuple{Oscar.TorusGroup}","page":"Invariants of Tori","title":"rank","text":"rank(T::TorusGroup)\n\nReturn the rank of T.\n\nExamples\n\njulia> T = torus_group(QQ,2);\n\njulia> rank(T)\n2\n\nwarning: Experimental\nThis function is part of the experimental code in Oscar. Please read here for more details.\n\n\n\n\n\n","category":"method"},{"location":"InvariantTheory/tori/","page":"Invariants of Tori","title":"Invariants of Tori","text":"field(T::TorusGroup)","category":"page"},{"location":"InvariantTheory/tori/#field-Tuple{Oscar.TorusGroup}","page":"Invariants of Tori","title":"field","text":"field(T::TorusGroup)\n\nReturn the field over which T is defined.\n\nExamples\n\njulia> T = torus_group(QQ,2);\n\njulia> field(T)\nRational field\n\nwarning: Experimental\nThis function is part of the experimental code in Oscar. Please read here for more details.\n\n\n\n\n\n","category":"method"},{"location":"InvariantTheory/tori/","page":"Invariants of Tori","title":"Invariants of Tori","text":"representation_from_weights(T::TorusGroup, W::Union{ZZMatrix, Matrix{<:Integer}, Vector{<:Int}})","category":"page"},{"location":"InvariantTheory/tori/#representation_from_weights-Tuple{Oscar.TorusGroup, Union{ZZMatrix, Matrix{<:Integer}, Vector{<:Int64}}}","page":"Invariants of Tori","title":"representation_from_weights","text":"representation_from_weights(T::TorusGroup, W::Union{ZZMatrix, Matrix{<:Integer}, Vector{<:Int}})\n\nReturn the diagonal action of T with weights given by W.\n\nExamples\n\njulia> T = torus_group(QQ,2);\n\njulia> r = representation_from_weights(T, [-1 1; -1 1; 2 -2; 0 -1])\nRepresentation of torus of rank 2\n  over QQ and weights \n  Vector{ZZRingElem}[[-1, 1], [-1, 1], [2, -2], [0, -1]]\n\nwarning: Experimental\nThis function is part of the experimental code in Oscar. Please read here for more details.\n\n\n\n\n\n","category":"method"},{"location":"InvariantTheory/tori/","page":"Invariants of Tori","title":"Invariants of Tori","text":"group(r::RepresentationTorusGroup)","category":"page"},{"location":"InvariantTheory/tori/#group-Tuple{Oscar.RepresentationTorusGroup}","page":"Invariants of Tori","title":"group","text":"group(r::RepresentationTorusGroup)\n\nReturn the torus group represented by r.\n\nExamples\n\njulia> T = torus_group(QQ,2);\n\njulia> r = representation_from_weights(T, [-1 1; -1 1; 2 -2; 0 -1]);\n\njulia> group(r)\nTorus of rank 2\n  over QQ\n\nwarning: Experimental\nThis function is part of the experimental code in Oscar. Please read here for more details.\n\n\n\n\n\n","category":"method"},{"location":"InvariantTheory/tori/#Constructor-for-Invariant-Rings","page":"Invariants of Tori","title":"Constructor for Invariant Rings","text":"","category":"section"},{"location":"InvariantTheory/tori/","page":"Invariants of Tori","title":"Invariants of Tori","text":"invariant_ring(r::RepresentationTorusGroup)","category":"page"},{"location":"InvariantTheory/tori/#invariant_ring-Tuple{Oscar.RepresentationTorusGroup}","page":"Invariants of Tori","title":"invariant_ring","text":"invariant_ring(r::RepresentationTorusGroup)\n\nReturn the invariant ring of the torus group represented by r.\n\nnote: Note\nThe creation of invariant rings is lazy in the sense that no explicit computations are done until specifically invoked (for example, by the fundamental_invariants function).\n\nExamples\n\njulia> T = torus_group(QQ,2);\n\njulia> r = representation_from_weights(T, [-1 1; -1 1; 2 -2; 0 -1]);\n\njulia> RT = invariant_ring(r)\nInvariant Ring of\ngraded multivariate polynomial ring in 4 variables over QQ under group action of torus of rank2\n\nwarning: Experimental\nThis function is part of the experimental code in Oscar. Please read here for more details.\n\n\n\n\n\n","category":"method"},{"location":"InvariantTheory/tori/#Fundamental-Systems-of-Invariants","page":"Invariants of Tori","title":"Fundamental Systems of Invariants","text":"","category":"section"},{"location":"InvariantTheory/tori/","page":"Invariants of Tori","title":"Invariants of Tori","text":"fundamental_invariants(RT::TorGroupInvarRing)","category":"page"},{"location":"InvariantTheory/tori/#fundamental_invariants-Tuple{Oscar.TorGroupInvarRing}","page":"Invariants of Tori","title":"fundamental_invariants","text":"fundamental_invariants(RT::TorGroupInvarRing)\n\nReturn a system of fundamental invariants for RT.\n\nExamples\n\njulia> T = torus_group(QQ,2);\n\njulia> r = representation_from_weights(T, [-1 1; -1 1; 2 -2; 0 -1]);\n\njulia> RT = invariant_ring(r);\n\njulia> fundamental_invariants(RT)\n3-element Vector{MPolyDecRingElem{QQFieldElem, QQMPolyRingElem}}:\n X[1]^2*X[3]\n X[1]*X[2]*X[3]\n X[2]^2*X[3]\n\nwarning: Experimental\nThis function is part of the experimental code in Oscar. Please read here for more details.\n\n\n\n\n\n","category":"method"},{"location":"InvariantTheory/tori/#Invariant-Rings-as-Affine-Algebras","page":"Invariants of Tori","title":"Invariant Rings as Affine Algebras","text":"","category":"section"},{"location":"InvariantTheory/tori/","page":"Invariants of Tori","title":"Invariants of Tori","text":"affine_algebra(RT::TorGroupInvarRing)","category":"page"},{"location":"InvariantTheory/tori/#affine_algebra-Tuple{Oscar.TorGroupInvarRing}","page":"Invariants of Tori","title":"affine_algebra","text":"affine_algebra(RT::TorGroupInvarRing)\n\nReturn the invariant ring RT as an affine algebra (this amounts to compute the algebra syzygies among the fundamental invariants of RT).\n\nIn addition, if A is this algebra, and R is the polynomial ring of which RT is a subalgebra, return the inclusion homomorphism  A hookrightarrow R whose image is RT.\n\nExamples\n\njulia> T = torus_group(QQ,2);\n\njulia> r = representation_from_weights(T, [-1 1; -1 1; 2 -2; 0 -1]);\n\njulia> RT = invariant_ring(r);\n\njulia> fundamental_invariants(RT)\n3-element Vector{MPolyDecRingElem{QQFieldElem, QQMPolyRingElem}}:\n X[1]^2*X[3]\n X[1]*X[2]*X[3]\n X[2]^2*X[3]\n\njulia> affine_algebra(RT)\n(Quotient of multivariate polynomial ring by ideal (-t[1]*t[3] + t[2]^2), Hom: quotient of multivariate polynomial ring -> graded multivariate polynomial ring)\n\nwarning: Experimental\nThis function is part of the experimental code in Oscar. Please read here for more details.\n\n\n\n\n\n","category":"method"},{"location":"CommutativeAlgebra/homological_algebra/","page":"Homological Algebra","title":"Homological Algebra","text":"CurrentModule = Oscar\nDocTestSetup = Oscar.doctestsetup()","category":"page"},{"location":"CommutativeAlgebra/homological_algebra/#Homological-Algebra","page":"Homological Algebra","title":"Homological Algebra","text":"","category":"section"},{"location":"CommutativeAlgebra/homological_algebra/","page":"Homological Algebra","title":"Homological Algebra","text":"Some OSCAR functions which are fundamental to homological algebra such as the kernel function for module homomorphisms and basic functions for handling chain and cochain complexes are discussed in the module section. Building on these functions, we here introduce further OSCAR functionality supporting computations in homological algebra.","category":"page"},{"location":"CommutativeAlgebra/homological_algebra/#Pruning-Modules","page":"Homological Algebra","title":"Pruning Modules","text":"","category":"section"},{"location":"CommutativeAlgebra/homological_algebra/","page":"Homological Algebra","title":"Homological Algebra","text":"prune_with_map(M::ModuleFP)","category":"page"},{"location":"CommutativeAlgebra/homological_algebra/#prune_with_map-Tuple{ModuleFP}","page":"Homological Algebra","title":"prune_with_map","text":"prune_with_map(M::ModuleFP)\n\nIf M is positively graded, return a module N and an isomorphism from N to M such that N is generated by a minimal number of elements.\n\nIf M is not (positively) graded, the function still aims at reducing the number of generators.\n\nExamples\n\njulia> R, (w, x, y, z) = graded_polynomial_ring(QQ, [:w, :x, :y, :z]);\n\njulia> Z = R(0)\n0\n\njulia> O = R(1)\n1\n\njulia> B = [Z Z Z O; w*y w*z-x*y x*z-y^2 Z];\n\njulia> A = transpose(matrix(B))\n[0         w*y]\n[0   w*z - x*y]\n[0   x*z - y^2]\n[1           0]\n\njulia> M = graded_cokernel(A)\nGraded subquotient of graded submodule of R^2 with 2 generators\n  1: e[1]\n  2: e[2]\nby graded submodule of R^2 with 4 generators\n  1: w*y*e[2]\n  2: (w*z - x*y)*e[2]\n  3: (x*z - y^2)*e[2]\n  4: e[1]\n\njulia> N, phi = prune_with_map(M);\n\njulia> N\nGraded subquotient of graded submodule of R^1 with 1 generator\n  1: e[1]\nby graded submodule of R^1 with 3 generators\n  1: (-x*z + y^2)*e[1]\n  2: (-w*z + x*y)*e[1]\n  3: w*y*e[1]\n\njulia> phi(first(gens(N)))\ne[2]\n\n\n\n\n\n","category":"method"},{"location":"CommutativeAlgebra/homological_algebra/#Presentations","page":"Homological Algebra","title":"Presentations","text":"","category":"section"},{"location":"CommutativeAlgebra/homological_algebra/","page":"Homological Algebra","title":"Homological Algebra","text":"presentation(M::ModuleFP)","category":"page"},{"location":"CommutativeAlgebra/homological_algebra/#presentation-Tuple{ModuleFP}","page":"Homological Algebra","title":"presentation","text":"presentation(M::ModuleFP; minimal = false)\n\nReturn a (free) presentation of M.  \n\nnote: Note\nIf minimal is true, and M is positively graded, a minimal presentation is returned. If minimal is true, and M is not (positively) graded, the function still aims at returning an ''improved'' presentation.\n\nExamples\n\njulia> R, (w, x, y, z) = graded_polynomial_ring(QQ, [:w, :x, :y, :z]);\n\njulia> Z = R(0)\n0\n\njulia> O = R(1)\n1\n\njulia> B = [Z Z Z O; w*y w*z-x*y x*z-y^2 Z];\n\njulia> A = transpose(matrix(B))\n[0         w*y]\n[0   w*z - x*y]\n[0   x*z - y^2]\n[1           0]\n\njulia> M = graded_cokernel(A)\nGraded subquotient of graded submodule of R^2 with 2 generators\n  1: e[1]\n  2: e[2]\nby graded submodule of R^2 with 4 generators\n  1: w*y*e[2]\n  2: (w*z - x*y)*e[2]\n  3: (x*z - y^2)*e[2]\n  4: e[1]\n\njulia> PM1 = presentation(M)\n0 <---- M <---- R^2 <---- R^4\n\njulia> PM2 = presentation(M, minimal = true)\n0 <---- M <---- R^1 <---- R^3\n\n\njulia> Rg, (x, y, z) = graded_polynomial_ring(QQ, [:x, :y, :z]);\n\njulia> F = graded_free_module(Rg, [1,2,2]);\n\njulia> p = presentation(F)\n0 <---- F <---- F <---- 0\n\njulia> p[-2]\nGraded free module Rg^0 of rank 0 over Rg\n\njulia> p[-1]\nGraded free module Rg^1([-1]) + Rg^2([-2]) of rank 3 over Rg\n\njulia> p[0]\nGraded free module Rg^1([-1]) + Rg^2([-2]) of rank 3 over Rg\n\njulia> p[1]\nGraded free module Rg^0 of rank 0 over Rg\n\njulia> map(p,-1)\nHomogeneous module homomorphism\n  from F\n  to 0\ndefined by\n  e[1] -> 0\n  e[2] -> 0\n  e[3] -> 0\n\njulia> map(p,0)\nHomogeneous module homomorphism\n  from F\n  to F\ndefined by\n  e[1] -> e[1]\n  e[2] -> e[2]\n  e[3] -> e[3]\n\njulia> map(p,1)\nHomogeneous module homomorphism\n  from 0\n  to F\ndefined by\n\njulia> F = graded_free_module(Rg, 1);\n\njulia> A = Rg[x; y];\n\njulia> B = Rg[x^2; y^3; z^4];\n\njulia> M = SubquoModule(F, A, B);\n\njulia> P = presentation(M)\n0 <---- M <---- Rg^2 <---- Rg^5\n\njulia> P[-2]\nGraded free module Rg^0 of rank 0 over Rg\n\njulia> P[-1]\nGraded subquotient of graded submodule of F with 2 generators\n  1: x*e[1]\n  2: y*e[1]\nby graded submodule of F with 3 generators\n  1: x^2*e[1]\n  2: y^3*e[1]\n  3: z^4*e[1]\n\njulia> P[0]\nGraded free module Rg^2([-1]) of rank 2 over Rg\n\njulia> P[1]\nGraded free module Rg^2([-2]) + Rg^1([-3]) + Rg^2([-5]) of rank 5 over Rg\n\njulia> map(P,-1)\nHomogeneous module homomorphism\n  from M\n  to 0\ndefined by\n  x*e[1] -> 0\n  y*e[1] -> 0\n\njulia> map(P,0)\nHomogeneous module homomorphism\n  from Rg^2\n  to M\ndefined by\n  e[1] -> x*e[1]\n  e[2] -> y*e[1]\n\njulia> map(P,1)\nHomogeneous module homomorphism\n  from Rg^5\n  to Rg^2\ndefined by\n  e[1] -> x*e[1]\n  e[2] -> -y*e[1] + x*e[2]\n  e[3] -> y^2*e[2]\n  e[4] -> z^4*e[1]\n  e[5] -> z^4*e[2]\n\n\n\n\n\n","category":"method"},{"location":"CommutativeAlgebra/homological_algebra/#Representation-as-Cokernel","page":"Homological Algebra","title":"Representation as Cokernel","text":"","category":"section"},{"location":"CommutativeAlgebra/homological_algebra/","page":"Homological Algebra","title":"Homological Algebra","text":"present_as_cokernel(M::SubquoModule, task::Symbol = :none)","category":"page"},{"location":"CommutativeAlgebra/homological_algebra/#present_as_cokernel","page":"Homological Algebra","title":"present_as_cokernel","text":"present_as_cokernel(M::SubquoModule, task::Symbol = :none)\n\nReturn a subquotient C which is isomorphic to M, and whose generators are the standard unit vectors of its ambient free module.\n\nAdditionally,\n\nreturn an isomorphism M to C if task = :with_morphism,\nreturn and cache an isomorphism M to C if task = :cache_morphism,\ndo none of the above if task = :none (default).\n\nIf task = :only_morphism, return only an isomorphism.\n\nExamples\n\njulia> R, (x, y, z) = polynomial_ring(QQ, [:x, :y, :z]);\n\njulia> A = R[x; y];\n\njulia> B = R[x^2; y^3; z^4];\n\njulia> M = SubquoModule(A, B)\nSubquotient of submodule with 2 generators\n  1: x*e[1]\n  2: y*e[1]\nby submodule with 3 generators\n  1: x^2*e[1]\n  2: y^3*e[1]\n  3: z^4*e[1]\n\njulia> C = present_as_cokernel(M)\nSubquotient of submodule with 2 generators\n  1: e[1]\n  2: e[2]\nby submodule with 5 generators\n  1: x*e[1]\n  2: -y*e[1] + x*e[2]\n  3: y^2*e[2]\n  4: z^4*e[1]\n  5: z^4*e[2]\n\njulia> Rg, (x, y, z) = graded_polynomial_ring(QQ, [:x, :y, :z]);\n\njulia> F = graded_free_module(Rg, 1);\n\njulia> A = Rg[x; y];\n\njulia> B = Rg[x^2; y^3; z^4];\n\njulia> M = SubquoModule(F, A, B);\n\njulia> present_as_cokernel(M, :with_morphism)\n(Graded subquotient of graded submodule of Rg^2 with 2 generators\n  1: e[1]\n  2: e[2]\nby graded submodule of Rg^2 with 5 generators\n  1: x*e[1]\n  2: -y*e[1] + x*e[2]\n  3: y^2*e[2]\n  4: z^4*e[1]\n  5: z^4*e[2], Hom: graded subquotient of graded submodule of Rg^2 with 2 generators\n  1: e[1]\n  2: e[2]\nby graded submodule of Rg^2 with 5 generators\n  1: x*e[1]\n  2: -y*e[1] + x*e[2]\n  3: y^2*e[2]\n  4: z^4*e[1]\n  5: z^4*e[2] -> M)\n\n\n\n\n\n","category":"function"},{"location":"CommutativeAlgebra/homological_algebra/#Free-Resolutions","page":"Homological Algebra","title":"Free Resolutions","text":"","category":"section"},{"location":"CommutativeAlgebra/homological_algebra/","page":"Homological Algebra","title":"Homological Algebra","text":"free_resolution(M::SubquoModule{<:MPolyRingElem}; \n    ordering::ModuleOrdering = default_ordering(M),\n    length::Int=0, algorithm::Symbol=:fres\n  )","category":"page"},{"location":"CommutativeAlgebra/homological_algebra/#free_resolution-Tuple{SubquoModule{<:MPolyRingElem}}","page":"Homological Algebra","title":"free_resolution","text":"free_resolution(M::SubquoModule{T}; \n    length::Int=0,\n    algorithm::Symbol = T <:MPolyRingElem ? :fres : :sres) where {T <: Union{MPolyRingElem, MPolyQuoRingElem}}\n\nReturn a free resolution of M.\n\nIf length != 0, the free resolution is only computed up to the length-th free module. Current options for algorithm are :fres, :nres, and :mres for modules over polynomial rings and :sres for modules over quotients of polynomial rings.\n\nnote: Note\nThe function first computes a presentation of M. It then successively computes higher syzygy modules.\n\nnote: Note\nIf algorithm == mres, and M is positively graded, a minimal free resolution is returned.\nIf algorithm == nres, and M is positively graded, the function proceeds as above except  that it starts by computing a presentation which is not necessarily minimal.In both cases, if M is not (positively) graded, the function still aims at returning an ''improved'' resolution.\n\nnote: Note\nIf algorithm == fres, the function relies on an enhanced version of Schreyer's algorithm  [EMSS16]. Typically, this is more efficient than the approaches above, but the  resulting resolution is far from being minimal.\n\nnote: Note\nIf M is a module over a quotient of a polynomial ring then the length keyword must be set to a nonzero value.\n\nExamples\n\njulia> R, (x, y, z) = polynomial_ring(QQ, [:x, :y, :z])\n(Multivariate polynomial ring in 3 variables over QQ, QQMPolyRingElem[x, y, z])\n\njulia> A = R[x; y]\n[x]\n[y]\n\njulia> B = R[x^2; x*y; y^2; z^4]\n[x^2]\n[x*y]\n[y^2]\n[z^4]\n\njulia> M = SubquoModule(A, B)\nSubquotient of submodule with 2 generators\n  1: x*e[1]\n  2: y*e[1]\nby submodule with 4 generators\n  1: x^2*e[1]\n  2: x*y*e[1]\n  3: y^2*e[1]\n  4: z^4*e[1]\n\njulia> fr = free_resolution(M, length=1)\nFree resolution of M\nR^2 <---- R^6\n0         1\n\njulia> is_complete(fr)\nfalse\n\njulia> fr[4]\nFree module of rank 0 over R\n\njulia> fr\nFree resolution of M\nR^2 <---- R^6 <---- R^6 <---- R^2 <---- 0\n0         1         2         3         4\n\njulia> is_complete(fr)\ntrue\n\njulia> R, (w, x, y, z) = graded_polynomial_ring(QQ, [:w, :x, :y, :z]);\n\njulia> Z = R(0)\n0\n\njulia> O = R(1)\n1\n\njulia> B = [Z Z Z O; w*y w*z-x*y x*z-y^2 Z];\n\njulia> A = transpose(matrix(B));\n\njulia> M = graded_cokernel(A)\nGraded subquotient of graded submodule of R^2 with 2 generators\n  1: e[1]\n  2: e[2]\nby graded submodule of R^2 with 4 generators\n  1: w*y*e[2]\n  2: (w*z - x*y)*e[2]\n  3: (x*z - y^2)*e[2]\n  4: e[1]\n\njulia> FM1 = free_resolution(M)\nFree resolution of M\nR^2 <---- R^7 <---- R^8 <---- R^3 <---- 0\n0         1         2         3         4\n\njulia> betti_table(FM1)\ndegree: 0  1  2  3\n------------------\n    -1: -  1  -  -\n     0: 2  -  -  -\n     1: -  3  3  1\n     2: -  3  5  2\n------------------\n total: 2  7  8  3\n\njulia> matrix(map(FM1, 1))\n[1            0]\n[0   -x*z + y^2]\n[0   -w*z + x*y]\n[0          w*y]\n[0        x^2*z]\n[0        w*x*z]\n[0        w^2*z]\n\njulia> FM2 = free_resolution(M, algorithm = :nres)\nFree resolution of M\nR^2 <---- R^4 <---- R^4 <---- R^2 <---- 0\n0         1         2         3         4\n\njulia> betti_table(FM2)\ndegree: 0  1  2  3\n------------------\n    -1: -  1  -  -\n     0: 2  -  -  -\n     1: -  3  -  -\n     2: -  -  4  2\n------------------\n total: 2  4  4  2\n\njulia> matrix(map(FM2, 1))\n[1            0]\n[0   -x*z + y^2]\n[0   -w*z + x*y]\n[0          w*y]\n\njulia> FM3 = free_resolution(M, algorithm = :mres)\nFree resolution of M\nR^1 <---- R^3 <---- R^4 <---- R^2 <---- 0\n0         1         2         3         4\n\njulia> betti_table(FM3)\ndegree: 0  1  2  3\n------------------\n     0: 1  -  -  -\n     1: -  3  -  -\n     2: -  -  4  2\n------------------\n total: 1  3  4  2\n\njulia> matrix(map(FM3, 1))\n[-x*z + y^2]\n[-w*z + x*y]\n[       w*y]\n\n\nNote: Over rings other than polynomial rings or quotients of polynomial rings, the method will default to a lazy,  iterative kernel computation.\n\n\n\n\n\n","category":"method"},{"location":"CommutativeAlgebra/homological_algebra/#Betti-Tables","page":"Homological Algebra","title":"Betti Tables","text":"","category":"section"},{"location":"CommutativeAlgebra/homological_algebra/","page":"Homological Algebra","title":"Homological Algebra","text":"Given a mathbb Z-graded multivariate polynomial ring S, and given a graded free resolution  with finitely generated graded free S-modules ","category":"page"},{"location":"CommutativeAlgebra/homological_algebra/","page":"Homological Algebra","title":"Homological Algebra","text":"F_i=bigoplus_j S(-j) ^beta_ij","category":"page"},{"location":"CommutativeAlgebra/homological_algebra/","page":"Homological Algebra","title":"Homological Algebra","text":"the numbers beta_ij are commonly known as the graded Betti numbers of the resolution. A convenient way of visualizing these numbers is to write a Betti table as in the example below:","category":"page"},{"location":"CommutativeAlgebra/homological_algebra/","page":"Homological Algebra","title":"Homological Algebra","text":"       0  1  2  3  \n------------------\n0    : 1  -  -  -  \n1    : -  2  1  -  \n2    : -  2  3  1  \n------------------\ntotal: 1  4  4  1","category":"page"},{"location":"CommutativeAlgebra/homological_algebra/","page":"Homological Algebra","title":"Homological Algebra","text":"A number i in the top row of the table refers to the i-th free  module F_i of the resolution. More precisely, the column with first  entry i lists the number of free generators of F_i in different degrees and, in the bottom row, the total number of free generators (that is, the rank of F_i). If k is the first entry of a row containing  a number beta in the column corresponding to F_i,  then F_i has beta generators in degree k+i. That is, for a free module F_i written as a direct sum as above, beta is the number beta_ij with j=k+i. The explicit example table above indicates, for instance,  that F_2 has one generator in degree 3 and three generators  in degree 4. In total, the diagram corresponds to a  graded free resolution of type ","category":"page"},{"location":"CommutativeAlgebra/homological_algebra/","page":"Homological Algebra","title":"Homological Algebra","text":"S leftarrow S(-2)^2oplus S(-3)^2 leftarrow S(-3)oplus S(-4)^3 leftarrow S(-5) leftarrow 0","category":"page"},{"location":"CommutativeAlgebra/homological_algebra/","page":"Homological Algebra","title":"Homological Algebra","text":"betti_table(F::FreeResolution)","category":"page"},{"location":"CommutativeAlgebra/homological_algebra/#betti_table-Tuple{FreeResolution}","page":"Homological Algebra","title":"betti_table","text":"betti_table(F::FreeResolution)\n\nGiven a mathbb Z-graded free resolution F, return the graded Betti numbers  of F in form of a Betti table.\n\nAlternatively, use betti.\n\nExamples\n\njulia> R, (w, x, y, z) = graded_polynomial_ring(QQ, [:w, :x, :y, :z]);\n\njulia> I = ideal(R, [x*z, y*z, x*w^2, y*w^2])\nIdeal generated by\n  x*z\n  y*z\n  w^2*x\n  w^2*y\n\njulia> A, _= quo(R, I)\n(Quotient of multivariate polynomial ring by ideal (x*z, y*z, w^2*x, w^2*y), Map: R -> A)\n\njulia> FA  = free_resolution(A)\nFree resolution of A\nR^1 <---- R^4 <---- R^4 <---- R^1 <---- 0\n0         1         2         3         4\n\njulia> betti_table(FA)\ndegree: 0  1  2  3\n------------------\n     0: 1  -  -  -\n     1: -  2  1  -\n     2: -  2  3  1\n------------------\n total: 1  4  4  1\n\njulia> R, (x, y) = graded_polynomial_ring(QQ, [:x, :y]);\n\njulia> I = ideal(R, [x, y, x+y]);\n\njulia> M = quotient_ring_as_module(I);\n\njulia> FM = free_resolution(M, algorithm = :nres);\n\njulia> betti_table(FM)\ndegree: 0  1  2\n---------------\n     0: 1  2  1\n---------------\n total: 1  2  1\n\n\n\n\n\n","category":"method"},{"location":"CommutativeAlgebra/homological_algebra/","page":"Homological Algebra","title":"Homological Algebra","text":"minimal_betti_table(F::FreeResolution{T}) where {T<:ModuleFP}","category":"page"},{"location":"CommutativeAlgebra/homological_algebra/#minimal_betti_table-Union{Tuple{FreeResolution{T}}, Tuple{T}} where T<:ModuleFP","page":"Homological Algebra","title":"minimal_betti_table","text":"minimal_betti_table(F::FreeResolution{T}; check::Bool=true) where {T<:ModuleFP}\n\nGiven a graded free resolution F over a standard mathbb Z-graded  multivariate polynomial ring with coefficients in a field, return the Betti table of the minimal free resolution arising from F.\n\nnote: Note\nThe algorithm proceeds without actually minimizing the resolution.\n\nExamples\n\njulia> R, (w, x, y, z) = graded_polynomial_ring(QQ, [:w, :x, :y, :z]);\n\njulia> I = ideal(R, [w^2-x*z, w*x-y*z, x^2-w*y, x*y-z^2, y^2-w*z]);\n\njulia> A, _ = quo(R, I)\n(Quotient of multivariate polynomial ring by ideal (w^2 - x*z, w*x - y*z, -w*y + x^2, x*y - z^2, -w*z + y^2), Map: R -> A)\n\njulia> FA = free_resolution(A)\nFree resolution of A\nR^1 <---- R^5 <---- R^6 <---- R^2 <---- 0\n0         1         2         3         4\n\njulia> betti_table(FA)\ndegree: 0  1  2  3\n------------------\n     0: 1  -  -  -\n     1: -  5  5  1\n     2: -  -  1  1\n------------------\n total: 1  5  6  2\n\njulia> minimal_betti_table(FA)\ndegree: 0  1  2  3\n------------------\n     0: 1  -  -  -\n     1: -  5  5  -\n     2: -  -  -  1\n------------------\n total: 1  5  5  1\n\n\n\n\n\n","category":"method"},{"location":"CommutativeAlgebra/homological_algebra/","page":"Homological Algebra","title":"Homological Algebra","text":"minimal_betti_table(M::ModuleFP{T}) where {T<:MPolyDecRingElem}","category":"page"},{"location":"CommutativeAlgebra/homological_algebra/#minimal_betti_table-Union{Tuple{ModuleFP{T}}, Tuple{T}} where T<:MPolyDecRingElem","page":"Homological Algebra","title":"minimal_betti_table","text":"minimal_betti_table(M::ModuleFP{T}) where {T<:MPolyDecRingElem}\nminimal_betti_table(A::MPolyQuoRing{T}) where {T<:MPolyDecRingElem}\nminimal_betti_table(I::MPolyIdeal{T}) where {T<:MPolyDecRingElem}\n\nGiven a finitely presented graded module M over a standard mathbb Z-graded  multivariate polynomial ring with coefficients in a field, return the Betti Table of the minimal free resolution of M. Similarly for A and I.\n\nExamples\n\njulia> R, (w, x, y, z) = graded_polynomial_ring(QQ, [:w, :x, :y, :z]);\n\njulia> I = ideal(R, [w^2-x*z, w*x-y*z, x^2-w*y, x*y-z^2, y^2-w*z]);\n\njulia> A, _ = quo(R, I)\n(Quotient of multivariate polynomial ring by ideal (w^2 - x*z, w*x - y*z, -w*y + x^2, x*y - z^2, -w*z + y^2), Map: R -> A)\n\njulia> minimal_betti_table(A)\ndegree: 0  1  2  3\n------------------\n     0: 1  -  -  -\n     1: -  5  5  -\n     2: -  -  -  1\n------------------\n total: 1  5  5  1\n\n\n\n\n\n","category":"method"},{"location":"CommutativeAlgebra/homological_algebra/#Castelnuovo-Mumford-Regularity","page":"Homological Algebra","title":"Castelnuovo-Mumford Regularity","text":"","category":"section"},{"location":"CommutativeAlgebra/homological_algebra/","page":"Homological Algebra","title":"Homological Algebra","text":"cm_regularity(M::ModuleFP)","category":"page"},{"location":"CommutativeAlgebra/homological_algebra/#cm_regularity-Tuple{ModuleFP}","page":"Homological Algebra","title":"cm_regularity","text":"cm_regularity(M::ModuleFP; check::Bool=true)\n\nGiven a finitely presented graded module M over a standard mathbb Z-graded  multivariate polynomial ring with coefficients in a field, return the Castelnuovo-Mumford regularity of M.\n\ncm_regularity(I::MPolyIdeal)\n\nGiven a (homogeneous) ideal I in a standard mathbb Z-graded  multivariate polynomial ring with coefficients in a field, return the Castelnuovo-Mumford regularity of I.\n\nExamples\n\njulia> R, (x, y, z) = graded_polynomial_ring(QQ, [:x, :y, :z]);\n\njulia> F = graded_free_module(R, 1);\n\njulia> M, _ = quo(F, [x^2*F[1], y^2*F[1], z^2*F[1]])\n(Graded subquotient of graded submodule of F with 1 generator\n  1: e[1]\nby graded submodule of F with 3 generators\n  1: x^2*e[1]\n  2: y^2*e[1]\n  3: z^2*e[1], Hom: F -> M)\n\njulia> cm_regularity(M)\n3\n\njulia> minimal_betti_table(M)\ndegree: 0  1  2  3\n------------------\n     0: 1  -  -  -\n     1: -  3  -  -\n     2: -  -  3  -\n     3: -  -  -  1\n------------------\n total: 1  3  3  1 \n\njulia> R, (w, x, y, z) = graded_polynomial_ring(QQ, [:w, :x, :y, :z]);\n\njulia> I = ideal(R, [-x*z+y^2, x*y-w*z, x^2-w*y]);\n\njulia> cm_regularity(I)\n2\n\njulia> A, _ = quo(R, I);\n\njulia> minimal_betti_table(A)\ndegree: 0  1  2\n---------------\n     0: 1  -  -\n     1: -  3  2\n---------------\n total: 1  3  2 \n\n\n\n\n\n","category":"method"},{"location":"CommutativeAlgebra/homological_algebra/#Homology","page":"Homological Algebra","title":"Homology","text":"","category":"section"},{"location":"CommutativeAlgebra/homological_algebra/","page":"Homological Algebra","title":"Homological Algebra","text":"homology(C::ComplexOfMorphisms{<:ModuleFP})","category":"page"},{"location":"CommutativeAlgebra/homological_algebra/#homology-Tuple{ComplexOfMorphisms{<:ModuleFP}}","page":"Homological Algebra","title":"homology","text":"homology(C::ComplexOfMorphisms{<:ModuleFP})\n\nReturn the homology of C.\n\nExamples\n\njulia> R, (x,) = polynomial_ring(QQ, [:x]);\n\njulia> F = free_module(R, 1);\n\njulia> A, _ = quo(F, [x^4*F[1]]);\n\njulia> B, _ = quo(F, [x^3*F[1]]);\n\njulia> a = hom(A, B, [x^2*B[1]]);\n\njulia> b = hom(B, B, [x^2*B[1]]);\n\njulia> C = ComplexOfMorphisms(ModuleFP, [a, b]);\n\njulia> H = homology(C)\n3-element Vector{SubquoModule{QQMPolyRingElem}}:\n Subquotient of submodule with 1 generator\n  1: x*e[1]\nby submodule with 1 generator\n  1: x^4*e[1]\n Subquotient of submodule with 1 generator\n  1: x*e[1]\nby submodule with 2 generators\n  1: x^3*e[1]\n  2: x^2*e[1]\n Subquotient of submodule with 1 generator\n  1: e[1]\nby submodule with 2 generators\n  1: x^3*e[1]\n  2: x^2*e[1]\n\n\n\n\n\n","category":"method"},{"location":"CommutativeAlgebra/homological_algebra/","page":"Homological Algebra","title":"Homological Algebra","text":"homology(C::ComplexOfMorphisms{<:ModuleFP}, i::Int)","category":"page"},{"location":"CommutativeAlgebra/homological_algebra/#homology-Tuple{ComplexOfMorphisms{<:ModuleFP}, Int64}","page":"Homological Algebra","title":"homology","text":"homology(C::ComplexOfMorphisms{<:ModuleFP}, i::Int)\n\nReturn the i-th homology module of C.\n\nExamples\n\njulia> R, (x,) = polynomial_ring(QQ, [:x]);\n\njulia> F = free_module(R, 1);\n\njulia> A, _ = quo(F, [x^4*F[1]]);\n\njulia> B, _ = quo(F, [x^3*F[1]]);\n\njulia> a = hom(A, B, [x^2*B[1]]);\n\njulia> b = hom(B, B, [x^2*B[1]]);\n\njulia> C = ComplexOfMorphisms(ModuleFP, [a, b]);\n\njulia> H = homology(C, 1)\nSubquotient of submodule with 1 generator\n  1: x*e[1]\nby submodule with 2 generators\n  1: x^3*e[1]\n  2: x^2*e[1]\n\n\n\n\n\n","category":"method"},{"location":"CommutativeAlgebra/homological_algebra/#Hom-and-Ext","page":"Homological Algebra","title":"Hom and Ext","text":"","category":"section"},{"location":"CommutativeAlgebra/homological_algebra/","page":"Homological Algebra","title":"Homological Algebra","text":"hom(M::ModuleFP, N::ModuleFP; algorithm::Symbol=:maps)","category":"page"},{"location":"CommutativeAlgebra/homological_algebra/#hom-Tuple{ModuleFP, ModuleFP}","page":"Homological Algebra","title":"hom","text":"hom(M::ModuleFP, N::ModuleFP; algorithm::Symbol=:maps)\n\nReturn the module Hom(M,N) as an object of type SubquoModule.\n\nAdditionally, if H is that object, return the map which sends an element of H to the corresponding homomorphism M to N.\n\nThe keyword algorithm can be set to :maps for the default algorithm or to :matrices for an alternative based on matrices.\n\nExamples\n\njulia> R, (x, y) = polynomial_ring(QQ, [:x, :y]);\n\njulia> F = FreeMod(R, 2);\n\njulia> V = [x*F[1], y^2*F[2]];\n\njulia> M = quo_object(F, V)\nSubquotient of submodule with 2 generators\n  1: e[1]\n  2: e[2]\nby submodule with 2 generators\n  1: x*e[1]\n  2: y^2*e[2]\n\njulia> H = hom(M, M)[1]\nhom of (M, M)\n\njulia> gens(H)\n2-element Vector{SubquoModuleElem{QQMPolyRingElem}}:\n (e[1] -> e[1])\n (e[2] -> e[2])\n\njulia> relations(H)\n4-element Vector{FreeModElem{QQMPolyRingElem}}:\n x*(e[1] -> e[1])\n y^2*(e[1] -> e[2])\n x*(e[2] -> e[1])\n y^2*(e[2] -> e[2])\n\n\n\n\n\n","category":"method"},{"location":"CommutativeAlgebra/homological_algebra/","page":"Homological Algebra","title":"Homological Algebra","text":"element_to_homomorphism(f::ModuleFPElem)","category":"page"},{"location":"CommutativeAlgebra/homological_algebra/#element_to_homomorphism-Tuple{ModuleFPElem}","page":"Homological Algebra","title":"element_to_homomorphism","text":"element_to_homomorphism(f::ModuleFPElem)\n\nIf f is an element of a module created via hom(M,N), for some modules M and N,  return the homomorphism M to N corresponding to f.\n\nExamples\n\njulia> R, (x, y) = polynomial_ring(QQ, [:x, :y]);\n\njulia> F = FreeMod(R, 2);\n\njulia> V = [x*F[1], y^2*F[2]];\n\njulia> M = quo_object(F, V)\nSubquotient of submodule with 2 generators\n  1: e[1]\n  2: e[2]\nby submodule with 2 generators\n  1: x*e[1]\n  2: y^2*e[2]\n\njulia> H = hom(M, M)[1];\n\njulia> gens(H)\n2-element Vector{SubquoModuleElem{QQMPolyRingElem}}:\n (e[1] -> e[1])\n (e[2] -> e[2])\n\njulia> relations(H)\n4-element Vector{FreeModElem{QQMPolyRingElem}}:\n x*(e[1] -> e[1])\n y^2*(e[1] -> e[2])\n x*(e[2] -> e[1])\n y^2*(e[2] -> e[2])\n\njulia> a = element_to_homomorphism(H[1]+y*H[2])\nModule homomorphism\n  from M\n  to M\n\njulia> matrix(a)\n[1   0]\n[0   y]\n\n\n\n\n\n","category":"method"},{"location":"CommutativeAlgebra/homological_algebra/","page":"Homological Algebra","title":"Homological Algebra","text":"homomorphism_to_element(H::ModuleFP, phi::ModuleFPHom)","category":"page"},{"location":"CommutativeAlgebra/homological_algebra/#homomorphism_to_element-Tuple{ModuleFP, ModuleFPHom}","page":"Homological Algebra","title":"homomorphism_to_element","text":"homomorphism_to_element(H::ModuleFP, a::ModuleFPHom)\n\nIf the module H is created via hom(M,N), for some modules M and N, and a: M to N is a homomorphism, then return the element of H corresponding to a.\n\nExamples\n\njulia> R, (x, y) = polynomial_ring(QQ, [:x, :y]);\n\njulia> F = FreeMod(R, 2);\n\njulia> V = [x*F[1], y^2*F[2]];\n\njulia> M = quo_object(F, V)\nSubquotient of submodule with 2 generators\n  1: e[1]\n  2: e[2]\nby submodule with 2 generators\n  1: x*e[1]\n  2: y^2*e[2]\n\njulia> H = hom(M, M)[1];\n\njulia> gens(H)\n2-element Vector{SubquoModuleElem{QQMPolyRingElem}}:\n (e[1] -> e[1])\n (e[2] -> e[2])\n\njulia> relations(H)\n4-element Vector{FreeModElem{QQMPolyRingElem}}:\n x*(e[1] -> e[1])\n y^2*(e[1] -> e[2])\n x*(e[2] -> e[1])\n y^2*(e[2] -> e[2])\n\njulia> W =  [M[1], y*M[2]];\n\njulia> a = hom(M, M, W);\n\njulia> is_welldefined(a)\ntrue\n\njulia> matrix(a)\n[1   0]\n[0   y]\n\njulia> m = homomorphism_to_element(H, a)\n(e[1] -> e[1]) + y*(e[2] -> e[2])\n\n\n\n\n\n","category":"method"},{"location":"CommutativeAlgebra/homological_algebra/","page":"Homological Algebra","title":"Homological Algebra","text":"ext(M::ModuleFP, N::ModuleFP, i::Int)","category":"page"},{"location":"CommutativeAlgebra/homological_algebra/#ext-Tuple{ModuleFP, ModuleFP, Int64}","page":"Homological Algebra","title":"ext","text":"ext(M::ModuleFP, N::ModuleFP, i::Int)\n\nReturn textExt^i(MN).\n\nExamples\n\njulia> R, (x, y) = polynomial_ring(QQ, [:x, :y]);\n\njulia> F = FreeMod(R, 1);\n\njulia> V = [x*F[1], y*F[1]];\n\njulia> M = quo_object(F, V)\nSubquotient of submodule with 1 generator\n  1: e[1]\nby submodule with 2 generators\n  1: x*e[1]\n  2: y*e[1]\n\njulia> ext(M, M, 0)\nSubquotient of submodule with 1 generator\n  1: (e[1] -> e[1])\nby submodule with 2 generators\n  1: y*(e[1] -> e[1])\n  2: x*(e[1] -> e[1])\n\njulia> ext(M, M, 1)\nSubquotient of submodule with 2 generators\n  1: (e[1] -> e[1])\n  2: (e[2] -> e[1])\nby submodule with 4 generators\n  1: y*(e[1] -> e[1])\n  2: x*(e[1] -> e[1])\n  3: y*(e[2] -> e[1])\n  4: x*(e[2] -> e[1])\n\njulia> ext(M, M, 2)\nSubquotient of submodule with 1 generator\n  1: (e[1] -> e[1])\nby submodule with 2 generators\n  1: y*(e[1] -> e[1])\n  2: x*(e[1] -> e[1])\n\njulia> ext(M, M, 3)\nSubmodule with 0 generators\nrepresented as subquotient with no relations\n\n\n\n\n\n","category":"method"},{"location":"CommutativeAlgebra/homological_algebra/#Tensorproduct-and-Tor","page":"Homological Algebra","title":"Tensorproduct and Tor","text":"","category":"section"},{"location":"CommutativeAlgebra/homological_algebra/","page":"Homological Algebra","title":"Homological Algebra","text":"tensor_product(G::ModuleFP...; task::Symbol = :none)","category":"page"},{"location":"CommutativeAlgebra/homological_algebra/#tensor_product-Tuple{Vararg{ModuleFP}}","page":"Homological Algebra","title":"tensor_product","text":"tensor_product(M::ModuleFP...; task::Symbol = :none)\n\nGiven a collection of modules, say, M_1 dots M_n over a ring R, return M_1otimes_R cdots otimes_R M_n.\n\nIf task = :map, additionally return the map which sends a tuple (m_1dots m_n) of elements m_iin M_i to the pure tensor m_1otimesdotsotimes m_n.\n\nExamples\n\njulia> R, (x, y, z) = polynomial_ring(QQ, [:x, :y, :z]);\n\njulia> F = free_module(R, 1);\n\njulia> A = R[x; y];\n\njulia> B = R[x^2; y^3; z^4];\n\njulia> M = SubquoModule(F, A, B);\n\njulia> gens(M)\n2-element Vector{SubquoModuleElem{QQMPolyRingElem}}:\n x*e[1]\n y*e[1]\n\njulia> T, t = tensor_product(M, M; task = :map);\n\njulia> gens(T)\n4-element Vector{SubquoModuleElem{QQMPolyRingElem}}:\n x^2*e[1] \\otimes e[1]\n x*y*e[1] \\otimes e[1]\n x*y*e[1] \\otimes e[1]\n y^2*e[1] \\otimes e[1]\n\njulia> domain(t)\nparent of tuples of type Tuple{SubquoModuleElem{QQMPolyRingElem}, SubquoModuleElem{QQMPolyRingElem}}\n\njulia> t((M[1], M[2]))\nx*y*e[1] \\otimes e[1]\n\n\n\n\n\n","category":"method"},{"location":"CommutativeAlgebra/homological_algebra/","page":"Homological Algebra","title":"Homological Algebra","text":"tor(M::ModuleFP, N::ModuleFP, i::Int)","category":"page"},{"location":"CommutativeAlgebra/homological_algebra/#tor-Tuple{ModuleFP, ModuleFP, Int64}","page":"Homological Algebra","title":"tor","text":"tor(M::ModuleFP, N::ModuleFP, i::Int)\n\nReturn textTor_i(MN).\n\nExamples\n\njulia> R, (x, y, z) = polynomial_ring(QQ, [:x, :y, :z]);\n\njulia> A = R[x; y];\n\njulia> B = R[x^2; y^3; z^4];\n\njulia> M = SubquoModule(A, B);\n\njulia> F = free_module(R, 1);\n\njulia> Q, _ = quo(F, [x*F[1]]);\n\njulia> T0 = tor(Q, M, 0)\nSubquotient of submodule with 2 generators\n  1: x*e[1] \\otimes e[1]\n  2: y*e[1] \\otimes e[1]\nby submodule with 4 generators\n  1: x^2*e[1] \\otimes e[1]\n  2: y^3*e[1] \\otimes e[1]\n  3: z^4*e[1] \\otimes e[1]\n  4: x*y*e[1] \\otimes e[1]\n\njulia> T1 = tor(Q, M, 1)\nSubquotient of submodule with 2 generators\n  1: x*e[1] \\otimes e[1]\n  2: x*y*e[1] \\otimes e[1]\nby submodule with 3 generators\n  1: x^2*e[1] \\otimes e[1]\n  2: y^3*e[1] \\otimes e[1]\n  3: z^4*e[1] \\otimes e[1]\n\njulia> T2 =  tor(Q, M, 2)\nSubmodule with 0 generators\nrepresented as subquotient with no relations\n\n\n\n\n\n","category":"method"},{"location":"CommutativeAlgebra/homological_algebra/#Fitting-Ideals","page":"Homological Algebra","title":"Fitting Ideals","text":"","category":"section"},{"location":"CommutativeAlgebra/homological_algebra/","page":"Homological Algebra","title":"Homological Algebra","text":"fitting_ideal(M::ModuleFP{T}, i::Int) where T <: MPolyRingElem","category":"page"},{"location":"CommutativeAlgebra/homological_algebra/#fitting_ideal-Union{Tuple{T}, Tuple{ModuleFP{T}, Int64}} where T<:MPolyRingElem","page":"Homological Algebra","title":"fitting_ideal","text":"fitting_ideal(M::ModuleFP{T}, i::Int) where T <: MPolyRingElem\n\nReturn the i-th Fitting ideal of M.\n\nExamples\n\njulia> R, (x, y) = polynomial_ring(QQ, [:x, :y]);\n\njulia> F = free_module(R, 2);\n\njulia> o = zero(R)\n0\n\njulia> U = matrix([x^3-y^2 o; o x^3-y^2; -x^2 y; -y x])\n[x^3 - y^2           0]\n[        0   x^3 - y^2]\n[     -x^2           y]\n[       -y           x]\n\njulia> M = quo_object(F,U)\nSubquotient of submodule with 2 generators\n  1: e[1]\n  2: e[2]\nby submodule with 4 generators\n  1: (x^3 - y^2)*e[1]\n  2: (x^3 - y^2)*e[2]\n  3: -x^2*e[1] + y*e[2]\n  4: -y*e[1] + x*e[2]\n\njulia> fitting_ideal(M, -1)\nIdeal generated by\n  0\n\njulia> fitting_ideal(M, 0)\nIdeal generated by\n  x^3 - y^2\n\njulia> fitting_ideal(M, 1)\nIdeal generated by\n  y\n  x\n\njulia> fitting_ideal(M, 2)\nIdeal generated by\n  1\n\n\n\n\n\n","category":"method"},{"location":"CommutativeAlgebra/homological_algebra/#Flatness","page":"Homological Algebra","title":"Flatness","text":"","category":"section"},{"location":"CommutativeAlgebra/homological_algebra/","page":"Homological Algebra","title":"Homological Algebra","text":"Checking flatness in OSCAR relies on characterizing flatness in terms of Fitting ideals.","category":"page"},{"location":"CommutativeAlgebra/homological_algebra/","page":"Homological Algebra","title":"Homological Algebra","text":"is_flat(M::ModuleFP{T}) where T <: MPolyRingElem","category":"page"},{"location":"CommutativeAlgebra/homological_algebra/#is_flat-Union{Tuple{ModuleFP{T}}, Tuple{T}} where T<:MPolyRingElem","page":"Homological Algebra","title":"is_flat","text":"is_flat(M::ModuleFP{T}) where T <: MPolyRingElem\n\nReturn true if M is flat, false otherwise.\n\nExamples\n\njulia> R, (x, y) = polynomial_ring(QQ, [:x, :y]);\n\njulia> F = free_module(R, 2);\n\njulia> o = zero(R)\n0\n\njulia> U = matrix([x^3-y^2 o; o x^3-y^2; -x^2 y; -y x])\n[x^3 - y^2           0]\n[        0   x^3 - y^2]\n[     -x^2           y]\n[       -y           x]\n\njulia> M = quo_object(F,U)\nSubquotient of submodule with 2 generators\n  1: e[1]\n  2: e[2]\nby submodule with 4 generators\n  1: (x^3 - y^2)*e[1]\n  2: (x^3 - y^2)*e[2]\n  3: -x^2*e[1] + y*e[2]\n  4: -y*e[1] + x*e[2]\n\njulia> is_flat(M)\nfalse\n\n\n\n\n\n","category":"method"},{"location":"CommutativeAlgebra/homological_algebra/","page":"Homological Algebra","title":"Homological Algebra","text":"non_flat_locus(M::ModuleFP{T}) where T <: MPolyRingElem","category":"page"},{"location":"CommutativeAlgebra/homological_algebra/#non_flat_locus-Union{Tuple{ModuleFP{T}}, Tuple{T}} where T<:MPolyRingElem","page":"Homological Algebra","title":"non_flat_locus","text":"non_flat_locus(M::ModuleFP{T}) where T <: MPolyRingElem\n\nReturn an ideal of base_ring(M) which defines the non-flat-locus of M in the sense that the localization of M at a prime ideal of base_ring(M) is non-flat iff the prime ideal contains the returned ideal.\n\nExamples\n\njulia> R, (x, y) = polynomial_ring(QQ, [:x, :y]);\n\njulia> F = free_module(R, 2);\n\njulia> o = zero(R)\n0\n\njulia> U = matrix([x^3-y^2 o; o x^3-y^2; -x^2 y; -y x])\n[x^3 - y^2           0]\n[        0   x^3 - y^2]\n[     -x^2           y]\n[       -y           x]\n\njulia> M = quo_object(F,U)\nSubquotient of submodule with 2 generators\n  1: e[1]\n  2: e[2]\nby submodule with 4 generators\n  1: (x^3 - y^2)*e[1]\n  2: (x^3 - y^2)*e[2]\n  3: -x^2*e[1] + y*e[2]\n  4: -y*e[1] + x*e[2]\n\njulia> non_flat_locus(M)\nIdeal generated by\n  x^3 - y^2\n\n\n\n\n\n","category":"method"},{"location":"CommutativeAlgebra/homological_algebra/#Regular-Sequence-Test","page":"Homological Algebra","title":"Regular Sequence Test","text":"","category":"section"},{"location":"CommutativeAlgebra/homological_algebra/","page":"Homological Algebra","title":"Homological Algebra","text":"is_regular_sequence(V::Vector{T}, M::ModuleFP{T}) where T <: MPolyRingElem","category":"page"},{"location":"CommutativeAlgebra/homological_algebra/#is_regular_sequence-Union{Tuple{T}, Tuple{Vector{T}, ModuleFP{T}}} where T<:MPolyRingElem","page":"Homological Algebra","title":"is_regular_sequence","text":"is_regular_sequence(V::Vector{T}, M::ModuleFP{T}) where T <: MPolyRingElem\n\nReturn true if the elements of V form, in the given order, a regular sequence on M. Return false, otherwise.\n\nExamples\n\njulia> R, (x, y, z) = polynomial_ring(QQ, [:x, :y, :z]);\n\njulia> F = free_module(R, 1);\n\njulia> V =  [x*z-z, x*y-y, x]\n3-element Vector{QQMPolyRingElem}:\n x*z - z\n x*y - y\n x\n\njulia> is_regular_sequence(V, F)\nfalse\n\njulia> W = [x*z-z, x, x*y-y]\n3-element Vector{QQMPolyRingElem}:\n x*z - z\n x\n x*y - y\n\njulia> is_regular_sequence(W, F)\ntrue\n\n\n\n\n\n","category":"method"},{"location":"CommutativeAlgebra/homological_algebra/#Koszul-Complex","page":"Homological Algebra","title":"Koszul Complex","text":"","category":"section"},{"location":"CommutativeAlgebra/homological_algebra/","page":"Homological Algebra","title":"Homological Algebra","text":"koszul_matrix(V::Vector{T}, i::Int) where T <: MPolyRingElem","category":"page"},{"location":"CommutativeAlgebra/homological_algebra/#koszul_matrix-Union{Tuple{T}, Tuple{Vector{T}, Int64}} where T<:MPolyRingElem","page":"Homological Algebra","title":"koszul_matrix","text":"koszul_matrix(V::Vector{T}, p::Int) where T <: MPolyRingElem\n\nIf f_1 dots f_r are the entries of V in the given order, return the matrix representing the p-th map of the Koszul complex K(f_1 dots f_r).\n\nExamples\n\njulia> R, (x, y, z) = polynomial_ring(QQ, [:x, :y, :z]);\n\njulia> V = gens(R)\n3-element Vector{QQMPolyRingElem}:\n x\n y\n z\n\njulia> koszul_matrix(V, 3)\n[x   y   z]\n\njulia> koszul_matrix(V, 2)\n[-y   -z    0]\n[ x    0   -z]\n[ 0    x    y]\n\njulia> koszul_matrix(V, 1)\n[ z]\n[-y]\n[ x]\n\n\n\n\n\n","category":"method"},{"location":"CommutativeAlgebra/homological_algebra/","page":"Homological Algebra","title":"Homological Algebra","text":"koszul_complex(V::Vector{T}) where T <: MPolyRingElem","category":"page"},{"location":"CommutativeAlgebra/homological_algebra/#koszul_complex-Union{Tuple{Vector{T}}, Tuple{T}} where T<:MPolyRingElem","page":"Homological Algebra","title":"koszul_complex","text":"koszul_complex(V::Vector{T}) where T <: MPolyRingElem\n\nIf f_1 dots f_r are the entries of V in the given order, return the Koszul complex K(f_1 dots f_r).\n\nExamples\n\njulia> R, (x, y, z) = polynomial_ring(QQ, [:x, :y, :z]);\n\njulia> V = gens(R)\n3-element Vector{QQMPolyRingElem}:\n x\n y\n z\n\njulia> K = koszul_complex(V);\n\njulia> matrix(map(K, 2))\n[-y   -z    0]\n[ x    0   -z]\n[ 0    x    y]\n\njulia> Kd = hom(K, free_module(R, 1));\n\njulia> matrix(map(Kd, 1))\n[-y    x   0]\n[-z    0   x]\n[ 0   -z   y]\n\n\n\n\n\n","category":"method"},{"location":"CommutativeAlgebra/homological_algebra/#Koszul-Homology","page":"Homological Algebra","title":"Koszul Homology","text":"","category":"section"},{"location":"CommutativeAlgebra/homological_algebra/","page":"Homological Algebra","title":"Homological Algebra","text":"koszul_homology(V::Vector{T}, M::ModuleFP{T}, p::Int) where T <: MPolyRingElem","category":"page"},{"location":"CommutativeAlgebra/homological_algebra/#koszul_homology-Union{Tuple{T}, Tuple{Vector{T}, ModuleFP{T}, Int64}} where T<:MPolyRingElem","page":"Homological Algebra","title":"koszul_homology","text":"koszul_homology(V::Vector{T}, M::ModuleFP{T}, p::Int) where T <: MPolyRingElem\n\nIf f_1 dots f_r are the entries of V in the given order, return the p-th homology  module of the complex K(f_1 dots f_r)otimes_R M, where K(f_1 dots f_r) is the Koszul complex defined by f_1 dots f_r.\n\nnote: Note\nSee [GP08] or [DL06] for the definition of the Koszul complex.\n\nExamples\n\njulia> R, (x, y, z) = polynomial_ring(QQ, [:x, :y, :z]);\n\njulia> F = free_module(R, 1);\n\njulia> V =  [x*y, x*z, y*z]\n3-element Vector{QQMPolyRingElem}:\n x*y\n x*z\n y*z\n\njulia> koszul_homology(V, F, 0)\nSubquotient of submodule with 1 generator\n  1: e[1]^e[2]^e[3]\nby submodule with 3 generators\n  1: y*z*e[1]^e[2]^e[3]\n  2: -x*z*e[1]^e[2]^e[3]\n  3: x*y*e[1]^e[2]^e[3]\n\njulia> koszul_homology(V, F, 1)\nSubquotient of submodule with 2 generators\n  1: y*e[1]^e[3] \\otimes e[1] + z*e[2]^e[3] \\otimes e[1]\n  2: x*e[1]^e[2] \\otimes e[1] - z*e[2]^e[3] \\otimes e[1]\nby submodule with 3 generators\n  1: -x*z*e[1]^e[2] \\otimes e[1] - y*z*e[1]^e[3] \\otimes e[1]\n  2: x*y*e[1]^e[2] \\otimes e[1] - y*z*e[2]^e[3] \\otimes e[1]\n  3: x*y*e[1]^e[3] \\otimes e[1] + x*z*e[2]^e[3] \\otimes e[1]\n\njulia> koszul_homology(V, F, 2)\nSubquotient of submodule with 1 generator\n  1: x*y*e[1] \\otimes e[1] + x*z*e[2] \\otimes e[1] + y*z*e[3] \\otimes e[1]\nby submodule with 1 generator\n  1: x*y*e[1] \\otimes e[1] + x*z*e[2] \\otimes e[1] + y*z*e[3] \\otimes e[1]\n\njulia> R, (w, x, y, z) = polynomial_ring(QQ, [:w, :x, :y, :z]);\n\njulia> TC = ideal(R, [x*z-y^2, w*z-x*y, w*y-x^2]);\n\njulia> F = free_module(R, 1);\n\njulia> koszul_homology(gens(TC), F, 0)\nSubquotient of submodule with 1 generator\n  1: e[1]^e[2]^e[3]\nby submodule with 3 generators\n  1: (w*y - x^2)*e[1]^e[2]^e[3]\n  2: (-w*z + x*y)*e[1]^e[2]^e[3]\n  3: (x*z - y^2)*e[1]^e[2]^e[3]\n\njulia> koszul_homology(gens(TC), F, 1)\nSubquotient of submodule with 2 generators\n  1: z*e[1]^e[2] \\otimes e[1] + y*e[1]^e[3] \\otimes e[1] + x*e[2]^e[3] \\otimes e[1]\n  2: y*e[1]^e[2] \\otimes e[1] + x*e[1]^e[3] \\otimes e[1] + w*e[2]^e[3] \\otimes e[1]\nby submodule with 3 generators\n  1: (-w*z + x*y)*e[1]^e[2] \\otimes e[1] + (-w*y + x^2)*e[1]^e[3] \\otimes e[1]\n  2: (x*z - y^2)*e[1]^e[2] \\otimes e[1] + (-w*y + x^2)*e[2]^e[3] \\otimes e[1]\n  3: (x*z - y^2)*e[1]^e[3] \\otimes e[1] + (w*z - x*y)*e[2]^e[3] \\otimes e[1]\n\njulia> koszul_homology(gens(TC), F, 2)\nSubquotient of submodule with 1 generator\n  1: (-x*z + y^2)*e[1] \\otimes e[1] + (-w*z + x*y)*e[2] \\otimes e[1] + (-w*y + x^2)*e[3] \\otimes e[1]\nby submodule with 1 generator\n  1: (x*z - y^2)*e[1] \\otimes e[1] + (w*z - x*y)*e[2] \\otimes e[1] + (w*y - x^2)*e[3] \\otimes e[1]\n\n\n\n\n\n","category":"method"},{"location":"CommutativeAlgebra/homological_algebra/#Depth","page":"Homological Algebra","title":"Depth","text":"","category":"section"},{"location":"CommutativeAlgebra/homological_algebra/","page":"Homological Algebra","title":"Homological Algebra","text":"The computation of depth in OSCAR relies on expressing depth in terms of  Koszul cohomology. ","category":"page"},{"location":"CommutativeAlgebra/homological_algebra/","page":"Homological Algebra","title":"Homological Algebra","text":"depth(I::MPolyIdeal{T}, M::ModuleFP{T}) where T <: MPolyRingElem","category":"page"},{"location":"CommutativeAlgebra/homological_algebra/#depth-Union{Tuple{T}, Tuple{MPolyIdeal{T}, ModuleFP{T}}} where T<:MPolyRingElem","page":"Homological Algebra","title":"depth","text":"depth(I::MPolyIdeal{T}, M::ModuleFP{T}) where T <: MPolyRingElem\n\nReturn the depth of I on M.\n\nExamples\n\njulia> R, (w, x, y, z) = polynomial_ring(QQ, [:w, :x, :y, :z]);\n\njulia> TC = ideal(R, [x*z-y^2, w*z-x*y, w*y-x^2]);\n\njulia> dim(TC)\n2\n\njulia> F = free_module(R, 1);\n\njulia> U = collect(gen(TC, i)*F[1] for i in 1:ngens(TC));\n\njulia> M, _ = quo(F, U);\n\njulia> I = ideal(R, gens(R))\nIdeal generated by\n  w\n  x\n  y\n  z\n\njulia> depth(I, M)\n2\n\njulia> S, x, y = polynomial_ring(QQ, :x => 1:3, :y => 1:5);\n\njulia> W = [y[1]-x[1]^2,  y[2]-x[2]^2,   y[3]-x[3]^2, y[4]-x[2]*(x[1]-x[3]),  y[5]-(x[1]-x[2])*x[3]];\n\njulia> J = eliminate(ideal(S, W), x);\n\njulia> R, y = polynomial_ring(QQ, :y => 1:5);\n\njulia> W = append!(repeat([zero(R)], 3), gens(R))\n8-element Vector{QQMPolyRingElem}:\n 0\n 0\n 0\n y[1]\n y[2]\n y[3]\n y[4]\n y[5]\n\njulia> P = hom(S, R, W);\n\njulia> VP4 = P(J);\n\njulia> dim(VP4)\n3\n\njulia> F = free_module(R, 1);\n\njulia> U = collect(gen(VP4, i)*F[1] for i in 1:ngens(VP4));\n\njulia> M, _ = quo(F, U);\n\njulia> I = ideal(R, gens(R))\nIdeal generated by\n  y[1]\n  y[2]\n  y[3]\n  y[4]\n  y[5]\n\njulia> depth(I, M)\n1\n\n\n\n\n\n","category":"method"},{"location":"AlgebraicGeometry/Schemes/MorphismsOfAffineSchemes/","page":"Morphisms of affine schemes","title":"Morphisms of affine schemes","text":"CurrentModule = Oscar","category":"page"},{"location":"AlgebraicGeometry/Schemes/MorphismsOfAffineSchemes/#Morphisms-of-affine-schemes","page":"Morphisms of affine schemes","title":"Morphisms of affine schemes","text":"","category":"section"},{"location":"AlgebraicGeometry/Schemes/MorphismsOfAffineSchemes/#Constructors","page":"Morphisms of affine schemes","title":"Constructors","text":"","category":"section"},{"location":"AlgebraicGeometry/Schemes/MorphismsOfAffineSchemes/#General-constructors","page":"Morphisms of affine schemes","title":"General constructors","text":"","category":"section"},{"location":"AlgebraicGeometry/Schemes/MorphismsOfAffineSchemes/","page":"Morphisms of affine schemes","title":"Morphisms of affine schemes","text":"morphism(X::AbsAffineScheme, Y::AbsAffineScheme, f::Vector{<:RingElem}; check::Bool=true)","category":"page"},{"location":"AlgebraicGeometry/Schemes/MorphismsOfAffineSchemes/#morphism-Tuple{AbsAffineScheme, AbsAffineScheme, Vector{<:RingElem}}","page":"Morphisms of affine schemes","title":"morphism","text":"morphism(X::AbsAffineScheme, Y::AbsAffineScheme, f::Vector{<:RingElem}; check::Bool=true)\n\nThis method constructs a morphism from the scheme X to the scheme Y. For this one has to specify the images of the coordinates (the generators of ambient_coordinate_ring(Y)) under the pullback map 𝒪(Y)  𝒪(X) as third argument.\n\nNote that expensive checks can be turned off by setting check=false.\n\nExamples\n\njulia> X = affine_space(QQ,3)\nAffine space of dimension 3\n  over rational field\nwith coordinates [x1, x2, x3]\n\njulia> Y = affine_space(QQ,3)\nAffine space of dimension 3\n  over rational field\nwith coordinates [x1, x2, x3]\n\njulia> morphism(X, Y, gens(OO(X)))\nAffine scheme morphism\n  from [x1, x2, x3]  affine 3-space over QQ\n  to   [x1, x2, x3]  affine 3-space over QQ\ngiven by the pullback function\n  x1 -> x1\n  x2 -> x2\n  x3 -> x3\n\n\n\n\n\n","category":"method"},{"location":"AlgebraicGeometry/Schemes/MorphismsOfAffineSchemes/#Special-constructors","page":"Morphisms of affine schemes","title":"Special constructors","text":"","category":"section"},{"location":"AlgebraicGeometry/Schemes/MorphismsOfAffineSchemes/","page":"Morphisms of affine schemes","title":"Morphisms of affine schemes","text":"identity_map(X::AbsAffineScheme{<:Any, <:MPolyRing})\ninclusion_morphism(X::AbsAffineScheme, Y::AbsAffineScheme; check::Bool=true)\ncompose(f::AbsAffineSchemeMor, g::AbsAffineSchemeMor)\nrestrict(f::AffineSchemeMor, U::AbsAffineScheme, V::AbsAffineScheme)","category":"page"},{"location":"AlgebraicGeometry/Schemes/MorphismsOfAffineSchemes/#identity_map-Tuple{AbsAffineScheme{<:Any, <:MPolyRing}}","page":"Morphisms of affine schemes","title":"identity_map","text":"identity_map(X::AbsAffineScheme{<:Any, <:MPolyRing})\n\nThis method constructs the identity morphism from an affine scheme to itself.\n\nExamples\n\njulia> X = affine_space(QQ,3)\nAffine space of dimension 3\n  over rational field\nwith coordinates [x1, x2, x3]\n\njulia> identity_map(X)\nAffine scheme morphism\n  from [x1, x2, x3]  affine 3-space over QQ\n  to   [x1, x2, x3]  affine 3-space over QQ\ngiven by the pullback function\n  x1 -> x1\n  x2 -> x2\n  x3 -> x3\n\n\n\n\n\n","category":"method"},{"location":"AlgebraicGeometry/Schemes/MorphismsOfAffineSchemes/#inclusion_morphism-Tuple{AbsAffineScheme, AbsAffineScheme}","page":"Morphisms of affine schemes","title":"inclusion_morphism","text":"inclusion_morphism(X::AbsAffineScheme, Y::AbsAffineScheme; check::Bool=true)\n\nReturn the inclusion map from X to Y.\n\nExamples\n\njulia> X = affine_space(QQ,3)\nAffine space of dimension 3\n  over rational field\nwith coordinates [x1, x2, x3]\n\njulia> R = OO(X)\nMultivariate polynomial ring in 3 variables x1, x2, x3\n  over rational field\n\njulia> (x1,x2,x3) = gens(R)\n3-element Vector{QQMPolyRingElem}:\n x1\n x2\n x3\n\njulia> Y = subscheme(X, x1)\nSpectrum\n  of quotient\n    of multivariate polynomial ring in 3 variables x1, x2, x3\n      over rational field\n    by ideal (x1)\n\njulia> f = inclusion_morphism(Y, X)\nAffine scheme morphism\n  from [x1, x2, x3]  scheme(x1)\n  to   [x1, x2, x3]  affine 3-space over QQ\ngiven by the pullback function\n  x1 -> x1\n  x2 -> x2\n  x3 -> x3\n\njulia> I = kernel(pullback(f))  # this is a way to obtain the ideal ``I ⊆  O(X)`` cutting out ``Y`` from ``X``.\nIdeal generated by\n  x1\n\njulia> base_ring(I) == OO(X)\ntrue\n\n\n\n\n\n","category":"method"},{"location":"AlgebraicGeometry/Schemes/MorphismsOfAffineSchemes/#compose-Tuple{AbsAffineSchemeMor, AbsAffineSchemeMor}","page":"Morphisms of affine schemes","title":"compose","text":"compose(f::AbsAffineSchemeMor, g::AbsAffineSchemeMor)\n\nThis method computes the composition of two morphisms.\n\nExamples\n\njulia> X = affine_space(QQ,3)\nAffine space of dimension 3\n  over rational field\nwith coordinates [x1, x2, x3]\n\njulia> R = OO(X)\nMultivariate polynomial ring in 3 variables x1, x2, x3\n  over rational field\n\njulia> (x1,x2,x3) = gens(R)\n3-element Vector{QQMPolyRingElem}:\n x1\n x2\n x3\n\njulia> Y = subscheme(X, x1)\nSpectrum\n  of quotient\n    of multivariate polynomial ring in 3 variables x1, x2, x3\n      over rational field\n    by ideal (x1)\n\njulia> m1 = inclusion_morphism(Y, X)\nAffine scheme morphism\n  from [x1, x2, x3]  scheme(x1)\n  to   [x1, x2, x3]  affine 3-space over QQ\ngiven by the pullback function\n  x1 -> x1\n  x2 -> x2\n  x3 -> x3\n\njulia> m2 = identity_map(X)\nAffine scheme morphism\n  from [x1, x2, x3]  affine 3-space over QQ\n  to   [x1, x2, x3]  affine 3-space over QQ\ngiven by the pullback function\n  x1 -> x1\n  x2 -> x2\n  x3 -> x3\n\njulia> m3 = identity_map(Y)\nAffine scheme morphism\n  from [x1, x2, x3]  scheme(x1)\n  to   [x1, x2, x3]  scheme(x1)\ngiven by the pullback function\n  x1 -> 0\n  x2 -> x2\n  x3 -> x3\n\njulia> compose(m3, compose(m1, m2)) == m1\ntrue\n\n\n\n\n\n","category":"method"},{"location":"AlgebraicGeometry/Schemes/MorphismsOfAffineSchemes/#restrict-Tuple{Oscar.AffineSchemeMor, AbsAffineScheme, AbsAffineScheme}","page":"Morphisms of affine schemes","title":"restrict","text":"restrict(f::AbsAffineSchemeMor, D::AbsAffineScheme, Z::AbsAffineScheme; check::Bool=true)\n\nThis method restricts the domain of the morphism f to D and its codomain to Z.\n\nExamples\n\njulia> X = affine_space(QQ,3)\nAffine space of dimension 3\n  over rational field\nwith coordinates [x1, x2, x3]\n\njulia> R = OO(X)\nMultivariate polynomial ring in 3 variables x1, x2, x3\n  over rational field\n\njulia> (x1,x2,x3) = gens(R)\n3-element Vector{QQMPolyRingElem}:\n x1\n x2\n x3\n\njulia> Y = subscheme(X, x1)\nSpectrum\n  of quotient\n    of multivariate polynomial ring in 3 variables x1, x2, x3\n      over rational field\n    by ideal (x1)\n\njulia> restrict(identity_map(X), Y, Y) == identity_map(Y)\ntrue\n\n\n\n\n\nrestrict(f::SchemeMor, U::Scheme, V::Scheme; check::Bool=true)\n\nReturn the restriction g U  V of f to U and V.\n\n\n\n\n\n","category":"method"},{"location":"AlgebraicGeometry/Schemes/MorphismsOfAffineSchemes/#Attributes","page":"Morphisms of affine schemes","title":"Attributes","text":"","category":"section"},{"location":"AlgebraicGeometry/Schemes/MorphismsOfAffineSchemes/#General-attributes","page":"Morphisms of affine schemes","title":"General attributes","text":"","category":"section"},{"location":"AlgebraicGeometry/Schemes/MorphismsOfAffineSchemes/","page":"Morphisms of affine schemes","title":"Morphisms of affine schemes","text":"domain(f::AbsAffineSchemeMor)\ncodomain(f::AbsAffineSchemeMor)\npullback(f::AbsAffineSchemeMor)\ngraph(f::AbsAffineSchemeMor)","category":"page"},{"location":"AlgebraicGeometry/Schemes/MorphismsOfAffineSchemes/#domain-Tuple{AbsAffineSchemeMor}","page":"Morphisms of affine schemes","title":"domain","text":"domain(f::AbsAffineSchemeMor)\n\nOn a morphism f  X  Y of affine schemes, this returns X.\n\nExamples\n\njulia> Y = affine_space(QQ,3)\nAffine space of dimension 3\n  over rational field\nwith coordinates [x1, x2, x3]\n\njulia> R = OO(Y)\nMultivariate polynomial ring in 3 variables x1, x2, x3\n  over rational field\n\njulia> (x1,x2,x3) = gens(R)\n3-element Vector{QQMPolyRingElem}:\n x1\n x2\n x3\n\njulia> X = subscheme(Y, x1)\nSpectrum\n  of quotient\n    of multivariate polynomial ring in 3 variables x1, x2, x3\n      over rational field\n    by ideal (x1)\n\njulia> f = inclusion_morphism(X, Y)\nAffine scheme morphism\n  from [x1, x2, x3]  scheme(x1)\n  to   [x1, x2, x3]  affine 3-space over QQ\ngiven by the pullback function\n  x1 -> x1\n  x2 -> x2\n  x3 -> x3\n\njulia> domain(f)\nSpectrum\n  of quotient\n    of multivariate polynomial ring in 3 variables x1, x2, x3\n      over rational field\n    by ideal (x1)\n\n\n\n\n\n","category":"method"},{"location":"AlgebraicGeometry/Schemes/MorphismsOfAffineSchemes/#codomain-Tuple{AbsAffineSchemeMor}","page":"Morphisms of affine schemes","title":"codomain","text":"codomain(f::AbsAffineSchemeMor)\n\nOn a morphism f  X  Y of affine schemes, this returns Y.\n\nExamples\n\njulia> Y = affine_space(QQ,3)\nAffine space of dimension 3\n  over rational field\nwith coordinates [x1, x2, x3]\n\njulia> R = OO(Y)\nMultivariate polynomial ring in 3 variables x1, x2, x3\n  over rational field\n\njulia> (x1,x2,x3) = gens(R)\n3-element Vector{QQMPolyRingElem}:\n x1\n x2\n x3\n\njulia> X = subscheme(Y, x1)\nSpectrum\n  of quotient\n    of multivariate polynomial ring in 3 variables x1, x2, x3\n      over rational field\n    by ideal (x1)\n\njulia> f = inclusion_morphism(X, Y)\nAffine scheme morphism\n  from [x1, x2, x3]  scheme(x1)\n  to   [x1, x2, x3]  affine 3-space over QQ\ngiven by the pullback function\n  x1 -> x1\n  x2 -> x2\n  x3 -> x3\n\njulia> codomain(f)\nAffine space of dimension 3\n  over rational field\nwith coordinates [x1, x2, x3]\n\n\n\n\n\n","category":"method"},{"location":"AlgebraicGeometry/Schemes/MorphismsOfAffineSchemes/#pullback-Tuple{AbsAffineSchemeMor}","page":"Morphisms of affine schemes","title":"pullback","text":"pullback(f::AbsAffineSchemeMor)\n\nOn a morphism f  X  Y of affine schemes X = Spec(S) and Y = Spec(R), this returns the ring homomorphism f^*  R  S.\n\nExamples\n\njulia> Y = affine_space(QQ,3)\nAffine space of dimension 3\n  over rational field\nwith coordinates [x1, x2, x3]\n\njulia> R = OO(Y)\nMultivariate polynomial ring in 3 variables x1, x2, x3\n  over rational field\n\njulia> (x1,x2,x3) = gens(R)\n3-element Vector{QQMPolyRingElem}:\n x1\n x2\n x3\n\njulia> X = subscheme(Y, x1)\nSpectrum\n  of quotient\n    of multivariate polynomial ring in 3 variables x1, x2, x3\n      over rational field\n    by ideal (x1)\n\njulia> pullback(inclusion_morphism(X, Y))\nRing homomorphism\n  from multivariate polynomial ring in 3 variables over QQ\n  to quotient of multivariate polynomial ring by ideal (x1)\ndefined by\n  x1 -> x1\n  x2 -> x2\n  x3 -> x3\n\n\n\n\n\n","category":"method"},{"location":"AlgebraicGeometry/Schemes/MorphismsOfAffineSchemes/#graph-Tuple{AbsAffineSchemeMor}","page":"Morphisms of affine schemes","title":"graph","text":"graph(f::AbsAffineSchemeMor)\n\nReturn the graph of f  X  Y as a subscheme of XY as well as the two projections to X and Y.\n\nExamples\n\njulia> Y = affine_space(QQ,3)\nAffine space of dimension 3\n  over rational field\nwith coordinates [x1, x2, x3]\n\njulia> R = OO(Y)\nMultivariate polynomial ring in 3 variables x1, x2, x3\n  over rational field\n\njulia> (x1,x2,x3) = gens(R)\n3-element Vector{QQMPolyRingElem}:\n x1\n x2\n x3\n\njulia> X = subscheme(Y, x1)\nSpectrum\n  of quotient\n    of multivariate polynomial ring in 3 variables x1, x2, x3\n      over rational field\n    by ideal (x1)\n\njulia> f = inclusion_morphism(X, Y)\nAffine scheme morphism\n  from [x1, x2, x3]  scheme(x1)\n  to   [x1, x2, x3]  affine 3-space over QQ\ngiven by the pullback function\n  x1 -> x1\n  x2 -> x2\n  x3 -> x3\n\njulia> graph(f)\n(scheme(x1, -x1, x2 - x2, x3 - x3), Hom: scheme(x1, -x1, x2 - x2, x3 - x3) -> scheme(x1), Hom: scheme(x1, -x1, x2 - x2, x3 - x3) -> affine 3-space over QQ with coordinates [x1, x2, x3])\n\n\n\n\n\ngraph(TropC::TropicalCurve{minOrMax,false})\n\nReturn the graph of an abstract tropical curve TropC.  Same as polyhedral_complex(tc).\n\n\n\n\n\n","category":"method"},{"location":"AlgebraicGeometry/Schemes/MorphismsOfAffineSchemes/#Special-attributes","page":"Morphisms of affine schemes","title":"Special attributes","text":"","category":"section"},{"location":"AlgebraicGeometry/Schemes/MorphismsOfAffineSchemes/","page":"Morphisms of affine schemes","title":"Morphisms of affine schemes","text":"In addition to the standard getters and methods for instances of AffineSchemeMor, we also have","category":"page"},{"location":"AlgebraicGeometry/Schemes/MorphismsOfAffineSchemes/","page":"Morphisms of affine schemes","title":"Morphisms of affine schemes","text":"image_ideal(f::ClosedEmbedding)","category":"page"},{"location":"AlgebraicGeometry/Schemes/MorphismsOfAffineSchemes/#image_ideal-Tuple{ClosedEmbedding}","page":"Morphisms of affine schemes","title":"image_ideal","text":"image_ideal(f::ClosedEmbedding)\n\nFor a closed embedding f  X  Y of affine schemes X = Spec(S)  into Y = Spec(R) such that S  RI via f for some ideal  I  R this returns I.\n\n\n\n\n\n","category":"method"},{"location":"AlgebraicGeometry/Schemes/MorphismsOfAffineSchemes/#Undocumented","page":"Morphisms of affine schemes","title":"Undocumented","text":"","category":"section"},{"location":"AlgebraicGeometry/Schemes/MorphismsOfAffineSchemes/","page":"Morphisms of affine schemes","title":"Morphisms of affine schemes","text":"The following functions do exist but are currently undocumented:","category":"page"},{"location":"AlgebraicGeometry/Schemes/MorphismsOfAffineSchemes/","page":"Morphisms of affine schemes","title":"Morphisms of affine schemes","text":"underlying_morphism,\ncomplement_ideal,\ncomplement_scheme,\npreimage,\ninverse,\nvarious type getters.","category":"page"},{"location":"AlgebraicGeometry/Schemes/MorphismsOfAffineSchemes/#Properties","page":"Morphisms of affine schemes","title":"Properties","text":"","category":"section"},{"location":"AlgebraicGeometry/Schemes/MorphismsOfAffineSchemes/","page":"Morphisms of affine schemes","title":"Morphisms of affine schemes","text":"is_isomorphism(f::AbsAffineSchemeMor)\nis_inverse_of(f::AbsAffineSchemeMor, g::AbsAffineSchemeMor)\nis_identity_map(f::AbsAffineSchemeMor)","category":"page"},{"location":"AlgebraicGeometry/Schemes/MorphismsOfAffineSchemes/#is_isomorphism-Tuple{AbsAffineSchemeMor}","page":"Morphisms of affine schemes","title":"is_isomorphism","text":"is_isomorphism(f::AbsAffineSchemeMor)\n\nThis method checks if a morphism is an isomorphism.\n\n\n\n\n\n","category":"method"},{"location":"AlgebraicGeometry/Schemes/MorphismsOfAffineSchemes/#is_inverse_of-Tuple{AbsAffineSchemeMor, AbsAffineSchemeMor}","page":"Morphisms of affine schemes","title":"is_inverse_of","text":"is_inverse_of(f::AbsAffineSchemeMor, g::AbsAffineSchemeMor)\n\nThis method checks if a morphism f is the inverse of a morphism g.\n\n\n\n\n\n","category":"method"},{"location":"AlgebraicGeometry/Schemes/MorphismsOfAffineSchemes/#is_identity_map-Tuple{AbsAffineSchemeMor}","page":"Morphisms of affine schemes","title":"is_identity_map","text":"is_identity_map(f::AbsAffineSchemeMor)\n\nThis method checks if a morphism is the identity map.\n\nExamples\n\njulia> X = affine_space(QQ,3)\nAffine space of dimension 3\n  over rational field\nwith coordinates [x1, x2, x3]\n\njulia> R = OO(X)\nMultivariate polynomial ring in 3 variables x1, x2, x3\n  over rational field\n\njulia> (x1,x2,x3) = gens(R)\n3-element Vector{QQMPolyRingElem}:\n x1\n x2\n x3\n\njulia> Y = subscheme(X, x1)\nSpectrum\n  of quotient\n    of multivariate polynomial ring in 3 variables x1, x2, x3\n      over rational field\n    by ideal (x1)\n\njulia> is_identity_map(inclusion_morphism(Y, X))\nfalse\n\n\n\n\n\n","category":"method"},{"location":"AlgebraicGeometry/Schemes/MorphismsOfAffineSchemes/#Methods","page":"Morphisms of affine schemes","title":"Methods","text":"","category":"section"},{"location":"AlgebraicGeometry/Schemes/MorphismsOfAffineSchemes/","page":"Morphisms of affine schemes","title":"Morphisms of affine schemes","text":"fiber_product(f::AbsAffineSchemeMor, g::AbsAffineSchemeMor)\nproduct(X::AbsAffineScheme, Y::AbsAffineScheme)\nsimplify(X::AbsAffineScheme{<:AbstractAlgebra.Field})","category":"page"},{"location":"AlgebraicGeometry/Schemes/MorphismsOfAffineSchemes/#fiber_product-Tuple{AbsAffineSchemeMor, AbsAffineSchemeMor}","page":"Morphisms of affine schemes","title":"fiber_product","text":"fiber_product(f::AbsAffineSchemeMor, g::AbsAffineSchemeMor)\n\nFor morphisms f  X  Z and g  Y  Z return the fiber product XY over Z together with its two canonical projections.\n\nWhenever you have another set of maps a: W → X and b : W → Y forming a commutative square with f and g, you can use induced_map_to_fiber_product to  create the resulting map W → X×Y.\n\n\n\n\n\n","category":"method"},{"location":"AlgebraicGeometry/Schemes/MorphismsOfAffineSchemes/#product-Tuple{AbsAffineScheme, AbsAffineScheme}","page":"Morphisms of affine schemes","title":"product","text":"product(X::AbsAffineScheme, Y::AbsAffineScheme)\n\nReturn a triple (XY p₁ p₂) consisting of the product XY over the common base ring 𝕜 and the two projections p₁  XY  X and p₂  XY  Y.\n\n\n\n\n\n","category":"method"},{"location":"AlgebraicGeometry/Schemes/MorphismsOfAffineSchemes/#simplify-Tuple{AbsAffineScheme{<:Field}}","page":"Morphisms of affine schemes","title":"simplify","text":"simplify(X::AbsAffineScheme{<:Field})\n\nGiven an affine scheme X with coordinate ring R = 𝕜x₁xₙI (or a localization thereof), use Singular's elimpart to try to eliminate variables xᵢ to arrive at a simpler presentation R  R = 𝕜y₁yₘJ for some ideal J; return a SimplifiedAffineScheme Y with X as its original.\n\n***Note:*** The ambient_coordinate_ring of the output Y will be different from the one of X and hence the two schemes will not compare using ==.\n\n\n\n\n\n","category":"method"},{"location":"PolyhedralGeometry/Polyhedra/intro/","page":"Introduction","title":"Introduction","text":"CurrentModule = Oscar","category":"page"},{"location":"PolyhedralGeometry/Polyhedra/intro/#Introduction","page":"Introduction","title":"Introduction","text":"","category":"section"},{"location":"PolyhedralGeometry/Polyhedra/intro/","page":"Introduction","title":"Introduction","text":"Let mathbbF be an ordered field; the default is that mathbbF=mathbbQ is the field of rational numbers and other fields are not yet supported everywhere in the implementation.","category":"page"},{"location":"PolyhedralGeometry/Polyhedra/intro/","page":"Introduction","title":"Introduction","text":"A set P subseteq mathbbF^n is called a (convex) polyhedron if it can be written as the intersection of finitely many closed affine halfspaces in mathbbF^n.  That is, there exists a matrix A and a vector b such that P = P(Ab) =  x in mathbbF^n mid Ax leq b Writing P as above is called an H-representation of P.","category":"page"},{"location":"PolyhedralGeometry/Polyhedra/intro/","page":"Introduction","title":"Introduction","text":"When a polyhedron P subset mathbbF^n is bounded, it is called a polytope and the fundamental theorem of polytopes states that it may be written as the convex hull of finitely many points. That is P = textrmconv(p_1ldotsp_N) p_i in mathbbF^n Writing P in this way is called a V-representation. Polytopes are necessarily compact, i.e., they form convex bodies.","category":"page"},{"location":"PolyhedralGeometry/Polyhedra/intro/","page":"Introduction","title":"Introduction","text":"Each polytope has a unique V-representation which is minimal with respect to inclusion (or cardinality). Conversely, a polyhedron which is full-dimensional, has a unique minimal H-representation. If the polyhedron is not full-dimensional, then there is no canonical choice of an H-representation.","category":"page"},{"location":"Groups/basics/","page":"Basics","title":"Basics","text":"CurrentModule = Oscar\nDocTestSetup = Oscar.doctestsetup()","category":"page"},{"location":"Groups/basics/#Basics","page":"Basics","title":"Basics","text":"","category":"section"},{"location":"Groups/basics/#elements_of_groups","page":"Basics","title":"Elements of groups","text":"","category":"section"},{"location":"Groups/basics/","page":"Basics","title":"Basics","text":"Given a group G, it is always possible to have access to some particular elements.","category":"page"},{"location":"Groups/basics/","page":"Basics","title":"Basics","text":"GAPGroup\nBasicGAPGroupElem{T<:GAPGroup}\nelem_type(::Type{T}) where T <: GAPGroup\none(x::GAPGroup)\none(x::GAPGroupElem)\nis_finite_order(x::GAPGroupElem)\ngens(::GAPGroup)\nhas_gens(::GAPGroup)\nnumber_of_generators(G::GAPGroup)\ngen(::GAPGroup, i::Int)\nsmall_generating_set(G::GAPGroup)\nminimal_size_generating_set(G::GAPGroup)\nBase.rand(G::GAPGroup)\nrand_pseudo(G::GAPGroup)","category":"page"},{"location":"Groups/basics/#GAPGroup","page":"Basics","title":"GAPGroup","text":"GAPGroup <: AbstractAlgebra.Group\n\nEach object of the abstract type GAPGroup stores a group object from the GAP system, and thus can delegate questions about this object to GAP.\n\nFor expert usage, you can extract the underlying GAP object via GapObj, i.e., if G is a GAPGroup, then GapObj(G) is the GapObj underlying G.\n\nConcrete subtypes of GAPGroup are PermGroup, FPGroup, SubFPGroup, PcGroup, SubPcGroup, and MatrixGroup.\n\n\n\n\n\n","category":"type"},{"location":"Groups/basics/#BasicGAPGroupElem","page":"Basics","title":"BasicGAPGroupElem","text":"BasicGAPGroupElem{T<:GAPGroup} <: GAPGroupElem{T}\n\nThe type BasicGAPGroupElem gathers all types of group elements described only by an underlying GAP object.\n\nIf x is an element of the group G of type T, then the type of x is BasicGAPGroupElem{T}.\n\n\n\n\n\n","category":"type"},{"location":"Groups/basics/#elem_type-Union{Tuple{Type{T}}, Tuple{T}} where T<:Oscar.GAPGroup","page":"Basics","title":"elem_type","text":"elem_type(::Type{T}) where T <: GAPGroup\nelem_type(::T) where T <: GAPGroup\n\nelem_type maps (the type of) a group to the type of its elements. For now, a group of type T has elements of type BasicGAPGroupElem{T}. So we provide it mostly for consistency with other parts of OSCAR. In the future, a more elaborate setup for group element types might also be needed.\n\n\n\n\n\n","category":"method"},{"location":"Groups/basics/#one-Tuple{Oscar.GAPGroup}","page":"Basics","title":"one","text":"one(G::GAPGroup) -> elem_type(G)\n\nReturn the identity of the group G.\n\n\n\n\n\n","category":"method"},{"location":"Groups/basics/#one-Tuple{GAPGroupElem}","page":"Basics","title":"one","text":"one(x::GAPGroupElem{T}) -> GAPGroupElem{T}\n\nReturn the identity of the parent group of x.\n\n\n\n\n\n","category":"method"},{"location":"Groups/basics/#is_finite_order-Tuple{GAPGroupElem}","page":"Basics","title":"is_finite_order","text":"is_finite_order(g::GAPGroupElem) -> Bool\n\nReturn true if g has finite order, and false otherwise.\n\nExamples\n\njulia> is_finite_order(gen(symmetric_group(5), 1))\ntrue\n\njulia> is_finite_order(gen(free_group(2), 1))\nfalse\n\n\n\n\n\n\n","category":"method"},{"location":"Groups/basics/#gens-Tuple{Oscar.GAPGroup}","page":"Basics","title":"gens","text":"gens(G::Group)\n\nReturn a vector of generators of G. To get the i-th generator, use G[i] or gen(G,i) (see gen) instead of gens(G)[i], as that is more efficient.\n\nExamples\n\njulia> g = symmetric_group(5);  gens(g)\n2-element Vector{PermGroupElem}:\n (1,2,3,4,5)\n (1,2)\n\njulia> g[2]\n(1,2)\n\n\nnote: Note\nThe output of gens(G) is not, in general, the minimal list of generators for G.\n\n\n\n\n\n","category":"method"},{"location":"Groups/basics/#has_gens-Tuple{Oscar.GAPGroup}","page":"Basics","title":"has_gens","text":"has_gens(G::Group)\n\nReturn whether generators for the group G are known.\n\nExamples\n\njulia> F = free_group(2)\nFree group of rank 2\n\njulia> has_gens(F)\ntrue\n\njulia> H = derived_subgroup(F)[1]\nFree group\n\njulia> has_gens(H)\nfalse\n\n\n\n\n\n","category":"method"},{"location":"Groups/basics/#number_of_generators-Tuple{Oscar.GAPGroup}","page":"Basics","title":"number_of_generators","text":"number_of_generators(G::GAPGroup) -> Int\n\nReturn the length of the vector gens(G).\n\nwarning: WARNING:\nthis is NOT, in general, the minimum number of generators for G.\n\n\n\n\n\n","category":"method"},{"location":"Groups/basics/#gen-Tuple{Oscar.GAPGroup, Int64}","page":"Basics","title":"gen","text":"gen(G::GAPGroup, i::Int)\n\nReturn one(G) if i == 0, the i-th element of the vector gens(G) if i is positive, and the inverse of the i-th element of gens(G) if i is negative.\n\nFor positive i, this is equivalent to G[i], and returns gens(G)[i] but may be more efficient than the latter.\n\nAn exception is thrown if abs(i) is larger than the length of gens(G).\n\nExamples\n\njulia> g = symmetric_group(5);  gen(g, 1)\n(1,2,3,4,5)\n\njulia> g[-1]\n(1,5,4,3,2)\n\n\n\n\n\n","category":"method"},{"location":"Groups/basics/#small_generating_set-Tuple{Oscar.GAPGroup}","page":"Basics","title":"small_generating_set","text":"small_generating_set(G::GAPGroup)\n\nReturn a reasonably short vector of elements in G that generate G; in general the length of this vector is not minimal.\n\nExamples\n\njulia> length(small_generating_set(abelian_group(SubPcGroup, [2,3,4])))\n2\n\njulia> length(small_generating_set(abelian_group(PermGroup, [2,3,4])))\n3\n\n\n\n\n\n","category":"method"},{"location":"Groups/basics/#minimal_size_generating_set-Tuple{Oscar.GAPGroup}","page":"Basics","title":"minimal_size_generating_set","text":"minimal_size_generating_set(G::GAPGroup)\n\nReturn a vector of minimal length of elements in G that generate G.\n\nExamples\n\njulia> length(minimal_size_generating_set(abelian_group(SubPcGroup, [2,3,4])))\n2\n\njulia> length(minimal_size_generating_set(abelian_group(PermGroup, [2,3,4])))\n2\n\njulia> minimal_size_generating_set(symmetric_group(5))\n2-element Vector{PermGroupElem}:\n (1,2,3,4,5)\n (1,2)\n\n\n\n\n\n","category":"method"},{"location":"Groups/basics/#rand-Tuple{Oscar.GAPGroup}","page":"Basics","title":"rand","text":"rand(rng::Random.AbstractRNG = Random.GLOBAL_RNG, G::Group)\n\nReturn a random element of G, using the random number generator rng.\n\n\n\n\n\n","category":"method"},{"location":"Groups/basics/#rand_pseudo-Tuple{Oscar.GAPGroup}","page":"Basics","title":"rand_pseudo","text":"rand_pseudo(G::GAPGroup)\n\nReturn a pseudo random element of G.  This works faster than rand, but the returned elements are not necessarily uniformly distributed.\n\nIt is sometimes necessary to work with finite groups that we cannot effectively enumerate, e.g. matrix groups over finite fields. We may not even know the size of these groups. Yet many algorithms need to sample elements from the group \"as randomly as possible\", whatever that means; but also they need this fast.\n\nThe function rand_pseudo returns elements that are cheap to compute and somehow random, but makes no guarantees about their distribution.\n\nFor finitely presented groups, it returns random words of bounded length.\n\nFor finite permutation and matrix groups, it uses a variant of the product replacement algorithm. For most inputs, the resulting stream of elements relatively quickly converges to a uniform distribution.\n\n\n\n\n\n","category":"method"},{"location":"Groups/basics/","page":"Basics","title":"Basics","text":"It is also possible to obtain the generators of G by typing","category":"page"},{"location":"Groups/basics/","page":"Basics","title":"Basics","text":"f1,f2,f3 = gens(G)","category":"page"},{"location":"Groups/basics/","page":"Basics","title":"Basics","text":"This is equivalent to","category":"page"},{"location":"Groups/basics/","page":"Basics","title":"Basics","text":"f1=G[1]; f2=G[2]; f3=G[3];","category":"page"},{"location":"Groups/basics/","page":"Basics","title":"Basics","text":"For a group G that has been created as a subgroup of another group, generated by a list L of elements, gens(G) is equal to L.","category":"page"},{"location":"Groups/basics/#Operations-on-group-elements","page":"Basics","title":"Operations on group elements","text":"","category":"section"},{"location":"Groups/basics/","page":"Basics","title":"Basics","text":"OSCAR supports the following operations and functions on group elements.","category":"page"},{"location":"Groups/basics/","page":"Basics","title":"Basics","text":"*, multiplication between two elements in a group.\ninv(x) and x^-1, the inverse of x.\nx/y, the element x y^-1.\nx^n, the n-th power of x; if n == 0, the identity of the group is returned; if n < 0, the -n-th power of the inverse of x is returned.\nisone(x) returns whether x is the identity of the group.\nconj(x,y) and x^y, the conjugate of x by y, i.e., the element y^-1 x y.\ncomm(x,y), the commutator of x and y, i.e., the element x^-1 y^-1 x y.","category":"page"},{"location":"Groups/basics/","page":"Basics","title":"Basics","text":"note: Note\nIn OSCAR, the expression x^y^z is equivalent to x^(y^z). In other words, conjugations are evaluated from the right to the left.","category":"page"},{"location":"Groups/basics/","page":"Basics","title":"Basics","text":"comm(x::GAPGroupElem, y::GAPGroupElem)","category":"page"},{"location":"Groups/basics/#comm-Tuple{GAPGroupElem, GAPGroupElem}","page":"Basics","title":"comm","text":"comm(x::GAPGroupElem, y::GAPGroupElem)\n\nReturn the commutator of x and y, which is defined as x^-1*y^-1*x*y, and usually denoted as [x,y] in the literature.\n\n\n\n\n\n","category":"method"},{"location":"Groups/basics/#Properties-of-groups","page":"Basics","title":"Properties of groups","text":"","category":"section"},{"location":"Groups/basics/","page":"Basics","title":"Basics","text":"is_finite(G::GAPGroup)\nis_trivial(G::GAPGroup)\nis_cyclic(G::GAPGroup)\nis_abelian(G::GAPGroup)\nis_elementary_abelian(G::GAPGroup)\nis_pgroup(G::GAPGroup)\nis_pgroup_with_prime(::Type{T}, G::GAPGroup) where T <: IntegerUnion\nis_nilpotent(G::GAPGroup)\nis_supersolvable(G::GAPGroup)\nis_solvable(G::GAPGroup)\nis_perfect(G::GAPGroup)\nis_simple(G::GAPGroup)\nis_almost_simple(G::GAPGroup)\nis_quasisimple(G::GAPGroup)\nis_sporadic_simple(G::GAPGroup)\nis_finitely_generated(G::GAPGroup)","category":"page"},{"location":"Groups/basics/#is_finite-Tuple{Oscar.GAPGroup}","page":"Basics","title":"is_finite","text":"is_finite(G::GAPGroup) -> Bool\n\nReturn true if G is finite, and false otherwise.\n\nExamples\n\njulia> is_finite(symmetric_group(5))\ntrue\n\njulia> is_finite(free_group(2))\nfalse\n\n\n\n\n\n\n","category":"method"},{"location":"Groups/basics/#is_trivial-Tuple{Oscar.GAPGroup}","page":"Basics","title":"is_trivial","text":"is_trivial(G::GAPGroup)\n\nReturn true if G has order 1, and false otherwise.\n\nExamples\n\njulia> is_trivial(symmetric_group(1))\ntrue\n\njulia> is_trivial(symmetric_group(2))\nfalse\n\n\n\n\n\n","category":"method"},{"location":"Groups/basics/#is_cyclic-Tuple{Oscar.GAPGroup}","page":"Basics","title":"is_cyclic","text":"is_cyclic(G::GAPGroup)\n\nReturn true if G is cyclic, i.e., if G can be generated by one element.\n\n\n\n\n\n","category":"method"},{"location":"Groups/basics/#is_abelian-Tuple{Oscar.GAPGroup}","page":"Basics","title":"is_abelian","text":"is_abelian(G::Group)\n\nReturn true if G is abelian (commutative), that is, x*y = y*x holds for all elements x y in G.\n\n\n\n\n\n","category":"method"},{"location":"Groups/basics/#is_elementary_abelian-Tuple{Oscar.GAPGroup}","page":"Basics","title":"is_elementary_abelian","text":"is_elementary_abelian(G::Group)\n\nReturn true if G is a abelian (see is_abelian) and if there is a prime p such that the order of each element in G divides p.\n\nExamples\n\njulia> g = alternating_group(5);\n\njulia> is_elementary_abelian(sylow_subgroup(g, 2)[1])\ntrue\n\njulia> g = alternating_group(6);\n\njulia> is_elementary_abelian(sylow_subgroup(g, 2)[1])\nfalse\n\n\n\n\n\n","category":"method"},{"location":"Groups/basics/#is_pgroup-Tuple{Oscar.GAPGroup}","page":"Basics","title":"is_pgroup","text":"is_pgroup(G)\n\nReturn true if G is a p-group for some prime p, that is, if the order of every element in G is a power of p.\n\nNote that a finite group is a p-group if and only if its order is a prime power. In particular, the trivial group is a p-group for every prime.\n\nExamples\n\njulia> is_pgroup(symmetric_group(1))\ntrue\n\njulia> is_pgroup(symmetric_group(2))\ntrue\n\njulia> is_pgroup(symmetric_group(3))\nfalse\n\n\n\n\n\n\n","category":"method"},{"location":"Groups/basics/#is_pgroup_with_prime-Union{Tuple{T}, Tuple{Type{T}, Oscar.GAPGroup}} where T<:Union{Integer, ZZRingElem}","page":"Basics","title":"is_pgroup_with_prime","text":"is_pgroup_with_prime(::Type{T} = ZZRingElem, G::GAPGroup) where T <: IntegerUnion\n\nReturn (true, nothing) if G is the trivial group, (true, p) if the order of every element in G is a power of a prime p, and (false, nothing) otherwise.\n\nFor finite groups G, the first return value is true if and only if the order of G is a prime power.\n\nExamples\n\njulia> is_pgroup_with_prime(symmetric_group(1))\n(true, nothing)\n\njulia> is_pgroup_with_prime(symmetric_group(2))\n(true, 2)\n\njulia> is_pgroup_with_prime(symmetric_group(3))\n(false, nothing)\n\n\n\n\n\n\n","category":"method"},{"location":"Groups/basics/#is_nilpotent-Tuple{Oscar.GAPGroup}","page":"Basics","title":"is_nilpotent","text":"is_nilpotent(G::GAPGroup)\n\nReturn whether G is nilpotent, i.e., whether the lower central series of G reaches the trivial subgroup in a finite number of steps.\n\nExamples\n\njulia> is_nilpotent(dihedral_group(8))\ntrue\n\njulia> is_nilpotent(dihedral_group(10))\nfalse\n\n\n\n\n\n","category":"method"},{"location":"Groups/basics/#is_supersolvable-Tuple{Oscar.GAPGroup}","page":"Basics","title":"is_supersolvable","text":"is_supersolvable(G::GAPGroup)\n\nReturn whether G is supersolvable, i.e., G is finite and has a normal series with cyclic factors.\n\nExamples\n\njulia> is_supersolvable(symmetric_group(3))\ntrue\n\njulia> is_supersolvable(symmetric_group(4))\nfalse\n\njulia> is_supersolvable(symmetric_group(5))\nfalse\n\n\n\n\n\n","category":"method"},{"location":"Groups/basics/#is_solvable-Tuple{Oscar.GAPGroup}","page":"Basics","title":"is_solvable","text":"is_solvable(G::GAPGroup)\n\nReturn whether G is solvable, i.e., whether derived_series(G) reaches the trivial subgroup in a finite number of steps.\n\nExamples\n\njulia> is_solvable(symmetric_group(3))\ntrue\n\njulia> is_solvable(symmetric_group(4))\ntrue\n\njulia> is_solvable(symmetric_group(5))\nfalse\n\n\n\n\n\n","category":"method"},{"location":"Groups/basics/#is_perfect-Tuple{Oscar.GAPGroup}","page":"Basics","title":"is_perfect","text":"is_perfect(G::GAPGroup)\n\nReturn whether G is a perfect group, i.e., equal to its derived subgroup.\n\nExamples\n\njulia> is_perfect(special_linear_group(2, 5))\ntrue\n\njulia> is_perfect(symmetric_group(5))\nfalse\n\n\n\n\n\n\n","category":"method"},{"location":"Groups/basics/#is_simple-Tuple{Oscar.GAPGroup}","page":"Basics","title":"is_simple","text":"is_simple(G::GAPGroup)\n\nReturn whether G is a simple group, i.e., G is not trivial and has no non-trivial normal subgroups.\n\nExamples\n\njulia> is_simple(alternating_group(5))\ntrue\n\njulia> is_simple(symmetric_group(5))\nfalse\n\n\n\n\n\n\n","category":"method"},{"location":"Groups/basics/#is_almost_simple-Tuple{Oscar.GAPGroup}","page":"Basics","title":"is_almost_simple","text":"is_almost_simple(G::GAPGroup)\n\nReturn whether G is an almost simple group, i.e., G is isomorphic to a group H with the property S leq H leq Aut(S), for some non-abelian simple group S.\n\nExamples\n\njulia> is_almost_simple(symmetric_group(5))\ntrue\n\njulia> is_almost_simple(special_linear_group(2, 5))\nfalse\n\n\n\n\n\n\n","category":"method"},{"location":"Groups/basics/#is_quasisimple-Tuple{Oscar.GAPGroup}","page":"Basics","title":"is_quasisimple","text":"is_quasisimple(G::GAPGroup)\n\nReturn whether G is a quasisimple group, i.e., G is perfect such that the factor group modulo its center is a non-abelian simple group.\n\nExamples\n\njulia> is_quasisimple(special_linear_group(2, 5))\ntrue\n\njulia> is_quasisimple(symmetric_group(5))\nfalse\n\n\n\n\n\n\n","category":"method"},{"location":"Groups/basics/#is_sporadic_simple-Tuple{Oscar.GAPGroup}","page":"Basics","title":"is_sporadic_simple","text":"is_sporadic_simple(G::GAPGroup)\n\nReturn whether G is a sporadic simple group.\n\nExamples\n\njulia> is_sporadic_simple(mathieu_group(11))\ntrue\n\njulia> is_sporadic_simple(mathieu_group(10))\nfalse\n\n\n\n\n\n\n","category":"method"},{"location":"Groups/basics/#is_finitely_generated-Tuple{Oscar.GAPGroup}","page":"Basics","title":"is_finitely_generated","text":"is_finitely_generated(G::GAPGroup)\n\nReturn whether G is a finitely generated group.\n\nExamples\n\njulia> F = free_group(2)\nFree group of rank 2\n\njulia> is_finitely_generated(F)\ntrue\n\njulia> H = derived_subgroup(F)[1]\nFree group\n\njulia> is_finitely_generated(H)\nfalse\n\n\n\n\n\n","category":"method"},{"location":"Groups/basics/#Attributes-of-groups","page":"Basics","title":"Attributes of groups","text":"","category":"section"},{"location":"Groups/basics/","page":"Basics","title":"Basics","text":"order(::Type{T}, x::Union{GAPGroupElem, GAPGroup}) where T <: IntegerUnion\nabelian_invariants(G::GAPGroup)\nabelian_invariants_schur_multiplier(G::GAPGroup)\ncyclic_generator(G::GAPGroup)\nexponent(G::GAPGroup)\ndescribe(G::GAPGroup)\nnilpotency_class(G::GAPGroup)\nprime_of_pgroup\nderived_length\nschur_cover(G::GAPGroup)\nschur_multiplier(G::Union{GAPGroup, FinGenAbGroup})","category":"page"},{"location":"Groups/basics/#order-Union{Tuple{T}, Tuple{Type{T}, Union{Oscar.GAPGroup, GAPGroupElem}}} where T<:Union{Integer, ZZRingElem}","page":"Basics","title":"order","text":"order(::Type{T} = ZZRingElem, x::Union{GAPGroupElem, GAPGroup}) where T <: IntegerUnion\n\nReturn the order of x, as an instance of T.\n\nFor a group element x in the group G, the order of x is the smallest positive integer n such that x^n is the identity of G. For a group x, the order of x is the number of elements in x.\n\nAn exception is thrown if the order of x is infinite, use is_finite for checking the finiteness of a group, and is_finite_order for checking whether a group element has finite order.\n\nExamples\n\njulia> g = symmetric_group(3);\n\njulia> order(g)\n6\n\njulia> order(gen(g, 1))\n3\n\njulia> g = free_group(1);\n\njulia> is_finite(g)\nfalse\n\njulia> is_finite_order(gen(g, 1))\nfalse\n\n\n\n\n\n","category":"method"},{"location":"Groups/basics/#abelian_invariants-Tuple{Oscar.GAPGroup}","page":"Basics","title":"abelian_invariants","text":"abelian_invariants(::Type{T} = ZZRingElem, G::Union{GAPGroup, FinGenAbGroup}) where T <: IntegerUnion\n\nReturn the sorted vector of abelian invariants of the commutator factor group of G (see maximal_abelian_quotient). The entries are prime powers or zeroes and have the type T. They describe the structure of the commutator factor group of G as a direct product of cyclic groups of prime power (or infinite) order.\n\nExamples\n\njulia> abelian_invariants(symmetric_group(4))\n1-element Vector{ZZRingElem}:\n 2\n\njulia> abelian_invariants(Int, abelian_group([2, 12]))\n3-element Vector{Int64}:\n 2\n 3\n 4\n\njulia> abelian_invariants(alternating_group(5))\nZZRingElem[]\n\n\n\n\n\n","category":"method"},{"location":"Groups/basics/#abelian_invariants_schur_multiplier-Tuple{Oscar.GAPGroup}","page":"Basics","title":"abelian_invariants_schur_multiplier","text":"abelian_invariants_schur_multiplier(::Type{T} = ZZRingElem, G::Union{GAPGroup, FinGenAbGroup}) where T <: IntegerUnion\n\nReturn the sorted vector of abelian invariants (see abelian_invariants) of the Schur multiplier of G. The entries are prime powers or zeroes and have the type T. They describe the structure of the Schur multiplier of G as a direct product of cyclic groups of prime power (or infinite) order.\n\nExamples\n\njulia> abelian_invariants_schur_multiplier(symmetric_group(4))\n1-element Vector{ZZRingElem}:\n 2\n\njulia> abelian_invariants_schur_multiplier(Int, alternating_group(6))\n2-element Vector{Int64}:\n 2\n 3\n\njulia> abelian_invariants_schur_multiplier(abelian_group([2, 12]))\n1-element Vector{ZZRingElem}:\n 2\n\njulia> abelian_invariants_schur_multiplier(cyclic_group(5))\nZZRingElem[]\n\n\n\n\n\n","category":"method"},{"location":"Groups/basics/#cyclic_generator-Tuple{Oscar.GAPGroup}","page":"Basics","title":"cyclic_generator","text":"cyclic_generator(G::GAPGroup)\n\nReturn an element of G that generates G if G is cyclic, and throw an error otherwise.\n\nExamples\n\njulia> g = permutation_group(5, [cperm(1:3), cperm(4:5)])\nPermutation group of degree 5\n\njulia> cyclic_generator(g)\n(1,2,3)(4,5)\n\n\n\n\n\n","category":"method"},{"location":"Groups/basics/#exponent-Tuple{Oscar.GAPGroup}","page":"Basics","title":"exponent","text":"exponent(::Type{T} = ZZRingElem, G::GAPGroup) where T <: IntegerUnion\n\nReturn the exponent of G, as an instance of T, i.e., the smallest positive integer e such that g^e is the identity of G for every g in G.\n\nExamples\n\njulia> exponent(symmetric_group(3))\n6\n\njulia> exponent(symmetric_group(13))\n360360\n\n\n\n\n\n","category":"method"},{"location":"Groups/basics/#describe-Tuple{Oscar.GAPGroup}","page":"Basics","title":"describe","text":"describe(G::GAPGroup)\n\nReturn a string that describes some aspects of the structure of G.\n\nFor finite groups, the function works well if G is an abelian group or a finite simple group or a group in one of the following series: symmetric, dihedral, quasidihedral, generalized quaternion, general linear, special linear.\n\nFor other finite groups, the function tries to decompose G as a direct product or a semidirect product, and if this is not possible as a non-splitting extension of a normal subgroup N with the factor group GN, where N is the center or the derived subgroup or the Frattini subgroup of G.\n\nFor infinite groups, if the group is known to be finitely generated and abelian or free, a reasonable description is printed.\n\nFor general infinite groups, or groups for which finiteness is not (yet) known, not much if anything can be done. In particular we avoid potentially expensive checks such as computing the size of the group or whether it is abelian. While we do attempt a few limited fast checks for finiteness and commutativity, these will not detect all finite or commutative groups.\n\nThus calling describe again on the same group after additional information about it becomes known to Oscar may yield different outputs.\n\nnote: Note\nfor finitely presented groups, even deciding if the group is trivial is impossible in general; the same holds for most other properties, like whether the group is finite, abelian, etc.,\nthere is in general no \"nice\" decomposition of G,\nthere may be several decompositions of G,\nnonisomorphic groups may yield the same describe result,\nisomorphic groups may yield different describe results,\nthe computations can take a long time (for example in the case of large p-groups), and the results are still often not very helpful.\n\nThe following notation is used in the returned string.\n\nDescription Syntax\ntrivial group 1\nfinite cyclic group C<size>\ninfinite cyclic group Z\nalternating group A<degree>\nsymmetric group S<degree>\ndihedral group D<size>\nquaternion group Q<size>\nquasidihedral group QD<size>\nprojective special linear group PSL(<n>,<q>)\nspecial linear group SL(<n>,<q>)\ngeneral linear group GL(<n>,<q>)\nproj. special unitary group PSU(<n>,<q>)\northogonal group, type B O(2<n>+1,<q>)\northogonal group, type D O+(2<n>,<q>)\northogonal group, type 2D O-(2<n>,<q>)\nproj. special symplectic group PSp(2<n>,<q>)\nSuzuki group (type 2B) Sz(<q>)\nRee group (type 2F or 2G) Ree(<q>)\nLie group of exceptional type E(6,<q>), E(7,<q>), E(8,<q>), 2E(6,<q>), F(4,<q>), G(2,<q>)\nSteinberg triality group 3D(4,<q>)\nsporadic simple group M11, M12, M22, M23, M24, J1, J2, J3, J4, Co1, Co2, Co3, Fi22, Fi23, Fi24', Suz, HS, McL, He, HN, Th, B, M, ON, Ly, Ru\nTits group 2F(4,2)'\nthe indicated group from the library of perfect groups PerfectGroup(<size>,<id>)\ndirect product A x B\nsemidirect product N : H\nnon-split extension Z(G) . G/Z(G) = G' . G/G', Phi(G) . G/Phi(G)\n\nExamples\n\njulia> g = symmetric_group(6);\n\njulia> describe(g)\n\"S6\"\n\njulia> describe(sylow_subgroup(g,2)[1])\n\"C2 x D8\"\n\njulia> describe(sylow_subgroup(g, 3)[1])\n\"C3 x C3\"\n\njulia> describe(free_group(3))\n\"a free group of rank 3\"\n\n\n\n\n\n\n","category":"method"},{"location":"Groups/basics/#nilpotency_class-Tuple{Oscar.GAPGroup}","page":"Basics","title":"nilpotency_class","text":"nilpotency_class(G::GAPGroup) -> Int\n\nReturn the nilpotency class of G, i.e., the smallest integer n such that G has a central series with n steps (meaning that it consists of n+1 groups). The trivial group is the unique group with nilpotency class 0 and all abelian groups have nilpotency class 1.\n\nAn exception is thrown if G is not nilpotent.\n\nSee also lower_central_series and upper_central_series.\n\nExamples\n\njulia> nilpotency_class(dihedral_group(8))\n2\n\njulia> nilpotency_class(dihedral_group(12))\nERROR: ArgumentError: The group is not nilpotent.\n\n\n\n\n\n","category":"method"},{"location":"Groups/basics/#prime_of_pgroup","page":"Basics","title":"prime_of_pgroup","text":"prime_of_pgroup(::Type{T} = ZZRingElem, G::GAPGroup) where T <: IntegerUnion\n\nReturn the prime p if G is a non-trivial p-group.\n\nAn exception is thrown if G is not a p-group or is a trivial group.\n\nExamples\n\njulia> prime_of_pgroup(quaternion_group(8))\n2\n\njulia> prime_of_pgroup(UInt16, quaternion_group(8))\n0x0002\n\njulia> prime_of_pgroup(symmetric_group(1))\nERROR: ArgumentError: only supported for non-trivial p-groups\n\njulia> prime_of_pgroup(symmetric_group(3))\nERROR: ArgumentError: only supported for non-trivial p-groups\n\n\n\n\n\n\n","category":"function"},{"location":"Groups/basics/#derived_length","page":"Basics","title":"derived_length","text":"derived_length(G::GAPGroup)\n\nReturn the number of steps in the derived series of G, that is the series length minus 1. See also derived_series.\n\nExamples\n\njulia> derived_length(symmetric_group(4))\n3\n\njulia> derived_length(symmetric_group(5))\n1\n\njulia> derived_length(dihedral_group(8))\n2\n\n\n\n\n\n","category":"function"},{"location":"Groups/basics/#schur_cover-Tuple{Oscar.GAPGroup}","page":"Basics","title":"schur_cover","text":"schur_cover(::Type{T} = FPGroup, G::GAPGroup) where T <: GAPGroup\n\nReturn S, f where S is a Schur cover of G and f is an epimorphism from S to G.\n\nExamples\n\njulia> S, f = schur_cover(symmetric_group(4));  order(S)\n48\n\njulia> S, f = schur_cover(PermGroup, dihedral_group(12));  order(S)\n24\n\n\n\n\n\n","category":"method"},{"location":"Groups/basics/#schur_multiplier-Tuple{Union{FinGenAbGroup, Oscar.GAPGroup}}","page":"Basics","title":"schur_multiplier","text":"schur_multiplier(::Type{T} = FinGenAbGroup, G::Union{GAPGroup, FinGenAbGroup}) where T <: Union{GAPGroup, FinGenAbGroup}\n\nReturn the Schur multiplier of G. This is an abelian group whose abelian invariants can be computed with abelian_invariants_schur_multiplier.\n\nExamples\n\njulia> schur_multiplier(symmetric_group(4))\nZ/2\n\njulia> schur_multiplier(PcGroup, alternating_group(6))\nPc group of order 6\n\njulia> schur_multiplier(abelian_group([2, 12]))\nZ/2\n\njulia> schur_multiplier(cyclic_group(5))\nZ/1\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/abelian/introduction/","page":"Introduction","title":"Introduction","text":"CurrentModule = Hecke\nDocTestSetup = quote\n    using Hecke\nend","category":"page"},{"location":"Hecke/manual/abelian/introduction/#AbelianGroupLink2","page":"Introduction","title":"Introduction","text":"","category":"section"},{"location":"Hecke/manual/abelian/introduction/","page":"Introduction","title":"Introduction","text":"Within Hecke, abelian groups are of generic abstract type GrpAb which does not have to be finitely generated, mathbb Qmathbb Z is an example of a more general abelian group. Having said that, most of the functionality is restricted to abelian groups that are finitely presented as mathbb Z-modules.","category":"page"},{"location":"Hecke/manual/abelian/introduction/#Basic-Creation","page":"Introduction","title":"Basic Creation","text":"","category":"section"},{"location":"Hecke/manual/abelian/introduction/","page":"Introduction","title":"Introduction","text":"Finitely presented (as mathbb Z-modules) abelian groups are of type FinGenAbGroup with elements of type FinGenAbGroupElem. The creation is mostly via a relation matrix M = (m_ij) for 1le ile n and 1le jle m. This creates a group with m generators e_j and relations","category":"page"},{"location":"Hecke/manual/abelian/introduction/","page":"Introduction","title":"Introduction","text":"   sum_i=1^n m_ij e_j = 0","category":"page"},{"location":"Hecke/manual/abelian/introduction/","page":"Introduction","title":"Introduction","text":"abelian_group(M::ZZMatrix)\nabelian_group(M::Matrix{ZZRingElem})\nabelian_group(M::Matrix{Integer})","category":"page"},{"location":"Hecke/manual/abelian/introduction/#abelian_group-Tuple{ZZMatrix}","page":"Introduction","title":"abelian_group","text":"abelian_group(::Type{T} = FinGenAbGroup, M::ZZMatrix) -> FinGenAbGroup\n\nCreates the abelian group with relation matrix M. That is, the group will have ncols(M) generators and each row of M describes one relation.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/abelian/introduction/#abelian_group-Tuple{Matrix{ZZRingElem}}","page":"Introduction","title":"abelian_group","text":"abelian_group(::Type{T} = FinGenAbGroup, M::AbstractMatrix{<:IntegerUnion})\n\nCreates the abelian group with relation matrix M. That is, the group will have ncols(M) generators and each row of M describes one relation.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/abelian/introduction/#abelian_group-Tuple{Matrix{Integer}}","page":"Introduction","title":"abelian_group","text":"abelian_group(::Type{T} = FinGenAbGroup, M::AbstractMatrix{<:IntegerUnion})\n\nCreates the abelian group with relation matrix M. That is, the group will have ncols(M) generators and each row of M describes one relation.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/abelian/introduction/","page":"Introduction","title":"Introduction","text":"Alternatively, there are shortcuts to create products of cyclic groups:","category":"page"},{"location":"Hecke/manual/abelian/introduction/","page":"Introduction","title":"Introduction","text":"abelian_group(M::Vector{Union{ZZRingElem, Integer}})","category":"page"},{"location":"Hecke/manual/abelian/introduction/#abelian_group-Tuple{Vector{Union{Integer, ZZRingElem}}}","page":"Introduction","title":"abelian_group","text":"abelian_group(::Type{T} = FinGenAbGroup, M::AbstractVector{<:IntegerUnion}) -> FinGenAbGroup\nabelian_group(::Type{T} = FinGenAbGroup, M::IntegerUnion...) -> FinGenAbGroup\n\nCreates the direct product of the cyclic groups mathbfZm_i, where m_i is the ith entry of M.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/abelian/introduction/","page":"Introduction","title":"Introduction","text":"using Hecke # hide\nG = abelian_group(2, 2, 6)","category":"page"},{"location":"Hecke/manual/abelian/introduction/","page":"Introduction","title":"Introduction","text":"or even","category":"page"},{"location":"Hecke/manual/abelian/introduction/","page":"Introduction","title":"Introduction","text":"free_abelian_group(::Int)\nabelian_groups(n::Int)","category":"page"},{"location":"Hecke/manual/abelian/introduction/#free_abelian_group-Tuple{Int64}","page":"Introduction","title":"free_abelian_group","text":"free_abelian_group(::Type{T} = FinGenAbGroup, n::Int) -> FinGenAbGroup\n\nCreates the free abelian group of rank n.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/abelian/introduction/#abelian_groups-Tuple{Int64}","page":"Introduction","title":"abelian_groups","text":"abelian_groups(n::Int) -> Vector{FinGenAbGroup}\n\nGiven a positive integer n, return a list of all abelian groups of order n.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/abelian/introduction/","page":"Introduction","title":"Introduction","text":"using Hecke # hide\nabelian_groups(8)","category":"page"},{"location":"Hecke/manual/abelian/introduction/#Invariants","page":"Introduction","title":"Invariants","text":"","category":"section"},{"location":"Hecke/manual/abelian/introduction/","page":"Introduction","title":"Introduction","text":"is_snf(A::FinGenAbGroup)\nnumber_of_generators(A::FinGenAbGroup)\nnrels(G::FinGenAbGroup)\nrels(A::FinGenAbGroup)\nis_finite(A::FinGenAbGroup)\ntorsion_free_rank(A::FinGenAbGroup)\norder(A::FinGenAbGroup)\nexponent(A::FinGenAbGroup)\nis_trivial(A::FinGenAbGroup)\nis_torsion(G::FinGenAbGroup)\nis_cyclic(G::FinGenAbGroup)\nelementary_divisors(G::FinGenAbGroup)","category":"page"},{"location":"Hecke/manual/abelian/introduction/#is_snf-Tuple{FinGenAbGroup}","page":"Introduction","title":"is_snf","text":"is_snf(G::FinGenAbGroup) -> Bool\n\nReturn whether the current relation matrix of the group G is in Smith normal form.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/abelian/introduction/#number_of_generators-Tuple{FinGenAbGroup}","page":"Introduction","title":"number_of_generators","text":"number_of_generators(G::FinGenAbGroup) -> Int\n\nReturn the number of generators of G in the current representation.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/abelian/introduction/#nrels-Tuple{FinGenAbGroup}","page":"Introduction","title":"nrels","text":"number_of_relations(G::FinGenAbGroup) -> Int\n\nReturn the number of relations of G in the current representation.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/abelian/introduction/#rels-Tuple{FinGenAbGroup}","page":"Introduction","title":"rels","text":"rels(A::FinGenAbGroup) -> ZZMatrix\n\nReturn the currently used relations of G as a single matrix.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/abelian/introduction/#is_finite-Tuple{FinGenAbGroup}","page":"Introduction","title":"is_finite","text":"isfinite(A::FinGenAbGroup) -> Bool\n\nReturn whether A is finite.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/abelian/introduction/#torsion_free_rank-Tuple{FinGenAbGroup}","page":"Introduction","title":"torsion_free_rank","text":"torsion_free_rank(A::FinGenAbGroup) -> Int\n\nReturn the torsion free rank of A, that is, the dimension of the mathbfQ-vectorspace A otimes_mathbf Z mathbf Q.\n\nSee also rank.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/abelian/introduction/#order-Tuple{FinGenAbGroup}","page":"Introduction","title":"order","text":"order(A::FinGenAbGroup) -> ZZRingElem\n\nReturn the order of A. It is assumed that A is finite.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/abelian/introduction/#exponent-Tuple{FinGenAbGroup}","page":"Introduction","title":"exponent","text":"exponent(A::FinGenAbGroup) -> ZZRingElem\n\nReturn the exponent of A. It is assumed that A is finite.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/abelian/introduction/#is_trivial-Tuple{FinGenAbGroup}","page":"Introduction","title":"is_trivial","text":"is_trivial(A::FinGenAbGroup) -> Bool\n\nReturn whether A is the trivial group.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/abelian/introduction/#is_torsion-Tuple{FinGenAbGroup}","page":"Introduction","title":"is_torsion","text":"is_torsion(G::FinGenAbGroup) -> Bool\n\nReturn whether G is a torsion group.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/abelian/introduction/#is_cyclic-Tuple{FinGenAbGroup}","page":"Introduction","title":"is_cyclic","text":"is_cyclic(G::FinGenAbGroup) -> Bool\n\nReturn whether G is cyclic.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/manual/abelian/introduction/#elementary_divisors-Tuple{FinGenAbGroup}","page":"Introduction","title":"elementary_divisors","text":"elementary_divisors(G::FinGenAbGroup) -> Vector{ZZRingElem}\n\nGiven G, return the elementary divisors of G, that is, the unique non-negative integers e_1dotsce_k with e_i mid e_i + 1 and e_ineq 1 such that G cong mathbfZe_1mathbfZ times dotsb times mathbfZe_kmathbfZ.\n\n\n\n\n\n","category":"method"}]
}